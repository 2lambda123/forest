===========================================
25 July 2006 

The code-fragment templates for the constructor functions should go in:
~/pads/padsc/include/pglx-codegen-macros.h

and the composition of the fragements go in: 
~/pads/padsc/comp/ckit/src/ast/extensions/pads/gen-galax.sml


===========================================
4 May 2006

Notes on PADS Constructors
==========================  

Problem:
--------

To convert from XML back into PADS, we need to generate (a collection
of) constructor methods/functions for each PADS type :

    open_T  : Corresponds to open_element event in XML-token stream;
              May have side effect of allocating memory for value of
              type T.

    close_T : Corresponds to close_element event in XML-token stream
              May have side effect of serializing value of type T. 

    final_T : Called when value of type T will no longer be accessed,
              e.g., during garbage collection, as side effect of
              serialization.

Issues:
-------

1. XML <pd> to PADS pd. 

   Is a pd in the XML representation mapped into a pd in the PADS
   representation?  If so, what does it mean?

2. Error invariants and gen_pd_T()

   We are assuming that the PADS Load operator is taking a *validated*
   typed SAX stream as input, so that the XML Schema validator has
   already detected any structural and value type errors in the XML
   input.

   Invariant: Under above assumption, the only errors that occur at
   runtime are detected by gen_pd functions, which check semantic
   constraints and any lexical/value constraints that cannot be
   expressed in XML Schema.

   Given PADS description T, XML Schema S = Map(T), then what can we
   say about: 
     Load_pads(Validate(XML,Map(T)))

   For any type that takes a parameter, the corresponding gen_pd()
   function should take that parameter so it can check/enforce
   lexical/value constraints.  (Currently, functions that get
   generated for parameterized types take extra arguments, and the
   compiler is responsible for passing those extra arguments.)

   For now, we punt...

   In general, the "top-level" type T (i.e., the one that allocates
   memory) does not take parameters, therefore we could call the
   gen_pd_T() function just once, for the entire rep of T in memory.

Example:
--------
XML: 
~~~
  <a><b><i>13</i><s>hello world!</s></b></a>

PADS types:
~~~~~~~~~~~
  Pstruct B { 
    Puint32 i; 
    Pstring s;
  };
  Psource Pstruct A { 
    B[] b; 
  }

Constructor functions:
~~~~~~~~~~~~~~~~~~~~~~
I. Base types  

  Since base types represent terminal values in the XML tree, the
  open_T() function does all the work. I'm using a (pseudo-)Curried
  function signature here.  Not sure how to do this in C. 

  We have to split this function into two parts: One that takes reploc
  & pdloc and one that takes a value. 

  PADX_Handle open_Puint32 (PADX_Handle px, void *m, void *x) {
    Puint32 *rep; 
    Puint32_m  *mask = (Puint32_m *)m; 
    Dm_atomic.atomicInt atomic = (Dm_atomic.atomicInt) x;

    if (mask & UNIT) {
        /* Some region initialization has happened */
        ch->reploc = new(px->ph, Puint32);
        ch->pdloc  = new(px->ph, Puint32_pd); 

      /* Initialize pd & rep -- this function recursively initializes the pd for
         all constituent types in Puint32. 
       */
        Puint32_init(px->ph, rep);
        Puint32_init_pd(px->ph, pd);
    }

    /* Figure out casting from void to Galax data model  */
    Dm_atomic.atomicInt value = Galax.get_int(atomic);
    Puint32 rep = (Puint32 *)reploc;

    /* Write rep */
    *rep = value; 

    return px; 
  }

  void close_Puint32(PADX_Handle px, void *m) { 
    Puint32 *rep = (Puint32 *)px->ch.reploc; 
    Puint32_pd *pd = (Puint32_pd *)px->ch.pdloc; 
    Puint32_m  *mask = (Puint32_m *)m; 

    /* Generate pd -- this function recursively generates the pd for
       all constituent types in Puint32. */
    if (mask & UNIT) 
      Puint32_gen_pd (px->ph, pd, rep); 

    if (mask & UNIT) 
        write_B(px->ph, rep);

    if (mask & ~UNIT)
      free(px)
      
  } 
  void final_Puint32(P_t ph, void *m, void *reploc, void *pdloc) { 
    Puint32 *rep = (Puint32 *)reploc; 
    Puint32_pd *pd = (Puint32_pd *)pdloc; 
    Puint32_m  *mask = (Puint32_m *)m; 

    if (mask & UNIT) {
        /* Return rep & pd to region allocator */
        free(ph, rep); 
        free(ph, pd);
    }
  } 

  PADX_Handle open_Pstring (PADX_Handle px, void *m, void *x) {
    Pstring *rep; 
    Pstring_m  *mask = (Pstring_m *)m; 
    Dm_atomic.atomicString value = Galax.get_string(atomic);

    if (mask & UNIT) {
        /* Some region initialization has happened */
        ch->reploc = new(px->ph, Pstring);
        ch->pdloc  = new(px->ph, Pstring_pd); 

      /* Initialize pd & rep -- this function recursively initializes the pd for
         all constituent types in Pstring. 
       */
        Pstring_init(px->ph, rep);
        Pstring_init_pd(px->ph, pd);
    }

    Pstring rep = (Pstring *)reploc;

    /* Write rep */
    /* Convert a C string into a PADS string; May have the side effect
       of growing a buffer for the string. */
    Dm_atomic.atomicString value = Galax.get_string(atomic);
    Pads_string_from_C_string (px->ph, value, rep);

    *rep = value; 

    return px; 
  }
  void close_Pstring(PADX_Handle px, void *m) { 
    Pstring *rep = (Pstring *)px->ch.reploc; 
    Pstring_pd *pd = (Pstring_pd *)px->ch.pdloc; 
    Pstring_m  *mask = (Pstring_m *)m; 

    /* Generate pd -- this function recursively generates the pd for
       all constituent types in Pstring. */
    if (mask & UNIT) 
      Pstring_gen_pd (px->ph, pd, rep); 

    if (mask & UNIT) 
        write_B(px->ph, rep);

    if (mask & ~UNIT)
      free(px)
      
  } 
  void final_Pstring(P_t ph, void *m, void *reploc, void *pdloc) { 
    Pstring *rep = (Pstring *)reploc; 
    Pstring_pd *pd = (Pstring_pd *)pdloc; 
    Pstring_m  *mask = (Pstring_m *)m; 

    if (mask & UNIT) {
        /* Return rep & pd to region allocator */
        free(ph, rep); 
        free(ph, pd);
    }
  } 

II. Pstruct 

For a given type T, a constructor handler maintains the current
location for a T rep and a T pd, and the constructor functions for T's
constituent parts.

For a Pstruct, the vtable function maps a field name of type T to a
tuple containing the open_T(), close_T() and final_T() functions.
In this pseudo-code, I'm using Curried functions.  Not sure how to do
this in C. 

vtable_fun : 
  for Pstruct : parent-node's constructor_hander * field-name string -> child's constructor_handler 
  for Punion  : parent-node's constructor_hander * field-name string -> child's constructor_handler 
  for Parray : parent-node's constructor_hander * index int -> child's constructor_handler 
  for Penum  : parent-node's constructor_hander * enum-name string -> child's constructor_handler 
  for Ptypedef : Just passes arguments through to underlying type -- Body calls only difference is gen_pd function

  /* For type T, constructor functions are specified at compile time: */
  struct constructor_functions = { 
    void *open_T;
    void *close_T;
    void *final_T; 
    void *vtable_fun;  (* See above *) 
  } *PADX_CF; 

  /* For instance of type T, constructor handler contains rep & pd
     locations and pointer to constructor functions */
  typedef struct constructor_handler = { 
    /* Run-time values that change */
    void *reploc;
    void *pdloc; 
    void *mask;
    PADX_CF functions;
  } *PADX_CH; 

  /* Alternate design is to generate a constructor-handler type for
     each T */
  typedef struct B_constructor_handler = { 
    /* Run-time values that change */
    B *reploc;
    B_pd *pdloc; 
    B_m *mask;
    PADX_CF functions;
  } *PADX_CH; 

  /* PADX handler contains PADS handle + constructor handler for
     "current" node */
  typedef struct padx_handler { 
    /* Run-time value that is unique */
    Pads_handle *ph;
    struct constructor_handler ch;
  } *PADX_Handle;

  /* This function is generated by the compiler */
  PADX_Handle children_vtable_B (PADX_Handle px, void *m, char *field_name) {
    B *rep = (B *)px->ch.reploc; 
    B_pd *pd = (B_pd *)px->ch.pdloc; 
    B_m  *mask = (B_m *)m; 

    PADX_Handle new_px = new(PADX_Handle); 
    new_px->ph = px->ph;

    switch (field_name) { 
      case "i" : 
         /* Return new constructor handler */
         new_px.ch->reploc = &(rep.i);
         new_px.ch->pdloc = &(pd.i);
         new_px.ch->mask = mask.i;
         new_px.ch->functions = Puint32_functions;
      case "s" : 
         /* Return new constructor handler */
         new_px.ch->reploc = &(rep.s);
         new_px.ch->pdloc = &(pd.s);
         new_px.ch->mask = mask.s;
         new_px.ch->functions = Pstring_functions;
      default  : 
         fatal("Field "^field_name^" does not occur in Pstruct B");
    }
    return new_px;
  }

  /* This structure is generated by the compiler, after the
     declarations for associated functions. */
  struct constructor_functions B_functions { 
    void *open_T = open_B; 
    void *close_T = close_B; 
    void *final_T = final_B; 
    void *child_fun = children_vtable_B; 
  };
  
  /* In open_B function  */
  /* Third argument to this function is always NULL */
  PADX_Handle open_B (PADX_Handle px, void *m, void *) { 
    PADX_CH ch = px.ch;
    B    *rep;
    B_pd *pd;
    B_m  *mask = (B_m *)m;

    /* As a side-effect, we may allocate memory for values of type B */ 
    if (mask & UNIT) {
        px->ch.reploc = new(px->ph, B);
        px->ch.pdloc  = new(px->ph, B_pd); 

      /* Initialize pd & rep -- this function recursively initializes the pd for
         all constituent types in B. 
       */
        init_B(px->ch.reploc);
        init_B_pd(px->ch.pdloc);
    }
    rep = (B *)ch->reploc;
    pd  = (B_pd *)ch->pdloc;

    /* Return new constructor handler */
   
    PADX_Handle new_px = new(px->ph, PADX_Handle); 
    new_px->ph = px->ph;

    new_px->ch.reploc = rep;
    new_px->ch.pdloc = loc;
    new_px->ch.mask = mask;
    new_px->ch.functions = B_functions;
    return new_px;
  }

  /* In close_B function, rep (and possibly pd) have already been
     written.  Free any temp space allocated in open_B(). I don't
     think we can assume that constructor handler can be freed at this
     point, because we might have to deallocate a memory buffer
     maintained in the CH at some point. 

  */
  void close_B (PADX_Handle px, void *m) { 
    PADX_CH ch = px.ch;
    B *rep = (B *)px->ch.reploc; 
    B_pd *pd = (B_pd *)px->ch.pdloc; 
    B_m  *mask = (B_m *)m;

    /* Generate pd -- this function recursively generates the pd for
       all constituent types in B. */
    if (mask & UNIT) 
      B_gen_pd (pd, rep); 

    /* Hack! As a side-effect of closing an element, we might call
       serialization */
    if (mask & UNIT) 
      write_B(px->ph, rep);

    if (mask & ~UNIT)
      free(px)
  }

  void final_B(P_t ph, void *m, void *reploc, void *pdloc) { 
    B *rep = (B *)reploc; 
    B_pd *pd = (B_pd *)pdloc; 
    B_m  *mask = (B_m *)m;

    /* As a side effect of finalization, de-allocation functions. */
    if (mask & UNIT) {
        free (ph, rep);
        free (ph, pd);
    }
  } 
  
Template program:
~~~~~~~~~~~~~~~~
Initialize mask for Psource
Create and initialize a PADX handle, which : 
  Creates PADS handle
  Initialize output channel in PADS handle
  Allocates a memory region 
  Get constructor handler for PADS type that represents "top-level"/repeated type. 
  Create instance of PADS data model that takes PADS handle and constructor handler 
  Install PADS data model as default for Galax Load.
Call galax load

Compiler:
~~~~~~~~~

1. 

21 April 2006

Notes on Pads_dm to support Load_[pads] operator:
================================================

Current Status:
--------------

1. padsDocumentNode constructor has signature:

   (doc_uri_opt : atomicAnyURI option ref) docid psource_file (nr:Pads_c.nodeRep) ->
   padsDocumentNode

   * Unidirectional mapping from PADS-source data in psource_file TO padsDocumentNode
   * (nr: Pads_c.nodeRep) is node-rep of a PADS-document-node, which
     contains initialized PADS handle. 

   * Lazily materializes descendant PADS nodes in PRE-ORDER tree traversal 
     E.g., padsElementNode constructor takes nodeRep of parent, then
     calls kth_child lazily to instantiate children: 

     padsElementNode 
      docid 
       (my_nr : Pads_c.nodeRep) 
         rqname 
           (my_parent : Pads_c.nodeRep option) 
             (nsenv : nsenv)

2. We need inverse constructors that take (PADS node reps) as arguments
   and construct a PADS node in POST-ORDER tree traversal. 

   Use Galax_load as a guide. 

     padsElementNode 
       docid/nodeid 
         rqname 
           (my_kids : Pads_c.nodeRep cursor)  (* list? *)
             (my_parent : Pads_c.nodeRep option) 
               (nsenv : nsenv) 
                 type_annotation 
                   typed_value?

     What happens for each kind of PADS type?
     
Notes on Galax to support Load_[pads] operator:
==============================================

Conclusions:
------------
1. Load(), Export() and Serialize() should be explicit algebraic
   operators, and they should have static, DM-protocol parameter,
   which is used during (physical typing? and) code selection to
   select appropriate implementation. 

   e.g., 

   Load_[pads](Sax->PADSDm) 
   Export_[pads](PADSDm->Sax) 
   Serialize_[pads](Sax->Unit)

   Load, Export are physical operators and should be explicit in
   physical plan.  But in Galax, we don't really have a physical plan
   right now -- we have a logical plan with physical annotations.
   Load & Export are not exposed in code -- internal representation of
   physical DM is a union.

   Serialize is a logical plan and should be explicit in the logical
   plan.

Current Status:
--------------
1. Load "operator" in Galax. 

   See Galax_load.ml for example of Load(Sax->DM) and
   Physical_load.ml.

   Right now, there is only one set of DM-loading functions in
   Physical_load.ml, but in general, it should be possible to have
   more than one set of loading functions, one for each external DM
   implementation, e.g., 

     Load_[galax](Sax->DM)  (Actually, Sax->GalaxDM)
     Load_[pads](Sax->PADS) (Actually, Sax->PADS-DM)

   We should make Load() an explicit operator in the physical algebra
   to permit these variants.
  
   For now, we could "hack" a solution by overriding Galax_load with a
   Pads_load module that overwrites the default loading function. 

2. fn:doc()

   We can register a new DM protocol that is recognized in fn:doc()
   calls with Fn_doc.register_back_end, which takes a back_end_call
   function, which loads a source and returns an (item sequence):

   type back_end_call =
    Processing_context.processing_context -> string * string option * string -> Physical_value.item list

   This top-level loading function should delegate to the
   implementation of the PADS load operator:

     Load_[pads](Sax->PADS) (Actually, Sax->PADS-DM)

3. Load() occurs implicitly in physical-type coercion functions right
   now.  Follow call-chain from Cs_util_coercion ->
   Physical_value_util -> Physical_xml_value, which contains:
    
    let materialize_xml_value xv =
      match xv with
      | DomValue s -> DomValue (materialize_sequence s)
      | SaxValue s ->
          let nodeid_context = Nodeid_context.default_nodeid_context () in
          (DomValue
    	 (LSeq (Physical_load.load_xml_value_from_typed_stream
      nodeid_context s)))
    
Invariants/Observations:
=======================
1. PADS manages PADS memory; pads_rep_init() initializes memory store
   for creation of new PADS objects.  

2. Parent node (of PADS type T) allocates enough memory for itself and
   all its children.  For types whose size is dynamic, PADS allocates
   a (growable) buffer so it is not necessary to know the size of
   node:T apriori

   This is important, because on Galax side, we may use Streamable/Sax
   representation of XML and therefore do not have entire XML document
   in memory. 

   Need a data-model-dependent implementation of the Load() operator. 
   Serialize : typed-sax-stream -> unit 

   Load   : typed-sax-stream -> PADS-node
   Export : PADS-node -> typed-sax-stream 
   Serialize : typed-sax-stream -> unit 

   Serialize o Export o Expr(DM->DM) o Load(Tokens->DM) o Parse(URL->Tokens)
   Serialize o Expr(Tokens->Tokens) Parse(URL->Tokens)

   Serialize o Export o Load(Tokens->PADS-DM) o Parse(URL->Tokens)

Questions:

  What do we assume about PADS nodes after they are constructed?

PADS-handle has region handle to growable buffer.   Every PADS
function takes PADS-handle as argument. 

6 March 2006

Galax Data Model                 PADS Data Model                What's happening
================                 ===============                ================
                    
                                 ph = pads_rep_init()           Initialization of PADS data model 
Convert Galax-NODE to PADS-NODE

  N1 T1                       -> rh  = construct_T1(ph)     If T is a PRecord, then allocate memory buffer 
								in which the rep of T will be constructed      

    N2 T2                     -> n2 = construct(rh, data)      construct T2 at pos 
                                 
    N3 T3                     -> n3 = construct(rh, data)

    N4 T4                     -> n4 = construct(rh, data)

                         -> construct_T1 (n2, n3, n4)

Serialization/writing of a PADS source:

  If you call the write function on a type annotated as 'PSource', the
  entire 

Generating template programs from the description:
  Pick streaming version vs. holistic PSource type. 

  A streaming version breaks the description up into pieces, e.g., a
  header, an array of Precords, and a trailer.

TODO:

  For format7

  o Mary needs to write the driver program for converting galax nodes to
    pads nodes, then serializing. 

  o Mary needs to write the generic code for converting a galax node
    to a pads node.

  o Write the pseudo-code for type-dependent dispatch. 

  o Kathleen will confer with Bob on dealing with PADS handle stuff. 

  

 