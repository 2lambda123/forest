Types of checking
-----------------

Flag PDC_SynCheck controls syntactic checking (all are built-in checks)

BASE:       checks that can be skipped and still read the base type


Example 1:  PDC_a_str_lit_read normally verifies that the string at the current IO position
            is the specified string literal.  However, if PDC_SynCheck is not set, it simply
            assumes the current IO position points to this string literal and advances the IO position
            by the length of the literal, without checking.  Note that if the required number
            of characters is not available, then an error IS reported, regardless of which
            flags are or are not set: a width check is an example of a check that cannot be skipped.

(Example 2 is not implemented, and maybe should not be)
Example 2: (pdc->disc->flags & PDC_WHITESPACE_OK) == 0
            normally means white spaces in <example case> cause an error,
            but this case is only checked if PDC_SynCheck is set in the mask
            associated with the base type element.

STRUCTURED: checks that can be skipped and still read the structure
            errors that can cause panic to be set are always checked,
            e.g., missing array terminator.
 
Example: extra stuff before array terminator normally causes an error,
         but this case is only checked if PDC_SynCheck is set in the mask
         in the 'array' field of the array's mask.


Flag PDC_SemCheck controls semantic checking.  This includes:
    1. All user-defined constraints.
    2. Range checking for numeric base types.
             
Example: suppose a .p file includes this Pstruct element:

         Pa_int16   x : x < 7;

In the corresponding mask, if the x mask has PDC_SemCheck set,
then this will cause both range checking and a check of whether
x is less than 7.  If PDC_SemCheck is not set, then neither
range checking nor the user constraint are checked.


N.B. Interaction of Checking With Punions
-----------------------------------------

A Punion read function tries to read the type of each union arm in
turn, and succeeds on the first successful read.  The union's mask
allows you to control the checking for each of the arms. If you disable
too much checking for a given arm, the read for that arm may succeed
even though the actual arm that you would like to succeed is a later
arm in the union.

Example:
   need to make up an example


