Notes/Problems/Ideas/Things to Consider:
 1. environment variables are tied to file paths.
 2. some files are in other formats----  should we have some way of 
    specifying "valid html file, valid css file, valid word doc, etc"
 3. command-line options
 4. prior work on hancock
 5. there needs to be some way to specify the root 
 6. tool: set permissions based on description
 7. tool: graphical representation of links, generate dependencies
 8. tool: check def/use pairs?
     Which scripts write to the log file?
 9. Directory field names:
     1. constants that match underlying file names
        -- how to convert these to program identifiers?
     2. program variables that have path/filename values
     3. program variables that form part of a path/filename
     4. environment variables
     possible solution:
       directory field names are expressions having type filepath.
       Strings (and possibly integers?) can be converted to file paths automatically?
       use syntax to map string expressions to environment variables.
11. Add separate notation for being able to specify the interface for different kind of plug-ins
12. Tool to seed description from current directory structure
13. Pros/cons of language extensions vs. library
    same underlying semantics
    library for Haskell
14. description of directory structure to extract
15. tool: given directory structure, extract description for editing

Core ideas:
  codify syntax
  list comprehensions?  
     - is there a different way of expressing them?
  functions come later?


(* Assume the existence of types that indicate well-formed
   word, css, html, jpg etc **)


(* Directory of image files *)
pdirectory imgs_t = {
    "pads_small.jpg" : p_jpg <| permission.all=r;
  }

(* Static visual content *)
pdirectory static_t = {
    "pads.css"           : p_css  <| permission.all=r;
    "learning-demo.html" : p_html <| permission.all=r
    "atitle.html"        : p_html <| permission.all=r
    "top-left.html"      : p_html <| permission.all=r
    "banner.html"        : p_html <| permission.all=r
    "nothing.html"       : p_html <| permission.all=r;
    "images"             : imgs_t <| permission=rwxr-xr-x;
  }


(* this is a good example where having a "set" type in pads would be useful *)
ptype config_t = {
   header : pstring_se(pre "$");
   "$host_name   ="  host_name   : "\"" * pstring("\"") * "\";\n"  -- Name of machine hosting web site
   "$static_path ="  static_path : "\"" * pstring("\"") * "\";\n"  -- URL prefix for static content
   "$cgi_path    ="  cgi_path    : "\"" * pstring("\"") * "\";\n"  -- URL prefix for cgi content
   "$script_path ="  script_path : "\"" * pstring("\"") * "\";\n"  -- Directory of scripts in live web site
   "$tmp_root    ="  tmp_root    : "\"" * pstring("\"") * "\";\n"  -- Directory for temporary user data
   "$pads_home   ="  pads_home   : "\"" * pstring("\"") * "\";\n"  -- Directory containing pads system
   "$learn_home  ="  learn_home  : "\"" * pstring("\"") * "\";\n"  -- Directory containing learning system
   "$sml_home    ="  sml_home    : "\"" * pstring("\"") * "\";\n"  -- Directory containing SML executable
   "$insrall_src ="  install_src : "\"" * pstring("\"") * "\";\n"  -- Directory containing website source
   "$static_dst  ="  static_dst  : "\"" * pstring("\"") * "\";\n"  -- Directory for static content in live site
   "$cgi_dst     ="  cgi_dst     : "\"" * pstring("\"") * "\";\n"  -- Directory for cgi content in live site
   trailer : pstring(eor);
}

(* userEntry_t maps a userID to the directory associated with that user. 
   usersFilt_t contains one such mapping for each user *)
ptype userEntry_t = {
   "id.",
   userId : pint,
   ",",
   "id.",
   dirId : pint * "." * pint
} <| userId = #1 dirId;

ptype usersFile_t = userEntry_t plist;

(* List of source data files whose formats can be learned. *)
ptype sourceFiles_t = pstring(peor) plist;

(* Log of requests.  Used to track denial of service attacks. *)
ptype logEntry_t = {
  userId : pint,         ",",
  ip     : pip,          ",",
  script : pstring(" "), " ",
  userDir: pstring(" "), " ",
  pads   : pstring(" "), " ",
  sml    : pstring_se(" "+peor), " "?, 
  msg    : pstring(peor)
};

ptype logFile_t = logEntry_t plist;

(* Data files used by demo application *)
pdirectory info_t = {
     "usersFile"   : usersFile_t   <| permission.all=r;   -- mappings from userIDs to directory names
     "sourceFiles" : sourceFiles_t <| permission.all=r;   -- list of source data files whose formats can be learned
     "logFile"     : logFile_t     <| permission.all=r;   -- log of server actions.
};                          

(* Given a set of userIds, return the associated set of directory names *)
userDirs(f:usersFile_t) = {x.dirId | x <- f};  -- Haskell syntax

pfile dataFile_t = p_txt <| permission=rw-rw-r--

pdirectory dataSource_t(sources : sourceFiles_t) = {
      dataSource[ s  | s <- sources] :* dataFile_t ;
  };

(* Type of a link with permission rwxrwxr-x to location p with type data_t *)
pfile dataLink_t(p:path) = (^p : dataFile_t) <| permission=rwxrwxr-x 

(* Directory of links to source data files *)
pdirectory data_t(sources : sourceFiles_t, dataSourceDir:dataSource_t(sources)) = {
     [s : dataLink_t(dataSourceDir/s) option |  s <- sources]
(* alt:     foo[s | s <- sources] : * dataLink_t(dataSourceDir/s) option *)
  foo[s | s <- sources] :* dataLink_t(dataSourceDir/s) option 
  s:Set(sources) :* dataLink_t(dataSourceDir/s) option 
};

pdirectory machineDep_t(source:string){
   source + ".c"      : p_ccode   <| permission.a=r;
   source + ".h"      : p_ccode   <| permission.a=r;
   source + ".o"      : p_objcode <| permission.a=r;
   source + ".pxml"   : p_xml     <| permission.a=r;  -- description in xml syntax
   source + ".xsd"    : p_xsd     <| permission.a=r;  -- xschema of xml syntax for source description
   source + "-accum"  : p_exe     <| permission=-rwxr-xr-x option;
   source + "-fmt"    : p_exe     <| permission=-rwxr-xr-x option;
   source + "-xml"    : p_exe     <| permission=-rwxr-xr-x option;
};

(* Each instance of this type contains the generated files for a particular description *)
(* Yet another way of using names... here an environment variable... *)
pdirectory example_t(source:string){
     source + ".p"    : p_pads   <| permission.a=r;    -- padsc description of data source
     source + ".pml"  : p_padsml <| permission.a=r;    -- padsml description of data source
     "vanilla.p"      : p_pads   <| permission.a=r;    -- input tokenization
     "GNUmakefile"    : p_make   <| permission.a=r;    
     $"AST_ARCH"      : machineDep_t(source) <| permission=rwxrwxrwx option;   -- Platform dependent files
     source + "-accum.c"       : p_ccode <| permission.a=r option;   -- template for generating accumulator output
     source + "-accum.out"     : p_txt   <| permission.a=r option;   -- ASCII Aaccumulator output
     source + "-accum_xml.out" : p_txt   <| permission.a=r option;   -- XML Aaccumulator output
     source + "-xml.c"         : p_ccode <| permission.a=r option;   -- template for generating xml output
     source + "-xml.out"       : p_txt   <| permission.a=r option;   -- XML representation of source
     source + ".xsd"           : p_xsd   <| permission.a=r option;   -- XSchema for XML representation of source
     source + "-fmt.c"         : p_ccode <| permission.a=r option;   -- template for generating fmt output
     source + "-fmt.out"       : p_txt   <| permission.a=r option;   -- Formatted representation of source
};

(* This directory stores all information for one user. *)
pdirectory user_t(sources:sourceFiles_t, dataSource:dataSource_t(sources))  = {
    [    s  : (example_t(s) <| permission=rwxrwxrwx) option | s <- sources];
     "data" : (data_t(sources,dataSource) <| permission=rwxrwxrwx) option;
  }


(* This directory stores temporary information associated with different users. *)
pdirectory users_t(info:info_t, dataSource:dataSource_t) = {
    [user : user_t(info.sourceFiles, dataSource) <| permission=rwxrwxrwx option
          | user <- userDirs(info.usersFile) ]
  }

description_t  : (src_name : string, 
                  userDir/src_name : example_t(src_name),
                  userDir/data/src_name : p_txt <| permission.a=r)
        -p_cgi-> . 

enterData_t   : (pads_home/learning/scratch/data/hp-struct : p_txt <| permission.a=r) 
        -p_cgi-> 

genData_t     : 

pdirectory cgi_t = {
    config1 as "PLConfig.pm"        : config_t <| permission.all=r;
    config2 as "PLConfig.pm"        : p_cgi  <| permission.all=r;
    "PLUtilities.pm"     : p_cgi  <| permission.all=r;
    "learning-demo.cgi"  : p_cgi  <| permission=rwxr-xr-x;
    "navbar-orig.cgi"    : p_cgi  <| permission=rwxr-xr-x;
    "pads.cgi"           : p_cgi  <| permission=rwxr-xr-x;
    "data-results.cgi"   : p_cgi  <| permission=rwxr-xr-x;         (* look further *)
    "navbar.cgi"         : p_cgi  <| permission=rwxr-xr-x;
    "build-description.cgi"    : description_t  <| permission=rwxr-xr-x;   
    "build-roll-your-own.cgi"  : p_cgi  <| permission=rwxr-xr-x;   (* look further *)
    "genData.cgi"        : p_cgi  <| permission=rwxr-xr-x;         (* look further *)
    "build-accum.cgi"    : p_cgi  <| permission=rwxr-xr-x;         (* look further *)
    "build-xml.cgi"      : p_cgi  <| permission=rwxr-xr-x;         (* look further *)
    "build-fmt.cgi"      : p_cgi  <| permission=rwxr-xr-x;         (* look further *)
    "build-library.cgi"  : p_cgi  <| permission=rwxr-xr-x;         (* look further *)
  }

ptype rlearn_t : (src_name :  string, 
                  dataSourceNames : sourceFiles_t,
                  dataSourceDir   : dataSource_t,
                  userDir         : user_t(dataSourceNames, dataSourceDir(dataSourceNames)) option
        -p_bash-> 
	          userDir + userDir/data : data_t(dataSourceNames,dataSourceDir(dataSourceNames))  
                          + userDir/src_name : example_t(src_name) 

pdirectory scripts_t = {
    "rlearn"             : rlearn_t <| permission=rwxr-xr-x;
    "rlearn-own"         : p_bash   <| permission=rwxr-xr-x;
    "r-accum"            : p_bash   <| permission=rwxr-xr-x;
    "r-xml"              : p_bash   <| permission=rwxr-xr-x;
    "r-fmt"              : p_bash   <| permission=rwxr-xr-x;
  }


pfoo website_t(c:config_t)  = {
  c.cgi_path     : cgi_t     <| rwxrwxr-x;      -- cgi web site content
  c.static_path  : static_t  <| rwxrwxr-x;      -- static web site content
  c.script_path  : scripts_t <| rwxrwxr-x;      -- scripts invoked by cgi to run learning system
  c.static_dst   : info_t    <| rwxrwxr-x;      -- administrative information about website
  c.tmp_root     : users_t   <| rwxrwxr-x;      -- per user information
} 


let w : website_t(Root/cgi-bin/PLConfig.PM)
          
