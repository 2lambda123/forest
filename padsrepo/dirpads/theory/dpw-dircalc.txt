+------------+
| DATA MODEL |
+------------+
n ::= ...            -- STRINGS

r,s ::=              -- PATHS
  | /n1/ ... /nk

m ::= ...            -- METADATA

T ::= -- FILESYSTEM CONTENTS
  | file(n)
  | dir({n1,...,nk})
  | link(r)

F ::= -- FILESYSTEM
  | { r |-> m * T }

Definition: F is WELL-FORMED if and only if it is a path-prefix-closed
finite map from paths to T and for all paths r in dom(F) 
either 
  (1) F(r) = m * dir{n1,...,nk} and for i=1..k. r/n in dom(F) or 
  (2) F(r) = m * file(n) and r/n not in dom(F)
  (3) F(r) = m * link(p) and r/n not in dom(F)

+--------+
| SYNTAX |
+--------+
s ::=                -- SPECIFICATION
    | k              -- constant (e.g., dir, file, link, csv, xml, ascii, etc.)
    | Adhoc(b)       -- PADS-described data
    | Pred(e)        -- predicate
    | Transform(e,s) -- transformation
    | e :: s         -- path 
    | <x:s, s>       -- dependent pair
    | s?             -- option
    | { s | x in e } -- structural recursion

v ::= m | n | r | true | false | Some v | None | {v1,..,vk}

e ::= x | v | ...

+-----------+
| SEMANTICS |
+-----------+
We assume a collection of type-indexed evaluation functions for expressions

eval_tau : env * F * path * exp -> tau

The judgment E; F; r |= s ==> v * d relates an environment E, file
system F, normal path r, specification s, value v, and parse
descriptor d.  The judgment is a total function from tuples (E,F,r,s)
to non-empty sets of pairs (v,d). 

We do not assume r in dom(F).

Parse Descriptors d have the following shape:

type header = bool
type 'a pd  = header * 'a

We use the function valid to determine if the data described by a was
parsed successfully:

fun valid (x:'a pd) : header = pi_1 x

============
= CONSTANT =
============

----------------------------
E;F;r |= k ==> check_k(F,r)

Here are several instances of check_k:

  * check_any(F,r) = ((),(true,m)) if F(r) = (m,_)
  * check_any(F,r) = ((),(false,default_m)) otherwise
    - RP: unit
    - PD: meta pd

  * check_dir(F,r) = (cs,(true,m)) if F(r) = (m,dir(cs)) 
  * check_dir(F,r) = ({},(false,m)) if F(r) = (m,T), T not dir(cs)
  * check_dir(F,r) = ({},(false,default_m)) otherwise
    - RP: string set
    - PD: meta pd

  * check_file(F,r) = (n,(true,m)) if F(r) = (m,file(n))
  * check_file(F,r) = ("",(false,m)) if F(r) = (m,T), T not file(n)
  * check_file(F,r) = ("",(false,default_m)) otherwise
    - RP: string
    - PD: meta pd 

  * check_link(F,r) = (p,(true,m)) if F(r) = (m,link(r')
  * check_link(F,r) = (/.,(false,m)) if F(r) = (m,T), T not link(r')
  * check_link(F,r) = (/.,(false,default_m)) otherwise
    - RP: path
    - PD: meta pd

=========
= ADHOC =
=========

RP: b_{RP}
PD: (b_{PD} * meta) pd

F(r) = (m,file(n'))
b(E,n') = (v,d)
-----------------------------------------
E;F;r |= Adhoc(b) ==> (v,(valid d,(d,m)))

F(r) = (m,dir(_)) or F(r) = (m,link(_)) or r not in dom(F)
b(E,"") = (v,d)
---------------------------------------
E;F;r |= Adhoc(b) ==> (v,(false,(d,m)))

=============
= PREDICATE = 
=============
RP: unit
PD: unit pd

-------------------------------------------------
E;F;r |= Pred(e) ==> ((),(eval_bool(E,F,r,e),()))

========
= PATH = 
========
RP: s_{RP}
PD: s_{PD} 

E;F;eval_path(E,F,r,r/e) |= s ==> (v,d)
---------------------------------------------
E;F;r |= e :: s ==> (v,d)

========
= PAIR = 
========
RP: s1_{RP} * s2_{RP}
PD: (s1_{PD} * s2_{PD}) pd

E;F;r |= s1 ==> (v1,d1)
E[x:=v1,x_d:=d1];F;r |= s2 ==> (v2,d2)
------------------------------------------------------------------
E;F;r |= <x:s1, s2> ==> ((v1,v2),(valid d1 && valid d2, (d1,d2)))

==========
= OPTION = 
==========
RP: s_{RP} option
PD: (s_{PD} option) pd

E;F;r |= s ==> (v,d) 
valid d = true
--------------------------------------------
E;F;r |= s? ==> (Some v,(true, Some d1))

E;F;r |= s ==> (v,d)
valid d1 = false
-------------------------------------------
E;F;r |= s? ==> (None,(false, None))

=================
= COMPREHENSION =
=================
RP: s_{RP} list
PD: (s_{PD} list) pd

eval_tau_set(E,F,r,e) = T 
S = { (v,d) | t in T and E[x:=t];F;r |= s ==> (v,d) }
----------------------------------------------------------------
E;F;r |= { s | x:tau in e } ==> (FST S, (&& (VALID (SND S)), DESC (SND S)))

-- We lift {fst,snd,valid,desc,&&} to sets in the obvious way:
  FST : ('a * 'b) set -> 'a set
  SND : ('a * 'b) set -> 'b set
  VALID : ('a pd) set -> header set
  DESC : ('a pd) set -> 'a set
  && : bool set -> bool
