ToDo:
- Fix well-formedness lemma based on hasHeader lemma.
- verify that types of constructors lemma is correct.
x Ensure that all figures have consistent ordering.
x Fix substitution lemmas, and proof cases for rec. and tyApp correspondingly.
x Define D_G, D_rep and D_PD in paper.
x Add condition to compute kinding rule to prevent a_Pb escape.
x Check that s (in compute(e:s)) is well formed in rep_var context:  D_rep |- s :: T.
x Prove Rep. Type Well-Formedness lemma.
x Add condition on base types. |- B_type(C) :: T

Note: PT(s) = [s]_PT, for any string s.


Lemma: If D;G |- t : k then |- D_G,G ok
pf: by induction
           
Lemma: If |- G ok and x:s in G, then G |-  s :: T 
pf: by induction.

Lemma: If [t]_rep == [t']_rep and [t]_PD == [t']_PD,
       then PT(t:k) == PT(t':k).
pf: by induction on kinds.
   case T: 
      to prove: 
        PT(t:T) == PT(t':T).
        b*o->o * [t]_rep * [t]_PD == b*o->o * [t']_rep * [t']_PD
      need to prove:
        [t]_rep == [t']_rep and [t]_PD == [t']_PD
      both are given.
   case s -> k:
        PT(t:s->k) == PT(t':s->k)      
        s -> PT(t e:k) == s -> PT(t' e:k)      
   need to prove,
        PT(t e:k) == PT(t' e:k)    
   as k is smaller, follows by induction.  

   case T -> k:
        PT(t:T->k) == PT(t':T->k)      
        Aa'_rep.Aa'_Pb.PT(a':T) -> PT(t a':k) == 
          Aa'_rep.Aa'_Pb.PT(a':T) -> PT(t' a':k)    
   need to prove,
        PT(t' a':k) == PT(t' a':k)    
   as k is smaller, follows by induction.  

Substitution Lemmas:

Definition: simultanueaous substitution:
[a/b,c/d,...] denotes a simultaneous substitution.

Defintion: substitution abbreviations:
X(t,a) = [t]_rep/a_rep, [t]_Pb/a_Pb
Y(t,a) = t/a, [t]_rep/a_rep, [t]_Pb/a_Pb

Lemma:
1. [t]_rep [X(t',a)] = [t[Y(t',a)]]_rep
2. [t]_PD [X(t',a)]  = [t[Y(t',a)]]_PD

pf: by induction on structure of types.
Two interesting cases: compute(e:s) b/c must take s into account, 
and t1 t2.

case [t1 t2]_PD:
     [t1 t2]_PD [X(t',a)]
   = ([t1]_PD [t2]_Pb) [X(t',a)]
   = [t1]_PD [X(t',a)] [t2]_Pb [X(t',a)]
By IH,
   = [t1 [Y(t',a)]]_PD [t2]_Pb [X(t',a)]   (A)

Now, by IH,
   [t2]_PD [X(t',a)] = [t2[Y(t',a)]]_PD
So,
   (pd_hdr * [t2]_Pb) [X(t',a)] = pd_hdr * [t2[Y(t',a)]]_Pb
   pd_hdr * ([t2]_Pb [X(t',a)]) = pd_hdr * [t2[Y(t',a)]]_Pb
So,
   [t2]_Pb [X(t',a)] = [t2[Y(t',a)]]_Pb

From this, we have:
   (A) = [t1 [Y(t',a)]]_PD [t2[Y(t',a)]]_Pb
   = [(t1 t2) [Y(t',a)]]_PD

Lemma: PT(t:k)[X(t',a)] = PT(t[Y(t',a)]:k[Y(t',a)])
pf: by induction on size of kind.
case T:
  PT(t:T) = b * o -> o * [t]_rep * [t]PD 
So,
  PT(t:T)[X(t',a)] =
    b * o -> o * [t]_rep[X(t',a)] * [t]_PD[X(t',a)]
  By lemma, 
    = b * o -> o * [t[Y(t',a)]]_rep * 
		   [t[Y(t',a)]]_PD
    = PT(t[Y(t',a)]:T)
    = PT(t[Y(t',a)]:T[Y(t',a)])

case s -> k:
  PT(t:s->k) = s -> PT(t e:k)
  PT(t:s->k)[X(t',a)] = (s -> PT(t e:k))[X(t',a)]
  = s[X(t',a)] -> PT(t e:k)[X(t',a)] 
Now, a not in FTV(s) so 
  s[X(t',a)] = s[Y(t',a)]
By IH, 
   PT(t e:k)[X(t',a)] = PT((t e)[Y(t',a)]:k[Y(t',a)])
   = PT(t[Y(t',a)] e : k[Y(t',a)])
From above
  s[X(t',a)] -> PT(t e:k)[X(t',a)] = s[Y(t',a)] -> PT(t[Y(t',a)] e : k[Y(t',a)])
   = PT(t[Y(t',a)] : (s->k)[Y(t',a)])

case T -> k:
  PT(t:T->k) = Aa'_rep.Aa'_pd_body.PT(a':T) -> PT(t a':k)

By IH,
  PT(a':T)[X(t',a)] = PT(a'[Y(t',a)]:T)
and
  PT(t a':k)[X(t',a)] = PT((t a')[Y(t',a)]:k[Y(t',a)])
As a' != a,
  PT(a'[Y(t',a)]:T) = PT(a':T)
and
  PT((t a')[Y(t',a)]:k[Y(t',a)]) = PT(t[Y(t',a)] a':k[Y(t',a)])

Now,
  PT(t:T->k)[X(t',a)]
  = (Aa'_rep.Aa'_pd_body.PT(a':T) -> PT(t a':k))[X(t',a)]
  = Aa'_rep.Aa'_pd_body.PT(a':T)[X(t',a)] -> PT(t a':k)[X(t',a)]
  = Aa'_rep.Aa'_pd_body.PT(a':T) -> PT(t[Y(t',a)] a':k[Y(t',a)])
  = PT(t[Y(t',a)] : T -> k [Y(t',a)])
  = PT(t[Y(t',a)] : (T -> k) [Y(t',a)])

Corrollary:
 If a_rep,a_Pb not in FTV(k), 
 then PT(t:k)[X(t',a)] = PT(t[Y(t',a)]:k)

**********

Has-header theorem.

**********

Goal: To prove that [t]_PD is well-defined for all well-formed types t.


% Note that by this definition, we not only get that [t]_PD type has the
% structure pd_hdr * ..., but that the [t]_PD is well-defined.
% Note: I don't think that first part of second condition is necessary
% as functions can only have parameters at kind T, so that part isn't
% used. Still, it "feels" right.

Definition: H(t:k), 
  H(t : k) iff 
   1) k = T and exists s s.t. [t]_PD == pd_hdr * s.
   2) or, k = T -> k', exists s s.t. [t]_PD == s and for all t' s.t. H(t': T), H(t t' : k').
   3) or, k = s -> k', exists s' s.t. [t]_PD == s' and for all e, H(t e : k').

Lemma:
  If H(t : k) then exists s s.t. [t]_PD = s.
pf: follows immediately from definition of H.

% Note that we implicitly demand that [t]_PD is well defined in the
% hypothesis of the lemma. Cannot assume that [t]_PD is well-defined,
% even for well-formed t, as that is what we are trying to prove.

Lemma: If [t]_PD == [t']_PD, then H(t:k) iff H(t':k)
pf: by induction on structure of kind:
case k = T:
  ("only if" direction):
  Then, H(t : T), which means that there exists s' s.t. [t]_PD == pd_hdr * s'.
  Since [t]_PD == [t']_PD, by symm. and trans.,
    exists s' s.t. [t']_PD == pd_hdr * s'.
  i.e. H(t' : T).

  ("if" direction):
  Given H(t : T), that is: exists s' s.t. [t']_PD == pd_hdr * s'.
  By trans, exists s' s.t. [t]_PD == pd_hdr * s'.
  i.e. H(t : T).
    
case k = T -> k'
  ("only if"):
  H(t : T -> k'), that is: 
    exists s s.t. [t]_PD = s and for all t'' s.t. H(t'':T), H(t t'' : k').
  Assume  H(t'' : T) for arbitrary t''.
     By above, (instantiating forall at t''):
       H(t t'' : k')
     By H(t'':T), 
       exists s s.t. [t'']_PD == pd_hdr * s,
     So, [t'']_Pb is well-defined:
       [t'']_Pb = s.
     By Q-App, [t]_PD == [t']_PD, and [t'']_Pb == [t'']_Pb:
       [t]_PD [t'']_Pb == [t']_PD [t'']_Pb
       [t t'']_PD == [t' t'']_PD
     By IH (and above),
       H(t' t'': k')
  So,
    H(t' : T -> k')

  ("if" direction):
  H(t' : T -> k'), that is: 
    exists s s.t. [t']_PD = s and for all t'' s.t. H(t'':T), H(t' t'' : k').
  Assume  H(t'' : T) for arbitrary t''.
      By above, (instantiating forall at t''):
	H(t' t'' : k')
      By H(t'':T), 
	exists s s.t. [t'']_PD == pd_hdr * s,
      So, [t'']_Pb is well-defined:
	[t'']_Pb = s.
      By Q-App, [t]_PD == [t']_PD, and [t'']_Pb == [t'']_Pb,
	[t]_PD [t'']_Pb == [t']_PD [t'']_Pb
	[t t'']_PD == [t' t'']_PD
      By IH (and above),
	H(t t'': k') iff  H(t' t'': k')
      As we have H(t' t'': k'), we now know:
       H(t t'': k') 
  So,
    H(t : T -> k')

case k = s -> k'
  ("only if"):
  H(t : s -> k'), that is: 
    exists s' s.t. [t]_PD = s' and for all e, H(t e : k').
  Assume arbitrary e
     By above, (instantiating forall at e):
       H(t e : k')
     From [t]_PD == [t']_PD we get:
       [t e]_PD == [t' e]_PD
     By IH (and above),
       H(t' e: k')
  So,
    H(t' : s -> k')

  "if" direction is analogous

Abbrev: U = X(t1,a1),...,X(tn,an)
        W = Y(t1,a1),...,Y(tn,an)

Lemma: 
 If D,a1:T,...,an:T;G |- t : k and H(ti:T) then H(t[W] : k).

pf: by induction on first kinding derivation.

case unit, bottom, constant, compute, absorb: immediate (no open variables).

case DepSum: 

	   D;G |- t : T   D;G,x:[t]_rep * [t]_PD |- t' : T
	   ----------------------------------------------- 
			 D;G |- E x:t.t' : T

To prove:
  H(E x:t.t'[W] : T), that is exists s s.t. [E x:t.t'[W]]_PD == pd_hdr * s.
As [E x:t.t']_PD = pd_hdr * ([t]_PD * [t']_PD), need to prove only
  exists s1,s2 s.t. [t[W]]_PD == s1 and [t'[W]]_PD == s2  
and then set s = s1 * s2
By IH,
  H(t[W]:T) and H(t'[W]:T)
So, exists s1,s2 s.t. [t[W]]_PD == s1 and [t'[W]]_PD == s2.

case Sum, Intersection, Constraint, seq, scan: analogous to DepSum.

case Abs:
  To prove: H((\x.t)[W]:s -> k).
  By IH, H(t[W]:k), so [t[W]]_PD exists, by which we know [\x.t[W]]_PD
  exists.

  Next, consider arbitrary e:
    Need to prove H((\x.t)[W] e: k). 
    Now, [(\x.t)[W] e]_PD = [(\x.t)[W]]_PD =[\x.t[W]]_PD = [t[W]]_PD.
    So, [(\x.t)[W] e]_PD == [t[W]]_PD.
    By (previous?) lemma, and IH, H((\x.t)[W] e:k).
    
case App:
  To prove: H((t e)[W]:k).
  By IH, H(t[W]:s->k), i.e. forall e, H(t[W] e: k).
  Instantiate with e[W],
    H(t[W] e[W]:k), i.e. H((t e)[W]:k).

case TyVar: 
  To prove: H(a[W]:T)
  If a = ai (for some i) then a[W] = ti and from premise, H(ti:T) so H(a[W]:T).
  If a != ai, then a[W] = a and [a]_PD = pd_hdr * a_Pb, so H(a[W]:T).

case Rec:
  To prove: H(ua.t[W]:T), that is exists s s.t. [ua.t[W]]_PD == pd_hdr * s.
  As (ua.t)[W] = ua.(t[W]), need to prove:
    exists s s.t. pd_hdr * ua_Pb.[t[W]]_PD == pd_hdr * s.
  From equality rules, we need exists s' s.t. [t[W]]_PD == s'.
  Then, s = ua_Pb.s' would give us our result. If we can prove the
  stronger result H(t[W]:T), then we are done.

  From derivation, D,a1:T,...,an:T,a:T;G |- t : T, which, by reordering gives
  us D,a:T,a1:T,...,an:T;G |- t : T. By IH, H(t[W]:T) and we're done.

case TyAbs:
  To prove: H((\a.t)[W]:T -> k), that is
    exists s s.t. [(\a.t)[W]]_PD == s and for all t' s.t. H(t': T), H((\a.t)[W] t' : k).
  
  First, lets prove that exists s s.t. [(\a.t)[W]]_PD == s.
  From derivation, D,a1:T,...,an:T,a:T;G |- t : k, which, by reordering gives
  us D,a:T,a1:T,...,an:T;G |- t : k. By IH, H(t[W]:k), so exists s' s.t. [t[W]]_PD == s'.
  As [(\a.t)[W]]_PD = \a_Pb.[t[W]]_PD, we have our s = \a_Pb.s'.

  Next, let's prove that for all t' s.t. H(t': T), H((\a.t)[W] t' : k).
  Assume H(t':T) for some arbitrary t'.    
    From derivation, D,a1:T,...,an:T,a:T;G |- t : k. By IH, H(t[W,Y(t',a)]:k).
    First, t[W,Y(t',a)] = t[W][Y(t'a,)] (i.e. change from simultaneous
    subst. to sequential subst.), because, if "a" free in any of
    ti, just alpha-vary "a" in "t". Next, by subst. lemma,
    [t[W][Y(t',a)]]_PD = [t[W]]_PD[X(t',a)]. As a_rep not in
    FTV(t[W]), = [t[W]]_PD[[t']_Pb/a_Pb].
    By equivalence rules, [t[W]]_PD[[t']_Pb/a_Pb] == (\a_Pb.[t[W]]_PD) [t']_Pb.
    So, [t[W,Y(t',a)]]_PD == (\a_Pb.[t[W]]_PD) [t']_Pb.
    That is, [t[W,Y(t',a)]]_PD == [(\a.t)[W]]_PD [t']_Pb.
    That is, [t[W,Y(t',a)]]_PD == [(\a.t)[W] t']_PD.
    By lemma and H(t[W,Y(t',a)]:k), we have H((\a.t)[W] t':k).

case TyApp:
  To prove: H((t1 t2)[W]: k). 
  By IH, H(t1[W]:T -> k) and H(t2[W] : T).
  So, forall t' s.t. H(t':T), H(t1[W] t':k).
  So, H(t1[W] t2[W]:k), i.e. H((t1 t2)[W]:k).

Corrollary 1:
 If D;G |- t : k then H(t : k).
  
Corrollary 2:
 If |- t : k then H(t : k).
  

Assume of F_omega:
If G |- s :: k and s == u then G |- u :: k.

Definition: Kind interpretation in F-omega.
K(T)      = T
K(s -> k) = K(k)
K(T -> k) = T -> K(k)

Lemma: Rep. Type Well-Formedness
If D;G |- t : k then 
  D_rep |- [t]_rep :: K(k)
  D_PD |- [t]_PD  :: K(k)
  if k = T then
   D_PD |- [t]_Pb  :: T
pf:  by induction using HasHeader lemma.

**************************
Type Correctness theorem:
**************************

If D;G |- t : k then D_G,G,[D]_PT |- [t] : [t:k]_PT

proof:
By induction on kinding derivations.


case Unit:
case Bottom:
  by code inspection and lemma on types of constructors.

case Const:
  by code inspection and condition on base types.

case Abs:

			   D;G,x:s |- t : k
			 -------------------- 
			 D;G |- \x.t : s -> k


By IH, D_G,G,x:s,[D]_PT |- [t] : PT(t:k)
By F_omega typing, D_G,G,[D]_PT |- \x.[t] : s -> PT(t:k)

case App:

		  D;G |- t : s -> k   D_G,G |- e : s
		  ---------------------------------- 
			    D;G |- t e : k

By IH, D_G,G,[D]_PT |- [t] : [t:s -> k]_PT
So,    D_G,G,[D]_PT |- [t] : s -> [t e:k]_PT
By typing, [t] e: [t e:k]_PT

case DepSum:

	   D;G |- t : T   D;G,x:[t]_rep * [t]_PD |- t' : T
	   ----------------------------------------------- 
			 D;G |- E x:t.t' : T


By IH, D_G,G,[D]_PT |- [t] : [t:T]_PT
By IH, D_G,G,x:[t]_rep * [t]_PD,[D]_PT |- [t'] : [t':T]_PT

To prove:
  D_G,G,[D]_PT |- [E x:t.t'] : [E x:t.t':T]_PT.

We have,
   D_G,G,[D]_PT |- [t] : b * o -> o * [t]_rep * [t]_PD
So,
   D_G,G,[D]_PT,B:b,w:o |- [t](B,w) : o * [t]_rep * [t]_PD
and,
   D_G,G,[D]_PT,B:b,w:o,w':o,r:[t]_rep,p:[t]_PD |- (r,p) : [t]_rep * [t]_PD
From IH,
   D_G,G,x:[t]_rep * [t]_PD,[D]_PT |- [t'] : b * o -> o * [t']_rep * [t']_PD
So,
   D_G,G,x:[t]_rep * [t]_PD,[D]_PT |- [t'](B,w') : o * [t']_rep * [t']_PD
And we then have the following context in which to type the final expression:
   D_G,G,[D]_PT,B:b,w:o,w':o,,w'':o,
   x:[t]_rep * [t]_PD,
   r:[t]_rep,p:[t]_PD,r':[t']_rep,p':[t']_PD
Instantiating R_E at [t]_rep and [t']_rep and P_E at [t]_Pb and 
[t']_Pb,
   (big context) |- (w'',R_E(r,r'),P_E(p,p')) :   o * [E x:t.t']_rep * [E x:t.t']_PD 


case Sum:

		   D;G |- t : T   D;G |- t' : T
		   ------------------------------- 
			  D;G |- t + t' : T

to prove:
  D_G,G,[D]_PT |- [t+t'] : PT(t+t':T)

As PT(t+t': T) = b*o -> o * [t+t']_rep * [t+t']pd
	       = b*o -> o * ([t]_rep + [t']_rep) * (pd_hdr * [t]pd + [t']pd),
we need to prove:
  D_G,G,PT(D) |- [t+t'] : b*o -> o * ([t]_rep + [t']_rep) * (pd_hdr * [t]pd + [t']pd)


By IH, D_G,G,PT(D) |- [t] : PT(t:T)
PT(t:T) = b*o -> o * [t]_rep * [t]pd
[t](B,w): o * [t]_rep * [t]pd
so, r : [t]_rep and p : [t]pd
instantiate R_+left with [t]_rep and [t']_rep,
instantiate P_+left with [t]_Pb and [t']_Pb,
and, by "Types of Constructors" lemma,
then-branch of line 2 has type 
o * ([t]_rep + [t']_rep) * 
  (pd_hdr * ([t]pd + [t')]pd))

By IH, D_G,G,PT(D) |- [t'] : PT(t':T)
  PT(t':T) = b*o -> o * [t']_rep * [t']pd
Using parallel argument to the above, obtain that else branch has type:
o * ([t]_rep + [t']_rep) * 
  (pd_hdr * ([t]pd + [t']pd)).

Therefore, the function has the correct type.

case Intersection: same method as sum.

case Set: same methods as product.

case Seq:
start by giving types to isDone and continue:

t_m = t seq(t_s,e,t_t)
isDone:o * [t_m]_rep * [t_m]pd -> bool
  use IH to show that p' has type [t_t]_PD and therefore valid argument
  to isOk.

continue: o * o * [t_m]_rep * [t_m]pd 
          ->  o * [t_m]_rep * [t_m]pd

next, we type the body:
r: int * [t]_rep seq
p: pd_hdr * (arr_pd [t]pd)
then-branch: o * (int * [t]_rep seq) * (pd_hdr * (arr_pd [t]pd))
else-branch:
  r_e : [t]_rep
  p_e : [t]pd
  continue (...) : o * [t seq{t_s,e,t_t)]_rep * 
  [t seq{t_s,e,t_t)]pd

as branches have same type, body has that type and the function has
the correct type.

case Var:

		       |- D_G,G ok  a in dom(D)
		       ------------------------ 
			     D;G |- a : T


To prove:
    D_G,G,[D]_PT |- [a] : [a:T]_PT
As a in dom(D), D = D',a:T and PT(D) = PT(D'),f_a:PT(a:T)
By var typing, 
    D_G,G,PT(D'),f_a:PT(a:T) |- f_a : PT(a:T)

case Rec:

Given

			   D,a:T;G |- t : T
			   ---------------- 
			   D;G |- ua.t : T

To prove,
   D_G,G,PT(D) |- [ua.t] : PT(ua.t : T)

By IH, 
   D_G,a_rep::T,a_Pb::T,G,PT(D),f_a:PT(a:T) |- [t] : PT(t:T)

From derivation and lemma, 
   D_G,G,PT(D) |- [ua.t]_rep :: T
   D_G,G,PT(D) |- [ua.t]_PD  :: T
   D_G,G,PT(D) |- [ua.t]_Pb :: T

Let S = X(ua.t,a).
By Type Substitution, TAPL Lemma 30.3.4, part 3:
   D_G,G[S],PT(D)[S],f_a:PT(a:T)[S] |- [t][S] : PT(t:T)[S]
By PT substitution Lemma,
   PT(a:T)[S] = PT(a[Y(ua.t,a)]:T) = PT(ua.t:T)
So,
   D_G,G[S],PT(D)[S],f_a:PT(ua.t:T) |- [t][S] : PT(t:T)[S]
As there are no typing annotations in [t],
   [t][S] = [t]
As a not in FTV(D;G), (can always a-vary to ensure this)
   D_G,G,PT(D),f_a:PT(ua.t:T) |- [t] : PT(t:T)[S]
which is equivalent to:
   D_G,G,PT(D) |- [t]: b*o-> o * [t]_rep [S] * [t]_PD[S]

By typing (and expanding out S),
   D_G,G,PT(D) |- w : o
   D_G,G,PT(D) |- r : [t]_rep [[ua.t]_rep/a_rep, [ua.t]_Pb/a_Pb]
   D_G,G,PT(D) |- p : [t]_PD [[ua.t]_rep/a_rep, [ua.t]_Pb/a_Pb]

By Rep. Type Well-Formedness Lemma,
  D_rep,G |- [t]_rep :: T
  D_PD,G |- [t]_PD :: T

So, a_Pb not in FTV([t]_rep) and a_rep not in FTV([t]_PD), so
   D_G,G,PT(D) |- r : [t]_rep [[ua.t]_rep/a_rep]
   D_G,G,PT(D) |- p : [t]_PD [[ua.t]_Pb/a_Pb]

As [ua.t]_rep = ua_rep.[t]_rep,
   D_G,G,PT(D) |- fold[[ua.t]_rep] r : u a_rep.[t]_rep (= [ua.t]_rep) 
As [ua.t]_Pb = u a_Pb.[t]_PD,
   D_G,G,PT(D) |- fold[[ua.t]_Pb] p : u a_Pb.[t]_PD (= [ua.t]_Pb)

case TyAbs:

			   D,a:T;G |- t : k
			 -------------------- 
			 D;G |- \a.t : T -> k

To prove:
   D_G,G,PT(D) |- [\a.t] : PT(\a.t : T -> k)
=
   D_G,G,PT(D) |- [\a.t] : A a_rep. A a_Pb. PT(a:T) -> PT(\a.t a: k)

[\a.t] = A a_rep. A a_Pb. \f_a.[t], so need to prove:
   D_G,G,PT(D),a_rep::T,a_Pb::T, f_a:PT(a:T) |- [t] : PT(\a.t a: k)

By IH,
   D_G,a_rep::T,a_Pb::T,G,PT(D),f_a:PT(a:T) |- [t] : PT(t:k)
Need to prove (with == as F-omega type equivalence),
   PT(\a.t a: k) == PT(t:k)
From lemma, need to prove:
  [\a.t a]_rep == [t]_rep and [\a.t a]_PD == [t]_PD.
  [\a.t a]_rep = (\a_rep.[t]_rep) a_rep == [t]_rep
  [\a.t a]_PD = (\a_Pb.[t]_PD) a_Pb == [t]_PD.
  
case TyApp:

		  D;G |- t1 : T -> k   D;G |- t2 : T
		  ---------------------------------- 
			   D;G |- t1 t2 : k

To prove:
   D_G,G,PT(D) |- [t1 t2] : PT(t1 t2: k)

[t1 t2] = [t1] [[t2]_rep] [[t2]_Pb] [t2]

By IH,
   D_G,G,PT(D) |- [t1] : PT(t1: T -> k)
By def. of PT,
   PT(t1: T -> k) = A a_rep. A a_Pb. PT(a:T) -> PT(t1 a: k), 
   with a fresh w.r.t. k and t1.
So,
   D_G,G,PT(D) |- [t1] : A a_rep. A a_Pb. PT(a:T) -> PT(t1 a: k)
By Rep. Type Well-Formedness lemma,
   D_rep |- [t2] :: T
   D_PD |- [t2]_Pb :: T
By typing,
   D_G,G,PT(D) |- [t1] [[t2]_rep]: (A a_Pb. PT(a:T) -> PT(t1 a: k))[[t2]_rep/a_rep]
   D_G,G,PT(D) |- [t1] [[t2]_rep] [[t2]_Pb]: 
      (PT(a:T) -> PT(t1 a: k))[[t2]_rep/a_rep][[t2]_Pb/a_Pb]
As a_Pb not free in [t2]_rep (by rep-type well formedness),
   [[t2]_rep/a_rep][[t2]_Pb/a_Pb] = [[t2]_rep/a_rep, [t2]_Pb/a_Pb] = X(t2,a)
   D_G,G,PT(D) |- [t1] [[t2]_rep] [[t2]_Pb]: (PT(a:T) -> PT(t1 a: k))[X(t2,a)]
By lemma and "a" fresh (if not, just a-vary it),
   D_G,G,PT(D) |- [t1] [[t2]_rep] [[t2]_Pb]: PT(t2:T) -> PT(t1 t2: k)

By induction,
   D_G,G,PT(D) |- [t2] : PT(t2 : T)

By typing,
   D_G,G,PT(D) |- ([t1] [[t2]_rep] [[t2]_Pb]) [t2]: PT(t1 t2: k)

   
case compute: trivial
case absorb: by induction
case scan: by induction.
