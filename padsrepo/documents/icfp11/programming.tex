\section{Programming with \forest{}}
\label{sec:exp}

\begin{figure}
%\caption{Load functions for Coral}
%\label{fig:coral-load}
%\end{figure}
%
%\begin{figure}
Representation Types:
\begin{code}
\kw{newtype} Stats = Stats \{last :: Last, topk :: Topk\}
\kw{newtype} Dat   = Dat   [(String, Site)]
\kw{newtype} Site  = Site  [(String, Log)]
\kw{data}    Log   = Log   \{log :: CoralLog\}
\end{code}
%\caption{Representation types for Coral}
%\label{fig:coral-rep}
%\end{figure}
%
%\begin{figure}
Metadata Types:
\begin{code}
\kw{type} Stats_md = (Forest_md, Stats_inner_md)
\kw{data} Stats_inner_md = Stats_inner_md 
    \{last_md :: (Forest_md, Last_md),
     topk_md :: (Forest_md, Topk_md)\}
\kw{type} Dat_md   = (Forest_md, [(String, Site_md)])
\kw{type} Site_md  = (Forest_md, [(String, Log_md)])
\kw{type} Log_md   = (Forest_md, Log_inner_md)
\kw{data} Log_inner_md = Log_inner_md 
    \{log_md :: (Forest_md, CoralLog_md)\}
\end{code}
%Forest Type Class (Selected Elements):
%\begin{code}
%class (Data rep, ForestMD md) => 
%  Forest rep md | rep -> md  
%where
%  load :: FilePath -> IO(rep, md)
%  generateManifest :: (rep,md) -> IO Manifest
%  defaultMd :: rep -> FilePath -> md
%\end{code}
%Store Functions:
%\begin{code}
%storeAt        :: FilePath -> Manifest -> IO ()
%store          ::             Manifest -> IO ()
%\end{code}
%%\mbox{}
%%md_default :: a
Load Functions:
\begin{code}
stats_load :: FilePath -> IO (Stats, Stats_md)
dat_load   :: FilePath -> IO (Dat, Dat_md)
site_load  :: FilePath -> IO (Site, Site_md)
log_load   :: FilePath -> IO (Log, Log_md)
\end{code}
Store Functions:
\begin{code}
stats_manifest :: (Stats, Stats_md) -> IO Manifest
dat_manifest   :: (Dat, Dat_md)     -> IO Manifest
site_manifest  :: (Site, Site_md)   -> IO Manifest
log_manifest   :: (Log, Log_md)     -> IO Manifest\smallskip
storeAt        :: FilePath -> Manifest -> IO ()
store          ::             Manifest -> IO ()
\end{code}
\caption{Artifacts generated from the CoralCND description.}
\label{fig:coral-aux}
\end{figure}

Many \forest{} programs work in two phases. In the first phase they
use \forest{} to load relevant portions of the file system into memory,
and in the second phase they use an ordinary Haskell function to
traverse the in-memory representation of the data (or its associated
metadata) and compute the desired result.  Some \forest{} programs
add a third phase in which they store updated structures back to the
filestore.

To facilitate this style of programming, the \forest{} compiler
generates several Haskell types and functions from every \forest{}
declaration.  Collectively, these types and functions define an instance
of the \cd{Forest} type class:
\begin{code}
\kw{class} (Data rep, ForestMD md) 
      \kw{=>} Forest rep md | rep -> md  \kw{where}
   load     :: FilePath -> IO(rep, md)
   manifest :: (rep,md) -> IO Manifest
   ...
\end{code}
In this type class, the type \cd{rep} is the generated in-memory
representation type
of the corresponding on-disk data.  The type \cd{md} is the generated type for the associated metadata.
The \cd{ForestMD} type class provides
operations for manipulating \forest{} metadata; all generated metadata
types belong to this type class.
\cut{
\footnote{For each \forest{} type declaration, the
  compiler makes the new type an instance of the \cd{Forest} type class.
%
\reviewer{A footnote says that the generated types and functions for a
particular filestore format form a single instance of a type class.
Have you thought about using a type class where each record type is an
instance, so that you don't need to declare a *\_load and *\_manifest
function for each type, but rather make these operations methods of
the new type class?}}
%
}

The generated load function lazily traverses the
file system and reads the files, directories, and symbolic links
mentioned in the description into a pair of the in-memory
representation and its metadata.
To reverse the process of reading data in to memory, \forest{}
also generates a \emph{manifest function}, which reads an in-memory
data structure, writes its contents out to disk in a temporary
space, and prepares a 
\emph{manifest log}.  The manifest log records inconsistencies
detected during this process as well as the sequence
of operations necessary to move data from the temporary space to
its final resting point.  Inconsistences
can arise when a programmer creates an erroneous in-memory
representation of a \filestore{}.
The dependencies that may be present in
\forest{} descriptions mean that not all such inconsistencies 
can be detected statically by the Haskell type system.
After creating a manifest, a programmer may analyze it
and decide whether to execute the 
generic \cd{store} or \cd{storeAt}
functions, which move a manifest (inconsistencies and all) to its 
rightful position on disk. 
%\jnf{Is this accurate?}If the manifest reports no
%inconsistencies, then Forest ensures that the resulting filestore will
%be consistent.
Details concerning the semantics of storing, 
especially where it concerns inconsistencies,
are explained in further depth in Section~\ref{sec:theory}.

As an example, consider the \coral{} logs described in
Figure~\ref{fig:coral-description}.  The corresponding load and store
functions, the representation types, and the metadata types appear in
Figure~\ref{fig:coral-aux}.\footnote{In the following examples, for
the sake of clarity, we use
  type-specific names such as \cd{dat\_load} and
  \cd{dat\_manifest}, rather than the overloaded names \cd{load} and \cd{manifest}.}
Note that the structure of each of these
artifacts mirrors the structure of the \forest{}
description that generated them. This close correspondence makes it
easy for programmers to write programs using these \forest{}-generated
artifacts.

%%Note that when storing freshly computed data, one often needs
%%a metadata structure.  The type-directed function \cd{f_default}
%%listed in Figure~\ref{fig:coral-aux} computes default metadata
%%of any type required.
%
For instance, consider the \cd{Dat} description in
Figure~\ref{fig:coral-description}. The \cd{dat\_load} function takes
a path as an argument and produces the representation and metadata
obtained by loading each of the site directories contained in the
directory at that path:
%
\begin{code}
(rep,md) <- dat_load "/var/log/coral/dat"
\end{code}
Because \cd{Dat} is a \forest{} list, the \cd{rep} is a Haskell
list. More specifically, \cd{rep} has the form
\begin{code}
Coral [("planetab2.eecs.wsu.edu", Site [...]),
       ("planetlab3.williams.edu",Site [...]),...]
\end{code}
where the list contains pairs of names of subdirectories and
representations for the data loaded from those directories. The
metadata is a pair consisting of a generic header of type
\cd{Forest\_md} and a list of pairs of names of subdirectories and
their associated metadata. The header collects information
about errors encountered during loading and it stores the file system
attributes of each file, directory, or symbolic link loaded from the
file system.  The following is the pretty-printed version of such a
structure: 
%
\begin{code}
Forest_md 
  \{ numErrors = 0, 
    errorMsg = Nothing, 
    fileInfo = FileInfo
      \{ fullpath = /var/log/coral/dat, 
        owner = alice, group = staff, size = 102, 
        access_time = Fri Nov 19 01:47:09 2010, 
        mod_time = Thu Nov 18 20:42:37 2010, 
        read_time = Fri Nov 19 01:47:28 2010, 
        mode = drwxr-xr-x, isSymLink = False, 
        kind = Directory \} \},
[("planetlab2.eecs.wsu.edu", Forest_md \{...\}),
 ("planetlab3.williams.edu", Forest_md \{...\}), ...]
\end{code}


Using these functions and types, it is easy to formulate many useful
queries as simple Haskell programs. For instance, to count the number
of sites we can simply compute the length of the nested list in
\cd{rep}:
%
\begin{code}
num_sites = \kw{case} rep \kw{of} Dat l -> List.length l 
\end{code}
%
More interestingly, since the internals of the web log are specified
using \padshaskell{} (see the
technical report~\cite{forest-techreport} for details), it is straightforward to dig in to the file data and
combine it with file metadata or attributes in queries.  For example,
to calculate the time when statistics were last reported for each
site, we can zip the lists in \cd{rep} and \cd{md} together and
project out the site name and the \cd{mod_time} field from each
element in the resulting list of pairs:
%
\begin{code}
get_site = fst
get_mod (_,(f,_)) = mod_time . fileInfo $ f  
sites_mod () = 
  \kw{case} (rep,md) \kw{of} (Dat rs, (_,ms)) -> 
    map (get_site *** get_mod) (zip rs ms)
\end{code}
% $

As this example shows, \forest{} blurs the distinction between data
represented on disk and in memory. After writing a suitable \forest{}
description, programmers can write programs that work on file system
data as if it were in memory. Moreover, because Forest uses Haskell's
lazy I/O 
operations, many simple programs do not require constructing an
explicit representation of the entire directory being loaded in
memory---a good thing as the directory of \coral{} logs contains
approximately 1GB of data!
Instead, the load functions only read the portions of the file system
that are needed to compute the result---in this case, only the site
directories and not the gzipped log files contained within them.

As a final analysis example, consider a program that computes the
top-$k$ requested URLs from all \coral{} nodes by size. The \coral{}
administrators compute this statistic periodically to help monitor and
tune the performance of the system~\cite{freedman:coral-experience}. 
We define the analogous function in Haskell using helper
functions such as \cd{get_sites} to project out components of
\cd{rep}:
%
\begin{code}
topk k = 
  take k $ sortBy descBytes $ toList $
  fromListWith (+)
    [ (get\_url e, get\_total e)
    | (site,sdir) <- get\_sites rep,
      (datetime,ldir) <- get\_dates sdir,
      e <- get\_entries ldir,
      is\_incoming e ]
\end{code}
% $
Reading this program inside-out, we see that it first uses a list
comprehension to iterate through \cd{rep}, collecting the
individual log entries corresponding to
%in the \cd{coralwebsrv.log.gz} file for
incoming requests using the 
\cd{is\_incoming} predicate.  It then projects  out the URL requested and the total
size of the request. It then sums the sizes of all requests for the
same URL using the \cd{fromListWith} function from the \cd{Data.Map}
module. Next, it sorts the entries in descending order. Finally, it
returns the first $k$ entries of the list as the final result.

Having implemented these analyses, a programmer may wish to store their
results.  She may do so via the following code, which
uses \cd{stats_manifest} to generate a manifest and \cd{store}
to copy it over to the \cd{stats} directory.  In addition,
the code uses \cd{stats_defaultMd}, a function
that constructs default metadata for stats structures
(a useful function in situations that require storing newly
constructed data).


\begin{code}
let result = Stats \{ last = sites_mod ()
                   , topk = topk 10 \}
manifest <- stats_manifest 
  ( result
  , stats_defaultMd result "/var/log/coral/stats" )
store manifest 
\end{code}

%Forest provides the type class \cd{Forest rep md} that collects 
%useful functions on Forest representation and metadata
%structures. These functions include the \cd{load} and \cd{generateManifest}
%functions described above as well as a variety of utility functions. One such utility
%function is \cd{defaultMd}, which takes a representation and a 
%path and creates a corresponding default metadata structure rooted at
%the supplied path. Variants of this function take parameters for
%setting groups, owners, and permissions.  For descriptions
%containing dynamically-determined paths, \cd{defaultMd} leaves the
%paths empty.  In such cases, the programmer must fill in the
%appropriate paths manually.


Overall, the main thing to take away from this section is how 
\forest{} and its tight integration with
\haskell{} facilitates exploratory data analysis,
enabling remarkably terse queries over the combination of file
contents, file attributes and directory structures.

%%Exploratory data analysis
%%in this new programming paradigm is light-weight, easy and highly effective.
%how the tight coupling of \forest{} and \haskell{} lead to highly
%productive programming practice.  
% \jnf{compare with the hand-written Python program Mike
%   actually uses? Highlight difficulties of dealing with large number
%   of huge files? dpw: it would be great to give some kind of comparison}
