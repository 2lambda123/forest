structure T = Tokens
structure KW = PadsKeywords

datatype lexresult
  = EOF
  | NL
  | TOK of {space : int, kind : T.token_kind, text : string}
  | INSERT_BEGIN
  | INSERT_END
  | CMD of (string * string)
  | COM of lexresult list
  | STR of lexresult list

val comLevel = ref 0
val inInsert = ref false

val resultStk = ref ([] : lexresult list)

val charList = ref ([] : string list)
fun makeString () = (concat(rev(!charList)) before charList := [])

val cmdStr = ref ""

fun inc r = (r := !r + 1)
fun dec r = (r := !r - 1)

val col = ref 0
val space = ref 0
fun tab () = let
      val n = !col
      val skip = 8 - (n mod 8)
      in
	space := !space + skip;
	col := n + skip
      end
fun expandTab () = let
      val n = !col
      val skip = 8 - (n mod 8)
      in
	charList := (StringCvt.padLeft #" " skip "") :: (!charList);
	col := n + skip
      end
fun addString s = (charList := s :: (!charList); col := !col + size s)
fun token tok = (
      space := 0;
      col := !col + size (#text tok);
      TOK tok)
fun newline () = (space := 0; col := 0; NL)
fun pushLine kind = let
      val tok = TOK{space = !space, kind = kind, text = makeString()}
      in
	space := 0;
	newline(); resultStk := NL :: tok :: !resultStk
      end
fun dumpStk kind = let
      val tok = TOK{space = !space, kind = kind, text = makeString()}
      in
	space := 0;
	(rev (tok :: !resultStk)) before resultStk := []
      end
fun mkId s = token(KW.mkToken{space = !space, text = s})
fun mkSym s = token({space = !space, kind = T.Symbol, text = s})
fun mkDelim s = token({space = !space, kind = T.Delim, text = s})
fun mkCon s = token({space = !space, kind = T.Literal, text = s})

fun eof () = (
      charList := []; resultStk := [];
      space := 0; col := 0;
      comLevel := 0;
      EOF)
fun error s = raise Fail s


%%

%header (structure PadsLexer);

%s CC C S F C0 C1 CHR; 

eol=.*"\n";
newline = ("\010" | "\010\013" | "\013" | "\013\010");
id	= [_A-Za-z][_A-Za-z0-9]*; 
octdigit	= [0-7];
hexdigit	= [0-9a-fA-F];
hexnum	= 0[xX]{hexdigit}+[uUlL]?[uUlL]?; 
octnum	= 0{octdigit}+[uUlL]?[uUlL]?;
decnum	= (0|([1-9][0-9]*))[uUlL]?[uUlL]?;
realnum = (([0-9]+(\.[0-9]+)?)|(\.[0-9]+))([eE][+-]?[0-9]+)?[lL]?;
ws	= ("\012"|[\t\ ])*;

simplecharconst  = '[^\010\013\\]';
escapecharconst  = '\\[^\010\\013]';

directive = #(.)*{newline};

%%

<INITIAL,C1,F>\t		=> (tab(); continue());
<INITIAL,F>" "			=> (inc space; inc col; continue());
<INITIAL>\n			=> (newline());

<INITIAL>":"		=> (mkDelim yytext);
<INITIAL>";"		=> (mkDelim yytext);
<INITIAL>"("		=> (mkDelim yytext);
<INITIAL>")"		=> (mkDelim yytext);
<INITIAL>"["		=> (mkDelim yytext);
<INITIAL>"]"		=> (mkDelim yytext);
<INITIAL>"{"		=> (mkDelim yytext);
<INITIAL>"}"		=> (mkDelim yytext);
<INITIAL>"."		=> (mkDelim yytext);
<INITIAL>"..."	        => (mkDelim yytext);
<INITIAL>".."           => (mkDelim yytext);
<INITIAL>","		=> (mkDelim yytext);
<INITIAL>"*"		=> (mkDelim yytext);
<INITIAL>"!"		=> (mkDelim yytext);
<INITIAL>"^"		=> (mkDelim yytext);
<INITIAL>"+"		=> (mkDelim yytext);
<INITIAL>"-"		=> (mkDelim yytext);
<INITIAL>"++"		=> (mkDelim yytext);
<INITIAL>"--"		=> (mkDelim yytext);
<INITIAL>"->"		=> (mkDelim yytext);
<INITIAL>"/"		=> (mkDelim yytext);
<INITIAL>"~"	        => (mkDelim yytext);
<INITIAL>"?"		=> (mkDelim yytext);
<INITIAL>"|"		=> (mkDelim yytext);
<INITIAL>"&"		=> (mkDelim yytext);
<INITIAL>"%"		=> (mkDelim yytext);
<INITIAL>"<="		=> (mkDelim yytext);
<INITIAL>">="		=> (mkDelim yytext);
<INITIAL>"=="		=> (mkDelim yytext);
<INITIAL>"="	        => (mkDelim yytext);
<INITIAL>"+="		=> (mkDelim yytext);
<INITIAL>"-="		=> (mkDelim yytext);
<INITIAL>"^="		=> (mkDelim yytext);
<INITIAL>"%="		=> (mkDelim yytext);
<INITIAL>"*="		=> (mkDelim yytext);
<INITIAL>"/="		=> (mkDelim yytext);
<INITIAL>"|="		=> (mkDelim yytext);
<INITIAL>"&="		=> (mkDelim yytext);
<INITIAL>"<<="	        => (mkDelim yytext);
<INITIAL>">>="	        => (mkDelim yytext);
<INITIAL>"<"		=> (mkDelim yytext);
<INITIAL>">"		=> (mkDelim yytext);
<INITIAL>"!="		=> (mkDelim yytext);
<INITIAL>"||"		=> (mkDelim yytext);
<INITIAL>"&&"		=> (mkDelim yytext);
<INITIAL>"<<"		=> (mkDelim yytext);
<INITIAL>">>"		=> (mkDelim yytext);

<INITIAL>"#"            => (mkDelim yytext);
<INITIAL>"$"            => (mkDelim yytext);
<INITIAL>"@"            => (mkDelim yytext);
<INITIAL>"<:"           => (mkDelim yytext);
<INITIAL>":>"           => (mkDelim yytext);
<INITIAL>"{:"           => (mkDelim yytext);
<INITIAL>":}"           => (mkDelim yytext);
<INITIAL>"(:"           => (mkDelim yytext);
<INITIAL>":)"           => (mkDelim yytext);
<INITIAL>"::"           => (mkDelim yytext);
<INITIAL>"<=>"          => (mkDelim yytext);
<INITIAL>":=:"          => (mkDelim yytext);
<INITIAL>":+:"          => (mkDelim yytext);
<INITIAL>":\\:"         => (mkDelim yytext);
<INITIAL>":-:"          => (mkDelim yytext);
<INITIAL>"\\"           => (mkDelim yytext);

<INITIAL>{id}        	=> (mkId yytext);
<INITIAL>{realnum}      => (mkCon yytext);
<INITIAL>{octnum}	=> (mkCon yytext);
<INITIAL>{hexnum}	=> (mkCon yytext);
<INITIAL>{decnum}	=> (mkCon yytext);
<INITIAL>"'\\"{octdigit}{1,3}"'"	=> (mkCon yytext);
<INITIAL>"'\\x"{hexdigit}+"'"	        =>  (mkCon yytext);
<INITIAL>{simplecharconst}	        => (mkCon yytext);
<INITIAL>{escapecharconst}              => (mkCon yytext);


<INITIAL>"/*@INSERT"{eol}	=> (inInsert := true; INSERT_BEGIN);

<INITIAL>"/*@"	=> (YYBEGIN C0; continue());
<C0>[-A-Z]*     => (YYBEGIN C1; cmdStr := yytext; continue());
<C1>"*/"{eol} 	=> (YYBEGIN INITIAL; 
		    space := 0; col := 0;
		    CMD(!cmdStr, makeString()));
<C1>.		=> (addString yytext; continue());
		    
<INITIAL>"/*"	=> (YYBEGIN C; addString yytext; comLevel := 1; continue());
<INITIAL>"*/"{eol}	=> (space := 0; col := 0;
			    if !inInsert
			      then (inInsert := false; INSERT_END)
			      else error "unmatched close comment");
<C>"/*"		=> (addString yytext; inc comLevel; continue());
<C>\n		=> (pushLine T.Comment; continue());
<C>"*/"		=> (addString yytext;
		    dec comLevel;
		    if (!comLevel = 0)
		      then (YYBEGIN INITIAL; COM(dumpStk T.Comment))
		      else continue());
<C>\t		=> (expandTab(); continue());
<C>.		=> (addString yytext; continue());


<INITIAL>"//"   => (YYBEGIN CC; addString yytext; comLevel := 1; continue());
<CC>{eol}   => (addString yytext;
		    dec comLevel;
		    if (!comLevel = 0)
			then (YYBEGIN INITIAL; COM(dumpStk T.Comment)) 
		    else continue());
<CC>\t		=> (expandTab(); continue());
<CC>.           => (addString yytext; continue());

<INITIAL>\"	=> (YYBEGIN S; addString yytext; continue());
<S>\"	        => (YYBEGIN INITIAL;addString yytext; STR(dumpStk T.Literal));
<S>{newline}	=> (error "unexpected newline in unclosed string");

<S>\\\n		=> (YYBEGIN F; pushLine T.Literal; continue());
<S>\t		=> (expandTab(); continue());
<S>\\\"		=> (addString yytext; continue());
<S>\\		=> (addString yytext; continue());
<S>[^"\\\n\t]*	=> (addString yytext; continue());

<F>\n		=> (resultStk := (newline ()) :: !resultStk; continue());
<F>\\		=> (YYBEGIN S; addString yytext; continue());
<F>.		=> (error "unclosed string");



<INITIAL>.        	=> (continue());

