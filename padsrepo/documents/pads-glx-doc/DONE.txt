+ Done: Convert handle_failure in smart.c to PGLX_report_err.

+ Done: Added function PGLX_report_err. This function wraps
  PDCI_report_err, catching all calls with error code P_FAILWITH_ERR
  and converting them to calls to failwith. Other codes are passed on
  to PDCI_report_err.

  Replaced calls in pads-galax code to PDCI_report_err with
  calls to

+ Done: The loc child of the PDCI_sequenced_pd is now returned in
  order relative to its docorder (as returned by getId).

+ Done: To Test: Changed naming scheme of macros: AR -> PCGEN_ARRAY
  make sure the generated code compiles correctly.

+ Done: Debug type ordering in generated header files.
  Explanation: Structs generated simply using cnvExternalDecl are spit
  out differently than those converted using cnvCTy. The latter
  function removes some amount of surrounding material which seems to
  change the way that it is treated.

+ Done: Use containsRecord flag in compiler to decide whether to generate
  smart array code or not.

+ Done: Commit Galax nodeid changes.
+ Done:Get rid of #ifdef GALAXCOMPILE from itemlist.h, permanently
  (i.e. check it in).

+ Done:QUE: What is the appropriate response to eltRead failing in
  smartNode_kthChild? Is it to report an error or return null?

  Mary: If you can report an error, then report it.

+ done: Fix the manual - the name in the table (elemBegin) is wrong.

+ Done: turn off nodeid debugging code in pads_dm.ml.

+ Done: Add kth_child_named to the pads-galax interface.

+ Done: Change kthChild function to allow read ahead.

+ Done: Change the kthChildNamed function to force read of entire array
  in case of request for length or pd field.

+ Done: Use consistent method of error reporting. See PDCI_report_err.
  Get rid of handle_failure. Never use failwith except in special
  error functions.
  Fix also error handling in node_mm.c.

+ Done: Fix location of length and pd fields. They should be moved to be
  the last child of the smart array rather than the first. Any
  requests for these children before the completion of the array,
  should force the reading of the array until termination.  

+ Done: Add full support for other Pads types.
  Popts
    Nothing needs to be done. Use code for unions.
  Penums
    Is it correct for the val node not to have a mask?

+ Done:Smart array init function needs to take the cparams.

+ Done: when is the smart node assigned its id? When smartNode_init
  is called, it calls read_one_init, which makes the appropriate
  call.

+ Done: Add id_offset field to nodes, used to calculate the id of the
  node based on an offset from the id in the pd. 

+ Done: Initialize pd field of Ppos_t. Pass pd to Ploc_t_node_new,
  Ppos_t_node_new and _val_node_new functions. The pd is used to
  calculate the node's id. The old architecture did not provide
  these Ploc_t and Ppos_t nodes with pds.

+ Done: Fix getId function to ensure that nodes are valid.

+ Done: Fix path_walk functions in path_walk.c to initialize 
  pd fields. 

+ Done: Pass offset to Ppos_t. Initialize offset in all pd_node_new functions.

+ Done:Add id for array length node. 

+ Done: Add hashtable for docids in pads_dm.ml

+ Done: Change compiler so that _id_ is part of the "common" block
  of fields. In this way, all pds can be cast to a Pbase_pd, from
  which the id can be safely extracted.

+ Done: Change COMMON_READ_INIT to incremement and assign the id
  counter. Change elt_read to reset the id counter. Implement
  infrastructure to return nodeids to galax_dm.

+ Done: Add smart code generation to compiler.

+ Done: Remove code for dealing specially with computed fields.
  They are just like normal fields. Code is in
  gen-galax.sml. Macros are in pglx-codgen-macros.h

+ Done: In reread, the if(notFirst) statement should only be
  inserted if there's a seperator. Currently, only the body of the
  statement depends on sepXOpt.

+ Done: Merge 2 checkpoints into one:
  remove inc/dec of inestLev
  call chkPtS' instead of chkPtS.
  change condition from rep->length > 1 to pd->numRead > 0.

+ Done: Look into pads macros returning P_ERR. Added new return
  value, P_READ_ERR, which is mapped to P_ERR, so that read_one
  functions returning P_ERR will behave correctly.

+ Done: Add allocElt to smartNode struct in smart.h.

+ Done: I don't think that read needs to return whether its done or
  not. I think that is enough to return whether the data is valid
  or not.

+ Done: The generated smart node code will have to alloc, store and
  pass the extra parameters correctly, on a per-type
  basis.

+ Done:reread function: offsets stored should be before any
  seperator. That way, bad elements will be reread correctly,
  and their pds set correctly. I need to change the way offsets
  are currently stored.

+ Done: Don't use rbuf for allocation. There's no need for the
  elements to be contiguous, so its a waste to use a resizable
  array.

+ Done: Pass tloc as parameter to init and read_one.

+ Done: Add read_driver to the compiler.

+ Done: Must deal correctly with seperator/terminator decls and cleanup.
  Done: Pass them into init, read_one and final_checks.
  (optional: Add new ty_read_cleanup to replace ty_end: label)
  Need to address allocation issues. The space is allocated
  in the read_one driver function.

+ Done: Make sure that every concluding call to read_one sets
  P_PS_isPartial. This is true for all calls to final_checks,
  but we need to deal with "return STATUS_ERROR".

+ Done: create two versions of macro AR_TEST_TRAILING_JUNK one with
  _P and one with _C. The appropriate one will be called depending
  on the type of the term. If its a character, _C will be called,
  otherwise, _P.

+ Done: If the array is in panic mode on entrance to read_one, then
  there is nothing that we can do and we should go to final checks.
  Therefore,lets assumes as invariant that the array is not in panic
  mode on entrance to the function.

+ Done: Why check for EOF at the beginning of read_one? Instead,
  check once in init function and then at the end of read_one.

+ Done: Extend the parse tree to add phantom declarations.

+ Done: fix bug in how ckit deals with the MARKstatements in the
  declaration list of Compound statements.

+ Done: Have compiler produce fake type_t vars only for types
  passed as args.

+ Done: Have compiler strip out fake type_t vars during pretty printing.
  We added phantom declarations that don't get converted into AST nodes.

+ Done: Change PDCI_sequenced_pd kthChild calls to return the optional
  "loc" field as the last field (when returning it at all). This
  change will simplify the code, as the if-then can be placed within
  the switch(idx) rather than around it.

+ Done: Make sure that paths are freed correctly.

+ Done: Add snd support for arrays.

+ Done: Use the rbuf in the barArray rep to allocate bar reps. 

+ Done: Eventually, need to get offsets working for all pads types
  (i.e. fix the compiler). Offsets should be located in pd->loc.b.
  Done: Then, use the offset information correctly in the smart node
  code.

+ Done: get rid of max_idx! Pehaps we should use P_PARTIAL/P_FINISHED
  flag to indicate completion instead? Then, if !P_PARTIAL,
  rep->length is valid and can be compared against in kthChild to
  reject invalid nodes.

+ Done: allow out of order kthChild. 

+ Done: allow out of order eltRead.

+ Done: Get offsets working correctly in pads code for barArray and
  bar.

+ Done: Get rid of lazy behaviour. Force element into memory when
  accessed for the first time and force into memory before touching
  values. Once an element info has been created, we can treate the
  element lazily becuase we already know that it exists. Therefore, we
  need only force a read when the corresponding element info is
  created.

+ Done: For PDCI_sequenced_pd and PDCI_structured_pd, the presence of
  child "loc" depends on field errCode >= 100. To know the value of
  errCode, we need to force the elt into memory (in
  sndNode_kthChild). Is there a better approach?  Also for base type
  kthChild functions. The presence of the val node depends on there
  having been no serious errors.  Downside to "lazy" validation: Have
  to validate each node once you try to read it. so, for case of
  printing out the whole tree, where you build up nodes breadth first,
  can potentially have to revalidate all of the nodes in the tree.
  OPT: when you validate a node, validate its parents as you go along.

+ Done: For arrays (for now, other types in the future) we need smart
  versions. For all types, we need smart-node-descendent
  versions. These are not the same. A simple distinction is that for
  the former, the snExt field is valid, while, in general, it is
  not. Furthermore, an element might (in some future release)
  potentially be both a descendent of one smart node and a smart node
  itself.

+ Done: Implement smart functions for bar and base types, as needed,
  - (Copy enum_kth.c to smart_array.c)
  - barArray_smartNode_new:
    PDCI_node_t *PADS_TY(_smartNode_new)(pads,"doc",&m, &pd, "main");

+ Done: Implement a dummy smart array that really just keeps
  everything in memory. Get everything working right with such a
  node. Then, change it "randomly" invalidate pointers, but not really
  evict elements from memory. Instead, the read call would just fix
  the pointers.

+ Done: How do I indicate a problem (P_FATAL) from node_mm.c if I
  don't have a pads handle? Change calls to use pads handle.

+ Done: Test reference counting system for non-cached nodes. Add
  debugging output to tell when nodes are freed.

+ Done: Decide what to do about whatfn parameter to XXX_node_new
  calls. Pass it to PDCI_report_err.

+ Done: Test new caching system:
  - Create a base-type node (using enum.c)
  - Make it into a caching node and check that the results are as
    expected. There is probably more debugging code that could be
    added in	to ensure safer behaviour, but I think that it will
    have to wait for Bob to return.

+ Done: Add node validation to v.t. functions, where needed. Don't
  force rep into memory in PGLX interface. Delay the choice until
  kthChild or when necessary.

+ Done: Implement smart node creation, and setup infrastructure

+ Done: Implement virtual functions of the smart array.

+ Done: Then...
  - Abstract out details of new PDCI_node functions and implement code generation.
  - Abstract out details of smart node infrastructure and implement code gen.

+ Done: Add cachedNode_init function to vt table. So, every
  node will have a way of changing itself to a cachedNode.

+ Done: Add PDCI_error_cachedNode_init for use in cachedNode vtables,
  to avoid reinitialization.

+ Done: Add free_fn entries to tables in pglx.c. Define free functions if necessary.

+ Done: From discussion w/ Bob:
  1. duplicate kth_child functions to support caching.
  2. use static constructors for each type
  3. use dynamic destructors for each type.
  4. initialize the cache in static constructor, which will know
     the cache size.
  5. Cached children can never be freed based on reference
     counting, because the parent/child_cache pointers form a
     cycle. So, cached nodes won't use reference counting and 
     their free function will be a noop.

+ Done: Ensure that the MM layering is as follows (for free calls):

	     PGLX_XXX
	     ------------
	     PDCI_XXX_NODE
	     -------------
	     Virtual Functions
  -------------           -----------------
  NodeMM_XXX :            Noop
    handles ref. 
    counting and 
    finalization
  -------------
  FreeList_XXX : 
     maintains free 
     list of node 
     structs.

+ Done: Add reference counting to base nodes. 

  Parent pointers reference nodes in addition to Galax. So, we need
  to use reference counting. As for cached nodes, they will
  override the (ref. counting based) free function and replace it
  with a noop due to their cyclical nature.

+ Done: Change the CKIT headers for the PDCI_XXX alloc/free/alias/etc. macros.

+ Done: Remove the children() function as it is no longer needed.

+ Done: Write kth_child_named function to use vt->kth_child. Then, only need
  to override kth_child to support caching.  Similarly,
  bar_cached_kth_child uses bar_kth_child like super.kth_child.

+ Done: Add free function to vtable, so nodes can be freed in a node specific manner.

+ Need to modify string_value and typed_value functions to validate
  node before accessing its pd and rep.

+ Add a "void *" field to the PADS handle datatype 
  with a name like 'ext1'.

+ Ask mary whether we need to handle multiple sequential queries 
  that use different pads data?

  We don't need to do anything special. Galax itself will keep 
  all the files in memory so we don't need to be any smarter.

+ Implement child caching for always-in-memory nodes.

+ Implement init functions for example PDCI_nodes (e.g. enum).
  There should be two: one for use as permanent node and the other
  as temp node. We use the kth_child function to set up the vtable
  correctly.

+ Modify MK_NODE macros to correctly initialize nodes, including
  default NULLing of added fields.

  We use one allocation scheme for all nodes. Use the free list
  for everyone. Only put back on the free list for smart nodes
  descendents. Store the pointer to the free list in the pads
  handle.

+ Handle garbage collection for uncached nodes.

  G.C calls the finalizer specified in pads_c.idl That finalizer
  calls PGLX_node_free in pglx.c, which calls PDCI_FREE_NODE macro
  in pglx_impl.h. There, we distinguish between cached and uncached
  nodes and take the appropriate action.

+ Implement free list and finalize function for ephemeral nodes.
  + Implement a free list module
  + Add finalize function for ephemeral nodes. Should call
    FreeList_add(node).
    + Need to change PDCI_FREE_NODE.

+ Document: Why is the parse-descriptor tree integrated into the node tree?
  (Given the integration of the trees, we don't need array pds to be
  smart, because you can never get to the element pds via a given
  pd. A given pd node only contains the children directly relevant to
  itself.)

+ Document: in kthChild functions, passing k > num_children is not an
  error. The correct semantics is to return NULL in such a
  situation, just as the children function used to return a
  null-terminated list.

+ Fill-in NodeMM datastructure, etc.
  alloc:
   (FreeList_alloc((FreeList_head_t *)((pads)->ext1))

  finalize:
    FreeList_head_t *head =     \
      (FreeList_heade_t *)(n)->pads->ext1;  \
    FreeList_add(head,n);        \

