A reviewer explicitly asks: Why is this work relevant to POPL? 

Sometimes scientific communities are formed around *techniques* and
other times they revolve around solving *problems*.  Communities that
focus on solving problems using any available techniques are often
stronger because they deliver the best possible solutions to the end
users that need them.  The classic paper "End-to-end arguments in
system design" articulately describes the need to focus on end-to-end
problems in systems research; the overarching concept applies equally
well to programming languages.

The end-to-end problem we address is how to facilitate programming
with ad hoc data.  Our approach is to automatically produce a
declarative description of the data in a domain-specific language.
From that description, we generate a library for manipulating the data
programmatically. We further use techniques from generic programming
to automatically generate a collection of end-user tools, making the
"programming" for certain tasks so easy as to require no user
intervention.  This result seems very interesting and relevant to the
programming languages community!

In addressing this problem we compete against programming language
technologies that regularly appear at POPL, PLDI, ICFP, OOPSLA, etc.
Example competitors include: (1) scripting languages broadly construed
(Perl, Python, O'Caml, Haskell, Scheme, ML), (2) type-directed
programming technology to implement generic, format-independent tool
suites (examples appear in Haskell, O'Caml, Concurrent Clean, Java,
etc.), (3) clever programming techniques like "Scrap your boilerplate"
and parser, printer or marshalling combinators that facilitate
programming with ad hoc data (4) domain-specific languages that also
ease data processing tasks such as Lex, Yacc, Xsugar, Demeter,
Boomerang, DataScript, PacketTypes, etc.  The critical question for
a reviewer is:

  Is the inference and tool generation system described in this paper a
  better way for programmers to process ad hoc data than to use
  Haskell's generic programming and parser combinators, or write an
  Xsugar program, or use a hand-written PADS specification, etc.?

There are clear tradeoffs: for example, description precision vs. programmer
time.  Moreover, it is also clear these alternatives are competing
solutions to the same problem.  If we cannot present our technology at
programming language conferences, then these competitors will be
unaware of how our system improves upon the community's ability
to solve the end task we are all addressing.

Finally, we believe that using non-standard techniques makes the work *more*
interesting to the POPL audience because it adds to the set of tools
available to the community to solve problems.  
-------

The second reviewer says: "I'm rather suspicious in terms of machine learning."

We would appreciate concrete references to systems that address the
same problem we do. As mentioned briefly in our submission, we
explicitly asked all attendees of the Workshop on Grammar Induction at
the International Conference on Machine Learning whether they knew of
any systems that tackled the same problem (generating tools for ad hoc
data sources, not XML) and though they were very thoughtful, no one
came up with any other systems.  If the reviewer knows of relevant
work, we would very much like to hear about it.

