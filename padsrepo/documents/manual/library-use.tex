\chapter{Using the generated library}
\label{chap:library-use}
\cutname{library_use.html}
In this chapter, we describe various functions provided by the core
\pads{} library for manipulating \pads{} handles.
\figref{figure:sirius-filter} shows a simple example of library use:
the call to \cd{P\_open} initializes the \pads{} handle, in this case
with a default \pads{} discipline and a default IO discipline;
the call to \cd{P\_io\_fopen} indicates that the input data may be
found in the file located at path \cd{\literal{ "data/sirius"}}; 
the function \cd{P_io_at_eof} tests if the file has been exhausted;
the call to \cd{P\_io\_close} closes the input file; and finally,
the call to \cd{P\_close} closes the \pads{} handle.

\begin{description}
\item[\small{\cd{Perror\_t  P\_open  (P\_t **pads\_out, Pdisc\_t
      *disc, Pio\_disc\_t *io\_disc)}}]
This function creates a \pads{} handle, which is returned in the space
supplied by the first parameter.  The second and third arguments are
input parameters pointing to a \pads{} discipline and an IO discipline
to use in the handle.  Either or both of these may be \cd{NULL}, in
which case default disciplines are used.

\item[\small{\cd{Perror\_t  P\_close (P\_t *pads)}}]
This function deallocates a \pads{} handle, freeing all associated resources.
If there is an installed IO discipline,
it is unmade; after this point it should NOT be used any more.

\item[\small{\cd{Perror\_t  P\_close\_keep\_io\_disc(P\_t *pads, \kw{int} keep\_io\_disc)}}]
This function is Like \cd{P\_close}, except takes an extra argument, \cd{keep\_io\_disc}, which
if non-zero indicates the installed IO discipline (if any) should not be unmade;
in this case it CAN be used again, \cd{}, in a future \cd{P\_open}
      call.

\item[\small{\cd{Pdisc\_t * P\_get\_disc(P\_t *pads)}}]
This function returns \cd{NULL} on error; otherwise, it returns a
pointer to the installed discipline.

\item[\small{\cd{Perror\_t  P\_set\_disc(P\_t *pads, Pdisc\_t
      *new\_disc, \kw{int} xfer\_io)}}]
This function installs a different discipline handle.  If the
parameter \cd{xfer\_io} is non-zero, then the IO discipline from the 
old handle is moved to the new handle.

\item[\small{\cd{Perror\_t  P\_set\_io\_disc(P\_t* pads, Pio\_disc\_t* new\_io\_disc)}}]
This function installs a different IO discipline into the
main discipline.  If there is an open SFIO stream,
it is transferred to the new IO discipline after closing the old IO
discipline in a way that returns all bytes beyond the current IO cursor to 
the stream.  The old IO discipline (if any) is unmade.   After this
point the old IO discipine should NOT be re-used.  

\item[\small{\cd{Perror\_t  P\_set\_io\_disc\_keep\_old(P\_t* pads, Pio\_disc\_t* new\_io\_disc, \kw{int} keep\_old)}}]
This function is like \cd{P\_set\_io\_disc}, except it takes an extra argument, \cd{keep\_old},
which if non-zero indicates that the old IO discipline
should not be unmade; in this case it CAN be used again, \eg{}, in a future
\cd{P\_set\_io\_disc} call. 

\item[\small{\cd{Tm\_zone\_t *P\_cstr2timezone(const char *tzone\_str)}}]
Utility function for converting a \C{} string to a time zone pointer.
It returns \cd{NULL} if the string is an invalid time zone string.
The following table describes the time zone names understood by the 
\cd{P\_cstr2timezone} function (columns two and three), as well as the
numeric representations of such (columns four and five).
Blank entries are represented by a dash.

\begin{tabular}{|l|l|l|l|l|}
\hline
Country & Standard & Savings & Minutes West of UTC & Saving Time Minutes Offset\\\hline
  - & GMT &   - &   0 &   0\\\hline
  - & UCT &   - &   0 &   0\\\hline
  - & UTC &   - &   0 &   0\\\hline
  - & CUT &   - &   0 &   0\\\hline
USA & HST &   - & 600 &   0\\\hline
USA & YST & YDT & 540 & -60\\\hline
USA & PST & PDT & 480 & -60\\\hline
USA & PST & PPET & 480 & -60\\\hline
USA & MST & MDT & 420 & -60\\\hline
USA & CST & CDT & 360 & -60\\\hline
USA & EST & EDT & 300 & -60\\\hline
CAN & AST & ADT & 240 & -60\\\hline
CAN & NST &   - & 210 &   0\\\hline
GBR &  -  & BST &   0 & -60\\\hline
EUR & WET &   - &   0 & -60\\\hline
EUR & CET &   - & -60 & -60\\\hline
EUR & MET &   - & -60 & -60\\\hline
EUR & EET &   - & -120 & -60\\\hline
ISR & IST & IDT & -180 & -60\\\hline
IND & IST &   - & -330 &   0\\\hline
CHN & HKT &   - & -480 &   0\\\hline
KOR & KST & KDT & -480 & -60\\\hline
SNG & SST &   - & -480 &   0\\\hline
JPN & JST &   - & -540 &   0\\\hline
AUS & AWST &   -& -480 &   0\\\hline
AUS & WST  &  - & -480 &   0\\\hline
AUS & ACST &   -&  -570 & -60\\\hline
AUS & CST &   - & -570 & -60\\\hline
AUS & AEST &   -&  -600&  -60\\\hline
AUS & EST &   - & -600 & -60\\\hline
NZL & NZST & NZDT & -720 & -60\\\hline
\hline
\end{tabular}

\item[\small{\cd{Perror\_t  P\_set\_in\_time\_zone(P\_t *pads, const char *new\_in\_time\_zone)}}]
\item[\small{\cd{Perror\_t  P\_set\_out\_time\_zone(P\_t *pads, const char *new\_out\_time\_zone)}}]
These functions set the  input and output time zones, respectively.  
See \secref{sec:library-customization-input-time-zone} and
\secref{sec:library-customization-output-time-zone} for more information.

\item[\small{\cd{Perror\_t  P\_io\_set (P\_t *pads, Sfio\_t *io)}}]
This function initializes or changes the current SFIO stream used for input.
If there is already an installed SFIO stream, \cd{P\_io\_close} is
implicitly called first.

\item[\small{\cd{Perror\_t  P\_io\_fopen(P\_t *pads, const char
      *path)}}]
This function opens a file for reading (a higher-level alternative to \cd{io\_set}).
It uses \cd{pads->disc->fopen\_fn} if that value is non-null;
otherwise, it  uses \cd{P\_fopen}.  It always opens files with mode
\cd{\literal{"r"}}.  The function returns \cd{P\_OK} on success, and
\cd{P\_ERR} on error.

\item[\small{\cd{Perror\_t  P\_io\_close(P\_t *pads)}}]
This function cleans up the IO discipline state.  It attempts to return bytes that were
read from the underlying SFIO stream but not consumed by the parse
back to the stream.

If the underlying SFIO stream arose from a file open via \cd{P\_io\_fopen},
the file is closed.  If the underlying Sfio stream was installed via
\cd{P\_io\_set}, it is not closed. In this case, it is up to the
program that opened the installed SFIO stream to close it
(\textit{after} calling \cd{P\_io\_close}). 

\item[\small{\cd{Perror\_t  P\_io\_next\_rec  (P\_t *pads, size\_t *skipped\_bytes\_out)}}]
This function advances the current IO position to start of the next record, if any.
It returns \cd{P\_OK} on success, \cd{P\_ERR} on failure, which
includes hitting \cd{EOF} before \cd{EOR}.
For the \cd{P\_OK} case, the function sets \cd{*skipped_bytes_out} to the number of
data bytes that were passed over while searching for \cd{EOR}.

\item[\small{\cd{Perror\_t  P\_io\_skip\_bytes(P\_t *pads, size\_t width, size\_t *skipped\_bytes\_out)}}]
This function advances the current IO position by specified number of bytes, or if that many
bytes cannot be skipped, then by as many bytes as available.
It sets \cd{*bytes_skipped_out} to the number of bytes skipped.
It returns \cd{P\_OK} if the requested bytes were skipped, \cd{P\_ERR} if fewer
than the requested bytes were skipped.  For record-based 
disciplines, the function does NOT advance the IO position beyond the
current record.

\item[\small{\cd{\kw{int} P\_io\_at\_eor(P\_t *pads)}}]
This function returns \cd{\literal{1}} if the current IO position is
at \cd{EOR}; otherwise it returns \cd{\literal{0}}.

\item[\small{\cd{\kw{int} P\_io\_at\_eof(P\_t *pads)}}]
This function returns \cd{\literal{1}} if the current IO position is
at \cd{EOF}; otherwise it returns \cd{\literal{0}}.

\item[\small{\cd{\kw{int} P\_io\_at\_eor\_or\_eof(P\_t *pads)}}]
This function returns \cd{\literal{1}} if the current IO position is
at \cd{EOR} or \cd{EOF}; otherwise it returns \cd{\literal{0}}.

\item[\small{\cd{\kw{const} \kw{char} * P\_io\_read\_unit(P\_t
      *pads)}}]
This function provides a description of the read unit used in \cd{Ppos\_t}
(\eg{}, \cd{\literal{"line"}}, \cd{\literal{"1K block"}},
\etc{}). Returns \cd{NULL} on error (if there is no installed IO discipline).

\item[\small{\cd{Perror\_t  P\_io\_getPos(P\_t *pads, Ppos\_t *pos,
      \kw{int} offset)}}]
This function fills in \cd{*pos} with the current IO position.
If \cd{offset} is zero, the current IO position is
used, otherwise the position used is \cd{offset} bytes from the
current IO position.  
The current IO position does not change.  \cd{P\_ERR} is returned if
information about the specified position cannot be determined. 
\cd{EOR} marker bytes (if any) are ignored when moving forward or back
based on \cd{offset}: \cd{offset} only refers to data bytes.

\item[\small{\cd{Perror\_t  P\_io\_getLocB(P\_t *pads, Ploc\_t *loc,
      \kw{int} offset)}}]
This function fills in \cd{loc->b} with the IO position.
See the description of \cd{P\_io\_getPos} for a description of the
\cd{offset} parameter.

\item[\small{\cd{Perror\_t  P\_io\_getLocE(P\_t *pads, Ploc\_t *loc,
      \kw{int} offset)}}]
This function fills in \cd{loc->e} with the IO position.
See the description of \cd{P\_io\_getPos} for a description of the
\cd{offset} parameter.
 
\item[\small{\cd{Perror\_t  P\_io\_getLoc(P\_t *pads, Ploc\_t *loc,
      \kw{int} offset)}}]
This function fills in both \cd{loc->b} and \cd{loc->e} with the IO
position. See the description of \cd{P\_io\_getPos} for a description of the
\cd{offset} parameter.
\end{description}


\section{Compiled regular expressions}
\label{sec:library-use-compiled-regular-expressions}

 The scan and read functions that take regular expressions as arguments
 require pointers to compiled regular expressions of type
 \cd{Pregexp\_t*}.

 A \cd{Pregexp\_t} contains two things:
\begin{enumerate}
\item a boolean, \cd{valid}, which indicates whether the \cd{Pregexp\_t}
       contains a valid compiled regular expression.
\item  some private state (an internal represention of the compiled regular expression)
       which should be ignored by the users of the library.
\end{enumerate}

\inputCode{code/comp-regexp}
%
\noindent
If \cd{my\_regexp.valid} is non-zero, then \cd{my\_regexp} requires cleanup when no longer needed.

Upon declaring a \cd{Pregexp\_t}, one should set \cd{valid} to \cd{\literal{0}}.
You can do this directly, as in:

\begin{centercode}
     Pregexp\_t my\_regexp = { 0 };
\end{centercode}
%
\noindent
or you can use the preferred method, which is to use the following
macro:

\begin{centercode}
    P\_REGEXP\_DECL\_NULL(my\_regexp);
\end{centercode}
%
\noindent
When through with a  \cd{Pregexp\_t}, one should call \cd{Pregexp\_cleanup}, as in:

\begin{centercode}
    Pregexp\_cleanup(pads, &my\_regexp);
\end{centercode}
%
\noindent
to clean up any private state that may have been allocated.

The following functions are used to compile a string into a \cd{Pregexp\_t}
and to cleanup a \cd{Pregexp\_t} when it is no longer needed.  They should
passed a pointer to a properly initialized (\cd{null} or \cd{valid}) \cd{Pregexp\_t}.

\begin{description}
\item[\small{\cd{Perror\_t Pregexp\_compile(P\_t *pads, \kw{const} Pstring
      *regexp\_str, Pregexp\_t *regexp)}}] 
  If \cd{regexp\_str} is a string containing a valid regular
 expression, this function fills in (\cd{*regexp}) and returns \cd{P\_OK}.
 If the string is not a valid regular expression, it returns \cd{P\_ERR}.

\item[\small{\cd{Perror\_t Pregexp\_compile\_cstr(P\_t *pads, \kw{const} \kw{char} *regexp\_str, Pregexp\_t *regexp)}}]
This function is like \cd{Pregexp\_compile}, but it takes a
\cd{\kw{const} \kw{char}*} argument rather than a \cd{\kw{const}
  Pstring*} argument.

\item[\small{\cd{Perror\_t Pregexp\_cleanup(P\_t *pads, Pregexp\_t
      *regexp)}}]
This function deallocates resources associated with \cd{regexp}.
\end{description}

Both compile functions will perform a cleanup action if \cd{regexp->valid} is
non-zero prior to doing the compilation, and they both set \cd{regexp->valid}
to \cd{\literal{0}} if the compilation fails and to \cd{\literal{1}} if it succeeds.  

Note that if you use a \cd{Pregexp\_t} to hold more than one compiled
regular expression over time, you only need to call \cd{Pregexp\_cleanup}
after the final use.  

\subsection{Regular expression macros}

The \cd{P\_RE\_STRING\_FROM} macros convert their \cd{\kw{char}} or string args into
strings containing regular expressions that match exactly the
specified character or string.  The string result is in temporary
 storage, so it should be used immediately (\eg{}., in a
\cd{Pregexp\_compile\_cstr} call).

\begin{description}
\item[\small{\cd{\kw{const} \kw{char}* P\_RE\_STRING\_FROM\_CHAR(P\_t
      *pads, Pchar char\_expr)}}]
This function produces a regular expression string that matches a single character.
\textbf{Example}:  \cd{P\_RE\_STRING\_FROM\_CHAR(pads, 'a')} returns string
\cd{\literal{ "/[a]/"}}.

\item[\small{\cd{\kw{const} \kw{char}* P\_RE\_STRING\_FROM\_CSTR(P\_t
      *pads, \kw{const} \kw{char} * str\_expr)}}]
Produces a regular expression string that matches a string.
\textbf{Example}:  \cd{P\_RE\_STRING\_FROM\_CSTR(pads, "abc")} returns
string \cd{\literal{"/abc/l"}}. 

\item[\small{\cd{\kw{const} \kw{char}* P\_RE\_STRING\_FROM\_STR(P\_t
      *pads, Pstring *str\_expr)}}]
Same as above, but takes a \cd{Pstring*} rather than a \cd{\kw{const}
  \kw{char}*}.



\item[\small{\cd{\kw{void} P\_REGEXP\_FROM\_CHAR(P\_t *pads, Pregexp\_t
      my\_regexp, Pchar char\_expr)}}]
\item[\small{\cd{\kw{void} P\_REGEXP\_FROM\_CSTR(P\_t *pads, Pregexp\_t
      my\_regexp, \kw{const} \kw{char} * str\_expr)}}]
\item[\small{\cd{\kw{void} P\_REGEXP\_FROM\_STR(P\_t *pads, Pregexp\_t
      my\_regexp, Pstring * str\_expr)}}]

The \cd{P\_REGEXP\_FROM} macros do the above conversions, and then do the added step
of compiling the result into \cd{Pregexp my\_regexp}.  In each case,
one can check \cd{my\_regexp.valid} after the macro call to check whether the result
is a valid compiled regular expression.
\end{description}

