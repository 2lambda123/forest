\section{Background}
\label{sec:Background}

%%\item Background
%%\begin{itemize}
%%\item Forest Language (primitives, load, store)
%%\item Running example 
%%\item Problems with naive semantics
%%\item Transactions to the rescue
%%\end{itemize}

To explain the design of TxForest, we will use a running example drawn
from the field of agriculture science, specifically SWAT.  This
modeling tool allows researchers to explore tradeoffs related to
different uses of land in a given watershed.  The model includes data
related to the topology of the watershed, current land use of regions
within the watershed, historic precipitation and temperature levels,
measurements of water purity at various locations, etc.  This data is
stored in a large collection of files and directories in the file
system.  A typical data SWAT installation contains XXX:hundreds of
files and require roughly XXX of disk space.  This data is documented
in a 654~page manual available on the web~\cite{SWAT-IO-Documentation}.

The Forest language was designed to describe exactly this kind of
datastore.  It includes primitives for describing files,
directories, symbolic links, and associated meta-data.  Meta-data
includes names, owners, groups, permissions, sizes, and timestamps.
File contents may be represented as simple strings in a variety of
encodings or as structured data using Pads
descriptions~\cite{fisher+:pads,fisher-walker:icdt}. Forest is
implemented using Haskell's quasi-quotation
mechanism~\cite{Mainland:quasi}.  Figure~\ref{fig:SWAT-description}
shows a (partial) Forest description of the SWAT datastore
that we will use as a running example throughout this paper.

The TxForest declarations appear within \texttt{[txforest|...|]}
quasiquotation brackets, allowing us to embed TxForest within Haskell
code files.  The SWAT description starts by declaring a number of
different file formats by applying the \texttt{File} constructor to
a PADS format description.  (For brevity, we omit the PADS
descriptions).   For example, the TxForest file format
\texttt{Preamble\_f}, which contains SWAT configuration information,
is described by the PADS type \texttt{Preamble}.
The other TxForest file formats in the figure use PADS types to
describe the format of files storing 
physical information about the watershed basin (\texttt{BSN\_f}),
daily precipitation data (\texttt{PCP\_f}),
daily temperature data (\texttt{TMP\_f}),
measured waterflow out of the basin (\texttt{Flow\_f}),
modeled waterflow out of the region (\texttt{RCH\_f}),
and the deviation between the measured and modeled outflows (\texttt{Deviation\_f}).

Given these file formats, the description describes the root SWAT
directory, \texttt{Swat\_d}.  This description of this directory
starts with the master watershed file, which has internal name
\texttt{cio}, on-disk name \texttt{file.cio}, and a file format
described by \texttt{Preamble\_f}.  The next component of the
directory is the \texttt{basin} field, which XXX (landing in Boston...)




Given such a description, the Forest compiler generates functions for
(lazily) loading the contents of the file store into a Haskell data
structure and for writing a Haskell data structure back to disk.
Writing structures to disk is a two-step process.  In step one, a
\textit{manifest} function writes the structure into a temporary space
and notes any errors.  In step two, a \textit{store} function copies
the temporary store into the correct location.  This two-step process
allows Forest to detect errors without corrupting the mainline
file store and lets users determine whether the errors should halt the
writing process.

The initial version of Forest did not attempt to ensure that 
concurrent loads and stores did not cause inconsistencies or
corruption.  As the number of users manipulating the file store grows,
this laissez-faire approach becomes untenable.  To address this
weekness, this paper integrates transactions into Forest.  With
Transactional Forest (TxForest) we ensure that all accesses to the
file store mediated by a Forest description will see and maintain a
consistent view by aborting and restarting transactions that would
otherwise have observed a conflict.


An example query that researchers using this tool might ask is
``what type of land use assignment to a given area of a watershed
keeps corn yield above a threshold, maintains housing capacity above
another threshold, and minimizes nitrate levels in nearby streams.''
The SWAT approach to solving such queries involves a concurrent black-box
optimization process in which each thread reads the current values of
all relevant parameters from the file system, computes the current
value of the optimization function, and makes local changes, and re-runs
the optimization function. If the new result is higher than the old
one, the tool writes those changes back into the file system.  Figure
~\ref{fig:SWAT-opt-code} shows Forest code that replicates this process.

\begin{figure}
\begin{code}
[txforest|
  \kw{data} Preamble\_f  = File Preamble
  data BSN\_f       = File SwatFile
  data PCP\_f       = File PCP
  data TMP\_f       = File TMP

  data Flow\_f      = File Flow                  
  data RCH\_f       = File RCH                   
  data Deviation\_f = File Deviation     
  ...                                        
  data Swat\_d = Directory 
     \{ cio \kw{is} "file.cio" :: Preamble\_f      
     , basin is <| getBasinPath cio |> :: BSN\_f          
     , pcps  is [f :: PCP\_f | f <- matches (GL "*.pcp") ] 
     , tmps  is [f :: TMP\_f | f <- matches (GL "*.tmp") ] 
     , ...
     \}
|]
\end{code}
\caption{(Partial) TxForest SWAT description. }
\label{fig:SWAT-description}
\end{figure}

\begin{figure}
\begin{code}
Update with relevant parts of SWAT optimization code
Not portable, relevant to illustrate the design differences?
\end{code}
\caption{Forest SWAT description. }
\label{fig:SWAT-opt-code}
\end{figure}



