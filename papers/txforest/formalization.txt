(*
-- TODOS:
-- Go through whole thing
-- - Recheck theorem proof
-- Fix translation to IMPOSIX

-- Do we need to add a mkdir?

-- If anything becomes vastly easier because of it,
-- maybe make read and write work on a whole file in POSIX

-- Low priority:
-- Minimize how much we need 'read whole file' and 'write whole file' assumptions
-- Add errors into theorem?

-- Super low:
-- Change from global lock to something fancier (like one of those cool data structures?)

Questions:
-- Where to put info about dedicated space?

-- Compilation look kinda like what you were thinking?
-- Lambdas look like you were thinking? Should I also remove f(e) and make everything lambdas?
-- - Alright to have them take in F,H,[whatever is actually passed in]?
-- - Should probably get rid of f(v) expression all together?
-- Not sure how I want to formulate Lemma 0c. I don't quite like the current one because it looks
   too much like the 1a case
 
-- Tuple case seems shaky. I feel like I need tuples in expression too though, non?
-- - Could possibly make a function that takes curried expressions and pairs them?
--   Not sure how to make it work for arbitrary n though.
-- - Could just make all functions curried?

-- Lemma 1b can't possibly be right.

-- Should I put in in some way that it runs the function after functional application?

Notes:
-- Data type constructors are implicit functions that construct them in the obvious way.
-- w[i,i+1] returns ERR if it's outside range
-- Technically, Lemma 2 is false since you could make operations depend on the heap
   in a way where running it in atomic actually changes what the commands do to the FS.


*)

(* JNF: 

1. Decide what fragment of POSIX File Systems we need. It's fine to
only handle a fragment but we need to be consistent.

2. Decide what to do with errors.

3. Let's not bake our use of the operations (e.g., reading the whole
file) into the calculus. If it is tailored to our use, it is less of a
contribution.

-- JDL: If things go wrong, make an ERROR (or -1) not multiple different ones

-- JDL: Make Data types for errors for the built-in helper functions

-- JDL: Skip errors initially and prove the main part of the theorem (non-transaction errors)
-- only skip in the theorem

-- JDL: Figure out if you need read/write atomic on whole files
-- If it cuts down complexity and it's fast, do it

--------------------------------------------------------------------------------
Dedicated Space
--------------------------------------------------------------------------------

Some file 'filelock' and some file 'glog'

--JDL: Not sure where to put this info

--------------------------------------------------------------------------------
Special types in functions below
--------------------------------------------------------------------------------

(* Metavariable Conventions *)
n in Integer
p in Path
w in String
c in Character
b in Boolean
l in List
F in FileStore

recType := Read(n,c,b) -- Read character c from fd n, which is a dir if b and file o.w.
        |  Write(n,w)  -- Wrote string w to fd n  
        |  Remove(p)   -- Removed path p
        |  Test(p)     -- Tested path p

testCond := TFile    --It is a file
         |  TDir(b)  --It is a possibly empty directory (b=true \implies empty)
         |  TNone    --No file there
         |  TUnknown --Need to check

readCond := RKnown   --Reading from a file/dir where we have it all
         |  RUnknown --Reading from a file/dir where we have none of it
         |  RPartial --Reading from a dir where we have part of it

logT := Test(p)    -- We've run 'test' on p
     |  RF(p,c,n)  -- We read from file p at index n and got c
     |  RD(p,w,n)  -- We read from dir p at index n and got w
     |  W(p,w,n)   -- We wrote w to file p at index n 
     |  Rm(p)      -- We removed file/dir p

logFST := Rem       -- Whatever was at this path has been removed
       |  Fi(w)     -- This path has a file containing w in it
       |  D(l,l',b) -- This is explained just below

-- D(l,l',b) means that the path is a directory containing the entries in list l
-- and not containing the entries in list l'. If b is true, then l is the complete
-- list of entries in the directory, otherwise we don't know and need to check.

--------------------------------------------------------------------------------
Built-in POSIX functions and their semantics
--------------------------------------------------------------------------------


[[ open ]] = fun (F,H,p) -> 
   let S = H(posix_fds) in 
   let n = gensym(S) in 
   let H' = H[posix_fds := S U { n |-> (p,0) }] in 
   (F,H',n, None)

[[ close ]] = fun (F,H,n) ->
   let S = H(posix_fds) in
   if n in dom(S) then
     let H' = H \ n
     (F,H',0,None)
   else
     (F,H,-1, None)

[[ read ]] = fun (F,H,n) ->
   if n \in H(posix_fds) then
     let (p,i) = H(posix_fds)(n) in
     match F(p) with
     | Some(File(w)) 
     | Some(Lock(File(w))) -> 
        let H' = H[posix_fds(n) :=  (p,i+1)] in
        let c = w[i,i+1] in
        (F,H',c, Some(RF(p,c,i)))
     | _       -> (F,H,ERR,None)
   else
      (F,H,ERR,None)

[[ readdir ]] = fun (F,H, n) ->
   if n \in H(posix_fds) then
     let (p,i) = H(posix_fds)(n) in
     match F(p) with
     | Some(Lock(Dir(l)))
     | Some(Dir(l)) -> 
        let H' = H[posix_fds(n) :=  (p,i+1)] in
        let f = l[i,i+1] in
        (F,H',f, Some(RD(p,f,i)))
     | _            -> (F,H,ERR,None)
   else
     (F,H,ERR,None)

[[ write ]] = fun (F,H,(n,w)) ->
   if n \in H(posix_fds) then
     let (p,i) = H(posix_fds)(n) in
     match F(p) with
     | Some(Lock(File(u))) ->
        let F' = F[p := Lock(File(u[i] := w))] in             -- JDL: Better way to write this?
        let H' = H[posix_fds(n) :=  (p,i + |w|)] in 
        (F',H',0,Some(W(p,w,i)))
     | Some(File(u)) ->
        let F' = F[p := File(u[i] := w)] in             -- JDL: Better way to write this?
        let H' = H[posix_fds(n) :=  (p,i + |w|)] in 
        (F',H',0,Some(W(p,w,i)))
     | None          ->
        let F' = F[p := File(w)] in             
        let H' = H[posix_fds(n) :=  (p,i + |w|)] in 
        (F',H',0,Some(W(p,w,i)))
     | _             -> (F,H,-1,None)
   else
     (F,H,-1,None)

[[ remove ]] = fun (F,H,p) ->
   match F(p) with
   | Some(Lock(File(_))) 
   | Some(Lock(Dir([]))) 
   | Some(File(_)) 
   | Some(Dir([])) ->
      let F' = F \ p in
      (F',H,0,Some(Rm(p))) 
   | _             -> 
      (F,H,-1,Some(Test(p))


-- JDL: add check if directory is empty?

[[ test ]] = fun (F,H,p) ->
   let b = 
     match F(p) with
     | Some(Lock(File(_)))
     | Some(File(_)) -> 0
     | Some(Lock(Dir([])))
     | Some(Dir([])) -> 2
     | Some(Lock(Dir(_))) 
     | Some(Dir(_))  -> 1
     | _ -> -1
   in 
   (F,H,b,Some(Test(x)))
   
[[ lockf ]] = fun (F,H,(p,n)) ->
   if n then
      match F(p) with
      | None          
      | Some(Lock(_)) -> (F,H,-1,None)
      | Some(x)       -> 
         let F' = F[p := Lock(x)] in
         (F',H,0,None)
   else
      match F(p) with
      | Lock(x) -> 
         let F' = F[p := x] in
         (F',H,0,None)
      | _       -> (F,H,-1,None)

--------------------------------------------------------------------------------
Built-in Helper functions and their semantics
--------------------------------------------------------------------------------

-- log is (roughly) the list of all commands that have been run
-- logFS is a portion of the FS built up from log
-- H(logFS)(p) maps to an option

-- JDL: Strong (but probably true) assumptions made + problems o.w.:
-- Reads are always in a loop that reads the whole file/directory
-- * At the very least a hassle, don't remember exactly the necessity though
-- Writes are always the whole file, + a truncate at end
-- * How does an open work? Could be part virtual, how do we know?

-- JDL: I don't think any of these are strictly necessary. If we
-- skipped making an FS, and instead walked through the entire log, we could
-- see if we've read that particular bit before or written to it
-- Or if the whole file has been removed, etc.

-- JDL: To think about if so:
-- 1. Record if we've encountered any sort of write
-- 2. If we hit a remove, we have an error (not if we've already hit a write)
-- 3. Since all fds are handled as though they're real, we shouldn't have a
--    problem there
-- 4. Open normally unless there's a remove (in which case fail) or
--    a write, in which case just open manually since we don't know if it
--    exists in the real FS.
-- 5. Close works normally
-- 6. If we open, then remove before closing, we'll need to have reads
--    return ERR
-- 7. Test will have to check log first as expected
-- 8. As will remove. This part will be harder with directories and checking
--    their emptiness because we now have to take those removes and writes into
--    account. Should not need recursiveness though.
-- 9. Writes will have to check to make sure the directory under them exists
-- 10. Reading directories becomes a super pain. Solution:
--     - Check and collect all writes and removes right below it
--       only keeping the last for each entry
--     - If there's a remove of directory, then we fail
--     - Then actually read what's there and check if it's actually supposed
--       to be at that spot. If it's not, it's either because of a write or remove.
--       Keep a special counter that you add to index and increase it with removes,
--       while reducing it with writes.
--     - If an RD of that spot is after any write/remove, then take that
--       Else, check what's supposed to be there (with RD) and then compare
--       with newer writes/removes.
--     - What if there's a write/remove after RDs, but we haven't read FDs in order?
--       Maybe look at all the RDs before and determine where it should be removed
--       and if it's before, update when doing write/remove?
--       Need reverse path to fd lookup then

-- Builds logFS
-- Depending on entry found (starting from beginning)
-- Reads:    RF(p,c,i) Adds c to accumulator or makes p Fi(acc) if c=ERR
-- ReadDirs: RD(p,d,i) Adds d to accumulator or makes p D(acc,[],true) if c=ERR
-- Writes:   W(p,w,i)  makes p Fi(w) and possibly adds p to p's directory
-- Removes:  Rm(p)     makes p Rm and removes it from p's dir

-- souq here is sort and unique at the same time.

let build_fs () =
   let l = rev H(log) in
   let rec helper lst map acc =
   match lst with
      | hd :: tl ->
         let map,acc =
         (match hd with
         | RF(p,c,i)  ->
            if c = ERR
            then add p Fi(acc) map
            else map
         | RD(p,d,i)  -> 
            if d = ERR
            then add p D(acc,[],true) map
            else map
         | W(p,w,_)   ->
            match map(dir(p)) with
            | None            -> add dir(p) D([p],[],false) (add p Fi(w) map)
            | Some(D(l,l',b)) -> add dir(p) D(souq (p :: l),rem p l',b) (add p Fi(w) map)
            | _               -> failwith "Path directory isn't a directory?"
         | Rm(p)    -> 
            match map(dir(p)) with
            | None            -> add dir(p) D([],[p],false) (add p Rm map)
            | Some(D(l,l',b)) -> add dir(p) D(rem p l,souq (p::l'),b)) (add p Rm map)
            | _               -> failwith "Path directory isn't a directory?"
         | _ -> map -- This is Test
         ),(match hd with
         | RF(p,c,i) 
         | RD(p,c,i)  -> 
            if c = EOF
            then []
            else c :: acc
         | _   -> acc
         )
         in
         helper tl map acc
      | [] -> map
   in 
   let H' = H[logFS := helper l empty ""] in
   (F,H',())

-- Lookup log for reads etc.
-- Do different things depending on type of file found
-- Files    (F)  always contain the byte, we read normally
-- Dirs     (D)  always contain the byte, but may not know right byte, do something fancy
-- Removes  (Rm) Will just return ERR when read normally
-- None          We don't know anything about it, needs to be read normally

[[ lookup_logR ]] = fun (F,H,n) -> 
   let (p,i) = H(posix_fds)(n) in
   let b = 
      match H(logFS)(p) with
      | Some(Fi(_))
      | Some(D(_,_,true))  -> RKnown       
      | Some(D(_,_,false)) -> RPartial
      | Some(Rm) 
      | None    -> RUnknown in 
   (F,H,b)

-- Lookup log for existence and type etc.
-- Do different things depending on type of file found
-- Files    (F)  exists and is TFile
-- Dirs     (D)  exist, but may or may not be empty, TDir(true) or TDir(false)
-- Removes  (Rm) truly don't exist, TNone
-- None          may or may not exist, TUnknown


[[ lookup_logE ]] = fun (F,H,p) -> 
   let b = 
      match H(logFS)(p) with
      | Some(Fi(_))                  -> TFile
      | Some(D(l,_,_)) when l <> [] -> TDir(false)
      | Some(D(_,_,false))            
      | None                        -> TUnknown
      | Some(D(_))                  -> TDir(true)
      | Some(Rm)                    -> TNone in 
   (F,H,b)

-- Do different things depending on type of file found
-- Files    (F)  always contain the byte
-- Dirs     (D)  only works if we know we have it all
-- Removes  (Rm) doesn't contain byte
-- None          doesn't contain byte

[[ read_log ]] = fun (F,H,n) ->
   let (p,i) = H(posix_fds)(n) in
   let H' = H[posix_fds(n) :=  (p,i+1)]) in 
   let c,x = 
      match H(logFS)(p) with
      | Some(Fi(w))         -> w[i],Some(RF(p,w[i],i))
      | Some(D(w,_,true))  -> w[i],Some(RD(p,w[i],i))    
      | Some(Rm)           
      | Some(D(_,_,false))     
      | None               -> failwith "lookup_logR would've failed"
   in 
   (F,H',c,x)

-- JDL: Check over this function to make sure it needs to be this complex
-- JDL: ERR > everything
[[ read_and_check ]] = fun (F,H,(n,e)) ->
   let (p,i) = H(posix_fds)(n) in
   let rec get_correct e last l l' =
      match l,l' with
      | [],[] -> (F,H,e,RD(p,e,i-1))
      | [], hd :: tl ->
        if hd = e
        then let _,H',r,_ = readdir n in
          read_and_check (n,r) 
        else get_correct e last l tl
      | hd :: tl,_ ->
        if hd > last && hd < e
        then (F,H[posix_fds(n) := (p,i-1)],hd)
        else if hd = e
        then (F,H,hd,RD(p,hd,i-1))
        else get_correct e last tl l'
   in
   match H(logFS)(p) with
   | D(l,l',false) -> 
     match H(log) with
     | RD(p',last,_) :: _ where p = p' -> get_correct e last l l'
     | _                               -> get_correct e ""   l l'
   | _               -> failwith "Would never get to here"

[[ record ]] = fun (F,H,t) -> 
   let l  = H(log) in
   let H' =
      match t with
      | Read(fd,v,d)   ->
        let (p,i) = H(posix_fds)(n) in
	let index = if H(real_index) = 0 && i > 0 then i-1 else H(real_index)-1 in
        let ele   = if d then RD(p,v,index) else RF(p,v,index) in
	let H' = if v = ERR then H[real_index := 0] else H in
        H'[log := ele :: l]
      | Write(fd,w)    ->  
         let (p,i) = H(posix_fds)(n) in
         H[log := W(p,w,i) :: l]
      | Remove(p)      -> H[log := Rm(p)    :: l]
      | Test(p)        -> H[log := Test(p)  :: l]
   in 
   let _     = build_fs () in
   (F,H',0)
   
-- In atomic translation

-- H(log) starts out as []

-- We need a global log of (time, path) pairs
-- We'll just use some reserved name in the FileStore for now,
-- but could easily be added in a shared memory structure (which is what it is)
   
[[ check_error ]] = fun (F,H,()) ->
   let t = H(tstart) in
   let glog =        -- We add all the changes that happened post tstart
      fold (fun acc (t',p) -> if t < t' then p :: acc else acc) F(glog)
   in
   let rec err_help l =
      match l with
      | hd :: tl ->
         match hd with
         | RD(p,_,_) 
         | RF(p,_,_)
         | Test(p) -> if exists (= p) glog then 1 else err_help tl
         | _       -> err_help tl
      | [] -> 0 in 
   let l = H(log) in
   let b = err_help l in
   (F,H,b)
   
-- Either use the FS, allowing for fewer operations
-- or just do all the operations of the log.
-- Starting with log because it's more obviously correct

-- If we're here, then we've passed the check_error, so depending
-- on if n > 1 or not, we append log or do FS writes

[[ write_log ]] = fun (F,H,()) ->
   let rec writer l acc =
      let F',H',lst = acc in
      match l with
      | hd :: tl ->
         match hd with
         | W(p,w,_)   -> 
            let F',H',fd = open p in
            let F',H',_  = write (fd,w) in
            let F',H',_  = close fd in
            writer tl (F',H',p :: lst)
         | Rm(p)    ->
            let F',H',_  = remove p in
            writer tl (F',H',p :: lst)
         | _        -> writer tl acc
      | [] -> acc
   in
   let l             = H(log) in
   let (F',H',clist) = writer (rev H(log)) (F,H,[]) in
   let t             = time() in
   let clist         = map (fun p -> (t,p)) clist in
   let F''           = F(glog := F(glog) @ clist) in
   (F'',H',())

--------------------------------------------------------------------------------
Syntax
--------------------------------------------------------------------------------

(* Metavariable Conventions *)
n in Integer
p in Path
w in String
F in FileStore
 
(* Values *)
v ::= n
    | p
    | w
    | (v1,...,vn)
    | l
    | fun x -> e

o ::= Some v 
    | None

l ::= v :: l | []

-- Things that can exist in filesystem
lf ::= File(w)
   | Dir(l)
   | Lock(lf)

(* Expressions *)
e ::= x
    | v
    | f e
    | e e
    | (e1,...,en)

(* Commands *)
c ::= skip
    | c1; c2
    | x := e
    | if e then c1 else c2
    | while e do c
    | atomic c

(* Heaps *)
H in Var |-> Value

(* Threads *)
t ::= <H,c>

M ::= {t1,...,tk}

--------------------------------------------------------------------------------
SEMANTICS
--------------------------------------------------------------------------------

(* Evaluation Contexts *)
E ::= . 
    | f E
    | E e
    | v E
    | (E,e2,...,en)
    | (v1,E,e3,...,en)
    | ...
    | (v1,...,v(n-1),E)

(* Expression evaluation: (F,H,e) - o -> (F',H',e') *)

(* Notational convention: 
   write 
     (F,H,e) - None -> (F',H',e') 
   as 
     (F,H,e) --> (F',H',e') 
*)  

H(x) = v
-------------- E-Var
(F,H,x) -> (F,H,v)

(F',H',v',o) = [[ f ]] (F,H,v)
--------------------------------- E-Call1
(F,H,f v) - o -> (F',H',v')


(F',H',v') = [[ f ]] (F,H,v)
--------------------------------- E-Call2
(F,H,f v) --> (F',H',v')

v1 = fun x -> e
e' = e[x -> v2]
--------------------------------- E-Lambda
(F,H,v1 v2) -> (F,H,e')

(F,H,e) - o -> (F',H',e')
--------------------------- E-Context
(F,H,E[e]) - o -> (F',H',E[e'])

(* Command evaluation: (F,H,c) - o -> (F',H',c') *)

C ::= . 
     | x := C
     | if C then c1 else c2
     | while C do c
     | C ; c

t ::= e | c 

C[t] needs to be well-formed...

(F,H,t) - o -> (F',H',t')
--------------------------- C-Context
(F,H,C[t]) - o -> (F',H',C[t'])
     
-------------------------- C-SkipSeq
(F,H,skip;c2) --> (F,H,c2)

H' = H[x:=v]
-------------------------C-Assgn
(F,H,x:=v) --> (F,H',skip)

--------------------------------------C-IfFalse
(F,H,if 0 then c1 else c2) --> (F,H,c2)

n <> 0
--------------------------------------C-IfTrue
(F,H,if n then c1 else c2) --> (F,H,c1)


--------------------------------C-WhileFalse
(F,H,while 0 do c) --> (F,H,skip)

n <> 0
------------------------------------------C-WhileTrue
(F,H,while n do c) --> (F,H,c;while n do c)

(* Multi-step command evaluation: (F,H,c) - l -> (F',H',c') *)

------------------------T-Refl
(F,H,t) - [] ->* (F,H,t)

(* JNF: NB, I flipped T-Step around so the effects are accumulated in
order *)

-- JDL: I reflipped it. The other log is collected in opposite order,
-- so I figure we may as well make this one the same.
-- Although it is a bit weird

(F,H,t) - l ->*  (F',H',t')
(F',H',t') - o -> (F'',H'',t'')
--------------------------------- T-Step
(F,H,t) - o :: l -> (F'',H'',t'')

--------------------------------------------------------------------------------
Concurrent Operational Semantics
--------------------------------------------------------------------------------

(F,H,c) -> (F',H',c')
----------------------------------------- M-step
(F,M U { <H,c> }) -> (F',M U { <H',c'> })

----------------------------------------- M-skip
(F,M U { <H,skip> }) -> (F,M)

(F,H,c) ->* (F',H',skip)
---------------------------------------------- M-atomic
(F,M U { <H,C[atomic c]> }) -> (F',M',C[skip])

--------------------------------------------------------------------------------
Translation from TxForest to IMPOSIX
--------------------------------------------------------------------------------

(* JNF: Let's define the syntax of the subset of Haskell that we're
using here? I think this includes new, read, write, etc. Should also
define data structures like Rep(p). *)

-- Notably, this could just be a POSIX tuple. This is mostly for ease of reading.
-- x is where it is stored.
rep := Dir(p,n,l,x)  -- Directory at path p, which contains l and is read if n=1
    |  File(p,n,w,x) -- File at path p containing w and is read if n=1
    |  Rm(p)         -- Just lets us know that we've removed it

spec := Directory
     |  File

-- Where ret is the return value

[[ new ]] = fun spec p ->
  match spec with
  | Directory ->
    x   := Dir(p,0,[],x);
    ret := Dir(p,0,[],x)
  | File      ->
    x   := File(p,0,"",x); 
    ret := File(p,0,"",x)
  where x is fresh.

[[ read ]] = fun rep ->
  match rep with
  | Rm(_)	  -> failwith "Can't read deleted rep"
  | Dir(_,1,w,_)
  | File(_,1,w,_) -> ret := (rep,w)
  | Dir(p,_,_,x)  ->
    tmp := [];
    r := 1;
    fd := open p;
    while r do {
      r   := readdir fd; 
      tmp := r :: H(tmp)
    };
    tmp := rev H(tmp);
    _ := close fd;
    x   := Dir(p,1,tmp,x);
    ret := (x,tmp)
  | File(p,_,_,x) -> -- For simplicity, I'll think of strings as a list of chars
    tmp := [];
    r := 1;
    fd := open p;
    while r do {
      r   := read fd; 
      tmp := r :: H(tmp)
    };
    tmp := rev H(tmp);
    _ := close fd;
    x   := File(p,1,tmp,x);
    ret := (x,tmp)
  where r, fd, and tmp are fresh
   
[[ delete ]] = fun rep ->
  match rep with
  | Rm(_) -> ret := ()
  | Dir(p,1,l,x) ->
    iter [[ delete ]] l 
    ret := ();
    _ := remove p;
    x := Rm(p)
  | Dir(p,n,l,x)  ->
    list := [p];
    ret := ()
    while list <> [] do {
      y := hd H(list);
      r := remove(x);
      if r then {
        fd := open (x);
        while r do {
          r    := readdir fd; 
          list := r :: H(list)
        };
        _ := close fd
      } 
      else list := tl H(list)
    }
    x := Rm(p)
  | File(p,_,_,x) ->
    ret := ();
    _ := remove p;
    x := Rm(p)
  where list, fd, y, and r are fresh.
   
-- JDL: Not quite sure what to do with b and func for errors?

[[ writeOrElse ]] = fun rep l' b func = 
  match rep with
  | Rm(_)
  | Dir(_,0,_,_)
  | File(_,0,_,_) -> ret := ()
  | Dir(p,n,l,x)  ->
    iter (fun rep' -> 
      match rep' with
      | File(_,_,newl,_)
      | Dir(_,_,newl,_)  -> [[ writeOrElse ]] rep' newl b func
      ) l'  
    x  := Dir(p,n,l',x)
  | File(p,n,w,x) ->
    _  := remove p;
    fd := open p;
    r  := write (fd,l');
    _  := close fd;
    if r = -1
    then ret := func r
    else ret := b;
    x  := File(p,n,l',x)
  where r and fd are fresh.

--------------------------------------------------------------------------------
Optimistic Compilation
--------------------------------------------------------------------------------

(* ([ e ]) : Exp *)

([ x ]) = x
([ v ]) = v
([ e1 e2 ]) =
   let e1' = ([ e1 ]) in
   let e2' = ([ e2 ]) in
   e1' e2'

([ (e1,...,en) ]) =
   let e1' = ([ e1 ]) in
   ...
   let en' = ([ en ]) in
   (e1',...,en')

([ open ]) = fun (F,H,p) -> open p

([ close ]) = fun (F,H,n) -> close n

([ read ]) = fun (F,H,n) ->
   match lookup_logR n with
   | RKnown   -> 
      let (_,H',r,x) = read_log n in
      let (_,H',_)   = record Read(n,r,false) in -- Solely required for proof of Lemma 2
      (F,H',r,x)
   | RUnknown ->
      let (_,H',r,x) = read n in
      let (_,H',_)   = record Read(n,r,false) in
      (F,H',r,x)
   | RPartial -> (F,H,-1,None)

([ readdir ]) =  fun (F,H,n) ->
   match lookup_logR n with
   | RKnown   -> 
      let (_,H',r,x) = read_log n in
      let (_,H',_) = record Read(n,r,true) in -- Solely required for proof of Lemma 2
      (F,H',r,x)
   | RUnknown ->
      let (_,H',r,x) = readdir n in
      let (_,H',_) = record Read(n,r,true) in
      (F,H',r,x)
   | RPartial ->
      let (_,H',r,_) = readdir n in
      let (_,H',r,x) = read_and_check (n,r) in
      let H' = H'[real_index := H'(real_index)+1] in
      let (_,H',_) = record Read(n,r,true)  in
      (F,H',r,x)

-- Need to add an error if F(p) = Dir(_)
([ write ]) = fun (F,H,(n,w)) ->
   let (_,H',x) = record Write(n,w) in
   (F,H',x)

([ remove ]) = fun (F,H,p) ->
   match lookup_logE p with
   | TFile       
   | TDir(true)  -> 
      let (_,H',t) = record Remove(p) in
      (F,H',t,Some(Rm(p)))
   | TNone       
   | TDir(false) -> (F,H,-1,None)
   | TUnknown    -> 
      let (_,H',t,x) = test p in
      let (_,H',t),x   = if t = 0 || t = 2
         then (record Remove(p)),Some(Rm(p))
         else (t,H',-1),x
      in
      (F,H',t,x)

([ test ]) = fun (F,H,p) ->
   let (_,H',_) = record Test(p) in
   match lookup_logE p with
   | TFile       -> (F,H',0,Test(p))
   | TNone       -> (F,H',-1,Test(p))
   | TDir(true)  -> (F,H',2,Test(p))
   | TDir(false) -> (F,H',1,Test(p))
   | TUnknown    -> test p


(* ([ c ]) : Com \ {atomic c} *)

([ skip ]) = skip

([ x := e ]) = 
   x := ([ e ])

([ c1; c2 ]) = ([ c1 ]); ([ c2 ])

([ if e then c1 else c2 ]) = 
   if ([ e ]) then ([ c1 ]) else ([ c2 ])

([ while e do c ]) = 
   while ([ e ]) do ([ c ])

([ atomic c ]) = 
   f := 1;
   while f do
     tstart := time (); -- Gets current time
     log := [];
     ([ c ]);
     lsucc := -1;
     while lsucc = -1 do -- Did we acquire lock successfully?
        lsucc := lockf (lockfile,1);
     f := check_error ();
     if not f then _ := write_log () else skip;       
     _ := lockf (lockfile,0)
   where f and lsucc are fresh, atomic is not a subcommand of c.
   and time returns the current time.

--------------------------------------------------------------------------------
Theorems
--------------------------------------------------------------------------------

-- For all compilations of the form ([ atomic(c) ]):
-- We require reads in c to be in a while loop, reading until EOF.
-- We require writes of string s to path p in c to be from position 0 in the fd 
-- and be preceded by a remove(p).

Theorem:
Given some starting filesystem F, executing ([ atomic(c) ]) || ([ atomic(d) ])
will generate a filesystem F', s.t. there exists a serializable order,
c;d or d;c where starting from filesystem F and executing one of the
two will also generate F'. Note that we do not restrict ourselves to
a particular heap. If both c and d run to completion on some 
(possibly different) heap, in effectively serial order, then we consider
it a success.

Proof of theorem:
Assume not. Then c = c_1;...;c_n and d=d_1;...;d_m and there is some
interleaving of them which creates F' (since by lemma 2, o.w. c;d or d;c would
generate F').
Consider the cases (I) where c and d do not overlap (in the files they read/modify),
(II) where c modifies files read by d, (II by symmetry) where d modifies files
read by c, and (III) where they both modify files read by each other.

(I)   : If they don't overlap, then any interleaving is equivalent to c;d
(II)  : If any modifications of files that d reads occurs after d has completed,
        then this is clearly equivalent to d;c.
        O.w., since all modifications to the filesystem happen in the final
        write_log (as noted in the proof of Lemma 2), ([ atomic(c) ])
	must have gotten the lock before ([ atomic(d) ]). Then, when it releases
	the lock and d does a check_error, it will detect that c has run, thus restarting,
	which means that we have c;d (with possible changes to the heap).
(III) : Either c or d will acquire the lock first. By proof of Lemma 2, we know
        that neither will change the FS before then. Assume WLOG that c gets it.
        Then, c can't be in conflict with anything (because the FS hasn't
        been changed) and thus commits his changes in write_log before
        releasing the lock. Then, since d read files modified by c,
        he will restart the transaction, thus resulting in c;d
        (again, with a possibly different heap).
        
Since in all cases, we get either c;d or d;c, the theorem holds.

******* SOME JNF PROOFS *******

Lemma 0a [Inversion of single-step relation]

* Not (F,H,skip) - o -> (F',H',c').

* If (F,H,skip;c1) - o -> (F',H',c') then 
    F=F' and H=H' and c'=c1 and o = None.

* If (F,H,c1;c2) - o -> (F',H',c') and c1 != skip, then 
    (F,H,c1) - o -> (F',H',c1') and c' = c1';c2

* ...

Lemma 0b [Inversion of multi-step relation]:

Commands:

* If (F,H,skip) - l ->* (F',H',c') then 
    F=F' and H=H' and c'=skip and l = [].

* If (F,H,c1;c2) -l ->* (F',H',c') then either
  - c' = c1';c2 and (F,H,c1) - l ->* (F',H',c1')
  - c' = c2' and (F,H,c1) - l1 ->* (F0,H0,skip) and (F0,H0,c2) - l2 ->* (F',H',c2') and l = l2@l1

* If (F,H,x := e) - l ->* (F',H',c') then either
  - c' = x := e' and (F,H,e) - l ->* (F',H',e') or
  - c' = skip and (F,H,x := e) - l1 ->* (F',H0, x:=v) and H' = H0[x:=v]

* If (F,H,if e then c1 else c2) - l ->* (F',H',c') then either
  - c' = if e' then c1 else c2 and (F,H,e) - l ->* (F',H',e') or
  - c' = c1' and (F,H,e) - l1 ->* (F0,H0,n) where n <> 0 and (F0,H0,c1) - l2 ->* (F',H',c1') and l = l2@l1 or
  - c' = c2' and (F,H,e) - l1 ->* (F0,H0,n) where n = 0 and (F0,H0,c2) - l2 ->* (F',H',c2') and l = l2@l1

* If (F,H,while e do c) - l ->* (F',H',c') then either
  - c' = while e' do c and (F,H,e) - l ->* (F',H',e') or
  - c' = c1;while e do c and (F,H,e) - l1 ->* (F0,H0,n) where n <> 0 and (F0,H0,c) - l2 ->* (F',H',c1) and l= l2@l1 or
  - c' = skip (F,H,e) - l ->* (F',H',n) where n = 0 

Expressions:

* If (F,H,f(e)) - l ->* (F',H',e') then either
  - e' = f(e0) and (F,H,e) - l ->* (F',H',e0) or
  - e' = v' and (F,H,e) - l1 ->* (F0,H0,v) and (F0,H0,f(v)) - o -> (F',H',v') and l = o::l1

* If (F,H,e1 e2) - l ->* (F',H',e') then either
  - e' = e1' e2 and (F,H,e1) - l ->* (F',H',e1') or
  - e' = v1 e2' and (F,H,e1) - l1 ->* (F0,H0,v1) and (F0,H0,e2) - l2 ->* (F',H',e2') and l = l2@l1 or
  - e' = e3 and (F,H,e1) - l1 ->* (F0,H0,fun x -> e) and (F0,H0,e2) - l2 ->* (F',H',v2)
    and e3 = e[x -> v2] and l = l2@l1 or
  - e' = e3 and (F,H,e1) - l1 ->* (F0,H0,fun x -> e) and (F0,H0,e2) - l2 ->* (F1,H1,v2)
    and (F1,H1,e[x -> v2]) - l3 ->* (F',H',e3) and l = l3@l2@l1


Lemma 0c [Translated function effects]:
  For any e1 and e2, such that ([ e1 ]) = fun x -> e',
  if (F,H,([ e1 e2 ])) - l ->* (F',H',e3) then F=F'.

Proof:
  This is obvious by inspection of the functions.
  They return the same F that they received.

Proof:
  By inspection.

Lemma 1a[Compiled Expression Effects]:
  If (F,H,([ e ])) - l ->* (F',H',e') then F=F'.

Proof.

By induction on e.

Case e = x:

  By the definition of ([ . ]) we have ([ x ]) = x

  By the semantic rule E-var, if (F,H,x) -> (F',H',e'), then e'=v and F=F'

Case e = v 

  By the definition of ([ . ]) we have ([ v ]) = v

  We are then stuck so F=F' trivially.

Case e = e1 e2

  By the definition of ([ . ]) we have ([ e1 e2 ]) = e1' e2'
  where e1' = ([ e1 ]) and e2' = ([ e2 ]).

  By Lemma 0b, case for lambdas, there are four subcases:
  
  Subcase e' = e1'' e2' and (F,H,e1') - l ->* (F',H',e1'')

    By inductive hypothesis applied to e1, we have F = F' as required.

  Subcase e' = v1 e2'' and (F,H,e1') - l1 ->* (F0,H0,v1) and (F0,H0,e2') - l2 ->* (F',H',e2'') and l = l2@l1

    By the inductive hypothesis applied to e1, we have F = F0.
    By the inductive hypothesis applied to e2, we have F0 = F'.
    By transitivity, we have F=F' as required.

  Subcase e' = e3 and (F,H,e1') - l1 ->* (F0,H0,fun x -> e) and (F0,H0,e2') - l2 ->* (F',H',v2)
               and e3 = e[x -> v2] and l = l2@l1

    By the inductive hypothesis applied to e1, we have F = F0.
    By the inductive hypothesis applied to e2, we have F0 = F'.
    By transitivity, we have F=F' as required.

  Subcase e' = e3 and (F,H,e1') - l1 ->* (F0,H0,fun x -> e) and (F0,H0,e2') - l2 ->* (F1,H1,v2) 
               and (F1,H1,e[x -> v2]) - l3 ->* (F',H',e3) and l = l3@l2@l1
            
    By the inductive hypothesis applied to e1, we have F = F0.
    By the inductive hypothesis applied to e2, we have F0 = F'.
    By Lemma 0c, we have F1=F'.
    By transitivity, we have F=F' as required.

Case e = (e1,...,en)

  By the definition of ([ . ]) we have ([ (e1,...,en) ]) = (e1',...,en')
  where e1' = ([ e1 ]),..., and en' = ([ en ]).

  We proceed by induction on n:
  
    Base case: n=1

      e = e1.
      By the inductive hypothesis applied to e1, we have F = F' as required.

    Inductive case: n=n+1

      e = (e1,...,en,e(n+1)).
      Consider the two cases where e(n+1) is reduced and where it isn't.
      Case e(n+1) is not reduced:

        Then, by the 2nd inductive hypothesis applied to the first n expressions of the n+1-tuple,
        F=F'.

      Case e(n+1) is reduced:

        By the semantic rule E-Context, e(n+1) can not be reduced until all previous components are.
        (F,H,(e1,...,en,e(n+1))) - l ->* (F0,H0,(v1,...,vn,e(n+1)))
        By the 2nd inductive hypothesis applied to the first n expressions of the (n+1)-tuple, F=F0.
        Then, (F0,H0,e(n+1)) - l' ->* (F',H',e(n+1)').
        By the inductive hypothesis applied to e(n+1), F0=F'
        By transitivity F=F'.  

Lemma 1b[Compiled Command Effects]. 
  Let c be a command that does not contain any sub-commands of the
  form atomic(_) and let c0 = ([c]). If (F,H,([c])) - l ->* (F',H',c')
  then F=F'.

Proof. 

By induction on the derivation of (F,H,([c])) - l ->* (F',H',c')

There are only two applicable rules:

Case T-Refl:

  --------------------------------T-Refl
  (F,H,([c])) - [] ->* (F,H,([c]))

  F=F' directly.

Case T-Step:

  (F,H,([c])) - l ->*  (F0,H0,c0)
  (F0,H0,c0) - o -> (F',H',c')
  --------------------------------- T-Step
  (F,H,([c])) - o :: l -> (F',H',c')

  By the inductive hypothesis we have F=F0.
  We want to show F0=F' by induction on the derivation of
  (F0,H0,c0) - o -> (F',H',c').

  Case C-SkipSeq:
  
  ------------------------------ C-SkipSeq
  (F0,H0,skip;c2) --> (F0,H0,c2)

  c0=skip;c2
  F0=F'. F=F' by transitivity.

  Case C-Assgn:

  H' = H0[x:=v]
  -------------------------- C-Assgn
  (F0,H0,x := v) --> (F0,H',skip)

  c0=x := v
  F0=F'. F=F' by transitivity.

  Case C-IfFalse:

  ------------------------------------------- C-IfFalse
  (F0,H0,if 0 then c1 else c2) --> (F0,H0,c2)

  c0=if 0 then c1 else c2
  F0=F'. F=F' by transitivity.

  Case C-IfTrue:

  n <> 0
  ------------------------------------------- C-IfTrue
  (F0,H0,if n then c1 else c2) --> (F0,H0,c1)

  c0=if n then c1 else c2
  F0=F'. F=F' by transitivity.

  Case C-WhileFalse:

  ------------------------------------------- C-WhileFalse
  (F0,H0,while 0 do c) --> (F0,H0,skip)

  c0=while 0 do c
  F0=F'. F=F' by transitivity.

  Case C-WhileTrue:

  n <> 0
  ------------------------------------------- C-WhileTrue
  (F0,H0,while n do c) --> (F0,H0,c;while n do c)

  c0=while n do c
  F0=F'. F=F' by transitivity.

  Case C-Context:
  
  (F0,H0,t) - o -> (F',H',t')
  --------------------------- C-Context
  (F0,H0,C[t]) - o -> (F',H',C[t'])
  
  c0= C[t]. We examine the possible contexts:

    Case c0 = x := C:
    
      The hole is an expression, so by Lemma 1a, F0=F'.
      By transitivity, F=F'.

    Case c0 = if C then c1 else c2:
    
      The hole is an expression, so by Lemma 1a, F0=F'.
      By transitivity, F=F'.

    Case c0 = While C do c:
    
      The hole is an expression, so by Lemma 1a, F0=F'.
      By transitivity, F=F'.

    Case c0 = C;c2:
    
      The hole is a command. C=c1. Then, we instantiate the Context rule
      (F0,H0,c1) - o -> (F',H',c1')
      ----------------------------------
      (F0,H0,c1;c2) - o -> (F',H',c1';c2)
      
      By the (second) inductive hypothesis derivation (F0,H0,c1) - o -> (F',H',c1'),
      we have F0 = F'. By transitivity, F=F'.

Lemma 2: If <F,H,c> - l -> * <F',H',skip> and <F,H,([ atomic c ])> - l' -> * <F'',H'',skip>,
         then F'=F'', where c does not contain sub-commands of the form atomic(_).
         

Proof:
  By the definition of ([ . ]), ([ atomic c ]) =
    f := 1;
    while f do
      tstart := time (); -- Gets current time
      log := [];
      ([ c ]);
      lsucc := -1;
      while lsucc = -1 do -- Did we acquire lock successfully?
        lsucc := lockf (lockfile,1)
      f := check_error ();
      if not f then _ := write_log () else skip;       
      _ := lockf (lockfile,0)
    where f and lsucc are fresh, atomic is not a subcommand of c.
    and time returns the current time.

    We will consider the sequence one piece at a time:
    
    1. (F,H,f:=1;rest) ->* (F,H[f:=1],rest)
       By the semantic rules C-Assgn and C-SkipSeq.
     
    2. (F,H[f:=1],while f do loopC1) ->* (F,H[f:=1],loopC1;while f do loopC1)
       By the semantic rules E-var and C-WhileTrue.

    3. (F,H[f:=1],tstart := time ();rest) ->* (F,H[f:=1,tstart:= t1],rest)
       Where t1 is the current time.
       By the semantic rules C-Assgn, definition of time, and C-SkipSeq.

    4. (F,H[f:=1,tstart:= t1], log := [];rest) ->* (F,H[f:=1,tstart:= t1,log := []],rest)
       By the semantic rules C-Assgn and C-SkipSeq.

    5. (F,H[f:=1,tstart:= t1, log := []], ([ c ]);rest) -l1->* (F,H'[f:=1,tstart:= t1],rest)
       By Lemma 1b, the FS doesn't change. Since f is fresh and tstart is a
       reserved variable, we know they don't change, o.w. H could be changed
       basically arbitrarily.

    6. (F,H'[f:=1,tstart:= t1], lsucc := -1;rest) ->* (F,H'[f:=1,tstart:= t1,lsucc := -1],rest)
       By the semantic rules C-Assgn and C-SkipSeq.

    7. (F,H'[f:=1,tstart:= t1,lsucc := -1], while lsucc = -1 do lsucc := lockf(lockfile,1);rest)
       ->* (F,H'[f:=1,tstart:= t1,lsucc := -1], lsucc := lockf(lockfile,1); while lsucc = -1 do lsucc := lockf(lockfile,1);rest)
       By the semantic rules E-var and C-WhileTrue.

    8. (F,H'[f:=1,tstart:= t1,lsucc := -1], lsucc := lockf(lockfile,1); while lsucc = -1 do lsucc := lockf(lockfile,1);rest)
       ->* (F / lockfile \uplus {lockfile -> Lock(File(""))},H'[f:=1,tstart:= t1,lsucc := 0], while lsucc = -1 do lsucc := lockf(lockfile,1);rest)
       By the semantic rules C-Assgn and C-SkipSeq and the definition of lockf. Since there are no other threads, lockf succeeds.

    9. (F / lockfile \uplus {lockfile -> Lock(File(""))},H'[f:=1,tstart:= t1,lsucc := 0], while lsucc = -1 do lsucc := lockf(lockfile,1);rest)
       ->* (F / lockfile \uplus {lockfile -> Lock(File(""))},H'[f:=1,tstart:= t1,lsucc := 0], rest)
       By the semantic rules E-var and C-WhileFalse.

    10. (F / lockfile \uplus {lockfile -> Lock(File(""))},H'[f:=1,tstart:= t1,lsucc := 0], f := check_error ();rest)
        ->* (F / lockfile \uplus {lockfile -> Lock(File(""))},H'[f:=0,tstart:= t1,lsucc := 0], rest)
        By the semantic rules C-Assgn and C-SkipSeq and the definition of check_error. Since there are no other
        threads and this thread hasn't written anything to glog yet, it will be empty. Thus,
        check_error succeeds and returns 0.

    11. (F / lockfile \uplus {lockfile -> Lock(File(""))},H'[f:=0,tstart:= t1,lsucc := 0], if not f then _ := write_log () else skip;rest)
        ->* (F / lockfile \uplus {lockfile -> Lock(File(""))},H'[f:=0,tstart:= t1,lsucc := 0], _ := write_log ();rest)
        By the semantic rules E-var and C-IfTrue. 

    12. (F / lockfile \uplus {lockfile -> Lock(File(""))},H'[f:=0,tstart:= t1,lsucc := 0], _ := write_log ();rest)
        - l2 ->* (F' / lockfile \uplus {lockfile -> Lock(File(""))},H''[f:=0,tstart:= t1,lsucc := 0], rest)
        By the semantic rules C-Assgn and C-SkipSeq and the definition of write_log. Write_log may change
        both the file system and the heap (well, actually it never changes the heap, but we don't care about
        proving that). However, all of the variables specifically noted (lockfile, f, tstart, lsucc) were either
        fresh or reserved. More on the changes done to the filesystem by later.

    13. (F' / lockfile \uplus {lockfile -> Lock(File(""))},H''[f:=0,tstart:= t1,lsucc := 0], _ := lockf (lockfile,0);rest)
        ->* (F',H''[f:=0,tstart:= t1,lsucc := 0], rest)
        By the semantic rules C-Assgn and C-SkipSeq and the definition of lockf. Notably, when 0 is passed into lockf,
        it simply undoes what was done when 1 was passed in.

    14. (F',H''[f:=0,tstart:= t1,lsucc := 0], while f do loopC1)
        ->* (F',H''[f:=0,tstart:= t1,lsucc := 0], skip)
        By the semantic rules E-Var and C-WhileFalse.

    Importantly, in the end, only write_log has wrought changes to the filesystem. These changes are described
    by the log, as written in ([ c ]).

  So what we have left to prove is that the changes described in the log are the same as those made by c.
  We proceed as follows:
  1. We show that build_fs correctly constructs a partial virtual filesystem (VFS) sitting atop the real one.
  2. We show that the translated commands correctly invoke this virtual FS to add the right things to the log
  3. such that write_log actually makes the same changes that running 'c' directly would.

  1. We will start with the meanings of the various constructs that can
     be in the log as they are important for the rest of the proof:
     RF(p,c,i) means we read location i of a file at path p and it contained c.
     RD(p,d,i) means we read location i of a directory at path p and it contained d.
     W(p,w,i)  means we wrote w to location i of a file at path p.
     Rm(p)     means we removed whatever was at path p.
     
     Now we look at how the build_fs function builds up the virtual filesystem (VFS)
     using each log entry.
     Paths can map to one of 3 different things (encoding our current knowledge of what's there)
     or nothing if we haven't changed the path:
     Fi(w) is a file containing string w.
     Rm means that whatever was there is now removed (so nothing is there).
     D(l,l',b) means that the path is a directory containing all the entries in l and none of the
     entries in l'.  If b is true, then l is the sum total of what's in the directory, o.w. we
     don't know if there is more.

     Starting from the first entry of the log and going to the last one,
     build_fs updates the VFS depending on what it sees as follows:
     RF(p,c,i) - Accumulates all characters into acc until it gets ERR at which point it makes
                 p map to Fi(acc). This works since we always read a full file.
     RD(p,d,i) - Accumulates all entries into acc until it gets ERR at which point it makes 
                 p map to D(acc,[],true). This works since we always read a full directory.
     W(p,w)   -
       If the path of the directory of p (dir(p)) doesn't map to anything it makes p map to Fi(w)
         and dir(p) map to D([p],[],false) (since we now know a p is in dir(p), but haven't read it).
       O.w. if dir(p) maps to D(l,l',b), it adds p into the sorted list of paths l at the correct
         position if it's not in there already and removes it from l'. It then makes dir(p) map to
         that construct and makes p map to Fi(w). Regardless of whether we had the complete list 
         (b is true) or not we continue to stay in that state since we just add what we know is
         now there (or nothing if it already was).
     Rm(p)    -
       It maps p to Rem, then:
       If dir(p) doesn't map to anything, it makes it map to D([],[p],false) since the only thing
         we know about the directory is that it no longer contains p.
       O.w. if it maps to D(l,l',b), it removes p from list l and adds it (in unique sorted order)
         to l' indicating that we now know that p is not in the directory.

     These statements are true by inspection, but it is not until we get to 2 that it is clear
     that this is correct. However, it should be apparent that:
     1. For any removed file or folder, we now know that it is removed (since it maps to Rem).
     2. That know said file/folder is no longer in the folder it was in.
     3. That files or folders we've read now are mapped to and known in their entirety
        (Fi(w) for files and D(l,l',true) for folders).
     4. And lastly that files written to are now known to exist and have known contents

  2. We will show this property by comparing the real log to the augmented log from the semantics.

     WTS: If H(log) = l, ([ c ]) = c’, c does not contain a sub-command of the form atomic(_), 
     <F',H,c’> - _ ->* <F',H1,c1'> and H1(log) = x :: l for some x iff \exists c2 s.t. 
     <F,H,c> - [o] ->* <F2,H2,c2> and o = Some(x) where, F=F' if len(l)=0. Assuming no errors.

     Proof: By induction on the length of the log in H.

       Base case: len(l) = 0
       We consider all possible functions that causes a change to either the augmented or real log
       if called between c' and c1' or c and c2.

       Subcase read n:

         If H(posix_fds)(n) = (p,i) for some p and i, and F(p) = File(w) then, by the definition of
         [[ read ]], o = Some(RF(p,w[i,i+1],i)).
         Given the same circumstances, lookup_logR n will return RUnknown. Thus, ([ read ]) will 
         call read n (returning byte w[i,i+1]), and then record Read(n,w[i,i+1],false), which adds 
         RF(p,w[i,i+1],i) to the log, as desired. Since those circumstances are required for there
         not to be an error, our property holds.         
       
       Subcase readdir n:

         If H(posix_fds)(n) = (p,i) for some p and i, and F(p) = Dir(l) then, by the definition of
         [[ readdir ]], o = Some(RD(p,l[i,i+1],i)).
         Given the same circumstances, lookup_logR n will return RUnknown. Thus, ([ readdir ]) will 
         call readdir n (returning entry l[i,i+1]), and then record Read(n,l[i,i+1],true), which adds 
         RD(p,l[i,i+1],i) to the log, as desired. Since those circumstances are required for there
         not to be an error, our property holds.

       Subcase write (n,w):

         If H(posix_fds)(n) = (p,i) for some p and i, and F(p) = File(w) or None then, by the definition
         of [[ write ]], o = Some(W(p,w,i)).
         ([ write ]) will call record Write(n,w), which adds W(p,w,i) to the log, as desired.
         Since those circumstances are required for there not to be an error, our property holds.

       Subcase remove p:

         If F(p) = File(_) or Dir([]) then, by the definition of [[ remove ]] o = Some(Rm(p)).
         Given the same circumstances, lookup_logE will return TUnknown (since the log is empty) so
         ([ remove ]) will call test p getting either 0 (if F(p) = File(_)) or 2 (if F(p) = Dir([]))
         back. Thus, it will call record Remove(p), which adds Rm(p) to the log as desired.

       Subcase test:

         In all cases, o = Some(Test(p)).
         ([ test ]) calls record Test(p), which will add Test(p) to the log.
     
       Since it holds for all subcases, it holds for the base case.

       Inductive case: We assume it holds for len(l) = n. Prove for len(l) = n + 1.
       Now, we no longer have that F = F', so we use part 1 to assert that the VFS correctly portrays
       the changed portion of the FS. 

       Subcase read m:

         If H(posix_fds)(m) = (p,i) for some p and i, and F(p) = File(w) then, by the definition of
         [[ read ]], o = Some(RF(p,w[i,i+1],i)).
         Given the same circumstances, lookup_logR may return either RUnknown or RKnown. 

         Subsubcase RUnknown: 
           If it returns RUnknown, then no changes have been made to path p, since by the inductive
           hypothesis, the log has so far been correctly built up and by part 1, the VFS is correctly
           extrapolated from there. So, F(p)=F'(p) and ([ read ]) adds RF(p,w[i,i+1],i) to the log
           correctly as in the base case.

         Subsubcase RKnown:
           If it instead returns RKnown, then by the inductive hypothesis and part 1,
           H1(logFS)(p)=Fi(w). Thus, ([ read ]) will read from the log, adding RF(p,w[i,i+1],i) to it
           as required.

         Notably, since we require that there wasn't an error, only those circumstances are allowable
         and lookup_logR can't return RPartial.

       Subcase readdir m:


         If H(posix_fds)(m) = (p,i) for some p and i, and F(p) = Dir(l) then, by the definition of
         [[ readdir ]], o = Some(RD(p,l[i,i+1],i)).
         Given the same circumstances, lookup_logR may return either RUnknown, RPartial or RKnown. 
         Subsubcase RUnknown:
           If it returns RUnknown, then no changes have been made to path p, since by the inductive
           hypothesis, the log has so far been correctly built up and by part 1, the VFS is correctly
           extrapolated from there. So, F(p)=F'(p) and ([ readdir ]) adds RD(p,l[i,i+1],i) to the log
           correctly as in the base case.
         
         Subsubcase RKnown:
           If it instead returns RKnown, then by the inductive hypothesis and part 1,
           H1(logFS)(p)=D(l,l',true). Thus, ([ readdir ]) will read from the log, adding RD(p,w[i,i+1],i)
           to it as required.

         Subsubcase RPartial:
           If it returns RPartial, then H1(logFS)(p)=D(l1,l1',false). By the inductive hypothesis
           and part 1, we know everything in l1 is in the directory F(p) and everything in l1'
           is not. Here, ([ readdir ]) actually reads an entry from F'(p), and passes it
           into the read_and_check helper routine. Notably, since F'(p) is not necessarily equal to
           F(p), we do not yet know that the read entry is l[i,i+1] (as in the uncompiled case).
           read_and_check checks what the correct entry to return is based on our extra knowledge,
           and correctly updates the file descriptor index for future reads, while keeping tabs of
	   the 'real' current index for logging. Thus, ([ readdir ]) adds RD(p,l[i,i+1],i) to the log 
	   as desired.

       Subcase write (n,w):

         If H(posix_fds)(n) = (p,i) for some p and i, and F(p) = File(w) or None then, by the definition
         of [[ write ]], o = Some(W(p,w,i)).
         ([ write ]) will call record Write(n,w), which adds W(p,w,i) to the log, as desired.
         Since those circumstances are required for there not to be an error, our property holds.

       Subcase remove p:

         If F(p) = File(_) or Dir([]) then, by the definition of [[ remove ]] o = Some(Rm(p)).
         Given the same circumstances, lookup_logE will return TUnknown,TFile,TDir(b), or TNone.
	 By the inductive hypothesis combined with part 1, we know that the VFS will correctly
	 describe the current state of the filesystem.
	 
	 Subsubcase TUnknown:
	   In this case, nothing has been changed on the path, thus it calls the test function and
	   correctly determines what is at the path since F'(p)=F(p). Since this is an empty
	   directory of a file, Rm(p) is correctly added to the log.

	 Subsubcase TFile:
	   In this case, the path contains a file in the VFS and thus in the parallel filesystem F,
	   so Rm(p) is added to the log.

	 Subsubcase TDir(true):
	   In this case, the path contains an empty directory in the VFS and thus in the parallel filesystem F,
	   so Rm(p) is added to the log.

	 Subsubcase TDir(false):
	   In this case, the path contains a non-empty directory in the VFS and thus in the parallel
	   filesystem F. So, remove fails (in both cases), which can't happen by our assumption.

	 Subsubcase TNone:
	   In this case, the path is empty in the VFS and thus in the parallel filesystem F. 
	   So, remove fails (in both cases), which can't happen by our assumption.

	 In all cases, the right thing is added.

       Subcase test:

         In all cases, o = Some(Test(p)).
         ([ test ]) calls record Test(p), which will add Test(p) to the log.
     
       Since it holds for all subcases, it holds for the inductive case and the base case,
       so we conclude that the hypothesis holds.

  3. Now that we know that the log is correct, we examine write_log to determine that it in
     fact does the right thing for the right log step. 

     Firstly, note that in the log the newest thing is first, so we want to do them in reverse order.
     Write_log reverses the list, then goes through it one at a time implementing the changes.
     
     We proceed by induction on possible log entries:

     Case Test(p):
       
       By the definition of writer in write_log, tests are simply discarded. Since they do
       not change the filesystem, by definition, this is fine.

     Case RF(p,c,n):
       
       By the definition of writer in write_log, reads are simply discarded. Since they do
       not change the filesystem, by definition, this is fine. 

     Case RD(p,w,n):
       
       By the definition of writer in write_log, reads are simply discarded. Since they do
       not change the filesystem, by definition, this is fine. 


     Case W(p,w,n):
       
       By the definition of writer in write_log, first 'open p' is called, then 'write (fd,w)'
       where fd is  the returned file descriptor, then 'close fd' is called.
       Notably, the open and close do not affect the filesystem, and effectively cancel
       each other out in terms of the heap.
       write(fd,w) correctly writes w to p. The n argument is ignored, since we have
       already assumed that the transactions only write full files.       

     Case Rm(p):
       
       By the definition of writer in write_log, 'remove p' is simply called, which
       will remove whatever is at p.

  So, by the analysis of ([ atomic c ]), we know only write_log changes the filesystem.
  Further, by parts 1,2, and 3 above, we know that the log is correctly written and that 
  write_log thus performs exactly the filesystem changing actions that c would have made.
  This finishes our proof of the Lemma.
