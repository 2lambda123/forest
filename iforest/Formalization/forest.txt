--------------------------------------------------------------------------------
Built-in POSIX functions and their semantics
--------------------------------------------------------------------------------

-- JDL: Add lookup_log + readl_og
-- JDL: Decide what error cases to add

-- Errs:
-- path must exist

[[ open ]] (F,H,p) = 
   let S = H(posix_fds) in 
   let n = gensym(S) in 
   let H' = H[posix_fds := S U { n |-> (p,0) }] in 
   (F,H',n)

[[ close ]] (F,H,n) =
   let S = H(posix_fds) in
   if n in dom(S) then 
      let H' = H \ n
      (F, H', 0)
   else
      (F,H,-1)

-- Errs:
-- n isn't open
-- p is not a file

[[ read ]] (F,H,n) =
   let (p,i) = H(posix_fds)(n) in
   let File(w) = F(p) in
   let c = w[i,i+1] in 
   let H' = H[posix_fds(n) :=  (p,i+1)] in 
   (F,H',c)

-- Errs:
-- n isn't open
-- p is not a file

[[ write ]] (F,H,(n,w)) =
   let (p,i) = H(posix_fds)(n) in
   let File(u) = F(p) in
   let F' = F[p := (u[i] := w)] in             -- JDL: Better way to write this?
   let H' = H[posix_fds(n) :=  (p,i + |w|)] in 
   (F',H',0)

-- Errs:
-- p doesn't exist
-- n < 0?

[[ truncate ]] (F,H,(p,n)) =
   let File(w) = F(p) in
   let F' = 
       if n=0 then          F[p := '']
       else if |w| > n then F[p := w[0:n-1]]
            else            F[p := w @ (0 X n-|w|)] -- JDL: n-|w| zeroes, fix?
   in
   (F',H,0)

[[ rename ]] (F,H,(p,p')) =
   if (F(p) = File(_) && F(p') = File(_)) ||
      (F(p) = Dir(_)  && F(p') = Dir([]))
   then
      let F' = F(p') := F(p) in
      let F' = F' \ p in
      (F',H,0)
   else
      (F,H,-1)

-- Errs:
-- n isn't open
-- p is not a directory

[[ readdir ]] (F,H, n) =
   let (p,i) = H(posix_fds)(n) in
   let Dir(l) = F(p) in
   let f = l[i,i+1] in 
   let H' = H[posix_fds(n) :=  (p,i+1)] in 
   (F,H',f)
   

-- Errs:
-- n isn't open

[[ lseek ]] (F,H,(n,m)) =
   let (p,_) = H(posix_fds)(n) in
   let H' = H[posix_fds(n) :=  (p,m)] in
   (F,H',0)

[[ remove ]] (F,H,p) =
   if F(p) = File(_) ||  F(p) = Dir([]) then
      let F' = F \ p in
      (F',H,0)
   else
      (F,H,-1)

-- Mostly added to be able to check the existence of a file
-- Errs:
-- p doesn't exist


[[ read ]] (F,H,n) =
   let (p,i) = H(posix_fds)(n) in
   let File(w) = F(p) in
   let c = w[i,i+1] in 
   let H' = H[posix_fds(n) :=  (p,i+1)] in 
   (F,H',c)

[[ test ]] (F,H,p) = 
   if F(p) = File(_)
   then (F,H,0)      
   else if (F(p) = Dir(_))
      then (F,H,1)
      else (F,H,-1)
   
-- Elided Stat and locks

--------------------------------------------------------------------------------
Built-in Helper functions and their semantics
--------------------------------------------------------------------------------

-- logList is the list of all commands that have been run (plus some extra info)
-- logFS is a portion of the FS built up from logList
-- H(logFS)(p) maps to an option

-- JDL: Strong (but probably true) assumptions made + problems o.w.:
-- Reads are always in a loop that reads the whole file/directory
-- * At the very least a hassle, don't remember exactly the necessity though
-- Writes are always the whole file, + a truncate at end
-- * How does an open work? Could be part virtual, how do we know?


-- Builds logFS
-- Depending on entry found (starting from beginning)
-- Reads:    RF(p,w)   makes p F(w)
-- ReadDirs: RD(p,l)   makes p D(l,true)
-- Writes:   W(p,w)    makes p F(w) and possibly adds p to p's directory
-- Renames:  Rn(p1,p2) makes p1 Rm and removes it from p1's directory
   	     	       and p2 what was at p1 (possibly adding p2 to p2's dir)
-- Removes:  Rm(p)     makes p Rm and removes it from p's dir
-- Truncate: T(p,n)    removes or extends F(w) at p, or makes p T(n)

let build_fs () =
    ...

-- Lookup log for opens
-- Do different things depending on type of File found
-- Files    (F)  Virtual open
-- Dirs	    (D)	 Virtual open
-- Removes  (Rm) Fail
-- Truncate (T)  Real open
-- None	    	 Real open

-- JDL: Make it correctly open a virtual fd (which we treat as realish)
-- let S = H(posix_fds) in 
-- let n = gensym(S) in 
-- let H' = H[posix_fds := S U { n |-> (p,0) }] in 

[[ lookup_logO ]] (F,H,p) = 
   let b = 
      match H(logFS)(p) with
      |	Some(Rm)	       -> -1
      |	Some(F(_))	       
      |	Some(D(_,true))	       -> 0
      |	Some(T(_))	       
      |	Some(D(_,false))       
      | None		       -> 1
   in
   let H' = if b
      then H
      else H[]
   in
   (F,H',b)

-- Lookup log for reads etc.
-- Do different things depending on type of file found
-- Files    (F)  always contain the byte
-- Dirs	    (D)	 always contain the byte, but may not know right byte
-- Removes  (Rm) doesn't exist so we're hosed (should be caught at open)
-- Truncate (T)  may know the byte (0 if it's beyond truncation)
-- None	    	 doesn't contain byte

[[ lookup_logR ]] (F,H,n) = 
   let (p,i) = H(posix_fds)(n) in
   let b = 
      match H(logFS)(p) with
      |	Some(Rm)	       -> failwith "Should never happen"
      |	Some(F(_))
      |	Some(D(_,true))
      |	Some(T(j)) when j <= i -> 1
      |	Some(T(_))	       
      |	Some(D(_,false))       
      | None		       -> 0
   in
   (F,H,b)

-- Lookup log for existence etc.
-- Do different things depending on type of file found
-- Files    (F)  exist
-- Dirs	    (D)	 exist, but may or may not be empty
-- Removes  (Rm) truly don't exist
-- Truncate (T)  exist
-- None	    	 doesn't contain byte

-- Results:
-- 0 = File
-- 1 = Non-empty dir
-- 2 = Empty dir
-- -1 = File not in log
-- -2 = File definitely doesn't exist

[[ lookup_logE ]] (F,H,p) = 
   let b = 
      match H(logFS)(p) with
      |	Some(F(_))
      |	Some(T(_))                   ->  0
      |	Some(D(_,false))            
      |	Some(D(l,true)) when l <> [] ->  1
      |	Some(D(_))                   ->  2
      |	Some(Rm)	             -> -2
      | None		             -> -1
   in
   (F,H,b)

-- Do different things depending on type of file found
-- Files    (F)  always contain the byte
-- Dirs	    (D)	 always contain the byte, but may not know right byte
-- Removes  (Rm) doesn't exist so we're hosed (should be caught at open)
-- Truncate (T)  always contains the byte
-- None	    	 doesn't contain byte

[[ read_log ]] (F,H,n) = 
   let (p,i) = H(posix_fds)(n) in
   let H' = H[posix_fds(n) :=  (p,i+1)] in
   let c = 
      match H(logFS)(p) with
      |	Some(Rm)	       
      |	Some(T(j)) when j <= i -> ''
      |	Some(F(w)) 	       
      |	Some(D(w,true))	       -> w[i]
      |	Some(T(_))	       
      |	Some(D(_,false))       
      | None		       -> failwith "lookup_logR would've failed"
   in 
   (F,H',c)


-- JDL: Indexing the rstring by path might reduce assumptions somewhat

[[ record ]] (F,H,t) = 
   let rs = H(rstring) in
   let l  = H(log) in
   let H' =
      match t with
      | Read(fd,v,d) ->
      	 let (p,_) = H(posix_fds)(fd) in
      	 if v = '' then 
      	    let ele = if d then RD(p,rs) else RF(p,rs) in
      	    let H'' = H[log := ele :: l] in
	    	      H''[rstring := '']
      	 else         H  [rstring := rstring @ v]
      |	Write(fd,w)  ->  
      	 let (p,_) = H(posix_fds)(fd) in
	 H[log := W(p,w) :: l]
      |	Trunc(fd,len)  ->  
      	 let (p,_) = H(posix_fds)(fd) in
	 H[log := T(p,len) :: l]
      |	Rename(p,p')   -> H[log := Rn(p,p') :: l]
      | Remove(p)      -> H[log := Rm(p)    :: l]
   in 
   let _     = build_fs () in
   (F,H',0)

--------------------------------------------------------------------------------
Syntax
--------------------------------------------------------------------------------

(* Metavariable Conventions *)
n in Integer
p in Path
w in String
F in FileStore
 
(* Values *)
v ::= n
    | p
    | w
    | (v1,...,vn)
    | l

l ::= v :: l | []

(* Expressions *)
e ::= x
    | v
    | f(e)

(* Commands *)
c ::= skip
    | c1; c2
    | x := e
    | if e then c1 else c2
    | while e do c
    | atomic c

(* Heaps *)
H in Var |-> Value

(* Threads *)
t ::= <H,c>

M ::= {t1,...,tk}

--------------------------------------------------------------------------------
SEMANTICS
--------------------------------------------------------------------------------

(* Evaluation Contexts *)
E ::= . 
    | open(E) 
    | close(E)  
    | read(E)
    | write(E,e) 
    | write(v,E)

(* Expression evaluation: (F,H,e) -> (F',H',e') *)

H(x) = v
-------------- E-Var
(F,H,x) -> (F,H,v)

(F',H',v') = [[ f ]] (F,H,v)
------------------------ E-Call
(F,H,f(v)) -> (F',H',v')

(F,H,e) -> (F',H',e')
--------------------------- E-Context
(F,H,E[e]) -> (F',H',E[e'])

(* Command evaluation: (F,H,c) -> (F',H',c') *)

C ::= . 
     | x := C
     | if C then c1 else c2
     | while C do c
     | C ; c

t ::= e | c 

C[t] needs to be well-formed...

(F,H,t) -> (F',H',t')
--------------------------- C-Context
(F,H,C[t]) -> (F',H',C[t'])
     
-------------------------- C-SkipSeq
(F,H,skip;c2) -> (F,H,c2)

H' = H[x:=v]
-------------------------C-Assgn
(F,H,x:=v) -> (F,H',skip)

--------------------------------------C-IfFalse
(F,H,if 0 then c1 else c2) -> (F,H,c2)

n <> 0
--------------------------------------C-IfTrue
(F,H,if n then c1 else c2) -> (F,H,c1)


--------------------------------C-WhileFalse
(F,H,while 0 do c) -> (F,H,skip)

n <> 0
------------------------------------------C-WhileTrue
(F,H,while n do c) -> (F,H,c;while n do c)

--------------------------------------------------------------------------------
Concurrent Operational Semantics
--------------------------------------------------------------------------------

(F,H,c) -> (F',H',c')
----------------------------------------- M-step
(F,M U { <H,c> }) -> (F',M U { <H',c'> })

----------------------------------------- M-skip
(F,M U { <H,skip> }) -> (F,M)

(F,H,c) ->* (F',H',skip)
---------------------------------------------- M-atomic
(F,M U { <H,C[atomic c]> }) -> (F',M',C[skip])

--------------------------------------------------------------------------------
Optimistic Compilation
--------------------------------------------------------------------------------

(* ([ e ]) : Com * Exp *)

-- We assume that assignment grabs the third part
-- of the tuple returned instead of just assigning
-- to (_,_,r) because it looks cleaner.

([ open(e) ]) = 
   let c',e' = ([[e]]) in
   (c';
    b := lookup_logO(e');
    if b
    then b:= open(e')
    else skip,
    b)
   where b is a fresh variable

([ close(e) ]) = 
   let c',e' = ([[e]]) in 
   (c', close(e'))

([ test(e) ]) = 
   let c',e' = ([[e]]) in 
   (c', test(e'))

([ lseek(e,e') ]) =
   let c1, e1 = ([ e  ]) in
   let c2, e2 = ([ e' ]) in
   (c1;c2, lseek(e1,e2))

-- Both read and readdir rely on the fact that 
-- Haskell reads/writes an entire file at once

([ read(e) ]) = 
  let c',e' = ([ e ]) in 
  (c';
   if lookup_logR(e') then {
     r := read_log(e')
   } else { 
     r := read(e');
     _ := record(Read(e',r,false));
   }, 
   r)
   where r is a fresh variable

([ readdir(e) ]) =
  let c',e' = ([ e ]) in 
  (c';
   if lookup_logR(e') then {
     r := read_log(e')
   } else { 
     r := readdir(e');
     _ := record(Read(e',r,true));
   }, 
   r)
   where r is a fresh variable

([ write(e,e') ]) =
   let c1, e1 = ([ e  ]) in
   let c2, e2 = ([ e' ]) in
   (c1;c2; 
    r := record(Write(e1,e2)),
    r)
    where r is a fresh variable

-- For the next 3 we need to know that the file exists
-- whether virtually, or for real

-- If the file exists and is a normal file, then we truncate
-- o.w. we return -1 and do nothing

([ truncate(e,e') ]) =
   let c1, e1 = ([ e  ]) in
   let c2, e2 = ([ e' ]) in
   (c1;c2; 
    t := lookup_logE(e);
    if t = 0
    then r := record(Trunc(e1,e2))
    else 
       if t = -1 then {
         b := ([ test e1 ]);
         if b = 0
         then r := record(Trunc(e1,e2))
         else r := -1
       }
       else   r := -1,
    r)
    where r,b,t are fresh variables

-- If From exists:
-- * Normal file implies (To doesn't exist or is a normal file)
-- * Directory implies (To doesn't exist or is empty directory)
-- o.w. we return -1 and do nothing

([ rename(e,e') ]) =
   let c1, e1 = ([ e  ]) in
   let c2, e2 = ([ e' ]) in
   (c1;c2; 
    from := lookup_logE(e1);
    to := lookup_logE(e2);
    if from = -1
    then from := ([ test e1])
    else skip;
    if from := -1 || from := -2
    then r := -1
    else -- from exists
    {
       r := -1;
       if to = -1
       then
       { 
          b := 1;
          to := ([ test e1 ])
       }
       else b := 0;
       -- to doesn't exist?
       if to = -1
       then r := record(Rename(e1,e2))
       else skip;
       -- Both files?
       if from = 0 && to = 0
       then r := record(Rename(e1,e2))
       else skip;
       -- Both folders and to is empty?
       if (from = 1 || from = 2) && to = 2
       then r := record(Rename(e1,e2))
       else skip;
       -- Both folders, but we don't know if to is empty?
       if (from = 1 || from = 2) && to = 1 && b
       then
       {
          b := ([ n := open(e2); readdir(n) ]);
          if b = ''
          then r := record(Rename(e1,e2))
          else skip
       }
       else skip
    },
    r)
    where r,b,from,to are fresh variables

-- If file is a directory and is empty
-- or if file is not a directory, but exists
-- we remove it, o.w. we return -1 and do nothing

([ remove(e) ]) =
   let c', e' = ([ e  ]) in
   (c; 
    t := lookup_logE(e);
    if t = 0 || t = 2
    then r := record(Remove(e'))
    else 
       if t = -1 then {
         b := ([ test e1 ]);
         if b = -1
         then r := -1
         else if b = 0 
            then r := record(Remove(e'))
            else {
               b := ([ n := open(e'); readdir(n) ]);
               if b = ''
               then r := record(Remove(e'))
               else r := -1
            }
       }
       else   r := -1,
    r)
    where r,b,t,n are fresh variables
   
(* ([ c ]) : Com \ {atomic c} *)

([ skip ]) = skip

([ x := e ]) = 
   let c',e' = ([ e ]) in 
   c'; x := e'

([ c1; c2 ]) = ([ c1 ]); ([ c2 ])

([ if e then c1 else c2 ]) = 
   let c',e' = ([ e ]) in 
   c'; if e' then ([ c1 ]) else ([ c2 ])

([ while e do c ]) = 
   let c',e' = ([ e ]) in 
   c'; while e' do ([ c ])

-- Currently using a global log lock, may swtich to fancy data structure

([ atomic c ]) = 
   f := 1;
   while f do {
     log := [];
     ([ c ]);
     lock();
     f := check_error();
     if not f then write_log(log) else skip;     	
     unlock()
   }
