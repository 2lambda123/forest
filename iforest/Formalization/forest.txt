--------------------------------------------------------------------------------
Built-in POSIX functions and their semantics
--------------------------------------------------------------------------------

-- JDL: Decide what error cases to add

-- Errs:
-- path must exist

[[ open ]] (F,H,p) = 
   let S = H(posix_fds) in 
   let n = gensym(S) in 
   let H' = H[posix_fds := S U { n |-> (p,0) }] in 
   (F,H',n)

[[ close ]] (F,H,n) =
   let S = H(posix_fds) in
   if n in dom(S) then 
      let H' = H \ n
      (F, H', 0)
   else
      (F,H,-1)

-- Errs:
-- n isn't open
-- p is not a file

[[ read ]] (F,H,n) =
   let (p,i) = H(posix_fds)(n) in
   let File(w) = F(p) in
   let c = w[i,i+1] in 
   let H' = H[posix_fds(n) :=  (p,i+1)] in 
   (F,H',c)

-- Errs:
-- n isn't open
-- p is not a file

[[ write ]] (F,H,(n,w)) =
   let (p,i) = H(posix_fds)(n) in
   let File(u) = F(p) in
   let F' = F[p := (u[i] := w)] in             -- JDL: Better way to write this?
   let H' = H[posix_fds(n) :=  (p,i + |w|)] in 
   (F',H',0)

-- Errs:
-- p doesn't exist
-- n < 0?

[[ truncate ]] (F,H,(p,n)) =
   let File(w) = F(p) in
   let F' = 
       if n=0 then          F[p := '']
       else if |w| > n then F[p := w[0:n-1]]
            else            F[p := w @ (0 X n-|w|)] -- JDL: n-|w| zeroes, fix?
   in
   (F',H,0)

[[ rename ]] (F,H,(p,p')) =
   if (F(p) = File(_) && F(p') = File(_)) ||
      (F(p) = Dir(_)  && F(p') = Dir([]))
   then
      let F' = F(p') := F(p) in
      let F' = F' \ p in
      (F',H,0)
   else
      (F,H,-1)

-- Errs:
-- n isn't open
-- p is not a directory

[[ readdir ]] (F,H, n) =
   let (p,i) = H(posix_fds)(n) in
   let Dir(l) = F(p) in
   let f = l[i,i+1] in 
   let H' = H[posix_fds(n) :=  (p,i+1)] in 
   (F,H',f)
   

-- Errs:
-- n isn't open

[[ lseek ]] (F,H,(n,m)) =
   let (p,_) = H(posix_fds)(n) in
   let H' = H[posix_fds(n) :=  (p,m)] in
   (F,H',0)

[[ remove ]] (F,H,p) =
   if F(p) = File(_) ||  F(p) = Dir([]) then
      let F' = F \ p in
      (F',H,0)
   else
      (F,H,-1)

-- Mostly added to be able to check the existence of a file
-- Errs:
-- p doesn't exist


[[ read ]] (F,H,n) =
   let (p,i) = H(posix_fds)(n) in
   let File(w) = F(p) in
   let c = w[i,i+1] in 
   let H' = H[posix_fds(n) :=  (p,i+1)] in 
   (F,H',c)

[[ test ]] (F,H,p) = 
   if F(p) = File(_)
   then (F,H,0)      
   else if (F(p) = Dir(_))
      then (F,H,1)
      else (F,H,-1)
   
-- Elided Stat and locks

--------------------------------------------------------------------------------
Built-in Helper functions and their semantics
--------------------------------------------------------------------------------

-- log is (roughly) the list of all commands that have been run
-- logFS is a portion of the FS built up from log
-- H(logFS)(p) maps to an option

-- JDL: Strong (but probably true) assumptions made + problems o.w.:
-- Reads are always in a loop that reads the whole file/directory
-- * At the very least a hassle, don't remember exactly the necessity though
-- Writes are always the whole file, + a truncate at end
-- * How does an open work? Could be part virtual, how do we know?


-- Builds logFS
-- Depending on entry found (starting from beginning)
-- Reads:    RF(p,w)   makes p F(w)
-- ReadDirs: RD(p,l)   makes p D(l,true) (barring previous modifications)
-- Writes:   W(p,w)    makes p F(w) and possibly adds p to p's directory
-- Renames:  Rn(p1,p2) makes p1 Rm and removes it from p1's directory
                       and p2 what was at p1 (possibly adding p2 to p2's dir)
                   Or if there was nothing, then Rn(p1)
-- Removes:  Rm(p)     makes p Rm and removes it from p's dir
-- Truncate: T(p,n)    removes or extends F(w) at p, or makes p T(n)


let get_fd n =
   match H(virtual_fds)(n) with
   | Some(x) -> x
   | None    -> H(posix_fds)(n)

let build_fs () =
   let l = rev H(log) in
   let rec helper lst map =
   match lst with
      | hd :: tl ->
         helper tl
         (match hd with
         | RF(p,w)  -> add p F(w) map
         | T(p,n)   -> 
            match map(p) with
            | None       -> add p T(n) map
            | Some(F(w)) -> 
               if n < len(w) 
               then add p F(sub w 0 n) map
               else add p F(fill w len(w) (n-len(w)) '0') map
            | Some(Rn(p,_)) -> 
               if n < len(w) 
               then add p F(sub w 0 n) map
               else add p F(fill w len(w) (n-len(w)) '0') map
            | _          -> failwith "Truncate should've failed"
         | W(p,w)   ->
            match map(dir(p)) with
            | None         -> add dir(p) (makeDir hd) (add p F(w) map)
            | Some(D(l,b)) -> add dir(p) (addDir hd D(l,b)) (add p F(w) map)
            | _            -> failwith "Path directory isn't a directory?"
         | Rn(p,p') -> 
            let map' =
               match map(dir(p)) with
               | None         -> add dir(p) (makeDir Rm(p)) (add p Rm map)
               | Some(D(l,b)) -> add dir(p) (addDir Rm(p) D(l,b)) (add p Rm map)
               | _            -> failwith "Path directory isn't a directory?"
            in
            match map'(p),map'(dir(p')) with
            | None   , None                                          -> 
               add dir(p') (makeDir hd) (add p' Rn(p,0) map')
            | Some(Rn(p'',0), None when p'' = p'                     -> 
               add dir(p') (makeDir hd) (remove p' map')
            | Some(Rn(p'',n), None when p'' = p'                     -> 
               add dir(p') (makeDir hd) (add p' T(n) map')
            | Some(x), None                                          -> 
               add dir(p') (makeDir hd) (add p' x map')
            | None   , Some(D(l,b))                                  -> 
               add dir(p') (addDir hd D(l,b)) (add p' Rn(p,0) map')
            | Some(Rn(p'',0), Some(D(l,b)) when p'' = p'             -> 
               add dir(p') (addDir hd D(l,b)) (remove p' map')
            | Some(Rn(p'',n), Some(D(l,b)) when p'' = p'             -> 
               add dir(p') (addDir hd D(l,b)) (add p' T(n) map')
            | Some(x), Some(D(l,b))                                  -> 
               add dir(p') (addDir hd D(l,b)) (add p' x map')
            | _ -> failwith "Path directory isn't a directory?"
         | Rm(p)    -> 
            match map(dir(p)) with
            | None         -> add dir(p) (makeDir hd) (add p Rm map)
            | Some(D(l,b)) -> add dir(p) (addDir hd D(l,b)) (add p Rm map)
            | _            -> failwith "Path directory isn't a directory?"
         | RD(p,l)  -> add p 
            match map(p) with
            | None          -> add p D(l,true) map
            | Some(D(l',b)) -> add p (mergeDirs D(l',b) D(l,true)) map
            | _             -> failwith "Path directory isn't a directory?"
         )
      | [] -> map
   in 
   let H' = H[logFS := helper l empty] in
   (F,H',())
   

-- Lookup log for opens
-- Do different things depending on type of File found
-- Files    (F)  Virtual open
-- Dirs    (D)  Virtual open
-- Removes  (Rm) Fail
-- Truncate (T)  Real open
-- Rn       (p)  Rerun operation, but for p
-- None           Real open

-- JDL: Make it correctly open a virtual fd (which we treat as realish)
-- let S = H(posix_fds) in 
-- let n = gensym(S) in 
-- let H' = H[posix_fds := S U { n |-> (p,0) }] in 

[[ lookup_logO ]] (F,H,p) = 
   let b = 
      match H(logFS)(p) with
      | Some(Rm)         -> -1
      | Some(F(_))             
      | Some(D(_,true))  -> 0
      | Some(T(_))              
      | Some(D(_,false))      
      | None             -> 1
      | Some(Rn(_))      -> 5
   in
   if b
   then (F,H,b)
   else 
      let S = H(posix_fds) in    
      let n = gensym(S) in 
      let H' = H[posix_fds := S U { n |-> (p,0) }] in 
      (F,H',n)

-- Lookup log for reads etc.
-- Do different things depending on type of file found
-- Files    (F)  always contain the byte
-- Dirs     (D)  always contain the byte, but may not know right byte
-- Removes  (Rm) doesn't exist so we're hosed (should be caught at open)
-- Truncate (T)  may know the byte (0 if it's beyond truncation)
-- Rn       (p)  Rerun operation, but for p
-- None          doesn't contain byte

[[ lookup_logR ]] (F,H,n) = 
   let (p,i) = get_fd(n) in
   let b = 
      match H(logFS)(p) with
      | Some(Rm)                        -> failwith "Should never happen"
      | Some(F(_))
      | Some(D(_,true))
      | Some(Rn(_,j)) when j <= i           
      | Some(T(j)) when j <= i    -> 1
      | Some(T(_))             
      | Some(D(_,false))       
      | Some(Rn(_))            
      | None                            -> 0
   in
   (F,H,b)

-- Lookup log for existence etc.
-- Do different things depending on type of file found
-- Files    (F)  exist
-- Dirs     (D)  exist, but may or may not be empty
-- Removes  (Rm) truly don't exist
-- Truncate (T)  exist
-- None          doesn't contain byte

-- Results:
-- 0 = File
-- 1 = Non-empty dir
-- 2 = Empty dir
-- -1 = File not in log
-- -2 = File definitely doesn't exist

[[ lookup_logE ]] (F,H,p) = 
   let b = 
      match H(logFS)(p) with
      | Some(F(_))
      | Some(Rn(_))                  
      | Some(T(_))                   ->  0
      | Some(D(_,false))            
      | Some(D(l,true)) when l <> [] ->  1
      | Some(D(_))                   ->  2
      | Some(Rm)                           -> -2
      | None                               -> -1
   in
   (F,H,b)

-- Do different things depending on type of file found
-- Files    (F)  always contain the byte
-- Dirs    (D)  always contain the byte, but may not know right byte
-- Removes  (Rm) doesn't exist so we're hosed (should be caught at open)
-- Truncate (T)  always contains the byte
-- None           doesn't contain byte

-- Gets real path where the file in p is stored

[[ get_rn ]] (F,H,p) =
   match H(logFS)(p) with
   | Some(Rn(np,_)) -> (F,H,np)  
   | _            -> failwith "Expected Rn"
   
-- In the case of a rename, the fd path is not
-- the path that we want to store it to.
   
[[ link_fd ]] (F,H,(n,p)) =
   let S  = H(virtual_fds) in
   let H' = H[virtual_fds := S U { n |-> (p,0)}] in
   (F,H',())
   
[[ close_fd ]] (F,H,n) =
   match H(virtual_fds)(n) with
   | Some(_) -> (F,H \ n, ())
   | None    -> (F,H,())

[[ read_log ]] (F,H,n) = 
   let (p,i,H') = 
      match H(virtual_fds)(n) with
      | Some(p,i) -> (p,i,H[virtual_fds(n) := (p,i+1)])
      | None -> let (p,i) = H(posix_fds)(n) in
         (p,i,H[posix_fds(n) :=  (p,i+1)])
   in
   let c = 
      match H(logFS)(p) with
      | Some(Rm)               
      | Some(T(j)) when j <= i
      | Some(Rn(_,j)) when j <= i -> ''
      | Some(F(w))             
      | Some(D(w,true))           -> w[i]
      | Some(T(_))             
      | Some(D(_,false))       
      | Some(Rn(_))            
      | None                            -> failwith "lookup_logR would've failed"
   in 
   (F,H',c)

[[ record ]] (F,H,t) = 
   let rs = H(rstring) in
   let l  = H(log) in
   let H' =
      match t with
      | Read(fd,v,d)   ->
        let (p,_) = get_fd n in
        if v = '' then 
           let ele = if d then RD(p,rs) else RF(p,rs) in
           let H'' = H[log := ele :: l] in
                       H''[rstring := '']
        else   H  [rstring := rstring @ v]
      | Write(fd,w)    ->  
         let (p,_) = get_fd n in
         H[log := W(p,w) :: l]
      | Trunc(fd,len)  ->  
         let (p,_) = get_fd n in
         H[log := T(p,len) :: l]
      | Rename(p,p')   -> H[log := Rn(p,p') :: l]
      | Remove(p)      -> H[log := Rm(p)    :: l]
   in 
   let _     = build_fs () in
   (F,H',0)
   
-- In atomic translation

-- H(transState) starts out as [(0,[],0)]
-- H(log) starts out as []

[[ trans_start ]] (F,H,()) =
   let tstate = H(transState) in
   let n,_,_ = hd(tstate) in
   let H'  = H [trans := ((n+1),H(log),time()) :: tstack] in
   let H'' = H'[log := []] in
   (F,H'',n)

-- We need a global log of (time, path) pairs
-- We'll just use some reserved name in the FileStore for now,
-- but could easily be added in a shared memory structure (which is what it is)
   
[[ check_error ]] (F,H,()) =
   let tstate = H(transState) in
   let n,tlog,t = hd(tstate) in
   let glog = 
      fold (fun acc (t',p) -> if t > t' then p :: acc else acc) F(glog)
   in
   let rec err_help l =
      match l with
      | hd :: tl ->
         match hd with
         | RD(p,_) 
         | RF(p,_) 
         | Rn(p,_) -> if exists (= p) glog then 1 else err_help tl
         | _       -> err_help tl
      | [] -> 0
   in
   let l = H(log) in
   let b = err_help l in
   if b then
      let H'  = H[log := tlog] in
      let H'' = H[transState := tl(tstate)] in
      (F,H'',b)
   else (F,H,b)
   
-- Either use the FS, allowing for fewer operations
-- or just do all the operations of the log.
-- Starting with log because it's more obviously correct

-- If we're here, then we've passed the check_error, so depending
-- on if n > 1 or not, we append log or do FS writes

-- JDL: Maybe add in error checking?

[[ write_log ]] (F,H,()) =
   let t = time() in
   let tstate = H(transState) in
   let n,tlog,_ = hd(tstate) in
   let rec writer l acc =
      let F',H',lst = acc in
      match l with
      | hd :: tl ->
         match hd with
         | W(p,w)   -> 
            let F',H',fd = open (F',H',p) in
            let F',H',_  = write(F',H',(fd,w)) in
            let F',H',_  = close(F',H',fd) in
            writer tl (F',H',(t,p) :: lst)
         | Rm(p)    ->
            let F',H',_  = remove(F',H',p) in
            writer tl (F',H',(t,p) :: lst)
         | T(p,n)   ->
            let F',H',_  = truncate(F',H',(p,n)) in
            writer tl (F',H',(t,p) :: lst)
         | Rn(p,p') -> 
            let F',H',_  = rename(F',H',(p,p')) in
            writer tl (F',H',(t,p) :: (t,p') :: lst)
         | _        -> writer tl acc
      | [] -> acc
   in
   let l = H(log) in
   if n > 1 then
      let H'  = H[log := H(log) @ tlog] in
      let H'' = H[transState := tl(tstate)] in
      (F,H'',())
   else
      let (F',H',l) = writer (rev H(log)) (F,H,[]) in
      let H''       = H'[transState := tl(tstate)] in
      (F',H'',())


--------------------------------------------------------------------------------
Syntax
--------------------------------------------------------------------------------

(* Metavariable Conventions *)
n in Integer
p in Path
w in String
F in FileStore
 
(* Values *)
v ::= n
    | p
    | w
    | (v1,...,vn)
    | l

l ::= v :: l | []

(* Expressions *)
e ::= x
    | v
    | f(e)

(* Commands *)
c ::= skip
    | c1; c2
    | x := e
    | if e then c1 else c2
    | while e do c
    | atomic c

(* Heaps *)
H in Var |-> Value

(* Threads *)
t ::= <H,c>

M ::= {t1,...,tk}

--------------------------------------------------------------------------------
SEMANTICS
--------------------------------------------------------------------------------

(* Evaluation Contexts *)
E ::= . 
    | open(E) 
    | close(E)  
    | read(E)
    | write(E,e) 
    | write(v,E)

(* Expression evaluation: (F,H,e) -> (F',H',e') *)

H(x) = v
-------------- E-Var
(F,H,x) -> (F,H,v)

(F',H',v') = [[ f ]] (F,H,v)
------------------------ E-Call
(F,H,f(v)) -> (F',H',v')

(F,H,e) -> (F',H',e')
--------------------------- E-Context
(F,H,E[e]) -> (F',H',E[e'])

(* Command evaluation: (F,H,c) -> (F',H',c') *)

C ::= . 
     | x := C
     | if C then c1 else c2
     | while C do c
     | C ; c

t ::= e | c 

C[t] needs to be well-formed...

(F,H,t) -> (F',H',t')
--------------------------- C-Context
(F,H,C[t]) -> (F',H',C[t'])
     
-------------------------- C-SkipSeq
(F,H,skip;c2) -> (F,H,c2)

H' = H[x:=v]
-------------------------C-Assgn
(F,H,x:=v) -> (F,H',skip)

--------------------------------------C-IfFalse
(F,H,if 0 then c1 else c2) -> (F,H,c2)

n <> 0
--------------------------------------C-IfTrue
(F,H,if n then c1 else c2) -> (F,H,c1)


--------------------------------C-WhileFalse
(F,H,while 0 do c) -> (F,H,skip)

n <> 0
------------------------------------------C-WhileTrue
(F,H,while n do c) -> (F,H,c;while n do c)

--------------------------------------------------------------------------------
Concurrent Operational Semantics
--------------------------------------------------------------------------------

(F,H,c) -> (F',H',c')
----------------------------------------- M-step
(F,M U { <H,c> }) -> (F',M U { <H',c'> })

----------------------------------------- M-skip
(F,M U { <H,skip> }) -> (F,M)

(F,H,c) ->* (F',H',skip)
---------------------------------------------- M-atomic
(F,M U { <H,C[atomic c]> }) -> (F',M',C[skip])

--------------------------------------------------------------------------------
Optimistic Compilation
--------------------------------------------------------------------------------

(* ([ e ]) : Com * Exp *)

-- We assume that assignment grabs the third part
-- of the tuple returned instead of just assigning
-- to (_,_,r) because it looks cleaner.

([ open(e) ]) = 
   let c',e' = ([[e]]) in
   (c';
    b := lookup_logO(e');
    if b = 5
    then {
      p := get_rn(e');
      b := open(p);
      _ := link_fd(b,e')
    }
    else if b
    then b:= open(e')
    else skip,
    b)
   where b,p are fresh variables

([ close(e) ]) = 
   let c',e' = ([[e]]) in 
   (c'; _ := close_fd(e'), close(e'))

([ test(e) ]) = 
   let c',e' = ([[e]]) in 
   (c', test(e'))

([ lseek(e,e') ]) =
   let c1, e1 = ([ e  ]) in
   let c2, e2 = ([ e' ]) in
   (c1;c2, lseek(e1,e2))

-- Both read and readdir rely on the fact that 
-- Haskell reads/writes an entire file at once

([ read(e) ]) = 
  let c',e' = ([ e ]) in 
  (c';
   if lookup_logR(e')
   then r := read_log(e')
   else { 
      r := read(e');
      _ := record(Read(e',r,false));
   }, 
   r)
   where r is a fresh variable

([ readdir(e) ]) =
  let c',e' = ([ e ]) in 
  (c';
   if lookup_logR(e')
   then r := read_log(e')
   else { 
     r := readdir(e');
     _ := record(Read(e',r,true));
   }, 
   r)
   where r is a fresh variable

([ write(e,e') ]) =
   let c1, e1 = ([ e  ]) in
   let c2, e2 = ([ e' ]) in
   (c1;c2; 
    r := record(Write(e1,e2)),
    r)
    where r is a fresh variable

-- For the next 3 we need to know that the file exists
-- whether virtually, or for real

-- If the file exists and is a normal file, then we truncate
-- o.w. we return -1 and do nothing

([ truncate(e,e') ]) =
   let c1, e1 = ([ e  ]) in
   let c2, e2 = ([ e' ]) in
   (c1;c2; 
    t := lookup_logE(e);
    if t = 0
    then r := record(Trunc(e1,e2))
    else 
       if t = -1 then {
         b := ([ test e1 ]);
         if b = 0
         then r := record(Trunc(e1,e2))
         else r := -1
       }
       else   r := -1,
    r)
    where r,b,t are fresh variables

-- If From exists:
-- * Normal file implies (To doesn't exist or is a normal file)
-- * Directory implies (To doesn't exist or is empty directory)
-- o.w. we return -1 and do nothing

([ rename(e,e') ]) =
   let c1, e1 = ([ e  ]) in
   let c2, e2 = ([ e' ]) in
   (c1;c2; 
    from := lookup_logE(e1);
    to := lookup_logE(e2);
    if from = -1
    then from := ([ test e1])
    else skip;
    if from := -1 || from := -2
    then r := -1
    else -- from exists
    {
       r := -1;
       if to = -1
       then
       { 
          b := 1;
          to := ([ test e1 ])
       }
       else b := 0;
       -- to doesn't exist?
       if to = -1
       then r := record(Rename(e1,e2))
       else skip;
       -- Both files?
       if from = 0 && to = 0
       then r := record(Rename(e1,e2))
       else skip;
       -- Both folders and to is empty?
       if (from = 1 || from = 2) && to = 2
       then r := record(Rename(e1,e2))
       else skip;
       -- Both folders, but we don't know if to is empty?
       if (from = 1 || from = 2) && to = 1 && b
       then
       {
          b := ([ n := open(e2); readdir(n) ]);
          if b = ''
          then r := record(Rename(e1,e2))
          else skip
       }
       else skip
    },
    r)
    where r,b,from,to are fresh variables

-- If file is a directory and is empty
-- or if file is not a directory, but exists
-- we remove it, o.w. we return -1 and do nothing

([ remove(e) ]) =
   let c', e' = ([ e  ]) in
   (c; 
    t := lookup_logE(e);
    if t = 0 || t = 2
    then r := record(Remove(e'))
    else 
       if t = -1 then {
         b := ([ test e1 ]);
         if b = -1
         then r := -1
         else if b = 0 
            then r := record(Remove(e'))
            else {
               b := ([ n := open(e'); readdir(n) ]);
               if b = ''
               then r := record(Remove(e'))
               else r := -1
            }
       }
       else   r := -1,
    r)
    where r,b,t,n are fresh variables
   
(* ([ c ]) : Com \ {atomic c} *)

([ skip ]) = skip

([ x := e ]) = 
   let c',e' = ([ e ]) in 
   c'; x := e'

([ c1; c2 ]) = ([ c1 ]); ([ c2 ])

([ if e then c1 else c2 ]) = 
   let c',e' = ([ e ]) in 
   c'; if e' then ([ c1 ]) else ([ c2 ])

([ while e do c ]) = 
   let c',e' = ([ e ]) in 
   c'; while e' do ([ c ])

-- Currently using a global log lock, may switch to fancy data structure

([ atomic c ]) = 
   f := 1;
   while f do {
     l := trans_start();
     ([ c ]);
     if l then skip else lock();
     f := check_error();
     if not f then write_log() else skip;       
     if l then skip else unlock()
   }
   where l is fresh.

--------------------------------------------------------------------------------
Theorems
--------------------------------------------------------------------------------

-- Problems: We don't really have serializability, because H can change and if
-- the transaction does different things depending on H and restarts, then...
-- That said, this is probably what we want. Not sure what a good way of
-- phrasing serializability modulo H is.
-- That said, we can solve this by pushing H to the stack for the time being

-- For all compilations of the form ([ atomic(c) ]):
-- We require reads in c to be in a while loop, reading until EOF.
-- We require writes of string s to path p in c to be from position 0 in the fd
-- and to be followed by a truncate(p,|s|).

Given some starting filesystem F, executing ([ atomic(c) ]) || ([ atomic(d) ])
will generate a filesystem F', s.t. there exists a serializable order,
c;d or d;c where such that starting from filesystem F and executing one of the
two will also generate F' as long as atomic(e) is not a sub-command of c or d.

Proof of theorem:
Assume not. Then c = c_1;...;c_n and d=d_1;...;d_m and there is some
interleaving of them which creates F' (since by lemma 2, o.w. c;d or d;c would
generate F').
Consider the cases where c and d do not overlap (in the files they read/modify)
(I), where c modifies files read by d (II), where d modifies files read by c 
(II by symmetry), and where they both modify files read by each other (III).

(I)   : If they don't overlap, then any interleaving is equivalent to c;d
(II)  : If any modifications of files that d reads occurs after d has completed,
        then this is clearly equivalent to d;c.
        O.w., since all modifications to the filesystem happen in write_log,
        by Lemma 1, ([ atomic(c) ]) must have gotten the lock before
        ([ atomic(d) ]). Then, when it releases the lock and d does a 
        check_error, it will detect that c has run, thus restarting, which
        means that we have c;d.
(III) : Either c or d will acquire the lock first. By Lemma 1, we know that
        neither will change the FS before then. Assume WLOG that c gets it.
        Then, c can't be in conflict with anything (because the FS hasn't
        been changed) and thus commits his changes in write_log before
        releasing the lock. Then, since d read files modified by c,
        he will restart the transaction, thus resulting in c;d.
        
Since in all cases, we get either c;d or d;c, the theorem holds.

Lemma 1: Does not exist a c (except atomic) s.t. (F,H,([ c ])) ->* (F',H',_)
         and F <> F'.
Proof: By induction on the compilation of expressions, commands, and the rules
       of the functions and commands they compile to:
       - All commands just compile to themselves, with subcommands and
         expressions compiled.
       - The small step operational semantics governing commands clearly
         show that they do not change the filesystem (barring the context
         ones). Only function calls change the filesystem.
       - By inspection, expressions compile into one of the various commands,
         themselves, and/or possibly a variety of function calls
         (exhaustively named below):
         - open
         - close
         - test
         - lseek
         - read
         - readdir
         - lookup_logO
         - lookup_logR
         - lookup_logE
         - read_log
         - record
       - Notably, the set of function calls above is disjoint from the
         set of function calls that modify the filesystem (listed below)
         as seen in the function semantics:
         - write
         - truncate
         - rename
         - remove
         - write_log
       Thus, since none of the possible functions that modify the filesystem
       are invoked, the filesystem clearly doesn't change.
       

Lemma 2: Given some starting filesystem F and sequence of commands c, if
         running c generates F', then so does running ([ atomic(c) ]).
Proof: The compilation of c logs exactly what it does that changes
       the filesystem (only writes, renames, removes, and truncates) by the
       definition of the record function.
       Then these operations are carried out in the same order with the same 
       arguments they would have had (given that nothing else is changing
       the filesystem and they don't by lemma 1).
         
