Latest Compiler TODO
--------------------
* generated copy functions for non-static types should do a cleanup of
  the target before doing the actual copy work.  Otherwise allocated
  space will never get cleanup up.  This is not right: strings and
  arrays re-use an existing rbuf.  The issue has to do with union
  types, where it is important to cleanup before doing the copy.
  Actually if all of the arms have the SAME type, then there is no
  need to do a cleanup.  Or even better: if TYPEOF(src->tag) == TYPEOF(targ->tag)
  then there is no reason to do a cleanup.  Hard for the compiler to
  generate this test?

* omitted fields for non-static types: currently we generate init calls,
  but no cleanup calls.  This means if the space is grown during read,
  it is not cleaned up before the temporaries pop off the stack.
  In C++ this would be easy to fix (destructor called on stack pop).
  For C code we will need to have
  a 'goto cleanup_and_return' everywhere and at that target we will
  do the cleanups and then the standard return (pd->nerr) ? P_ERR : P_OK.

Misc Bob (PADS library) TODO
----------------------------
* IO position macros: start using them everywhere?

TO DISCUSS (NO DECISION YET)
-----------------------------
* nerr/neerr for all structured types
  => in this case, nerr would always be 0 or 1, so it could become a flag in psate if we want

* Penum right now supports only one 'in stream' type, ASCII string.
  We might want to support others: any type where you can express constants could
  be used.  Penum could be a type template, as in

// the current Penum would become something like this:

Penum<Pa_string> my_enum1 {
  foo,
  bar = 7,
  Sfor Pfrom("for")
};

Penum<Psbh(:4:)> my_enum2 {
  foo Pfrom(0),
  bar Pfrom(7) = 7,
  Sfor Pfrom(8)
};

For all types except string types, you always need to specify the Pfrom, so maybe
we need another syntax, perhaps

  on-disk-val [: enum_tag] [= in-memory-enum-val]

Penum<Pa_string> my_enum1 {
  foo,
  bar = 7,
  "for" : Sfor
};

Penum<Psbh(:4:)> my_enum2 {
  4   : foo,      /* in memory enum val == 0 */
  10  : bar = 7   /* in memory enum val == 7 */
};


soon
----
 * add instructions in README for how to obtain SML
   which is required for padsc compiler

by end of Aug
-------------
 * manual

 * skipped fields should have their error fields set.

 * Pcompute fields should have associated mask

 * should pd of Punion use union or struct
      struct allows you to find out why all of the arms failed
      but has higher space overhead

 * for Penum, if you have something like this:

Penum CMDLINE_discipline {
  fwrec,
  ctrec,
  nlrec,
  vlrec,
  fwrec_noseek,
  ctrec_noseek,
  nlrec_noseek,
  vlrec_noseek
};

Then the _noseek cases are never matched.
For now, the compiler should issue a warning for each 'shadowed' enum val.
Longer term, we should build a little DFA that does matching, rather
than using strlit_read for each string, and we should allow
the above. 

Note that if the enum values for the above are the desired ones, then the
rewrite would have to do:

Penum CMDLINE_discipline {
  fwrec_noseek = 4,
  ctrec_noseek = 5,
  nlrec_noseek = 6,
  vlrec_noseek = 7,
  fwrec = 0,
  ctrec = 1,
  nlrec = 2,
  vlrec = 3
};

 * Add base types whose in-memory rep is either PDC_float32 or PDC_float64

       Pfloat32, Pa_float32, Pe_float32, Pfloat64, Pa_float64, Pe_float64
       Pb_float32, Pb_float64
       Psbl_float32, Psbl_float64
       Psbh_float32, Psbh_float64

 * Change the way we do file locations
      1. get rid of descriptive string in each pos

      2. each pos has three size_t (x,y,z) interpreted by io_disc, e.g.,
         an io discipline might know that:
              record in stream        = x
              offset in record data   = y
              raw offset in record    = z
         whereas for another io_disc x,y,z could have very different meaning.
         There must be a function to get the io_disc to describe the pos.
         There should probably also be a function that gets the io_disc to
         describe a loc, rather than having PDCI_report_err try to do it???

      3. A pos also has an raw_off field that is the the raw offset
         from the start of the IO stream.

         If pos1.raw_off == pos2.raw_off, you can assume that
         pos1.x == pos2.x, pos1.y == pos2.y, pos1.z == pos2.z
         (thus raw_off gives the fastest equality check).

      4. Each pos also has an 'after' flag which is normally 0... normally
         the pos describes the location just before the specified byte,
         but if after is 1 it describes the location just after the
         specified byte.

      5. Locations should be well formed, and loc's that we generate are
         guaranteed to be well formed.  This means:
              a. loc.b.raw_off <= loc.e.raw_off (e's byte is never before b's byte)
              b. if loc.b.raw_off == loc.e.raw_off, then it is never the case that
                   loc.b.after is 1 and loc.e.after is 0

      The above changes mean that we no longer use 'fake' positions or the hack
      where the end position is one less than the start position.

 * for most scripts, replace .tcsh with .sh
   or consider using perl (e.g., for padsc script)
   [Not everyone will have tcsh...]

 * for scripts designed to be sourced by csh/tcsh, 
   rename foo.tcsh to foo.csh

NOT SURE WHEN
-------------
  * should array eat the Pterm char?  (no other term gets eaten)
  * for every type that has a term should there be a way to declare
       that the term should be eaten?
  * liberalize array termination-
       allow users to indicate that an array element violation should
       constitute array termination.  similarly for lack of a separator.

DEFERRED
--------
* skipped error codes: PDC_SKIPPED (library and generated code)

testing
-------

to decide
---------
  * for stop_regexp, how to specify the charset to use?
     XXX perhaps stop_regexp is overkill and should be removed
  * design and implement support for bit fields
     - C bitfields have platform dependent semantics
       (fill from left or from right)
     - want to be able to define special bit patterns,
        either individual bits or collections of them.
  * padsl pragmas for specifying record-type, endian, slurp mode
  * allow union arms with no variable names by specifying a tag name
  * support for optional fields?
  * how to handle name conflicts for enums and unions
     how relates to name spaces and separate compilation
  * in-place parsing from buffers?
  * translation specs: generate conversion from one pads type to
  another.


data formats to write
---------------------
  * netflow data
  * DNS data
  * http packets

to document
-----------
  * write documentation to allow users to define new base types.
  * write user manual

library todo
------------
 * accum report to buffer and to IO (now just to PDC error stream)
 * buffer data source
 * alias to PDC_IO_dump_start, PDC_IO_dump_end
 * non-preserving write functions for base types

MORE BASE TYPES:
     * afloat32, afloat64, bfloat32, bfloat64
     * astringME, estringME (low priority)

IO STUFF:
 * PDCI_IO_commit_sfwrite : writes all bytes from start of checkpoint
                            to the current IO cursor that is being committed
                            to the sfio stream provided
           => requires support from io disciplines, a fun call that gives    
                start and end positions for an sfio write and also gives
                a new io_cur_elt/io_remain to allow cleanup after write

ACCUM STUFF:
  * accumulators need quad grouping
    - skipped values, syntactic errors, semantic errors, good values


padsc compiler todo
-------------------
NEW
* Ptypedef without a constraint should be legal.

* Pswitch int test should be assignable to int

* Penum:
    a. specify both a C identifier and the source rep:
          package_file Pfrom "package-file"

    b. maybe Pfrom form should allow regexp?
          Penum my_enum {
            clock from Pre "/clock/i",
            package_file Pfrom Pre "/package-file/i"
          };

    c. specify a suffix to add to all the identifiers
          Penum my_enum Psuf(_e) {
            clock,
            package_file Pfrom "package-file"
          };
       ==> clock_e, package_file_e

* Parray: Pskip constraint which is used on each element after a successful read
          (including: use of Plast test did not remove the element).  If true,
          length is decremented by 1 (IO position does not change).

* foo_m_init: after filling everything in with the provided base mask,
    if the Set flag has been set, it should be unset for Pomit fields,
    so that the user does not need to do this by hand.
    This is tricky because foo_m_init functions
    do not call each other, so you would have a top-level function doing
    something like...

   void foo_m_init (P_t *pads,foo_m *mask,Pbase_m baseMask)
   {
     PDCI_fill_mask ((Pbase_m *) mask,baseMask,sizeof(foo_m));
     // special code for foo type that has some P_omit fields 
     baseMask &= (~P_Set);
     mask->foo.bar = mask->baz.zebra = mask->zot = baseMask;
   }

DEFER
 * More support for Pstring, as in:

       // convert from x|y| to single field z containing "xy"
       Pstruct my_struct {
          Pomit Pstring(:'|') x; '|';
          Pomit Pstring(:'|') y; '|';
          Pcompute Pstring z = x . y;
       }

       // alternate version of the above
       Pstruct my_struct {
          Pstring(:'|') z; '|';
          Pomit Pstring(:'|') y; '|' : (z .= y, 1);
       }

 * It should be possible to declare type parameters as only
    required for reading, both for built-in types and for user-defined types,
    and maybe we will need to declare params that are are only
    required for writing, although I am less sure about that.  E.g.,

      Pint32 x        :  x is both a read and a write param
      Pread Pint32 x  :  x is only a read param
      Pwrite Pint32 x :  x is only a write param

In base-ty-info table we will need a new column, e.g:
      -         : all params are both read and write params
      r2,r3,w4  : param 1 is both, params 2+3 are read, param 4 is write
    
  * set parse descriptor errCode to PDC_NoError if read successfully
  * if checkset mask is ignore or no-check, then set error descriptor
    to indicate that status: PDC_Skipped
  * set parse descriptor errCode to PDC_NotParsed in initialization
    function 
      -- can't do this as no requirement that init function will be called.
      -- also, might reuse parse descriptor multiple times.
      -- this issue really comes into play when we support partial reads.

  * if a user-defined constraint involves a field that has errCode != PDC_NO_ERR,
    the error message should be something like
      "User constraint skipped due to error reading one of its parts"
       and the error code should be, e.g.,
       PDC_USER_CONSTRAINT_SKIPPED.
 * illegal to omit fields used later as parameters 

  * make enum.p work (strings that match c keywordsk, etc)
  * fix accumulator generation program to start from file type
  * add analysis to determine if checkset mask is plausible 
    given other constraints
  * generate write functions
        - xml (need canonical mapping)

Optimizations
  * implement compiler optimizations mentioned in talk
      - glomming ignores (see examples/gen/dibbler2-mod.c)
        # I'm not sure this is a good idea.
        # I would want to see performance numbers to show it is an
	  optimization.
        # Static specification of error mask and related customization
	  will be a bigger win, I think.

