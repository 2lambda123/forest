soon
----
 * add instructions in README for how to obtain SML
   which is required for padsc compiler

by end of Aug
-------------
 * manual

 * Add base types whose in-memory rep is either PDC_float32 or PDC_float64

       Pfloat32, Pa_float32, Pe_float32, Pfloat64, Pa_float64, Pe_float64
       Pb_float32, Pb_float64
       Psbl_float32, Psbl_float64
       Psbh_float32, Psbh_float64

 * for most scripts, replace .tcsh with .sh
   or consider using perl (e.g., for padsc script)
   [Not everyone will have tcsh...]

 * for scripts designed to be sourced by csh/tcsh, 
   rename foo.tcsh to foo.csh

DEFERRED
--------
* skipped error codes: PDC_SKIPPED (library and generated code)

testing
-------

to decide
---------
  * for stop_regexp, how to specify the charset to use?
     XXX perhaps stop_regexp is overkill and should be removed
  * design and implement support for bit fields
     - C bitfields have platform dependent semantics
       (fill from left or from right)
     - want to be able to define special bit patterns,
        either individual bits or collections of them.
  * padsl pragmas for specifying record-type, endian, slurp mode
  * allow union arms with no variable names by specifying a tag name
  * support for optional fields?
  * how to handle name conflicts for enums and unions
     how relates to name spaces and separate compilation
  * in-place parsing from buffers?
  * translation specs: generate conversion from one pads type to another.

data formats to write
---------------------
  * netflow data
  * DNS data

to document
-----------
  * write documentation to allow users to define new base types.
  * write user manual

library todo
------------
 * accum report to buffer and to IO (now just to PDC error stream)
 * buffer data source
 * alias to PDC_IO_dump_start, PDC_IO_dump_end
 * non-preserving write functions for base types

MORE BASE TYPES:
     * afloat32, afloat64, bfloat32, bfloat64
     * astringME, estringME (low priority)

IO STUFF:
 * PDCI_IO_commit_sfwrite : writes all bytes from start of checkpoint
                            to the current IO cursor that is being committed
                            to the sfio stream provided
           => requires support from io disciplines, a fun call that gives    
                start and end positions for an sfio write and also gives
                a new io_cur_elt/io_remain to allow cleanup after write

ACCUM STUFF:
  * accumulators need quad grouping
    - skipped values, syntactic errors, semantic errors, good values


padsc compiler todo
-------------------
NEW
  * set parse descriptor errCode to PDC_NotParsed in initialization
    function 
      -- can't do this as no requirement that init function will be called.
      -- also, might reuse parse descriptor multiple times.
      -- this issue really comes into play when we support partial reads.
  * set parse descriptor errCode to PDC_NoError if read successfully
  * if checkset mask is ignore or no-check, then set error descriptor
    to indicate that status: PDC_Skipped


DEFER
  * if a user-defined constraint involves a field that has errCode != PDC_NO_ERR,
    the error message should be something like
      "User constraint skipped due to error reading one of its parts"
       and the error code should be, e.g.,
       PDC_USER_CONSTRAINT_SKIPPED.
 * illegal to omit fields used later as parameters 

  * make enum.p work (strings that match c keywordsk, etc)
  * fix accumulator generation program to start from file type
  * add analysis to determine if checkset mask is plausible 
    given other constraints
  * generate write functions
        - xml (need canonical mapping)

Optimizations
  * implement compiler optimizations mentioned in talk
      - glomming ignores (see examples/gen/dibbler2-mod.c)
        # I'm not sure this is a good idea.
        # I would want to see performance numbers to show it is an
	  optimization.
        # Static specification of error mask and related customization
	  will be a bigger win, I think.

