6/7/05 (phone conversation Y + D)
Add to principles:
Key invariants with regard to values - ie. rep and pd pairs:

1. Reps *can* be separated from pds, but only safely through special
   deconstructors. Safety is enforced by the type system. In order to
   support rep extraction or base types, I have invented the pattern
   base(x) (comments welcome). For example,

     Fun foo (x: Pint) : int =
	case x of 
	  int(y) => y
	| noval => 0   

   Notice, however, that in <<x,pd>>, x is bound to the whole value,
   not just the rep. I don't see any way to extract the rep as we
   don't have types for prevalues. However, there's no reason (that I
   see) that we couldn't - we just don't.

2. On the other hand, pds *cannot* be created by the programmer. Only
   the language/compiler can do that.

Sum: in deconstruction, we can separate reps from pds, but in
construction we cannot explicitly pair them.

6/3/05
Download EANCS format. Steal proposal intro.

1. Intro
- What is ad hoc data?
- What problems? Errors.
- Filter out errors, normalize time zones (Darkstar) - data cleaning.
- Transform to match another description (May be a standardized one)
- Four examples: Darkstar, Gigascope, Richard at Princeton, Olga/Magic.
- Solution: Data description Language + transform language
- New contributions
  + ML Syntax (parameterized datatypes)
    - PADS binding for functional languages (maybe mention rec. types
      in passing).
    - Concise (datatypes,etc.)
    - Fits with transforms
      +  Symetric (constructors/destructors)
    - New: polymorphism
    - New: datatypes
  + Our (Functional) Language for Transforms
    - fun. language => good fit for data-driven transforms
      + pattern matching
      + higher-order functions
    - PADS/ML types as contracts to handle dependency
      + new way of implementing contracts - replace exceptions with meta data record.
    - values are pairs of data item and error descriptor
      + compiler controls invariants of relationship between value and
	its descriptor.
      + concise way of ignoring errors safely (due to pairing),
      + error querying
      + error preservation allows programatic repair of faulty
	records (rather than just dumping bad records at beginning).
      + will show examples

2. PADS/ML
  - PADS Weltanshauung (worldview)
     + Diagram: type -> parser->rep+pd : types as transducers b/w
        ext. data and rep + pd.
     + Describe parse descriptor (corr. shape, syn. vs. sem. errors,
     etc.)
     + recovery
     + What do we need to express ?
      - Motivating example data (snippets for each later example format)
      - sequences (of different types), alternations, arrays(seq of same
        types), constraints, recursion (tree-structured), dependency
        + introduce syntax in above discussion - top down view.
      - how? 
        (+ constraints and dependency => CFG/REs not convenient)
        + we use types
      - "error-aware" computing (emphasize this).
  - Further Examples
    + Simple (Dibbler)
    + Complex (Kathleen)
    + Recursion (Newick)

  - "Formal" Syntax Chart

3. PADS/T
  - Reminder of motivation
    + Transforms, one format to another
    + (unobtrusive) error-aware computing.
  - Language design for error-aware computing.
    + compiler ensures data items are coupled with descriptors
      - programmers can't screw it up
      - preserved by the transformations
    + Reading PD
      + concise notation allows programmers to leave error processing
	for downstream process.
      + yet, ability to compute with errors and fix if you want
      + programmers can read descriptions and make decisions (but no
	writing).
    + Writing PD:
      - Safely and correctly create parse descriptors based on
        contract-style dynamic checks.
      - contracts dynamicly enforce rich constraints that can't be
        checked at compile time.
    
   - Syntax figure - don't explain much, just reference.

   (- Example template
     + Drawn from real-world examples but modified for proprietary
     purposes and for illustration.
     + Heres the transform we want
     + here's the code
     + explain the code)
   
   - Example of Normalizing, reordering
     + Alarms; VPN Monitoring
   - Syntax of parse descriptors
   - Example of using parse descriptor
     + Dibbler transform.
     + Show invariants in action.
  
  - Subsection with some judgment forms, perhaps some informal
    explanation of what's going on.

4. Implementation techniques
   - talk to Kathleen

5. Related work - Mary
   + standard stuff ...
   + XDUCE/CDUCE
   + Lenses (we're a front end).

6. Conclusions and future work - Dave
   - error aware parsing
   - func. lang. for  ...
   - static checking
   - polymorphic datatypes (alarm example)
   - semantics
   - meta theory
   - implementation

5/27/05

More Principles
===============
3. User is allowed to write any value including no-val, whose default
   pd always contains an error.  (User always writes down values; and
   we always construct parse-descriptors).

Type Deconstructor Patterns
===========================

Pstruct

  case y : Pstruct of
    { foo : Pint = <foo,foo_pd> (* foo, foo-pd in scope *)
      bar : T3   = <bar,bar_pd>
    }
    
Punion

  case x : Punion of
      i : Pint = <i,i_pd> =>
    | b : Pbool = <b, b_pd> =>

Popt

  case z : Popt of
      None =>
    | Some TypePat => 

Parray 

  Deconstruct arrays into lists of values, a separator and a
  terminator.  Write recursive functions to transform elements in
  list; then construct new array from new list, new separator, new
  terminator.

  rec fun listmap (f, l) = 
    case l : T Plist of
      Nil => Nil
    | Cons(<x, x_pd>, rest) => Cons (f x, listmap f rest)

  rec fun arraymap (f, a) = 
    case a of 
    (list, sep, term) => 
      if a.pd.err != OK then ???raise error???
      else let l' = listmap(f, l) in 
        l' Parray (',', '\n')
    
   Some functions over lists should be built-in.

Pds

  { errcode = ErrPat
    span = SpanPat
    nerr = IntegerPat
  } 

  ErrPat ::= OK | Panic | Err


TypePat 
  
5/20/05

Principles
==========
4. Error paths should not clutter normal path.
   Note that values always have a paired parse descriptor, so
   we can handle the case of no specified transform for an error
   by just marking an error in result.

5. Don't want users to have to do low-level memory management.
   Also, should be able to manipulate strings at a high-level of abstraction.

6. Preserve metadata-data relationship. In particular, keep track of
   source of errors even under transform. E.g. if we combine two error
   fields, how do we record where the new error came from?

   This principle is dictated by the Canonical-forms Lemma:
   if { x : T | P(x) } 
   then <v_rep, v_parse> s.t. if P(v_rep) and v_rep : T then v_parse = OK


7. Separate language into destructors and constructors.

8. Base X-lang design on IPADS.

9. In pattern matching, support pattern matching on values and
   types. Value names can be used in value-expressions and type names
   can be used in type expressions.

  
Issues 
======

Implementation Issues
----------------------

o Constraint language and transform language have to be in sync - if
  constr. language is C but Xform language is ML, how do they work
  together?

o How do we use the generated C parsing libraries?

o How do we match transform language to constraint language?

o Is the transformation language compiled or interpreted?

Other
-----
Array introduction and elimination notes:
intlist = Puint32 [Plit '|'; e or len x+2, Peor];

match arr with 
 e : eTy [sTy; exp, tTy] =>
 f(e) : ... (using names in type above).

f represents a function to apply to all elements e, as in map. We have
more work to do here. The key point is that the pattern-matching
elimination form of the array allows you to bind both the value and
type portions of the array to names. Then, the value names can be used
as usual and the type-related names can be used in a type annotation
on the right-hand side.

We've decided to based the design of the transformation language on
the syntax/structure of IPADS, for simplicity. Once that is
accomplished, we will have to decide whether to come up with a new
syntax that's appropriate to PADS itself, whether to modify the PADS
syntax to bring it closer the IPADS syntax, or whether to do some
combination of the two.

What is the target language of the transformation language? If we
don't compile into C, how do we interface with existing PADS? we can't
redo entire pads infrastructure. What are performance issues of
interfacing C and ML?

Can we separate code in compiler that deals with constraint
expressions into its own module that could be binding-dependent?
Eg. if constr. lang. is subset of c, C-binding module would just
return the expr. while ML-binding module would compile it into ML code
(if possible), etc.

Think about optimization of transforms - merge into parsing to avoid
separate pass. Particularly for streaming, don't want to parse then
transform but do it all together.

For surface language (i.e. not the core X-lang. we're working on now),
we'd like user to be able to ignore error cases and have default code
handle. For pieces that depend on error data, should be able to mark
them themselves as error. But, want some way to know that the error
came from dependency on other error, so want some form of error-source
tracking.

5/17/05

Principles
==========

1. User cannot touch reps w/ syntactic errors.

2. User does not construct Pds.   Language should do all Pd
   manipulation.  (Preserves theorem)

3. User can specify output type (including constraints) and
   system checks the constraints.  

Issues 
======

Answers question of why we're not using a GPL/FPL.

Other
-----
o General expressiveness of language 
  - should language be terminating? 
  - or permit arbitrary definition of functions?

o Why not embed PADS in ML/Haskell?

o Usefulness of row polymorphism 

o How to do I/O?
  - Psource represents I/O

  - What do other languages do about I/O? Xduce/Cduce/Haskell variants

o Union splitting -- how to express it? builtin or via a library
  function. 

o Composing transforms 
  - How implicit can tree-walking be?

o Compiler optimizations
  - Guarantee one pass over data!

o What do we do about (rep, parse descriptor) pair?

  - Patterns (as written in our example) implicitly match values that
    have no errors/i.e., no pd.

  - How to express case(s) when value does contain an error?

  - Several cases:

    Input      Output 
    No Pd      No Pd
    No Pd      Pd (constraint invalid)
    Pd(syntax) Must supply a value
    Pd(semantic) Pd opt

    Does output type reflect output pd?

    *** Output type for transform functions could be rep-val or
        raw-bits

o Built-in operators 

  - On base types, which know how to manipulate Pds?

o What do we do about constraints?

  - Include predicate expressions in the types 
    exprs that can show up in the types are limited
  - Should be able to drop constraint on a field
  - Implicitly add constraints to output types
    constraints on array lengths more common
    constraints on strings/dates not so common
    David knows about techniques for this
  - Programmer could write down constraints by hand

o Bi-directional type system 
  - Ideas from dependently typed ML languages

o A type that reflects the possible presence of errors: 

     ? Pstruct rec_t
             {    ? Puint64 key;
              '|' ? Pdate(:'|':) d;
              '|' ? Pstring(:'|':) unused;
              '|' ? Pip dest;
              '|' ? Pip source;
              '|' ? payload_t p;
             } 

  When (? Pstruct rec_t) contains no error, there is an operator
  (error erasure) that converts above type to :

     Pstruct rec_t
             {    Puint64 key;
              '|' Pdate(:'|':) d;
              '|' Pstring(:'|':) unused;
              '|' Pip dest;
              '|' Pip source;
              '|' payload_t p;
             } 

fun cvtIn (? Pstruct In_t i) : Out_t = 
  match i with 
    Pstruct In_t => 
      match i_pd.err with 
        OK => /* Here, we can erase errors from (? Pstruct In_t) 
                 so type of i is refined to (Pstruct In_t) */
      | PANIC => 
      | other => 

o Included below is one take on fleshing out our ideas from Wednesday
into sample code.  It includes both a universal and a splitting
interpretation of unions.

Kathleen

/* Desired transforms:

    . Normalize comment
    . Reverse IP fields
    . Change delimiters
    . Normalize union
    . Drop unused field

    We want to transform both reps and parse descriptors?
    How do we infer/specify names for result types?

    Can we infer the terminating value for a string from the following
    literal?

    How do we map complex array termination conditions?
    How do we map predicate expressions?

    Why is this not a general purpose language, i.e., an existing one?
    What if we added PADS types to Haskell say.  Why would that not
    be a better choice?  Some possible answers:
    1. by limiting the transform language, we can track properties
       (such as?)
    2. transformms work on value and parse descrptors at the same time
    3. we can infer resulting schema
    4. we can support label polymorphism
    5. closer meshing with pads
    6. easier I/O model?

    Clearly, we want to infer return types at the very least.
*/

open source.p
open target.p

/* HomeDepot encoding of Daytona escapes */
val escapes = [('&', "&0"), ('%', "&1"), ('|', "&2"), ('{', "&3"), 
('}', "&4"),
                ('[', "&5"), (']', "&6"), ('#', "&7"), ('\n', "&8"), 
('\\', "&9")]

fun escape (Pstring p) = implode (map (subst escapes) (explode p))

/* cvtPayload returns an anonymous structure, which can be appended to
   another anonymous structure.  A separate operator names a
   structure. */
fun cvtPayload(payload_t p) :{     Popt Pstring(:',':) comment;
                               ',' Popt Ptime          t;
                               ',' Popt Puint32        code;
                               ',' Popt Puint32        error;} =

  /* What is the serialization for SOME v and NONE?  Should be possible
     to specify what the serializations of SOME/NONE are. */
case p of
  Pstruct normal_t
          {    Pstring(:'|':) comment;
           '|' Ptime t;
           '|' Puint32 code
          } =>
          {    Popt Pstring(:',':) comment = SOME (escape comment);
           ',' Popt Ptime          t       = SOME t;
           ',' Popt Puint32        code    = SOME code;
           ',' Popt Puint32        error   = NONE;
          }
| Pstruct down_t {Puint32 error;} =>
          {    Popt Pstring(:',':) comment = NONE;
           ',' Popt Ptime          t       = NONE;
           ',' Popt Puint32        code    = NONE;
           ',' Popt Puint32        error   = SOME error;
          }

fun cvtRec(Pstruct rec_t r) : univrec_t =
case r of
   Pstruct rec_t
           {     Puint64 key;
            '|'; Pdate(:'|':) d;
            '|'; Pstring(:'|':) unused;
            '|'; Pip dest;
            '|'; Pip source;
            '|'; payload_t p;
           } =>
   /* @ is the record append operator */
   Pstruct univrec_t
          ({   Puint32 key = key mod MAX_INT;
	   ',' Pdate(:',':) d = toGMT d;
	   ',' Pip source = source;
	   ',' Pip dest = dest;
	   ',' } @ (cvtPayload p))

/* C-like syntax */
Parray univRecs_t cvtRecs(Parray recs_t rs) = {
    map cvtRec rs
}

/* ML-like syntax: */
fun cvtRecs(rs : Parray recs_t) : Parray univRecs_t = 
    map cvtRec rs

   /************** split stream version  *****************/

fun cvtNormalPayload(payload_t p) :Popt {    Pstring(:',':) comment;
                                         ',' Ptime          t;
   				         ',' Puint32        code; } =
case p of
   Pstruct normal_t
          {    Pstring(:'|':) comment;
           '|' Ptime t;
           '|' Puint32 code
          } =>
          SOME
          {    Pstring(:',':) comment = (escape comment);
           ',' Ptime          t       =  t;
           ',' Puint32        code    =  code;
          }
| Pstruct down_t =>  NONE

fun cvtCore(rec_t r) : {    Puint32 key;
  	                ',' Pdate(:',':) d;
	                ',' Pip source;
	                ',' Pip dest;} =
  case r of
     Pstruct rec_t
             {    Puint64 key;
              '|' Pdate(:'|':) d;
              '|' Pstring(:'|':) unused;
              '|' Pip dest;
              '|' Pip source;
              '|' payload_t p;
             } => { Puint32 key = 
                       case key_pd of 
                     | OK => (key mod MAX_INT);  /* OK case */
                     | non-panic-error => key_fixme(key, key_pd); /* FIXME case */
                     | PANIC => key_panic(key_pd);      /* PANIC case */
  	        ',' Pdate(:',':) d = toGMT d;
  	        ',' Pip source = source;
     		',' Pip dest = dest;}


/* Error case, when key field is invalid: */
fun cvtCore_X(rec_t r) : {  Puint32 key;
  	                ',' Pdate(:',':) d;
	                ',' Pip source;
	                ',' Pip dest;} =
  case r of
     Pstruct rec_t
             {    Pbase_pd key_pd;
              '|' Pdate(:'|':) d;
              '|' Pstring(:'|':) unused;
              '|' Pip dest;
              '|' Pip source;
              '|' payload_t p;
             } => { Puint32 key = DEFAULT_VALUE;
  	        ',' Pdate(:',':) d = toGMT d;
  	        ',' Pip source = source;
  		',' Pip dest = dest;}

fun cvtNormal(rec_t r) : recNormal_t =
   Pstruct recNormal_t ((cvtCore r) @ {','} @ (cvtNormalPayload r.p))

fun cvtDownPayload(payload_t p) : Popt { Puint32 error;} =
  case p of
    Pstruct normal_t => NONE
  | Pstruct down_t   => SOME down_t

fun cvtDown(rec_t r) : recDown_t =
     Pstruct recDown_t ((cvtCore r) @ {','} @ (cvtDownPayload r.p))

fun cvtNormals(recs_t rs) : recsNormal_t = mapMerge cvtNormal rs

fun cvtDowns(recs_t rs)   : recsDown_t   = mapMerge cvtDown rs

/* And then perhaps we need some parallel composition to cause both
   cvtNormals and cvtDowns to both consume input recs in a single pass
*/

/* Stream splitting : */

5/11/05

Reading:
XDuce, Lenses,

Source Example:
Pstruct normal_t{
    Pstring(:'|':) comment;
'|' Ptime t;
'|' Puint32 code
}

Pstruct down_t{
  Puint32 error;
}

Punion payload_t{
  normal_t n;
  down_t d;
}

Pstruct rec_t{
  Puint64 key;
'|' Pdate(:'|':) d;
'|' Pstring(:'|':) unused;
'|' Pip dest;
'|' Pip source;
'|' payload_t p;
}

Psource Parray recs{
  rec_t[];
}

Target example:
Pstruct univrec_t{
      Pint32 key;
  ',' Pdate(:',':) d;
  ',' Pip source;
  ',' Pip dest;
  ',' Popt Psstring(:',':) comment;
  ',' Popt Ptime t;
  ',' Popt Puint32 code;
  ',' Popt Puint32 error;
}

Pstruct recNormal_t{
  key;d;source;dest;comment;t;code
}

Pstruct recDown{
  key;d;source;dest;error;
}
