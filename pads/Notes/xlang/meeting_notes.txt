5/20/05

Principles
==========
4. Error paths should not clutter normal path.
   Note that values always have a paired parse descriptor, so
   we can handle the case of no specified transform for an error
   by just marking an error in result.

5. Don't want users to have to do low-level memory management.
   Also, should be able to manipulate strings at a high-level of abstraction.

6. Preserve metadata-data relationship. In particular, keep track of source of errors even under transform. E.g. if we combine two error fields, how do we record where the new error came from?

7. Separate language into destructors and constructors.

8. Base X-lang design on IPADS.

9. In pattern matching, support pattern matching on values and types. Value names can be used in value-expressions and type names can be used in type expressions.

  
Issues 
======

Implementation Issues
----------------------
o Constraint language and transform language have to be in sync - if constr. language is C but Xform language is ML, how do they work together?

o How do we use the generated C parsing libraries?

o How do we match transform language to constraint language?

o Is the transformation language compiled or interpreted?

Other
-----
Array introduction and elimination notes:
intlist = Puint32 [Plit '|'; e or len x+2, Peor];

match arr with 
 e : eTy [sTy; exp, tTy] =>
 f(e) : ... (using names in type above).

f represents a function to apply to all elements e, as in map. We have more work to do here. The key point is that the pattern-matching elimination form of the array allows you to bind both the value and type portions of the array to names. Then, the value names can be used as usual and the type-related names can be used in a type annotation on the right-hand side.

We've decided to based the design of the transformation language on the syntax/structure of IPADS, for simplicity. Once that is accomplished, we will have to decide whether to come up with a new syntax that's appropriate to PADS itself, whether to modify the PADS syntax to bring it closer the IPADS syntax, or whether to do some combination of the two.

What is the target language of the transformation language? If we don't compile into C, how do we interface with existing PADS? we can't redo entire pads infrastructure. What are performance issues of interfacing C and ML?

Can we separate code in compiler that deals with constraint expressions into its own module that could be binding-dependent? Eg. if constr. lang. is subset of c, C-binding module would just return the expr. while ML-binding module would compile it into ML code (if possible), etc.

Think about optimization of transforms - merge into parsing to avoid separate pass. Particularly for streaming, don't want to parse then transform but do it all together.

For surface language (i.e. not the core X-lang. we're working on now), we'd like user to be able to ignore error cases and have default code handle. For pieces that depend on error data, should be able to mark them themselves as error. But, want some way to know that the error came from dependency on other error, so want some form of error-source tracking.

5/17/05

Principles
==========

1. User cannot touch reps w/ syntactic errors.

2. User does not construct Pds.   Language should do all Pd
   manipulation.  (Preserves theorem)

3. User can specify output type (including constraints) and
   system checks the constraints.  

Issues 
======

Answers question of why we're not using a GPL/FPL.

Other
-----
o General expressiveness of language 
  - should language be terminating? 
  - or permit arbitrary definition of functions?

o Why not embed PADS in ML/Haskell?

o Usefulness of row polymorphism 

o How to do I/O?
  - Psource represents I/O

  - What do other languages do about I/O? Xduce/Cduce/Haskell variants

o Union splitting -- how to express it? builtin or via a library
  function. 

o Composing transforms 
  - How implicit can tree-walking be?

o Compiler optimizations
  - Guarantee one pass over data!

o What do we do about (rep, parse descriptor) pair?

  - Patterns (as written in our example) implicitly match values that
    have no errors/i.e., no pd.

  - How to express case(s) when value does contain an error?

  - Several cases:

    Input      Output 
    No Pd      No Pd
    No Pd      Pd (constraint invalid)
    Pd(syntax) Must supply a value
    Pd(semantic) Pd opt

    Does output type reflect output pd?

    *** Output type for transform functions could be rep-val or
        raw-bits

o Built-in operators 

  - On base types, which know how to manipulate Pds?

o What do we do about constraints?

  - Include predicate expressions in the types 
    exprs that can show up in the types are limited
  - Should be able to drop constraint on a field
  - Implicitly add constraints to output types
    constraints on array lengths more common
    constraints on strings/dates not so common
    David knows about techniques for this
  - Programmer could write down constraints by hand

o Bi-directional type system 
  - Ideas from dependently typed ML languages

o A type that reflects the possible presence of errors: 

     ? Pstruct rec_t
             {    ? Puint64 key;
              '|' ? Pdate(:'|':) d;
              '|' ? Pstring(:'|':) unused;
              '|' ? Pip dest;
              '|' ? Pip source;
              '|' ? payload_t p;
             } 

  When (? Pstruct rec_t) contains no error, there is an operator
  (error erasure) that converts above type to :

     Pstruct rec_t
             {    Puint64 key;
              '|' Pdate(:'|':) d;
              '|' Pstring(:'|':) unused;
              '|' Pip dest;
              '|' Pip source;
              '|' payload_t p;
             } 

fun cvtIn (? Pstruct In_t i) : Out_t = 
  match i with 
    Pstruct In_t => 
      match i_pd.err with 
        OK => /* Here, we can erase errors from (? Pstruct In_t) 
                 so type of i is refined to (Pstruct In_t) */
      | PANIC => 
      | other => 

o Included below is one take on fleshing out our ideas from Wednesday
into sample code.  It includes both a universal and a splitting
interpretation of unions.

Kathleen

/* Desired transforms:

    . Normalize comment
    . Reverse IP fields
    . Change delimiters
    . Normalize union
    . Drop unused field

    We want to transform both reps and parse descriptors?
    How do we infer/specify names for result types?

    Can we infer the terminating value for a string from the following
    literal?

    How do we map complex array termination conditions?
    How do we map predicate expressions?

    Why is this not a general purpose language, i.e., an existing one?
    What if we added PADS types to Haskell say.  Why would that not
    be a better choice?  Some possible answers:
    1. by limiting the transform language, we can track properties
       (such as?)
    2. transformms work on value and parse descrptors at the same time
    3. we can infer resulting schema
    4. we can support label polymorphism
    5. closer meshing with pads
    6. easier I/O model?

    Clearly, we want to infer return types at the very least.
*/

open source.p
open target.p

/* HomeDepot encoding of Daytona escapes */
val escapes = [('&', "&0"), ('%', "&1"), ('|', "&2"), ('{', "&3"), 
('}', "&4"),
                ('[', "&5"), (']', "&6"), ('#', "&7"), ('\n', "&8"), 
('\\', "&9")]

fun escape (Pstring p) = implode (map (subst escapes) (explode p))

/* cvtPayload returns an anonymous structure, which can be appended to
   another anonymous structure.  A separate operator names a
   structure. */
fun cvtPayload(payload_t p) :{     Popt Pstring(:',':) comment;
                               ',' Popt Ptime          t;
                               ',' Popt Puint32        code;
                               ',' Popt Puint32        error;} =

  /* What is the serialization for SOME v and NONE?  Should be possible
     to specify what the serializations of SOME/NONE are. */
case p of
  Pstruct normal_t
          {    Pstring(:'|':) comment;
           '|' Ptime t;
           '|' Puint32 code
          } =>
          {    Popt Pstring(:',':) comment = SOME (escape comment);
           ',' Popt Ptime          t       = SOME t;
           ',' Popt Puint32        code    = SOME code;
           ',' Popt Puint32        error   = NONE;
          }
| Pstruct down_t {Puint32 error;} =>
          {    Popt Pstring(:',':) comment = NONE;
           ',' Popt Ptime          t       = NONE;
           ',' Popt Puint32        code    = NONE;
           ',' Popt Puint32        error   = SOME error;
          }

fun cvtRec(Pstruct rec_t r) : univrec_t =
case r of
   Pstruct rec_t
           {     Puint64 key;
            '|'; Pdate(:'|':) d;
            '|'; Pstring(:'|':) unused;
            '|'; Pip dest;
            '|'; Pip source;
            '|'; payload_t p;
           } =>
   /* @ is the record append operator */
   Pstruct univrec_t
          ({   Puint32 key = key mod MAX_INT;
	   ',' Pdate(:',':) d = toGMT d;
	   ',' Pip source = source;
	   ',' Pip dest = dest;
	   ',' } @ (cvtPayload p))

/* C-like syntax */
Parray univRecs_t cvtRecs(Parray recs_t rs) = {
    map cvtRec rs
}

/* ML-like syntax: */
fun cvtRecs(rs : Parray recs_t) : Parray univRecs_t = 
    map cvtRec rs

   /************** split stream version  *****************/

fun cvtNormalPayload(payload_t p) :Popt {    Pstring(:',':) comment;
                                         ',' Ptime          t;
   				         ',' Puint32        code; } =
case p of
   Pstruct normal_t
          {    Pstring(:'|':) comment;
           '|' Ptime t;
           '|' Puint32 code
          } =>
          SOME
          {    Pstring(:',':) comment = (escape comment);
           ',' Ptime          t       =  t;
           ',' Puint32        code    =  code;
          }
| Pstruct down_t =>  NONE

fun cvtCore(rec_t r) : {    Puint32 key;
  	                ',' Pdate(:',':) d;
	                ',' Pip source;
	                ',' Pip dest;} =
  case r of
     Pstruct rec_t
             {    Puint64 key;
              '|' Pdate(:'|':) d;
              '|' Pstring(:'|':) unused;
              '|' Pip dest;
              '|' Pip source;
              '|' payload_t p;
             } => { Puint32 key = 
                       case key_pd of 
                     | OK => (key mod MAX_INT);  /* OK case */
                     | non-panic-error => key_fixme(key, key_pd); /* FIXME case */
                     | PANIC => key_panic(key_pd);      /* PANIC case */
  	        ',' Pdate(:',':) d = toGMT d;
  	        ',' Pip source = source;
     		',' Pip dest = dest;}


/* Error case, when key field is invalid: */
fun cvtCore_X(rec_t r) : {  Puint32 key;
  	                ',' Pdate(:',':) d;
	                ',' Pip source;
	                ',' Pip dest;} =
  case r of
     Pstruct rec_t
             {    Pbase_pd key_pd;
              '|' Pdate(:'|':) d;
              '|' Pstring(:'|':) unused;
              '|' Pip dest;
              '|' Pip source;
              '|' payload_t p;
             } => { Puint32 key = DEFAULT_VALUE;
  	        ',' Pdate(:',':) d = toGMT d;
  	        ',' Pip source = source;
  		',' Pip dest = dest;}

fun cvtNormal(rec_t r) : recNormal_t =
   Pstruct recNormal_t ((cvtCore r) @ {','} @ (cvtNormalPayload r.p))

fun cvtDownPayload(payload_t p) : Popt { Puint32 error;} =
  case p of
    Pstruct normal_t => NONE
  | Pstruct down_t   => SOME down_t

fun cvtDown(rec_t r) : recDown_t =
     Pstruct recDown_t ((cvtCore r) @ {','} @ (cvtDownPayload r.p))

fun cvtNormals(recs_t rs) : recsNormal_t = mapMerge cvtNormal rs

fun cvtDowns(recs_t rs)   : recsDown_t   = mapMerge cvtDown rs

/* And then perhaps we need some parallel composition to cause both
   cvtNormals and cvtDowns to both consume input recs in a single pass
*/

/* Stream splitting : */

5/11/05

Reading:
XDuce, Lenses,

Source Example:
Pstruct normal_t{
    Pstring(:'|':) comment;
'|' Ptime t;
'|' Puint32 code
}

Pstruct down_t{
  Puint32 error;
}

Punion payload_t{
  normal_t n;
  down_t d;
}

Pstruct rec_t{
  Puint64 key;
'|' Pdate(:'|':) d;
'|' Pstring(:'|':) unused;
'|' Pip dest;
'|' Pip source;
'|' payload_t p;
}

Psource Parray recs{
  rec_t[];
}

Target example:
Pstruct univrec_t{
      Pint32 key;
  ',' Pdate(:',':) d;
  ',' Pip source;
  ',' Pip dest;
  ',' Popt Psstring(:',':) comment;
  ',' Popt Ptime t;
  ',' Popt Puint32 code;
  ',' Popt Puint32 error;
}

Pstruct recNormal_t{
  key;d;source;dest;comment;t;code
}

Pstruct recDown{
  key;d;source;dest;error;
}
