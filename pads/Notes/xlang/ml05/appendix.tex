\appendix
\section{Language Syntax}
{\allowdisplaybreaks
\noindent
{\bf Syntax of data descriptions and other types}
\label{app:syntax-dd}
\begin{bnf}
\name{Constants} \meta{k} \::= \mcd{true} \| \mcd{false} \| \mcd{()} \| ...
\\
\name{Type Variables} \meta{\alpha}
\\
\name{Type Names} \meta{t}
\\
\name{\Core{} Types} \meta{T} \::= 
  \alpha 
\| {Pbase} 
\| M 
\nlalt \ppair x {T_1} {T_2} 
\| \precord {\nont{ffts}} 
\| \nont{tas}\;t(M) 
\nlalt \pset x T M 
\nlalt \parray T {M_{sep}} {M_{term}} 
\\
\name{\Core{} Datatypes} \meta{D} \::= 
  \mcd{datatype}\; \nont{tps}\; t(x{:}F) = \nont{b} \nlalt
  \mcd{type}\; \nont{tps}\; t(x{:}F) = T
\\
\name{Type Parameters} \meta{tps} \::= \cdot \| \alpha \| (\nont{tvs})
\\
\name{} \meta{tvs} \::= \alpha \| \alpha,\, \nont{tvs}
\\
\name{Type Arguments} \meta{tas} \::= \cdot \| T \| (\nont{ts})
\\
\name{} \meta{ts} \::= T \| T,\, \nont{tss}
\\
\name{} \meta{b} \::= \nont{cs} \| \mcd{case}\; M\; \mcd{of}\; \nont{ccs}
\\
\name{} \meta{cs} \::= c\;\mcd{of}\;T \| c\;\mcd{of}\;T \cvb \nont{cs}
\\
\name{} \meta{ccs} \::= 
  \nont{pat} \Rightarrow c\;\mcd{of}\;T \nlalt
  \nont{pat} \Rightarrow c\;\mcd{of}\;T \cvb \nont{ccs}
\\
\name{\Core{} Field Types} \meta{ffts} \::= \nont{fft} \| \nont{fft};\;\nont{ffts}
\\
\name{\Core{} Field Type} \meta{fft} \::= T \| x = T
\end{bnf}
%\include{dtsyn}

\noindent
{\bf Syntax of terms}
\label{app:syntax-terms}
\begin{bnf}
\name{Types} \meta{F} \::= 
  T           \descr{type of \pvalue{}} 
\nlalt \nont{base} \descr{values of ordinary base types} 
\nlalt \mcd{PD}    \descr{PD type}
\nlalt F * F       \descr{ordinary pairs} 
\nlalt \{\nont{fts}\}     \descr{ordinary records} 
\nlalt F \-> F     \descr{functions}
\nlalt \pstream F  \descr{streams}
\\
\name{Field Types} \meta{fts} \::= x = F \| x=F,\;\nont{fts}
\\
%\end{bnf}
%\begin{bnf}
\name{Parse Descriptors} \meta{pd} \::=   
  G \| B \| N \| S \| U
\\
\name{\Core{} Terms} \meta{N} \::=  
       Pbase[M_1](M_2)                \descr{base type constructor}
\nlalt \langle M \rangle              \descr{unit value (with singleton type M)}
\nlalt (x{=}{M_1} \mathrel{**} {M_2}) \descr{pair}
\nlalt \lcr \nont{fs} \rcr            \descr{record}
\nlalt c[M_1](M_2)                    \descr{data type constructor}
\nlalt \{x = {M_1} \cvb {M_2}\}       \descr{constrained type, with
  $M_2$ the constraint}
\nlalt \mcd{Parray}(M, M_{sep}, M_{term})   \descr{array; first element is stream}
\end{bnf}

\newpage

\begin{bnf}
\name{Terms} \meta{M} \::= 
       x                        \descr{variable}
\nlalt N                        \descr{\core{} terms}
\nlalt k                        \descr{constants}
\nlalt \nont{pd}                      \descr{pd value}
\nlalt (M_1 * M_2)              \descr{ordinary pair}
\nlalt \{\nont{fs}\}        \descr{ordinary record}
\nlalt \tfun {x_1}{x_2}{F_1}{F_2}{M}     \descr{recursive function x1 with arg x2}
\nlalt \mcd{nil}                \descr{empty stream}
\nlalt M_1 \mathrel{::} M_2     \descr{cons}
\nlalt \mcd{case}\;M\;\mcd{of}\;\nont{ms} \descr{deconstructors}
\nlalt M_1\;(M_2)               \descr{function application}
\nlalt \mcd{op}\;M                     \descr{additional uninteresting operations}
\nlalt \mcd{let}\;x = M_1\;\mcd{in}\;M_2           \descr{computation in host language}
\nlalt \mcd{cast}\;(M : T)             \descr{type annot/dependent cast?}
\\
\name{Fields} \meta{fs} \::= x = M \| x = M; \nont{fs}
\\
\name{Matches}\meta{ms} \::= 
  \nont{pat} \Rightarrow M \| \nont{pat} \Rightarrow M \cvb \nont{ms}
\end{bnf}
%\include{dtsyn_terms}
  
\newpage

\noindent
{\bf Syntax of patterns}
\label{app:syntax-pat}
\begin{bnf}
% \name{Parse Descriptors} \meta{pd} \::=   
%          G    \descr{good}
% \nlalt   B    \descr{bad}
% \nlalt   N    \descr{nested error}
% \nlalt   S    \descr{semantic error}
% \nlalt   U    \descr{unknown}
\name{\Core{} Patterns} \meta{fpat} \::=
x \| \nont{Pbase}(\nont{pat})
\nlalt \langle \nont{pat} \rangle             \descr{singleton}
\nlalt (\nont{fpat} \mathrel{**} \nont{fpat})   \descr{\core{} pair}
\nlalt \lcr \nont{ffps} \rcr                  \descr{\core{} record}
\nlalt c(\nont{fpat})                          \descr{constructor}
\nlalt \{\nont{fpat} \cvb \nont{cpat}\}        \descr{type constaint}
\nlalt \mcd{Parray}(\nont{pat}, x_{sep}, x_{term}) \descr{array with stream, sep and term.}
\nlalt \nont{fpat}\langle\langle\nont{pdpat}\rangle\rangle
\\
\name{Patterns}\meta{pat} \::= 
       \nont{fpat} \descr{\core{} pattern}
\nlalt k \| \nont{pdpat}                      \descr{constants and parse descriptors}
\nlalt (\nont{pat} * \nont{pat})              \descr{normal pair}
\nlalt \{\nont{fps}\}                        \descr{record}
\nlalt \mcd{nil} \| \nont{pat}_1 \mathrel{::} \nont{pat}_2 \descr{stream}
\\
\name{\Core{} Field Pattern} \meta{ffps} \::= x = \nont{fpat} \| x = \nont{fpat};\;\nont{ffps}
\\
\name{Constraint Pattern} \meta{cpat} \::= x \| \mcd{true} \| \mcd{false}
\\
\name{PD Pattern} \meta{pdpat}\::= x \| \nont{pd}
\\
\name{Field Pattern} \meta{fps} \::= x = \nont{pat} \| x = \nont{pat};\;\nont{fps}
\end{bnf}
%\include{dtsyn_pat}

\noindent
{\bf Syntax of programs}
\label{app:syntax-prog}
\begin{bnf}
\name{Program} \meta{prog} \::= 
  M              
 \nlalt D\; \nont{prog}          \descr{type declaration}
 \nlalt \mcd{val}\;x = M\;\mcd{prog} \descr{value declaration}
\end{bnf}
%\include{dtsyn_prog}
}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
