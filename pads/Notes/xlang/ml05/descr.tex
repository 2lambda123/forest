\section{Describing Data in \datatype{}}
\label{sec:data-description}

A \datatype{} description specifies the physical layout and semantic
properties of an ad hoc data source.  The language provides a
type-based model: basic types describe atomic data, while structured
types describe compound data built from simpler pieces.  Examples of
base types include 8-bit unsigned integers (\cd{Puint8}), 32-bit
integers (\cd{Pint32}), binary 32-bit integers (\cd{Pbint32}), dates
(\cd{Pdate}), strings (\cd{Pstring}), and IP addresses (\cd{Pip}).
Semantic conditions for such base types include checking that the
resulting number fits in the indicated space, \ie, 16-bits for
\cd{Pint16}.

Base types (and other types) may be parameterized by values.  This
mechanism serves both to reduce the number of base types and to permit
the format and properties of later portions of the data to depend upon
earlier portions.  For example, the base type \cd{Puint16_FW(3)}
specifies an unsigned two byte integer physically represented by
exactly three characters, while the type \cd{Pstring(' ')} describes a
string terminated by a space.  The \datatype{} implementation will
exploit the fact that we have already implemented many, many such base
types in the underlying \pads{} backend.

To describe more complex data, \datatype{} provides a collection of
structured types loosely based on the type structure of functional
programming languages such as Haskell and ML.
\figref{figure:dibblerml} gives a \datatype{} description for the
\dibbler{} phone order summaries in our proposed syntax.  Overall, the
data description is a sequence of type definitions.  It is probably
easiest to understand the data source by reading these descriptions
bottom up.


\subsection{\dibbler{}}
In order
to give the reader a sense of data descriptions
and some of the challenges, we will take a look at an example of ad
hoc data: summaries of phone order information produced by the
\dibbler{} project.
%To track AT\&T's provisioning process, the \dibbler{} project compiles
%weekly summaries of the state of certain types of phone service orders.  
These ASCII summaries store the summary date and one record per order.
Each order record contains a header followed by a sequence of events.
The header has 13 pipe separated fields: the order number, AT\&T's
internal order number, the order version, four different telephone
numbers associated with the order, the zip code of the order, a
billing identifier, the order type, a measure of the complexity of the
order, an unused field, and the source of the order data.  Many of
these fields are optional, in which case nothing appears between the
pipe characters.  The billing identifier may not be available at the
time of processing, in which case the system generates a unique
identifier, and prefixes this value with the string ``no\_ii'' to
indicate the number was generated. The event sequence represents the
various states a service order goes through; it is represented as a
new-line terminated, pipe separated list of state, timestamp pairs.
There are over 400 distinct states that an order may go through during
provisioning.  The sequence is sorted in order of increasing timestamps. 
\figref{figure:dibbler-records} shows a small example of
this format.
%156 different states for one order
%-rw-r--r--    1 angusm   dibbler   2187472314 Jun  9  2003 /fs/dibblerd/tlf/data/out_sum.stream
%2171.364u 31.379s 40:41.54 90.2% 0+0k 2+0io 2pf+0w
%53 had trailing t or } after zip code
%It may be apparent from this paragraph that English is a poor
%language for describing data formats!


\begin{figure*}
\begin{small}
%\begin{center}
\begin{verbatim}
0|1005022800
9152|9152|1|9735551212|0||9085551212|07988|no_ii152272|EDTF_6|0|APRL1|DUO|
9153|9153|1|0|0|0|0||152268|LOC_6|0|FRDW1|DUO|
\end{verbatim}
\caption{Tiny example of \dibbler{} provisioning data.}
\label{figure:dibbler-records}
%\end{center}
\end{small}
\end{figure*}

\suppressfloats

\begin{figure}
\begin {code}
\input{dibblerml}
\end{code}
\caption{\datatype{} description for \dibbler{} provisioning data.}
\label{figure:dibblerml}
\end{figure}

The last type definition \cd{source} is intended to be a definition of
an entire \dibbler{} data source.  The type description states that a
\cd{source} is a \cd{summery\_ header} followed by a sequence of
objects made up of an \cd{order\_header} followed by \cd{events}.  The
tuple type constructor (\cd{T1 ** T2}) and the array type constructor
(\cd{T Parray(sep,term)}) both specify sequences of objects in a data
source.  The \cd{Parray} type depends upon two value parameters,
(\cd{sep} and \cd{term}).  The first parameter describes the syntactic
separators that may be found between elements of the array.  In this
case \cd{NL} (the newline character) may be found between each element
of the array.  In other words, once the \cd{summary\_header} has been
parsed, each line of the data source will contain an
\cd{order\_header} and \cd{events}.  The second parameter is the
terminator for the array.  In this case, the terminator is the
end-of-file marker.  We will also support other termination conditions
for arrays when our research proves they are necessary.

The definition of \cd{events} indicates that this part of the
\dibbler{} data will contain a sequence of \cd{event}s separated by
verticle bars and terminated by a newline.  Each \cd{event} is a
string terminated by a veriticle bar, followed by a verticle bar and
ending with an unsigned 32-bit integer.  The interesting part of this
sequence is the presence of the type \cd{'|'}.  In type-theoretic
terms, this is a {\em singleton type}.  It states that one should
expect exactly the character \cd{'|'} in the input stream at this
point.  Other singletons appear in the summary header type as
\cd{"0|"} and NL (the newline character).

The type \cd{order\_header} is a record type that indicates
the data format involves the sequence of items described by
the fields of the record.  Notice that there are two different
sorts of fields: anonymous fields containing directives to parse
a particular character (\cd{'|'}), like the singleton types,
and fields with names.  The second named field,
\cd{att\_order\_num}, reveals two other proposed features of 
\datatype: dependency and constraints.  Here,
\cd{att\_order\_num} is constrained to be less than
\cd{order\_num}, the value parsed in an earlier field.
This is a relatively simple constraint on the correctness of the
ad hoc data format.  In practice, constraints can become very rich
involving properties such as sortedness of records in an array,
definitions of expected characters,
restrictions on date and time ranges, constraints on IP address
domains, restrictions on phone number area codes and virtually 
infinite variety of other possibilities. 

The last interesting feature in the \dibbler{} example is the
datatype definition of \cd{dib\_ramp}.  It describes
two alternatives for a portion of data, either an integer alone
or the fixed string \cd{"no\_ii"} followed by an integer.
In order to parse data in this format, the parser will
first attempt to parse the first branch and only if it
fails will it attempt to parse the second branch.

\begin{figure}
\begin{code}
{\rm Tiny data fragment with type trees: }
\mbox{}
(B:10,(A:34,C:15,E:23):4,D:2):12;
((A:4,E:22):4,D:2):11;
\mbox{}
val COMMA  = ','
val COLON  = ":"
val SEMI   = ';'
val LPAREN = '('
val RPAREN = ')'
\mbox{}
type entry = Pstring(COLON) ** COLON ** Puint32
\mbox{}
datatype tree =
    Tree of LPAREN ** tree Parray(COMMA,RPAREN) ** "):" ** Puint32
  | Tip of entry
\mbox{}
type trees = (tree ** SEMI) Parray(NL,EOF)
\end{code}
\caption{Simplified Tree-shaped Newick Data}
\label{fig:newick}
\end{figure}

\subsection{Newick}

A second interesting example of ad hoc data comes courtesy of Steven
Kleinstein, program coordinator of Princeton's Picasso project for
interdisciplinary research in computational sciences.  Kleinstein is
in the process of building a simulator to study immune response.  Data
needed for his simulations comes in a Newick format, which is a flat
representation of trees and used by many biologists~\cite{newick}.  In
Kleinstein's Newick format (simplified here for expository purposes),
leaves of the tree are string labels followed by a colon and a number.
A parent node in the tree introduces a collection of children by
placing a sequence of trees within parens.  Following the parens is a
colon and a number, as is the case for the leaf node (incidentally,
the numbers are called ``distances'' and represent the number of
genetic mutations that separate the child from the parent).  Each line
of a file may contain a different tree, terminated by a semi-colon.

\figref{fig:newick} gives a description of Newick and a bit of example
data.  Despite the relative complexity of the structure of the data,
the description is remarkably concise.  Notice that the data type
definition of \cd{tree} is recursive --- there appears to be no
effective description of this data source without it.

\begin{figure}
  \centering
  \small
\begin{verbatim}
 2:3004092508||5001|dns1=abc.com;dns2=xyz.com|c=slow link;w=lost packets
 |INTERNATIONAL
 3:|3004097201|5074|dns1=bob.com;dns2=alice.com|src_addr=192.168.0.10;
 dst_addr=192.168.23.10;start_time=1234567890;end_time=1234568000;
 cycle_time=17412|SPECIAL
\end{verbatim}  
  \caption{Simplified Network Monitoring Data}
  \label{fig:darkstar-records}
\end{figure}

\subsection{\darkstar{}}

Another example comes from the \darkstar{} project, shown in
Figure~\ref{fig:darkstar-records}. Note that this example is derived
from a real data format in use at AT\&T. In particular, it is based on
alarm data recorded by a network link monitor. An alarm signals a
problem with a network link. Also, it has been formatted to fit on the
page - individual records do not contain newlines. In our example,
there are two classes of alarms, indicated with the integers 2 and 3.
The alarm class is specified first, followed by a colon. When a class
2 alarm occurs, the ``start'' timestamp is recorded, while when a
class 3 alarm occurs, the ``clear'' timestamp is recorded.  Next, we
have an integer indicating the exact type of the alarm.  Following
this, we expect two pairs of strings, with the strings of each pair
separated by '='. The first string is a name and the second a string
value associated with that name. The pairs are separated by a
semicolon.  The first pairs has name ``dns1'' and the second ``dns2'',
indicating the DNS names of the parties on either end of the network
link. Next, the record contains information about the alarm. The
format of this information differs depending on the type of alarm. For
alarm 5074, we include a specific set of details about the failure.
For other alarms, there appears a sequence of name-string pairs of
unpspecfied length.  Finally, the alarm indicates the service class of
the network. This value is one of three strings: ``DOMESTIC'',
``INTERNATIONAL,'' and ``SPECIAL.'' Each field of the alarm is
separated by a vertical bar, except where otherwise specified.

The details included for alarm 5074 are as follows: a source and
detination IP address, both encoded as name-IP pairs, with names
``src\_addr'' and ``dest\_addr.'' These are followed by two
name-timestamp pairs, with names ``start\_time'' and ``end\_time,''
indicating the start and end times of the problem. The timestamps are
10-digits indicating the number of seconds since the epoch, in
GMT. The last field is a name-integer pair, with name ``cycle\_time,''
indicating ???. Note that each field is separated by a semicolon.

\begin{figure}
  \centering
  \small
  \include{darkstarsml}
  \caption{Description of \darkstar{} Data.}
  \label{fig:darkstar-ml}
\end{figure}
We now turn to the data description, shown in \figref{fig:darkstar-ml}.
The source type is an array of \cd{alarm}s, where each alarm is a
\cd{raw\_alarm}, constrained to ensure that the alarm number is
properly correlated with the timestamps.  We check this correlation
with the function \cd{checkCorr}.  The type \cd{raw\_alarm} closely
follows the description above. We highlight a few important features.
First, we note that the type of the field \cd{info} depends on the
alarm code, reflecting the text above. More interestingly, the type
\cd{info} is implemented with a switched datatype, deciding how to
parse based on the parameter \cd{alarm\_code}.  Next, we note that the
description includes five different types of name-value pairs. We take
advantage of both the type and value parameterization of types to
encode all of these pair types based on one common description,
\cd{pnvp}. This type is polymorphic in the type of the value and takes
an arbitrary constraint \cd{c} as an argument. The type \cd{nvp} is
polymorphic in the type of the value, but takes the expected name of
the string as an argument. Finally, we note that the type \cd{service}
is a datatype with only tags for constructors.  Each tag implicitly
looks in the data for the string that exactly matches the name of the
tag. For example, the tag \cd{DOMESTIC} attempts to read the string
``DOMESTIC'' from the data source. This datatype could alternatively
have been specified as:
\begin{code}
datatype service =
    DOMESTIC      of "DOMESTIC"
  | INTERNATIONAL of "INTERNATIONAL"
  | SPECIAL       of "SPECIAL"
\end{code}

Note that the base type \cd{Pstring} takes a string indicating a set
of acceptable terminator characters for the string. So, a
\cd{Pstring(";|")} can be terminated by either a semicolon or a
vertical bar.

\subsection{Syntax}

\begin{figure}
  \centering
  \include{dtsyn}
  \caption{Syntax of Data Descriptions and Other Types}
  \label{fig:syntax-dd}
\end{figure}

We present the formal syntax of data descriptions, including that used
in the examples, in \figref{fig:syntax-dd}. We will specify the
definition of terms \cd{M} in the next section, \figref{fig:syntax-terms}.

%\subsection{The \pads{} Weltanshauung}
\subsection{Error Representation}

The data description primitives of the \pads{} language are types.
However, more than describing data alone, these types describe a
transformation from data in an external format to data in an internal
format.  Yet, in \pads{}, data does not live alone. A critical benefit
of the parsing is the meta-data gained during the transformation
process.  Therefore, the result of a parse is a pair consisting of a
canonical in-memory representation of the data and meta-data for the
parse.  We refer to the meta-data as the {\em parse descriptor} (PD).
The parse descriptor may hold a variety of bits of information
including the position of the data in the file and a characterization
of the possible errors in the data.  There are several different sorts
of errors that may arise.  Syntactic errors occur when a parser cannot
read a valid item of the right type from the file (eg: of parser
attempts to read an integer to find the character '?'  instead).
Semantic errors occur when a parser can read an item but it does not
satisfy the appropriate semantic condition (eg: the parse finds an
integer in the file, but the integer is $-1$ when it should be greater
than zero).  Furthermore, the \pads{} system does not view errors as
fatal. Through the parse descriptor, \pads{} is able to record the
presence of errors and continue (performing recovery as necessary),
instead of throwing an exception or halting the parse as may be done
in more conventional, ``data-only'' systems. Here, the parse
descriptors play a critical role in the functioning of the system,
beyond their otherwise ``passive,'' descriptive role.
