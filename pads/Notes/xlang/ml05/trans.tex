\section{Transforming Data in \datatype{}}
\label{sec:data-transformation}

\datatype{} is more than a data description language. It is also a
functional programming language with extensive support for data
transformation. Most importantly, \datatype{} is not merely a
combination of these two language elements - data description and
transformation - but a synthesis.  The meta-data learned during the
process of parsing the data based on its description is not lost once
the parsing is finished, but instead plays a prominent role in the
programmatic elements of the language. As we are particularly
concerned with error-related meta-data, we term this synthesis
``error-aware computing.''

\subsection{Language Design for Error-aware Computing}

A typical \datatype{} program begins with parsing a data source. The
result of the parse is a pair of a representation of the parsed data
and a parse descriptor. Many transformations and analyses of data are
concerned with both the data and the meta-data. Therefore, the
language directly supports manipulating them together. To begin,
\datatype{} integrates the two together into one element, which we
term a \pvalue{}. This integrated value pairs a parse descriptor with
a data element at every level of a data structure. That is, the
subcomponents of a data structure (if any) are themselves \pvalue{}.
Next, associated with the set of \pvalue{} are data constructors and
patterns (destructors) designed to enable the programmer to program
with \pvalue{} in a natural way.  Finally, \datatype{} carefully
controls the use of \pvalue{} to maintain the invariant that a
\pvalue{}'s parse descriptor accurately describes the representation.
Critical to this last feature is \datatype{}'s type system, which is
designed with this invariant in mind. We will further discuss the type
system towards the end of the section, after describing some features
of the language itself.

\begin{figure}
  \centering
  \include{dtsyn_terms}
  \caption{Syntax of Constructors}
  \label{fig:syntax-terms}
\end{figure}

\begin{figure}
  \centering
  \include{dtsyn_pat}
  \caption{Syntax of Patterns}
  \label{fig:syntax-pat}
\end{figure}

\begin{figure}
  \centering
  \include{dtsyn_prog}
  \caption{Syntax of Programs}
  \label{fig:syntax-prog}
\end{figure}

In essence, data transformation in \datatype{} is performed by
deconstructing values using patterns and reconstructing them after
applying a transformation to their contents. For each type capable of
describing data, their is a corresponding pattern and constructor for
manipulating a \pvalue{} that corresponds to that type. We will see
and explain these patterns and constructors in the upcoming examples.
However, we do encourage interested readers to reference
\figref{fig:syntax-dd}, \figref{fig:syntax-terms},
\figref{fig:syntax-pat} and \figref{fig:syntax-prog} for a formal
presentation of the syntax. Data constructors are included under terms
\cd{M}, and patterns under \cd{pat}. We also note that while
\datatype{} focuses on supporting \pvalue{}s, the language also
includes standard constructs such as functions, pairs, and normal base
values, for example, \cd{int}.

In addition, although programmers cannot construct a parse descriptor
and pair it with a representation to create a \pvalue{}, there is a
generic pattern for all \pvalue{}s, \patreadpd {pat} {pdpat}, to
extract and read a value's parse descriptor (note that while the right
subpattern matches only the parse descriptor, the pattern on the left
matches the entire pair). There are currently four possible
descriptions in a parse descriptor: \pdgood{}, \pdbad{},\pdnest{} and
\pdsem{}. The description \pdgood{} describes data that is error free;
\pdbad{} describes data that is entirely invalid; \pdnest{} describes
data with an error in one or more subcomponents; \pdsem{} describes
data with a semantic error.  Note that in the actual language, parse
descriptors will carry more information including the location in the
source file (or a default location if generated by any user), but for
the purposes of this paper we have simplified the representation to
the one described.

{\em is this par. important?}
Notice that when the programmer
determines that a value's parse descriptor is \cd{G}ood, this implies
the entire substructure is error free and need not be checked further
for errors.  This greatly facilitates programming with data that is
expected to be error-free in the common case --- a programmer can
simply check the top-level PD and if it is indeed \cd{G}ood, she need
not clutter the rest of her code with error-checking preteens.  In
addition, when the top-level PD is \cd{G}ood, the value representation
might perhaps be optimized as the PDs for the substructures are
unnecessary.
  
The direct access to parse descriptors enables two powerful features:
error querying and error repair. For error querying, the programmer
can write a program to walk over the data source and collect
information about the errors in the data such as how many errors
occured, where they occured, etc. Given the expressiveness of the
language, the queryist is limited only by his imagination. It would be
an interesting future project to implement a generic query engine for
a well known query language such as XQuery. Lest this seem like an
unreasonable goal, a popular implementation of XQuery - Galax - is
already written in O'Caml.

Alternatively, the programmer might be interested in cleaning the data
in preparation for use in another application or even just further
transformation. Again, based on the parse descriptor, the programmer
can know the location and nature of errors in the data. This
information, combined with any relevant domain-specific knowledge
about the data can allow the programmer to effectively repair broken
records or remove them entirely. The fine-grained nature of the
meta-data can be important in minimizing how much work must be done in
such a cleaning process.

\begin{figure}
\begin{code}
type streams = entry stream * entry stream
\mbox{}
fun splitEntry (e:entry * streams) : streams =
  case e of
    (<<entry, G>> * (good * bad)) => (entry::good * bad)
  | (<<entry, _>> * (good * bad)) => (good * entry::bad)
\mbox{}    
fun splitSource (s:source) : streams =
    let (hdr * Parray(entries,_,_)) = s in 
    stream\_fold splitEntry (nil * nil) entries
\mbox{}
fun app (fds : fd * fd * fd) : unit =  
  let (fdin * fdgood * fdbad) = fds            in
  let input               = Pread::source fdin in
  let (good*bad)          = splitSource input  in
  Pwrite::(entry Parray(NL,EOF)) (Parray(good,NL,EOF)* fdgood);
  Pwrite::(entry Parray(NL,EOF)) (Parray(bad,NL,EOF)* fdbad)
\end{code}
\caption{Error filter for \dibbler{} data}
\label{fig:ex-data-clean}
\end{figure}

As an example of data cleaning, we provide the program in
\figref{fig:ex-data-clean}. It takes the \dibbler{} data source and
walks through all of the entries in the source checking for entries
with errors.  The good entries are placed in one output stream and the
bad entries are placed in another.  The idea is that the good entries
may then be further processed or directly loaded into a database
without corrupting the valuable data therein.  A human might examine
the bad entries off-line to determine the cause of errors and to
figure out how to fix the corrupted entries.

The \cd{splitEntry} function describes how to check an entry to
determine whether it is \cd{G}ood (syntactically and semantically
valid) or not.  Here, \cd{<<pat,pdpat>>} is a pattern that the
programmer uses to extract information about the parse descriptor from
a value.  \cd{pdpat} is the pattern for PDs and \cd{pat} is a pattern
for the value's substructures. Also, \cd{(good * bad)} deconstructs a pair,
while \cd{(good * entry::bad)} constructs one.

The \cd{splitSource} function pattern matches against the input
source, extracting the stream of entries, and iteratively applying the
\cd{splitEntry} function.  In this example, \cd{Parray(entry,\_,\_)}
is a pattern for array values.  An array value is a stream (in this
case \cd{entry}) coupled with a separator and a terminator.  Also in
this example, we assume \cd{fold\_stream} iteratively applies a
function to a stream.  

The function \cd{app} is responsible for reading in data from the file
descriptors it is given, splitting the data into good and bad and
writing the data back out to files.  The process of reading and
writing is dependent on the type descriptions of the ad hoc data.
Here, we write \cd{read::T} to read a data source formatted according
to \cd{T} and \cd{write::T} to write a format according to \cd{T}.
The read function will parse a file and generates an ad hoc data value
with type \cd{T}.  The write function will write an ad hoc data value
with type \cd{T} to a file.

\begin{figure}
  \centering
\begin{code}
fun checkAlarm (a : alarm): alarm opt =
    case a of 
	\{\{alarm=<<_,S>>;...\} |_\} => SOME(a)
      | _ => NONE
\mbox{}
fun collectAlarms(as : alarm stream): alarm stream =
    Stream.compact (Stream.map checkAlarm as)  
\end{code}
  \caption{Querying for Erroneous Alarm Values}
  \label{fig:ex-error-query}
\end{figure}

We present a furthre example of error querying in
\figref{fig:ex-error-query}, based on the \darkstar{} data
description. The function \cd{checkAlarm} takes an alarm set-type,
extracts the underlying raw alarm and checks its \cd{alarm} field for
a semantic error.  If the \cd{alarm} field contained a semantic error,
we return the entire alarm (wrapped in \cd{SOME}). Otherwise, we
return \cd{NONE}. The pattern \cd{\{pat | setpat\}} for set-types
matches \cd{pat} against the underlying value, and \cd{setpat} against
a boolean indicating whether the constraint was satisfied. As we don't
care about the constraint on the alarm itself, we specify a wild-card
pattern.  Also, the pattern for records is quite similar to that found
in ML. We note, however, that literal fields in a record type do not
appear as part of the pattern. 

The function \cd{collectAlarms}, then,
collects all alarm records in the alarm stream \cd{as}, whose
\cd{alarm} field has a semantic error.

\begin{figure}
  \centering
\begin{code}
fun fixAlarmVal (al : \{x:Puint32 | x==2 orelse x==3\}): 
  \{x:Puint32 | x==2 orelse x==3\} =
    case al of
      \{20 | _\} => \{x = Puint32(2) | x == 2 orelse x == 3\}
    | \{30 | _\} => \{x = Puint32(3) | x == 2 orelse x == 3\}
    | _ => al
\mbox{}
fun fixAlarm (a : alarm): alarm opt =
    case a of 
	\{\{alarm=<<al,S>>; start=s; clear=c; 
          code=cd; src_dns=sd; dest_dns=dd; 
	  info=i; service=s\} |_\} 
          => \{x=\{alarm=fixAlarmVal al; 
                 start=s; clear=c; 
                 code=cd; src_dns=sd; dest_dns=dd; 
                 info=i; service=s\}
              | checkCorr x\} 
      | _ => a
\mbox{}
fun fixAlarms(as : alarm stream): alarm stream =
    Stream.map checkAlarm as
\end{code}
  \caption{Repairing Erroneous Alarms}
  \label{fig:ex-error-repair}
\end{figure}

For an example of error repair in which the erroneous records are
fixed, please see \figref{fig:ex-error-repair}. Here, the data analyst
has discovered that some process producing alarm records was
erroneously using the values $20$ and $30$ for the alarm classes,
instead of the required $2$ and $3$. The program finds all alarm
records with semantics errors in the alarm field and corrects those
with value $20$ or $30$, leaving other untouched. We highlight three
new features. In function \cd{fixAlarmVal}, the bodies of the case
branches use the constructor for set types (\cd{\{x=M | M'\}}) and the
constructor for base types (\cd{Pbase(M)}.  In the pattern
\cd{<<_,S>>} the variable \cd{al} is bound to the entire \pvalue{} of
the \cd{alarm} \pvalue{}, rather than just the data. {\em should we
  explain this decision here?  its simpler for the language and for
  the programmer - don't have to worry about prevalues.}

\begin{figure}
  \centering
  \begin{code}
type d_alarm = \{
       alarm    :  \{ alarm : Puint32 | alarm == 2 
                                        orelse alarm == 3\};
 ':';  start :  date_time Popt;
 '|';  clear :  date_time Popt;
 '|';  code: Puint32;
 '|';  src_dns  :  nsp("dns1");
 ';';  dest_dns :  nsp("dns2");
 '|';  details  : details;
 '|';  service  :  service;
\}
\mbox{}
type g_alarm = \{
       alarm    :  \{ alarm : Puint32 | alarm == 2 
                                        orelse alarm == 3\};
 ':';  start :  date_time Popt;
 '|';  clear :  date_time Popt;
 '|';  code: Puint32;
 '|';  src_dns  :  nsp("dns1");
 ';';  dest_dns :  nsp("dns2");
 '|';  generic  : nsp_a Parray(';', '|');
 '|';  service  :  service;
\}
\mbox{}
fun splitAlarm (ra : raw_alarm): 
    d_alarm opt * g_alarm list opt
  = case ra of
        \{alarm=a; start=s; clear=c; code=cd; 
         src_dns=sd; dest_dns=dd; 
         info=Details(d); service=s\} 
        => 
        (SOME \{alarm=a; start=s; clear=c; 
               code=cd; src_dns=sd; dest_dns=dd; 
               details=d; service=s\}, 
         NONE)
      | \{alarm=a; start=s; clear=c; code=cd; 
         src_dns=sd; dest_dns=dd; 
         info=Generic(g); service=s\} 
        => 
        (NONE,
         SOME \{alarm=a; start=s; clear=c; 
               code=cd; src_dns=sd; dest_dns=dd; 
               generic=g; service=s\})    
  \end{code}
  \label{fig:ex-no-err-check}
  \caption{Shredding \darkstar{} Data Based on the {\tt info} Field}
\end{figure}

\begin{figure}
  \centering
  \begin{code}
type time = 
  \{time: Ptimestamp_explicit_FW(8, "%H:%M:%S", GMT);
   ':'; timezone: Pstring_FW(3)\}
\mbox{}
fun normalizeTimeToGMT(t : time): Ptimestamp_FW(8) =
    case t of
      \{time=t;timezone="GMT"\} => t
    | \{time=t;timezone="EST"\} => t + (5 * 60 * 60)
    | \{time=t;timezone="PST"\} => t + (8 * 60 * 60)
    | ...    
  \end{code}
  \caption{Normalizing Timestamps}
  \label{fig:ex-normalize}
\end{figure}

In addition to their primary focus, the examples above illustrated
another crucial aspect of our design of \datatype{} - error handling
is ``pay as you go''.  Despite the essential pairing of data and
meta-data, programmers can choose exactly when and where in the
transformation to attend to errors, or even to safely ignore them. The
programmer can deconstruct data without examining the parse
descriptor. That is, use of the pattern \patreadpd{pat}{pdpat} is not
required. This feature allows structural manipulation of the data (see
\darkstar{} example) without regard to errors. For example, the
program in \figref{fig:ex-no-err-check} shreds the \darkstar{} data
source into two, based on the \cd{info} field, without any reference
to parse descriptors at all.

However, such structural manipulation is not enough to fully shield
the programmer from dealing with errors. When manipulating base
values, there might be no structure to manipulate. If the parse failed
for that value, the representation will be \btm{}, and no meaningful
value can be extracted. Therefore, we have also designed our operators
to be able to safely operate on \btm{}, by propogating it from inputs
to output. For example, addition of one or more \btm{} values results
in \btm{}. We use this property in the example in
\figref{fig:ex-normalize}, where we normalize timestamp-timezone pairs
into simple timestamps in GMT time.

The many advantages of accurate parse descriptors highlight the
importance of maintaining accurate meta-data. Therefore, we need
language support for pairing newly created data with an accurate parse
descriptor, based on the type of the pair. Furthermore, we would like
to be able to check whether an existing value matches a particular
data description (i.e. type), for example, in a cast operation.
However, data descriptions can contain rich constraints that can't
necessarily be checked at compile time.

To this end, we include a mechanism for translating the constraints
found in the data descriptions into dynamic checks in the style of
contracts~\cite{contracts}. For example, in
\figref{fig:ex-error-repair}, the compiler will insert a dynamic check
at the end of function \cd{fixAlarmVal} to ensure that the constraint
on the set-type is satisfied. However, unlike previous work on
contracts, our system does not raise an exception when a dynamic check
fails, but, instead, records the failure in the parse descriptor of
the datum being checked.  The exact nature and location of these
checks will be detailed in the semantics of the language.

\subsection{Semantics Preview}

As \datatype{} is a work-in-progress, we have not fully worked out the
details of the semantics.  Therefore, we present here an overview of
the main concepts involved, together with some of the judgment forms.
...

% assigns \pvalue{}s to their own class of types.
% For this purpose, programmers can never construct PDs themselves; they
% are always constructed automatically by the compiler system.  It will
% be impossible for a programmer to corrupt the relationship between
% representation and PD accidentally. Additionally, there is no
% mechanism for accessing a representation directly.  Instead, it can
% only be accessed by deconstructing it with one of the patterns. While
% this is not critical for the safety of the language, we feel it is an
% important element of the language design that parsed data always be
% paired with its meta-data.
% Furthermore, note that while the right subpattern
% matches only the parse descriptor, the pattern on the left matches the
% entire pair, preventing direct access to the data representation, as
% discussed above.
