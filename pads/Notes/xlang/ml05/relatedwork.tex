\section{Related Work}
\label{sec:related-work}

Given the importance of ad hoc data, it is perhaps surprising that
more tools do not support it.  Many, many tools simply assume that the
data they manipulate is in the right format from the beginning.  If it
is not, it is up to the user to get the data in the correct format
themselves --- he or she receives little or no help with the problem.
For instance, \xml{} and relational databases expect their inputs are
already in \xml{} or standard formats such as CSV (Comma-Separated
Values).  The development of \datatype{} is completely complementary
to research on relational and semi-structured databases as \datatype
will be explicitly designed to help with the problem (among others) of
loading one of these databases with data that is not currently in the
expected format.

As \datatype{} supports both data description and transformation, we
will divide related work between these two functions. It is
interesting to note that, to the best of our knowledge, there are no
other languages that synthesize these two functions as \datatype{}
does.

\paragraph{Data Description}

One might wonder why we do not choose to base our descriptions on
regular expressions or context-free grammars. First, regular
expressions and context-free grammars, while excellent formalisms for
describing programming language syntax, are not ideal for describing
the sort of ad hoc data we have discussed in this paper.  The main
reason for this is that regular expressions and context free grammars
do not support dependency and do not support deep semantic constraints
that are important for ensuring data integrity.

ASN.1~\cite{asn} and related systems~\cite{asdl} allow the user to
specify the {\em logical} in-memory representation and generate a {\em
  physical} on-disk format, but this doesn't help when given a
particular, fixed physical on-disk format.  \datatype{} helps solve
the latter problem.

More closely related work includes \erlang{}'s bit
syntax~\cite{erlang} and the \packettypes{}~\cite{sigcomm00} and
\datascript{} languages~\cite{gpce02}, all of which allow declarative
descriptions of physical data.  These projects were motivated by
parsing protocols, \textsc{TCP/IP} packets, and \java{} jar-files,
respectively.  Like \datatype{}, these languages have a type-directed
approach to describing ad hoc data and permit the user to define
semantic constraints.  In contrast to our work, these systems handle
only binary data and assume the data is error-free or halt parsing if
an error is detected.  Parsing non-binary data poses additional
challenges because of the need to handle delimiter values and to
express richer termination conditions on sequences of
data. Furthermore, these languages provide bindings for imperative
languages only, while we have focused here on data descriptions in a
functional setting.


\paragraph{Data Transformation}

The closest work to our own is the XDuce
language~\cite{hosoya+:xduce-journal} for processing {XML}. XDuce is a
statically typed, functional and domain-specific. It includes {XML}
documents as basic data values, and data constructors and
deconstructors (pattern matching) targeted specifically at {XML}
data. However, {XML} and \datatype{} types are syntactically quite
different ... and {XML} parsing must be perfect in order to succeed ...
 
CDuce~\cite{benzaken+:cduce} and Xtatic~\cite{gapeyev+:XtaticRuntime}
both aim to integrate the advantages of the XDuce language into a
general purpose progamming language. CDuce is a functional language,
while Xstatic is an imperative, OO language based on {C\#}.

Harmony and lenses~\cite{foster+:lenses} is about transformations, but
focuses on the issue of transforming abstract views and then
resynching them with the whole data structure. hence the need for
bi-directional.

% ... yes there are similarities and we want to take advantage of them but, I
% would argue we **do** have a new approach -- one founded on {\em error-aware
% computing}.  All these XML languages assume that their input is error-free
% and simply throw up their hands if not.  This is one feature that makes ad
% hoc data completely different from XML.  Our language focuses on handling
% this novel form of complexity.  This is a major new area of research...

% And of course our language of types and patterns is different in the details
% as well.  

% The tone of the writing should emphasize that the similarities, where they
% exist, are positive (no need to be defensive at all).  We will study these
% other languages and extract every bit of information we can from them.  We
% do not have to worry about being defensive about overlap because there are
% clearly so many novel elements of the design.  We just must make the novelty
% clear.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
