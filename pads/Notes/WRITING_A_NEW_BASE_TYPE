DRAFT: NOT FINISHED YET

Implementing base types
=======================

Suppose we are adding a new base type Pnines which represents a
reliability level (3 nines corresponds to a reliablity of 99.9
percent, 5 nines corresponds to 99.999 percent, and so on).  In the data
stream, the input field just has a positive integer.  In memory,
we represent the number as a double holding the appropriate
percent (a number less than one), i.e., if the input is 3,
we will store 0.999 in the rep.

+ define a rep type (if necessary)
typedef Pfloat32 Pnines;

+ define any useful helper functions or macros.
In this case it seems like the following might be useful:

int Pnines2num_nines(Pnines n);
Pnines num_nines2Pnines(int num_nines);

int Pnines2num_nines(Pnines n) {
  int num_digits = 0;
  int digit = (int)(10 * n);
  // The double may have lost some precision.
  // Stop when the next digit is less than 8
  while (digit >= 8) {
    num_digits++;
    n -= (.1 * digit);
    digit = (int)(10 * n);
  }
  return num_digits;
}

Pnines num_nines2Pnines(int num_nines) {
  Pnines res = 0;
  while (--num_nines >= 0) {
    res *= .1;
    res += .9;
  }
  return res;
}
+ declare read function


+ declare write functions
      (write2io, write2buf, write_xml_2io, write_xml2buf)
  format functions
      (fmt2io, fmt2buf, fmt2buf_final)
  assumulator functions
      (init, add, ...)

+ implement all of the above
    + you can implement fmt2io, fm2buf, fmt2buf_final
      in terms of a write2buf function.
    
+ modify base-ty-info.txt OR extend PADS
   with your own base type info file
   (documented [HERE]).
+ write at least one test program
   under libpads/tests, put example data
   in libpads/data
   put appropriate build
   rule in libpads/tests/GNUmakefile
+ once the test is working, put regression
    results in libpads/regress, put
    a regression test rule in libpads/tests/GNUmakefile
+ write at least one examle .p file
   in padsc/examples/p, put example
   data for that p file in
   examples/data/, write the following test programs:
      rwxml_foo.c
      test_foo.c
      ???_foo.c
+ once the tests are working, turn them into
   regression tests, as follows.



Implementing character-based base types
=======================================

Implementing character-based types is tricky because you need to
handle all of the valid character sets.  In other words, you need to
supply declarations and implementations of read and write functions
for all of these character sets, plus the 'default' read and write
functions which use the current default character set.

The approach taken in the PADS implementation of character-based base
types involves a bit of sleight-of-hand.  All of the different
required functions are declared in pads.h, but we do not actually
provide distinct implemenations for each of these functions.  Instead,
we use macros to map calls to the public APIs to a smaller set
of internal routines, where each internal routine has two extra
arguments:  

Pcharset char_set    : which character set is used
const char *whatfn   : the name of the public function that was called

The whatfn argument is used by error reporting code, so that
the errors appear to come from the appropriate public function.

For example, we declare three Pchar read functions in pads.h,
but wrap them so that these declarations are only visible to CKIT:

#ifdef FOR_CKIT
Perror_t Pa_char_read (P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pchar *c_out);
Perror_t Pe_char_read (P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pchar *c_out);
Perror_t Pchar_read   (P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pchar *c_out);
#endif

The actual pads.h file has a more complicated form
than the above, because config flags are used so that you can just do
ascii, or just do ebcdic.  In addition, you can decide whether
you want read functions at all.  So the actual form is:

#ifdef FOR_CKIT
#if P_CONFIG_READ_FUNCTIONS > 0

#if P_CONFIG_A_CHAR_STRING > 0
Perror_t Pa_char_read (P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pchar *c_out);
#endif

#if P_CONFIG_E_CHAR_STRING > 0
Perror_t Pe_char_read (P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pchar *c_out);
#endif

#if P_CONFIG_A_CHAR_STRING > 0 && P_CONFIG_E_CHAR_STRING > 0
Perror_t Pchar_read   (P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pchar *c_out);
#endif

#endif /* P_CONFIG_READ_FUNCTIONS */
#endif /* FOR_CKIT */


The file pads-impl.h is used when FOR_CKIT is *not* defined, i.e., for
actual building a test program or the pads library.  In pads-impl.h,
there is a declaration of a single internal function to handle the
three public char_read functions:

Perror_t PDCI_char_read(P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pchar *c_out,
			Pcharset char_set, const char *whatfn);

The PDCI_ prefix stands for something like 'PaDs Code - Internal'.
It is used for functions, macros, and types that the user should
not see.

pads-impl.h has three macros that map the public functions
to the internal function:

#define Pchar_read(pads, m, pd, c_out) \
  PDCI_char_read(pads, m, pd, c_out, PDCI_DEF_CHARSET(pads), "Pchar_read")

#define Pa_char_read(pads, m, pd, c_out) \
  PDCI_char_read(pads, m, pd, c_out, Pcharset_ASCII, "Pa_char_read")

#define Pe_char_read(pads, m, pd, c_out) \
  PDCI_char_read(pads, m, pd, c_out, Pcharset_EBCDIC, "Pe_char_read")

This means we only have to implement one internal read function
(but our implementation must handle the two different character sets).

Here is the implementation of PDCI_char_read.  We break it down
into parts below.

Perror_t
PDCI_char_read(P_t *pads, const Pbase_m *m,
	       Pbase_pd *pd, Pchar *c_out, Pcharset char_set,
	       const char *whatfn)
{
  PDCI_IO_NEED_K_BYTES_SETUP;

  PDCI_IODISC_2P_CHECKS(whatfn, m, pd);
  PDCI_READFN_PD_INIT(pads, pd);
  P_TRACE2(pads->disc, "PDCI_char_read called, char_set = %s, whatfn = %s",
	     Pcharset2str(char_set), whatfn);
  PDCI_IO_NEED_K_BYTES(1, goto fatal_nb_io_err);
  if (end-begin != 1)     goto width_not_avail;
  if (c_out && P_Test_Set(*m)) {
    switch (char_set)
      {
      case Pcharset_ASCII:
	(*c_out) = *begin;
	break;
      case Pcharset_EBCDIC:
	(*c_out) = P_mod_ea_tab[(int)(*begin)];
	break;
      default:
	goto invalid_charset;
      }
  }
  PDCI_IO_FORWARD(1, goto fatal_forward_err);
  return P_OK;

 invalid_charset:
  PDCI_READFN_GETLOC_SPAN0(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_INVALID_CHARSET);

 width_not_avail:
  PDCI_READFN_BEGINLOC(pads, pd->loc);
  PDCI_READFN_ENDLOC_MINUS1(pads, pd->loc);
  PDCI_READFN_RET_ERRCODE_WARN(whatfn, 0, P_WIDTH_NOT_AVAILABLE);

 fatal_nb_io_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO error (nb)", P_IO_ERR);

 fatal_forward_err:
  PDCI_READFN_RET_ERRCODE_FATAL(whatfn, *m, "IO_forward error", P_FORWARD_ERR);
}

