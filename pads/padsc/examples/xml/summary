Roughly, the data source is a time stamp followed by a (long) list of 
variable length records.  Each record has a fixed header, an arbitrarily 
long sequence of "events" (which are state, time stamp pairs, sorted in 
increasing order of timestamp), and a fixed trailer, (some of whose 
fields are optional).

A DTD for the data source might look like:

<!ELEMENT dibbler timeStamp (order*)>
<!ELEMENT timeStamp (#PCDATA)>
<!ELEMENT order (header, event+, trailer)>

<!ELEMENT header (orderNum, orderItem, serviceTN, billingTN,
                   zip,nlpServiceTN, nlpBillingTN)>
<!ELEMENT orderNum (#PCDATA)>
<!ELEMENT orderItem (#PCDATA)>
<!ELEMENT serviceTN (telephone | stamp)>
<!ELEMENT billingTN (telephone | stamp)>
<!ELEMENT zip (#PCDATA)>
<!ELEMENT nlpServiceTN (telephone | stamp)>
<!ELEMENT nlpBillingTN (telephone | stamp)>

<!ELEMENT telephone (#PCDATA)>
<!ELEMENT stamp (#PCDATA)>


<!ELEMENT event (state, timeStamp)>
<!ELEMENT state (#PCDATA)>

<!ELEMENT trailer (siid, createID, rampII, orderType,parentOrder)>
<!ELEMENT siid (#PCDATA?)>
<!ELEMENT createID (#PCDATA?)>
<!ELEMENT rampII (#PCDATA?)>
<!ELEMENT orderType (#PCDATA)>
<!ELEMENT parentOrder (#PCDATA)>

English versions of David's queries are roughly the following:

Filters: all orders
     * with given start date
     * for selected customers
     * containing given state (first, last or anywhere)
     * from specified geographic location
     * active for more than a certain length of time
     * that have not yet completed (not yet reached certain state)
     * whose first state has a timestamp within a given window.
     * entering state 320 by date X and still in 320 by date Y
Filters: all states
     * from a specified list

Aggregation:
     * Generally, how many orders satisfy some predicate P?
     * Number of orders that got to state 5.
     * Number of orders in a substate over time.
     * Number of transitions into a given state.
     * Fix a date, for each state, report number of orders, time in
       state.

Time questions:
     * Given collection of orders, how many took x time to go from
       initial state to specied state?
     * What is average time between state x and state y?
     * Total time spent in a specified collection of substates.
     * Identify sink states.
     * For orders that eventually got to state 5, the difference between
       the time associated with state 4 and the time associated with the
       first usage state.

Some XQUERY fragments:
Loading data:
input("out_sum.xml")  -- this is not right; don't want to materialize
                          data in xml.
s = source("out_sum.raw", "dibbler.p")
                       -- is somethign like this plausible? It would
                          take the location of raw
                          data and pads description of such.


Filter:
s/dibbler/order[1]/header/zip   -- zip code of first order
s/dibbler/order/header/zip      -- all zip codes
s/dibbler/order/event[state=4]  -- all events with state four
s/dibbler/order/event[timeStamp > may 10]  -- all events after may 10
s/dibbler/order/event[1]        -- first event of each order
(s/dibbler/order/event)[1]      -- first event of entire database

Constructing results:
"all orders such that the timestamp of the first event is
  between date1 and date2"
<result>
  {s/dibbler/order/event[1][date1 < timeStamp and timeStamp  < date2]}
</result>

"all orders that got to state 5"
<result>
  {s/dibbler/order/event[state=5]}
</result>

"number of orders placed after may 10 that passed through state 5"
<result count="{count(s/dibbler/order[timeStamp > May 10][state = 5]>

</result>

