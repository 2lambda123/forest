- define (~), an equivalence relation that relates the (potentially)
  infinite unfolding of two filestores with the same structure---i.e.,
  ignoring metadata and the contents of files.
- define ++ on filestores
- show that (++) preserves equivalence, is commutative, and is associative
- show [PlusPlusPreserve] that F(r)=c and F++G =F',true implies F'(r)=c and similarly for G(r). 

+--------------------------------------------------------------------------+
| SEMANTICS 
+--------------------------------------------------------------------------+

check : env -> rep * md -> bool

pull  : (e:env) * filesystem * path -> 
        ((v:rep) * (d:md) where valid d implies check e v)

push  : ((e : env) * filesystem * path) -> 
        (v : (rep * md) where check e v) -> 
        filesystem * bool

pull (E,F,r) = (v,d)
valid (d)
F' ~ F
push (E,F',r) (v,d) = (F'',true)
--------------------------------[PullPush]
F'' ~ F

check E (v,d)
push (E,F,r) (v,d) = (F',true)
F'++G = (F'',true)
pull (E,F'',r) = (v',d)
---------------------------------[PushPull]
v = v' and valid(d) iff valid(d')

+--------------------------------------------------------------------------+
| CONSTANTS 
+--------------------------------------------------------------------------+

File.pull (E,F,r) = 
  { (n, true)    if F(r) = File(n)
  { ("", false)  otherwise

File.check E (n,b) = b

File.foot (E,r) (n,b) = { r }

File.push (E,F,r) (n,b) = 
  (F[r:=File(n)], F(r) undefined or F(r) = File(n))

 
PullPush:
  Assume 
    F' ~ F
    push (E,F',r) (n,b) = (F'',true) 
  By the definition of push we have 
    F'' = F'[r:=File(n)]
  It follows that F'' ~ F~. 
  By transitivity of ~ we also have
    F'' ~ F 
  as required.
   
PushPull:
  Assume 
    check E (n,b)     
    push (E,F,r) (n,b) = (F',true)  
    F'++G = (F'',true)
    pull (E,F'',r) = (n',b').
  By the definitions of check and push we have
    b=true
    F'(r)=File(n)
  and using PlusPlusPreserve we also have 
    F''(r)=File(n)
  Using the definition of pull we then obtain
    n'=n
    b'=true    
  as required.

     -----------------------------------------------------------------

(Adhoc(b)).pull (E,f,r) = 
  { (v,(valid (d),d)) if F(r) = File(n) and b.parse (n) = (v,d)
  { (v,(false,d))     if F(r) != File(n) and b.parse ("") = (v,d)

(Adhoc(b)).check E (v,d) = valid (d)

(Adhoc(b)).push (E,F,r) (v,d) = 
  (F[r:=File(b.print(v,d))], F(r) undefined or F(r) = File(b.print(v,d)))


PullPush:
  Assume 
    F' ~ F
    push (E,F',r) (v,d) = (F'',true) 
  By the definition of push we have 
    F'' = F'[r:=b.print(v,d)]
  It follows that F'' ~ F'.
  By transitivity of ~ we also have
    F'' ~ F 
  as required.
   
PushPull:
  Assume 
    check E (v,d) 
    push (E,F,r) (v,d) = (F',true)  
    F'++G = true,F''
    pull (E,F'',r) = (v',d').
  By the definition of push we have    
    F'(r)=File(b.print(v,d))
  and using PlusPreserve we also have
    F''(r)=File(b.print(v,d)) 
  Using the definition of pull we then obtain
    (v',d') = b.parse(b.print(v,d))
  The required equalities, namely
    v' = v
    valid(d) iff valid(d')
  hold *if* b satisfies a round-tripping law!

     -----------------------------------------------------------------

(e::s).pull (E,F,r) = s.pull (E,F,r/n)
where [[e]] E = n 

(e::s).check E (v,d) = s.check E (v,d)

(e::s).push (E,F,r) (v,d) = s.push (E,F,r/n) (v,d)
where [[e]] E = n


PullPush:
  Assume
    pull (E,F,r) = (v,d) 
    valid (d) 
    F' ~ F
    push (E,F',r) (v,d) = (F'',true)
  By the definition of pull and push we have
    [[e]] E = n 
    (v,d) = s.pull (E,F,r/n) 
    (F'',true) = s.push (E,F',r/n) (v,d)
  By PullPush for s we also have 
    F'' ~ F'
  By transitivity of ~ we also have
    F'' ~ F 
  as required.

PushPull:
  Assume 
    check E (v,d) 
    push (E,F,r) (v,d) = (F',true)  
    F'',true = F'++G
    pull (E,F'',r) = (v',d')
  By the definition of push we have    
    [[e]] = n
    s.push (E,F,r/n) (v,d) = (F',true)
  Using the definition of pull we also have 
    (v',d') = s.pull (E,F'',r/n)  
  The required equalities, 
    v' = v
    valid(d) iff valid(d')
  follow from PushPull for s. 

     -----------------------------------------------------------------

<x:s1,s2>.pull (E,F,r) = ((v1,v2),(valid d1 && valid d2,(d1,d2)))
where s1.pull (E,F,r) = (v1,d1)
  and s2.pull (E[x:=v1,x_d:=d1],F,r) = (v2,d2)

<x:s1,s2>.check E ((v1,v2),(b,(d1,d2))) = 
  check (E,F) (v1,d1) &&
  check (E[x:=v1,x_d:=d1],F) (v2,d2)

<x:s1,s2>.push (E,F,r) ((v1,v2),(b,(d1,d2))) = 
  let F2,b2 = s2.push (E[x:=v1,x_d:=d1],F,r) (v2,d2) in 
  let F1,b1 = s1.push (E,F, r) (v1,d1) in 
  let F12,b12 = F1++F2 in 
  (F12, b2 && b1 && b12)

PullPush:
  Assume
    pull (E,F,r) = (v,d) 
    valid (d) 
    F' ~ F
    push (E,F',r) (v,d) = (F'',true)
  By the definition of pull and push we have
    s1.pull (E,F,R) = (v1,d1)
    s2.pull (E[x:=v1,x_d:=d1],F,R) = (v2,d2)
    ((v1,v2),((valid d1 && valid d2), d1,d2)) = (v,d)
    (F2,true) = s2.push (E[x:=v1,x_d:=d1],F',r) (v2,d2)
    (F1,true) = s1.push (E,F',r) (v1,d1)
    (F'',true) = F1++F2 
  By PullPush for s2 and s1 we have 
    F2 ~ F'
    F1 ~ F'  
  As (++) preserves (~) we also have 
    F'' = F12 ~ F'
  By transitivity of ~ we also have
    F'' ~ F 
  as required.

PushPull:
  Assume 
    check E (v,d) 
    push (E,F,r) (v,d) = (F',true)  
    (F'',true) = F'++G
    pull (E,F'',r) = (v',d').
  Using types we have 
    ((v1,v2),(b,(d1,d2)) = (v,d)
    ((v1',v2'),(b',(d1',d2')) = (v',d')
  Also, by the definition of push we have    
    (F2,true) = s2.push (E[x:=v1,x_d:=d1],F,r) (v2,d2)
    (F1,true) = s1.push (E,F,r) (v1,d1)
    (F',true) = F1++F2
  and so by the associativity and commutativity of (++) we have
    (F'',true) = (F1++F2)++G
               = F1++(F2++G)
               = F2++(F1++G)
  Moreover, with the definition of pull we have
    (v1',d1') = s1.pull (E,F'',r)
    (v2',d2') = s2.pull (E[x:=v1',x_d:=d1'],F'',r)
  By PushPull for s1 we have 
    v1' = v1 and valid(d1') iff valid(d1)
  *If* we remove x_d* then...
  By PushPull for s2 we have 
    v2' = v2 and valid(d2') iff valid(d2)
  It follows that
    v' = v and valid(d) iff valid(d')
  as required.

     -----------------------------------------------------------------

[s | x in e].pull (E,F,r) = ([v1,..,vk], (valid d1 && .. && valid dk,[d1,..,dk]))
  where [[e]] E = [u1,...,uk]
    and s.pull (E[x:=ui],F,r) = (vi,di) for i from 1 to k
  
[ s | x in e ].check E ([v1,..,vk],(b,[d1,..,dk])) = b1k
  where [[e]] E = [u1,...,uk]
  and bi = s.check E[x:=ui] (vi,di) for i from 1 to k

[ s | x in e ].push (E,F,r) ([v1,..,vk],(b,[d1,..,dl])) = (F1k, b1k && b1 &&...& bk)
  where [[e]] E = [u1,...,uk]
    and Fi,bi = s.push (E[x:=ui],F,r) for i from 1 to k
    and (F1k,b1k) = F1++...++Fk 


PullPush:
  Assume
    pull (E,F,r) = (v,d) 
    valid (d) 
    F' ~ F
    push (E,F',r) (v,d) = (F'',true)
  By the definition of pull and push we have
    [[e]] = [u1,...,uk] 
    s.pull (E[x:=ui],F,R) = (vi,di) for i from 1 to k
    (valid d1 && ... & valid dk)
    (Fi,true) = s.push (E[x:=vi],F',r) (vi,di) for i from 1 to k
    (F'',true) = F1++...++Fk
  By PullPush for s (k times) we have 
    F1 ~ F' 
      ...
    Fk ~ F'  
  As (++) preserves (~) we also have 
    F'' ~ F'
  as required.

PushPull:
  Assume 
    check E (v,d) 
    push (E,F,r) (v,d) = (F',true)  
    (F'',true) = F'++G
    pull (E,F'',r) = (v',d').
  Using types (and the definition of check) we have 
    ([v1,...,vk],(b,[d1,...,dk])) = (v,d) 
    ([v1',...,vl'],(b',[d1',...,dl'])) = (v',d') 
  Also, by the definition of push we have    
    [[e]] E = [u1,...,uk]
    (Fi,true) = s.push (E[x:=ui],F,r) (vi,di) for 1 from 1 to k
    (F',true) = F1++...++Fk
  and so by the associativity and commutativity of (++) we have
    (F'',true) = (F1++...++Fk)++G
               = F1++(F2++...++Fk++G)
                   ...
               = Fk++(F1++...++F(k-1)++G)
  Moreover, with the definition of pull we have
    k = l 
    (vi',di') = s.pull (E[x:=ui],F'',r) for 1 from 1 to k
  By PushPull for s (k times) we have 
    vi' = vi and valid(di') iff valid(di) for i from 1 to k
  It follows that
    v' = v and valid(d) iff valid(d')
  as required.

     -----------------------------------------------------------------

(Pred(e)).pull (E,F,r) ((),([[e]] E))

(Pred(e)).check E ((),(b,())) = [[e]] E = b

(Pred(e)).push (E,F,r) ((),b) = F


PullPush:
  Assume
    pull (E,F,r) = (v,d) 
    valid (d) 
    F' ~ F
    push (E,F',r) (v,d) = (F'',true)
  By the definition of push we have
    F'' = F'
  By transitivity of ~ we also have
    F'' ~ F 
  as required.

PushPull:
  Assume 
    check E (v,d) 
    push (E,F,r) (v,d) = (F',true)  
    (F'',true) = F'++G
    pull (E,F'',r) = (v',d').
  By the definition of pull we immediately have
    v' = () = v
    d = [[e]] E = d'
  as required. 

     -----------------------------------------------------------------

(s?).pull (E,F,r) = 
  { (None,(false,None))       if F(r) undefined
  { (Some v,(valid d,Some d)) otherwise
    where s.pull (E,F,r) = v,d

(s?).check E (vo,(b,do)) = 
     not b & vo = do = None
  || b & vo = Some v && do = Some d && s.check (E,F) (v,d) 

(s?).push (E,F,r) (vo,(b,do)) = 
  { F\{r}      if vo = do = None 
  { s.push (E,F,r) (v,d) otherwise
    where vo = Some v
      and do = Some d


PullPush:
  Assume
    pull (E,F,r) = (v,d) 
    valid (d) 
    F' ~ F
    push (E,F',r) (v,d) = (F'',true)
  We analyze two cases. 
  Case F(r) undefined:
    Can't happen as valid(d)
  Case F(r) defined:
    By the definitions of push and pull we have
      v = Some v1
      d = (valid d1, Some d1)
      (v1,d1) = s.pull (E,F,r)
      (F'',true) = s.push (E,F',r) (v1,d1)    
    By PullPush for s we have 
      F'' ~ F
    as required.
    
PushPull:
  Assume 
    check E (v,d) 
    push (E,F,r) (v,d) = (F',true)  
    (F'',true) = F'++G
    pull (E,F'',r) = (v',d')
  We analyze two cases.
  Case v = None
    By the definition of check we have 
      d = (false,None)
    With the definition of push we also have 
      F' = F\{r}
    Then, using the definition of pull we obtain 
      (v',d') = (None,(false,None))
    Hence, 
      v' = None = v
      valid(d') = false = valid(d)
    as required.

+------------------------------------------------------------------------------+
| Some examples:
+------------------------------------------------------------------------------+

If 

s = <n:("name.txt"::File), n::File>

then executing s.push with

v' = ("foo.ml", "let rec f x = x")

works as you'd expect. However, if 

v' = ("name.txt", "let rec f x = x")

then s.push needs to be rejected if we want to have round-tripping
laws. Fortunately
 
  s.foot (E,r) (v',d) = { r/name.txt, r/name.txt }

definitely does *not* satisfy unique_paths :-)

     -----------------------------------------------------------------

< l:(p::Link), ^l::File > 

     -----------------------------------------------------------------

Similarly, note that if we take

s = <"x.txt"::File, "x.txt"::File>

and

v' = ("Hello", "World")

Then 

s.push (E,r) (v'd,) 

will update r/x.txt to "Hello", losing the "World" value. But again,
s.foot (E,r) (v',d) does not satisfy unique_paths, so we're okay.

     -----------------------------------------------------------------

s = <"x.txt"::Adhoc(b1), "x.txt"::Adhoc(b2)>

More generallly, specifications like s will not have useful push
functions (if we assume that we will only use s.push when s.check and
s.foot are satisfied). We could generalize s.foot to compute a
finer-grained footprint -- e.g., if b1 and b2 describe disjoint parts
of "x.txt", then we might be tempted to define push functions that
only change those parts of the file. But this is getting rather
baroque...

     -----------------------------------------------------------------

s = <"x.txt"::Adhoc(b1), "x.txt"::Adhoc(b2)>

More generallly, specifications like s will not have useful push
functions (if we assume that we will only use s.push when s.check and
s.foot are satisfied). We could generalize s.foot to compute a
finer-grained footprint -- e.g., if b1 and b2 describe disjoint parts
of "x.txt", then we might be tempted to define push functions that
only change those parts of the file. But this is getting rather
baroque...

     -----------------------------------------------------------------

