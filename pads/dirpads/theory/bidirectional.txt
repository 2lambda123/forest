- define (~), an equivalence relation that relates the (potentially)
  infinite unfolding of two filestores with the same structure---i.e.,
  ignoring metadata and the contents of files.
- define ++ on filestores
- show that (++) preserves equivalence, is commutative, and is associative
- show [PlusPlusPreserve] that F(r)=c and F++G =F',true implies F'(r)=c and similarly for G(r). 

+--------------------------------------------------------------------------+
| SEMANTICS 
+--------------------------------------------------------------------------+

check : env -> rep * md -> bool

pull  : (e:env) * filesystem * path -> 
        ((v:rep) * (d:md) where valid d implies check e v)

push  : ((e : env) * filesystem * path) -> 
        (v : (rep * md) where check e v) -> 
        filesystem * bool

pull (E,F,r) = (v,d)
valid (d)
F' ~ F
push (E,F',r) (v,d) = (F'',true)
--------------------------------[PullPush]
F'' ~ F'

check E (v,d)
push (E,F,r) (v,d) = (F',true)
F'++G = (F'',true)
pull (E,F'',r) = (v',d)
---------------------------------[PushPull]
v = v' and valid(d) iff valid(d')

+--------------------------------------------------------------------------+
| CONSTANTS 
+--------------------------------------------------------------------------+

File.pull (E,F,r) = 
  { (n, true)    if F(r) = File(n)
  { ("", false)  otherwise

File.check E (n,b) = b

File.foot (E,r) (n,b) = { r }

File.push (E,F,r) (n,b) = 
  (F[r:=File(n)], F(r) undefined or F(r) = File(n))

 
PullPush:
  Assume 
    F' ~ F
    push (E,F',r) (n,b) = (F'',true) 
  By the definition of push we have 
    F'' = F'[r:=File(n)]
  It follows that F'' ~ F'
   
PushPull:
  Assume 
    check E (n,b)     
    push (E,F,r) (n,b) = (F',true)  
    F'++G = (F'',true)
    pull (E,F'',r) = (n',b').
  By the definitions of check and push we have
    b=true
    F'(r)=File(n)
  and using PlusPlusPreserve we also have 
    F''(r)=File(n)
  Using the definition of pull we then obtain
    n'=n
    b'=true    
  as required.

     -----------------------------------------------------------------

(Adhoc(b)).pull (E,f,r) = 
  { (v,(valid (d),d)) if F(r) = File(n) and b.parse (n) = (v,d)
  { (v,(false,d))     if F(r) != File(n) and b.parse ("") = (v,d)

(Adhoc(b)).check E (v,d) = valid (d)

(Adhoc(b)).push (E,F,r) (v,d) = 
  (F[r:=File(b.print(v,d))], F(r) undefined or F(r) = File(b.print(v,d)))


PullPush:
  Assume 
    F' ~ F
    push (E,F',r) (v,d) = (F'',true) 
  By the definition of push we have 
    F'' = F'[r:=b.print(v,d)]
  It follows that F'' ~ F'.
   
PushPull:
  Assume 
    check E (v,d) 
    push (E,F,r) (v,d) = (F',true)  
    F'++G = true,F''
    pull (E,F'',r) = (v',d').
  By the definition of push we have    
    F'(r)=File(b.print(v,d))
  and using PlusPreserve we also have
    F''(r)=File(b.print(v,d)) 
  Using the definition of pull we then obtain
    (v',d') = b.parse(b.print(v,d))
  The required equalities, namely
    v' = v
    valid(d) iff valid(d')
  hold *if* b satisfies a round-tripping law!

     -----------------------------------------------------------------

(e::s).pull (E,F,r) = s.pull (E,F,r/n)
where [[e]] E = n 

(e::s).check E (v,d) = s.check E (v,d)

(e::s).push (E,F,r) (v,d) = s.push (E,F,r/n) (v,d)
where [[e]] E = n


PullPush:
  Assume
    pull (E,F,r) = (v,d) 
    valid (d) 
    F' ~ F
    push (E,F',r) (v,d) = (F'',true)
  By the definition of pull and push we have
    [[e]] E = n 
    (v,d) = s.pull (E,F,r/n) 
    (F'',true) = s.push (E,F',r/n) (v,d)
  By PullPush for s we have 
    F'' ~ F'
  as required.

PushPull:
  Assume 
    check E (v,d) 
    push (E,F,r) (v,d) = (F',true)  
    F'',true = F'++G
    pull (E,F'',r) = (v',d')
  By the definition of push we have    
    [[e]] = n
    s.push (E,F,r/n) (v,d) = (F',true)
  Using the definition of pull we also have 
    (v',d') = s.pull (E,F'',r/n)  
  The required equalities, 
    v' = v
    valid(d) iff valid(d')
  follow from PushPull for s. 

     -----------------------------------------------------------------

<x:s1,s2>.pull (E,F,r) = ((v1,v2),(valid d1 && valid d2,(d1,d2)))
where s1.pull (E,F,r) = (v1,d1)
  and s2.pull (E[x:=v1,x_d:=d1],F,r) = (v2,d2)

<x:s1,s2>.check E ((v1,v2),(b,(d1,d2))) = 
  check (E,F) (v1,d1) &&
  check (E[x:=v1,x_d:=d1],F) (v2,d2)

<x:s1,s2>.push (E,F,r) ((v1,v2),(b,(d1,d2))) = 
  let F2,b2 = s2.push (E[x:=v1,x_d:=d1],F,r) (v2,d2) in 
  let F1,b1 = s1.push (E,F, r) (v1,d1) in 
  let F12,b12 = F1++F2 in 
  (F12, b2 && b1 && b12)

PullPush:
  Assume
    pull (E,F,r) = (v,d) 
    valid (d) 
    F' ~ F
    push (E,F',r) (v,d) = (F'',true)
  By the definition of pull and push we have
    s1.pull (E,F,R) = (v1,d1)
    s2.pull (E[x:=v1,x_d:=d1],F,R) = (v2,d2)
    ((v1,v2),((valid d1 && valid d2), d1,d2)) = (v,d)
    (F2,true) = s2.push (E[x:=v1,x_d:=d1],F',r) (v2,d2)
    (F1,true) = s1.push (E,F',r) (v1,d1)
    (F'',true) = F1++F2 
  By PullPush for s2 and s1 we have 
    F2 ~ F'
    F1 ~ F'  
  As (++) preserves (~) we also have 
    F12 ~ F'
  as required.

PushPull:
  Assume 
    check E (v,d) 
    push (E,F,r) (v,d) = (F',true)  
    (F'',true) = F'++G
    pull (E,F'',r) = (v',d').
  By the type of rep * md we have 
    ((v1,v2),(b,(d1,d2)) = (v,d)
    ((v1',v2'),(b',(d1',d2')) = (v',d')
  Also, by the definition of push we have    
    (F2,true) = s2.push (E[x:=v1,x_d:=d1],F,r) (v2,d2)
    (F1,true) = s1.push (E,F,r) (v1,d1)
    (F',true) = F1++F2
  and so by the associativity and commutativity of (++) we have
    (F'',true) = (F1++F2)++G
               = F1++(F2++G)
               = F2++(F1++G)
  Moreover, with the definition of pull we have
    (v1',d1') = s1.pull (E,F'',r)
    (v2',d2') = s2.pull (E[x:=v1',x_d:=d1'],F'',r)
  By PushPull for s1 we have 
    v1' = v1 and valid(d1') iff valid(d1)
  *If* we remove x_d* then...
  By PushPull for s2 we have 
    v2' = v2 and valid(d2') iff valid(d2)
  It follows that
    v' = v and 
    valid(valid(d1) && valid(d2),(d1,d2)) iff 
    valid (valid(d1') && valid(d2'),(d1',d2'))
  as required.

*** JNF RAGGED BELOW HERE ***

     -----------------------------------------------------------------

{s | x in e}.pull (E,F,r) = ({v1,..,vk}, (valid d1 && .. && valid dk,{d1,..,dk}))
where [[e]] E = {u1,...,uk}
  and s.pull (E[x:=ui],F,r) = (vi,di) for i from 1 to k
  
{ s | x in e }.check E ({v1,..,vk},(b,{d1,..,dk})) = 
  b && s.check (E[x:=vi,x_d:=di],F) (vi,di) for i from 1 to k

{ s | x in e }.push (E,F,r) ({v1,..,vk},(b,{d1,..,dl})) = Fk
where s.push (E[x:=vi,x_d:=di],F{i-1},r) = Fi for i from 1 to k
  and F0 = F

     -----------------------------------------------------------------

(Pred(e)).pull (E,F,r) ((),([[e]] E,()))

(Pred(e)).check E ((),(b,())) = [[e]] E = b

(Pred(e)).foot (E,r) ((),(b,())) = {} 

(Pred(e)).push (E,F,r) _ = F

     -----------------------------------------------------------------

(s?).pull (E,F,r) = { (None,(false,None))       if r not in dom(F)
                    { (Some v,(valid d,Some d)) otherwise
where s.pull (E,F,r) = v,d

(s?).check E (vo,(b,do)) = 
     vo = do = None
  || vo = Some v && do = Some d && s.check (E,F) (v,d) 

(s?).push (E,F,r) (vo,(b,do)) = 
    { F                    if r not in dom(F)
    { s.push (E,F,r) (v,d) otherwise
      where vo = Some v
        and do = Some d

+------------------------------------------------------------------------------+
| Some examples:
+------------------------------------------------------------------------------+

If 

s = <n:("name.txt"::File), n::File>

then executing s.push with

v' = ("foo.ml", "let rec f x = x")

works as you'd expect. However, if 

v' = ("name.txt", "let rec f x = x")

then s.push needs to be rejected if we want to have round-tripping
laws. Fortunately
 
  s.foot (E,r) (v',d) = { r/name.txt, r/name.txt }

definitely does *not* satisfy unique_paths :-)

     -----------------------------------------------------------------

< l:(p::Link), ^l::File > 

     -----------------------------------------------------------------

Similarly, note that if we take

s = <"x.txt"::File, "x.txt"::File>

and

v' = ("Hello", "World")

Then 

s.push (E,r) (v'd,) 

will update r/x.txt to "Hello", losing the "World" value. But again,
s.foot (E,r) (v',d) does not satisfy unique_paths, so we're okay.

     -----------------------------------------------------------------

s = <"x.txt"::Adhoc(b1), "x.txt"::Adhoc(b2)>

More generallly, specifications like s will not have useful push
functions (if we assume that we will only use s.push when s.check and
s.foot are satisfied). We could generalize s.foot to compute a
finer-grained footprint -- e.g., if b1 and b2 describe disjoint parts
of "x.txt", then we might be tempted to define push functions that
only change those parts of the file. But this is getting rather
baroque...

     -----------------------------------------------------------------

s = <"x.txt"::Adhoc(b1), "x.txt"::Adhoc(b2)>

More generallly, specifications like s will not have useful push
functions (if we assume that we will only use s.push when s.check and
s.foot are satisfied). We could generalize s.foot to compute a
finer-grained footprint -- e.g., if b1 and b2 describe disjoint parts
of "x.txt", then we might be tempted to define push functions that
only change those parts of the file. But this is getting rather
baroque...

     -----------------------------------------------------------------

