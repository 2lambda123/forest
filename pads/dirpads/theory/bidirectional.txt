+--------------------------------------------------------------------------+
| SEMANTICS 
+--------------------------------------------------------------------------+

pull  : env * fs * path -> rep * md
check : env * fs -> rep * md -> bool
foot  : env * path -> rep * md -> path bag
push  : (e : env * fs * path) -> (v : rep * md where check e v) ->  fs 

Note that check could be folded into (a partial version of) the check
function; I'm splitting it out here to make it easier to state
properties.

pull (E,F,r) = (v,d)
valid (d)
--------------------------[PullCheck]
check (E,F) (v,d) = true

F(r') = Directory{}
check (E,F) (v,d)
push (E,F,chroot(r')) (pull (E,F,r)) = F'
-----------------------------------------[PullPush]
F'(r') ~ F(r)

where ~ is an equivalence relation that relates filestores with
identical structure (i.e., ignoring metadata and the contents of
files).

valid(d)
check (E,F) (v,d)
push (E,F,chroot(r')) (v,d) = F'
foot (E,r) = B
--------------------------------[PushFoot]
paths(F'(r')) <= setof(B)

check (E,F) (v,d)
unique_paths (foot(E,r)) (v,d)
push (E,F,chroot(r')) (v,d) = F'
--------------------------------[PushPull]
pull (E,F',r') = (v,d)

Note: I'm actually ignoring filesystem metadata completely in this
note. I hope we can easily add it back in.

+--------------------------------------------------------------------------+
| CONSTANTS 
+--------------------------------------------------------------------------+

File.pull (E,F,r) = { (n,true)    if F(r) = File(n)
                    { ("",false)  otherwise

File.check (E,F) (n,b) = b

File.foot (E,r) (n,b) = {r}

File.push (E,F,r) (n,b) = F[r:=File(n)]

     -----------------------------------------------------------------

(Adhoc(b)).pull (E,f,r) = 
    { (v,(valid(d),d))   if F(r) = File(n) and b.parse(n) = (v,d)
    { (v,(false,d))      if F(r) != File(n) and b.parse("") = (v,d)

(Adhoc(b)).check (E,F) (v,d) = valid(d)

(Adhoc(b)).foot (E,r) (v,d) = {r}

(Adhoc(b)).push (E,F,r) (v,d) = F[r:=File(b.print(v,d))]

     -----------------------------------------------------------------

(e::s).pull (E,F,r) = s.pull (E,F,r/n)
where [[e]] E = n 

(e::s).check (E,F) (v,d) = s.check (E,F)

(e::s).foot (E,r) (v,d) = s.foot (E,r/n) 
where [[e]] E = n

(e::s).push (E,F,r) (v,d) = s.push (E,F,r/n) (v,d)
where [[e]] E = n

Question: do we want to put n in the metadata? It seems to me that we
don't -- we don't need it to define the check and push functions, and
adding it will only make them less flexible.

     -----------------------------------------------------------------

<x:s1,s2>.pull (E,F,r) = ((v1,v2),(valid d1 && valid d2,(d1,d2)))
where s1.pull (E,F,r) = (v1,d1)
  and s2.pull (E[x:=v1,x_d:=d1],F,r) = (v2,d2)

<x:s1,s2>.check (E,F) ((v1,v2),(b,(d1,d2))) = 
  check (E,F) (v1,d1) &&
  check (E[x:=v1,x_d:=d1],F) (v2,d2)

<x:s1,s2>.foot (E,r) ((v1,v2),(b,d1,d2)) = 
  (s1.foot (E,r) (v1,d1) U (s2.foot (E[x:=v1,x_d:=d1],r) (v2,d2))

<x:s1,s2>.push (E,F,r) ((v1,v2),(b,(d1,d2))) = 
  s1.push (E, s2.push (E[x:=v1,x_d:=d1],F,r) (v2,d2), r) (v1,d1)

     -----------------------------------------------------------------

{s | x in e}.pull (E,F,r) = ({v1,..,vk}, (valid d1 && .. && valid dk,{d1,..,dk}))
where [[e]] E = {u1,...,uk}
  and s.pull (E[x:=ui],F,r) = (vi,di) for i from 1 to k
  
{ s | x in e }.check (E,F) ({v1,..,vk},(b,{d1,..,dk})) = 
  b && s.check (E[x:=vi,x_d:=di],F) (vi,di) for i from 1 to k

{ s | x in e }.foot (E,r) ({v1,...,vk},(b,{d1,...,dk})) = 
  U_{vi in [[e]] E } (s.foot(E[x:=vi,x_d:=di],r)

{ s | x in e }.push (E,F,r) ({v1,..,vk},(b,{d1,..,dl})) = Fk
where s.push (E[x:=vi,x_d:=di],F{i-1},r) = Fi for i from 1 to k
  and F0 = F

     -----------------------------------------------------------------

(Pred(e)).pull (E,F,r) ((),([[e]] E,()))

(Pred(e)).check (E,F) ((),(b,())) = [[e]] E = b

(Pred(e)).foot (E,r) ((),(b,())) = {} 

(Pred(e)).push (E,F,r) _ = F

     -----------------------------------------------------------------

(s?).pull (E,F,r) = { (None,(false,None))       if r not in dom(F)
                    { (Some v,(valid d,Some d)) otherwise
where s.pull (E,F,r) = v,d

(s?).check (E,F) (vo,(b,do)) = 
     vo = do = None
  || vo = Some v && do = Some d && s.check (E,F) (v,d) 

(s?).foot (E,r) (vo,(b,do)) = 
    { {}                if r not in dom(F)
    { s.foot(E,r) (v,d) if otherwise 
      where vo = Some v
        and do = Some d 

(s?).push (E,F,r) (vo,(b,do)) = 
    { F                    if r not in dom(F)
    { s.push (E,F,r) (v,d) otherwise
      where vo = Some v
        and do = Some d

+------------------------------------------------------------------------------+
| Some examples:
+------------------------------------------------------------------------------+

If 

s = <n:("name.txt"::File), n::File>

then executing s.push with

v' = ("foo.ml", "let rec f x = x")

works as you'd expect. However, if 

v' = ("name.txt", "let rec f x = x")

then s.push needs to be rejected if we want to have round-tripping
laws. Fortunately
 
  s.foot (E,r) (v',d) = { r/name.txt, r/name.txt }

definitely does *not* satisfy unique_paths :-)

     -----------------------------------------------------------------

Similarly, note that if we take 

s = <"x.txt"::File, "x.txt"::File>

and

v' = ("Hello", "World")

Then 

s.push (E,r) (v'd,) 

will update r/x.txt to "Hello", losing the "World" value. But again,
s.foot (E,r) (v',d) does not satisfy unique_paths, so we're okay.

     -----------------------------------------------------------------

s = <"x.txt"::Adhoc(b1), "x.txt"::Adhoc(b2)>

More generallly, specifications like s will not have useful push
functions (if we assume that we will only use s.push when s.check and
s.foot are satisfied). We could generalize s.foot to compute a
finer-grained footprint -- e.g., if b1 and b2 describe disjoint parts
of "x.txt", then we might be tempted to define push functions that
only change those parts of the file. But this is getting rather
baroque...

     -----------------------------------------------------------------

s = <"x.txt"::Adhoc(b1), "x.txt"::Adhoc(b2)>

More generallly, specifications like s will not have useful push
functions (if we assume that we will only use s.push when s.check and
s.foot are satisfied). We could generalize s.foot to compute a
finer-grained footprint -- e.g., if b1 and b2 describe disjoint parts
of "x.txt", then we might be tempted to define push functions that
only change those parts of the file. But this is getting rather
baroque...

     -----------------------------------------------------------------

