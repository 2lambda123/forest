Assumptions:
(1) phi(F1++F2) implies phi(F1) and phi(F2)
    Note: this does not hold for the constraints produced by glob-comprehensions :-(

(2) F ~ F1 and F ~ F2 implies F ~ (F1++F2)

(3) (++) associative and commutative 

+--------------------------------------------------------------------------+
| SEMANTICS 
+--------------------------------------------------------------------------+

pull : Env * Path -> Filesystem -> Rep * Metadata
push : Env * Path -> Rep * Metadata -> Filesystem -> Constraint * Filesystem

pull (E,r) F = (v,d)
F' ~ F
push (E,r) (v,d) F' = phi,F''
phi(F'')
---------------------------[PullPush]
F'' ~ F

push (E,r) (v,d) F = phi,F'
phi(F'++F'')
pull (E,r) (F'++F'') = (v',d')
---------------------------------[PushPull]
v = v' and valid(d) iff valid(d')

+------+
| FILE |
+------+ 

File.pull (E,r) F = 
  { (n, true)    if F(r) = File(n)
  { ("", false)  otherwise

File.push (E,r) (n,b) = 
  (fun F -> b && (F(r) = File(n') implies n' = n), F[r:=File(n)])

PullPush:
  Assume 
    pull (E,r) F = (n,b)
    F' ~ F
    push (E,r) (n,b) F' = phi,F''
    phi(F'')
  By the definition of push we have 
    phi = (fun F -> b && (F(r) = File(n') implies n' = n))
  With phi(F'') we have 
    b = true
  Using the definition of pull we then obtain
    F(r) = File(n)
  By the definition of push we have 
     F'' = F'[r:=File(n)]
  Hence, F'' ~ F' and so F'' ~ F by transitivity. 

PushPull:
  Assume
    push (E,r) (n,b) F = phi,F'
    phi(F'++F'')
    pull (E,r) (F'++F'') = (n',b')
  By the definition of push we have 
    phi = (fun F -> b && (F(r) = File(n') implies n' = n))
    F' = F[r:=File(n)]
  By phi(F'++F'') and the definition of ++ we have 
    b = true
    (F'++F'')(r) = File(n)
  By the definition of pull we have 
    n' = n and b' = true
  Hence, n' = n and b iff b', as required. 

+------+
| PATH |
+------+ 

(e::s).pull (E,r) F = 
  let n = [[e]] (E,r) in 
  s.pull (E,r/n) F 

(e::s).push (E,r) (v,(b,n,d)) = 
  let n = [[e]] (E,r) in 
  s.push (E,r/n) (v,d)

PullPush:
  Assume 
    pull (E,r) F = (v,d)
    F' ~ F 
    push (E,r) (v,d) F' = phi,F''
    phi(F'')
  By the definition of pull we have 
    n = [[e]] (E,r)
    v,d = s.pull (E,r/n) F
    b = valid(d) 
  By the definition of push we also have  
    phi,F'' = s.push (E,r/n) (v,d) F'
  By PullPush for s we obtain
    F'' ~ F 
  as required. 

PushPull:
  Assume
    push (E,r) (v,d) F = phi,F'
    phi(F'++F'')
    pull (E,r) (F'++F'') = (v',d')
  By the definition of push we have 
    n = [[e]] (E,r)
    phi,F' = s.push (E,r/n) (v,d)
  By the definition of pull we also have 
    v',d' = s.pull (E,r/n) (F'++F'')
  By PushPull for s we obtain 
    v' = v and valid(d') iff valid(d)
  as required.

+------+
| PAIR |
+------+ 

<x:s1,s2>.pull (E,r) F = 
  let v1,d1 = s1.pull (E,r) F in 
  let v2,d2 = s2.pull (E[x:=v1],r) F in
  ((v1,v2),(valid(d1) && valid(d2),d1,d2))

<x:s1,s2>.push (E,r) ((v1,v2),(b,d1,d2)) F = 
  let phi1,F1 = s1.push (E,r) (v1,d1) F in 
  let phi2,F2 = s1.push (E[x:=v1],r) (v2,d2) F in 
  let phi = (fun F -> (b iff valid(d1) && valid(d2)) && phi1(F) && phi2(F)) in 
  (phi, F1++F2)

PullPush:
  Assume 
    pull (E,r) F = ((v1,v2),(b,d1,d2))
    F' ~ F 
    push (E,r) ((v1,v2),(b,d1,d2)) F' = phi,F''
    phi(F'')
  By the definition of pull we have 
    v1,d1 = s1.pull (E,r) F
    v2,d2 = s2.pull (E[x:=v1],r) F
  By the definition of push we have  
    phi1,F1 = s1.push (E,r) (v1,d1) F'
    phi2,F2 = s2.push (E[x:=v1],r) (v2,d2) F' in 
    F'' = F1++F2
    phi = (fun F -> (b iff valid(d1) && valid(d2)) && phi1(F) && phi2(F))
  By phi(F1++F2) we have 
    phi1(F1++F2)
    phi2(F1++F2)
  By assumption (1) we have 
    phi1(F1)
    phi2(F2)
  By PullPush for s1 and s2 we have 
    F2 ~ F
    F1 ~ F
  By assumption (2) we have 
    F1++F2 ~ F
  as required.
  
PushPull:
  Assume
    push (E,r) ((v1,v2),(b,d1,d2)) F = phi,F'
    phi(F'++F'')
    pull (E,r) (F'++F'') = ((v1',v2'),(b',d1',d2'))
  By the definition of push we have 
    phi1,F1 = s1.push (E,r) (v1,d1) F
    phi2,F2 = s2.push (E[x:=v1],r) (v2,d2) F in 
    F' = F1++F2
    phi = (fun F -> (b iff valid(d1) && valid(d2)) && phi1(F) && phi2(F))
  By the definition of phi we have 
    b iff valid(d1) && valid(d2)
    phi1(F'++F'')
    phi2(F'++F'')
  Using assumption (3) we can rewrite these as 
    phi1(F1++F2++F'')
    phi2(F2++F1++F'')  
  By the definition of pull we also have 
    v1',d1' = s1.pull (E,r) (F'++F'')
    v2',d2' = s2.pull (E[x:=v1],r) (F'++F'')
    b' = valid(d1') && valid(d2')
  By PushPull for s1 and s2 we then obtain 
    v1' = v1 and valid(d1') iff valid(d1)
    v2' = v2 and valid(d2') iff valid(d2)
  It follows that b' iff b. 

+------+
| GLOB |
+------+ 
    
[ s | x in * ].pull (E,r) F = 
  if F(r) = Directory({n1,...,nk}) then 
    let vi,di = s.pull (E[x:=ni],r) F for i from 1 to n in 
    ([v1,...,vk],(valid(d1) && ... valid(dk),[d1,...,dk]))
  else 
    ([],(false,[]))

[s | x in * ].push (E,r) ([v1,...,vj],(b,[d1,...,dk]) = 
  if F(r) = Directory({n1,...,nl}) then 
    let k' = min(j,k,l) in 
    let phii,Fi = s.push (E[x:=ni],r) F for i from 1 to k' in 
    let phi = (fun F -> j = k = l
                && (b iff valid(d1) && ... && valid(dk')) 
                && F(r) = Directory{n1,...,nk'} && 
                && phi1(F) && ... && phik'(F)) in 
    (phi,F1++...++Fk')
  else 
    (fun F -> false, F)

PullPush:
  Assume 
    pull (E,r) F = ([v1,...,vk],(b,[d1,...dk]))
    F' ~ F 
    push (E,r) ([v1,...,vk],(b,[d1,...,dk])) F' = phi,F''
    phi(F'')
  We analyze two cases. 
  Case F(r) = Directory({n1,...,nk}):
    By the definition of pull we have 
      vi,di = s.pull (E[x:=ni],r) F for i from 1 to k
    By F' ~ F we have 
      F'(r) = Directory({n1,...,nk})
    By the definition of push we have
      phii,Fi = s.push (E[x:=ni],r) (vi,di) F' for i from 1 to k
      F'' = F1++...++Fk
      phi = (fun F -> k = l = m
               && (b iff valid(d1) && ... && valid(dk)) 
               && F(r) = Directory{n1,...,nk} && 
               && phi1(F) && ... && phik(F)) in 
    By phi(F1++...++Fk) we have 
      phii(F1++...++Fk) for i from 1 to k
    By assumption (1) we have 
      phii(Fi) for i from 1 to k
    By PullPush for s (k times) we have 
      Fi ~ F for i from 1 to k
    By assumption (2) (k times) we have 
     F1++...++Fk ~ F
    as required.
  Case F(r) != Directory(_):
    Can't happen. By F' ~ F we have 
      F'(r) != Directory(_)
    By the definition of push we have 
      phi = (fun F -> false)
      F'' = F
    which contradicts the assumption that phi(F'').

PushPull:
  Assume
    push (E,r) ([v1,...,vj],(b,[d1,...,dk])) F = phi,F'
    phi(F'++F'')
    pull (E,r) (F'++F'') = ([v1',...,vm'],(b,[d1',...,dm']))
  We analyze two cases. 
  Case F(r) = Directory({n1,...,nl}):
    Let k' = min(j,k,l).
    By the definition of push we have 
      phii,Fi = s.push (E[x:=ni],r) (vi,di) for i from 1 to k'.
      phi = (fun F -> j = k = l
               && (b iff valid(d1) && ... && valid(dk')) 
               && F(r) = Directory{n1,...,nk'} && 
               && phi1(F) && ... && phik'(F)) in 
      F' = F1++...++Fk'
    By the definition of phi we have 
      j = k = l 
      b iff valid(d1) && ... && valid(dj)
      (F'++F'')(r) = Directory({n1,...,nk})
      phii(F'++F'') for i from 1 to k
    Using assumption (3) we can rewrite the facts about phii as
      phii(Fi++F1++...++F(i-1)++F(i+1)++...++Fk++F'') for i from 1 to k
    By the definition of pull we also have 
      vi',di' = s.pull (E[x:=ni],r) (F'++F'') for i from 1 to k
      b' = valid(d1') && .. && valid(dk')
    By PushPull for s (k times) we then obtain 
      vi' = vi and valid(di') iff valid(di) for i from 1 to k
    It follows that b' iff b. 
  Case F(r) != Directory(_):
    Can't happen. By the definition of push we have
      phi = (fun F -> false)
    which contradicts the assumption that phi(F'++F'').
