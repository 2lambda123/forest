Assumptions:
(1) F++F = F
 
(2) F1++(F2++F3) = (F1++F2)++F3

(3) F1(r) defined or F2(r) defined implies (F1++F2)(r) defined

+--------------------------------------------------------------------------+
| SEMANTICS 
+--------------------------------------------------------------------------+

pull : Env * Path -> Filesystem -> Rep * Metadata
push : Env * Path -> Rep * Metadata -> Filesystem -> Constraint * Filesystem

pull (E,r) F = (v,d)
push (E,r) (v,d) F = phi,F'
---------------------------[PullPush]
F' = F and phi(F')

push (E,r) (v,d) F = phi,F'
phi(G1++F'++G2)
pull (E,r) (G1++F'++G2) = (v',d')
---------------------------------[PushPull]
v = v' and valid(d) iff valid(d')

+------+
| FILE |
+------+

File.pull (E,r) F = 
  if F(r) = File(n) then (n, true) 
  else ("",false)

File.push (E,r) (n,b) = 
  if b then 
    (fun F -> F(r) undefined or F(r) = File(n), F[r:=File(n)])
  else
    (fun F -> n = "" && F(r) != File(_), F)

PullPush:
  Assume 
    pull (E,r) F = (n,b)
    push (E,r) (n,b) F = phi,F'
  We analyze two cases. 
  Case b = true:
    By the definition of pull we have 
      F(r) = File(n)
    By the definition of push we have
      F' = F[r:=File(n)]
      phi = (fun F -> F(r) undefined or F(r) = File(n))
    We immediately have phi(F') and F' = F. 
  Case b = false:
    By the definition of pull we have 
      F(r) != File(_)
    By the definition of push we have 
      F' = F
      phi = (fun F -> F(r) != File(_))
    We immediately have phi(F') and F' ~ F. 
        
PushPull:
  Assume
    push (E,r) (n,b) F = phi,F'
    phi(G1++F'++G2)
    pull (E,r) (G1++F'++G2) = (n',b')
  We analyze two cases.
  Case b = true:    
    By the definition of push we have 
      phi = (fun F -> F(r) undefined or F(r) = File(n))
      F' = F[r:=File(n)]
    By phi(G1++F'++G2) and assumption (3) we have       
      (G1++F'++G2)(r) = File(n)
    By the definition of pull we have 
      n' = n and b' = true
    Hence, n' = n and b iff b', as required. 
  Case b = false:
    By the definition of push we have
      phi = (fun F -> F(r) != File(_))
      F' = F
    By phi(G1++F'++G2) we have 
      n = ""
      (G1++F'++G2)(r) != File(_) 
    By the definition of pull we have
      n' = "" and b' = false 
    Hence, n' = n and b iff b', as required. 

+-----------+
| DIRECTORY |
+-----------+ 

File.pull (E,r) F = 
  if F(r) = Directory([n1,...,nk]) then ([n1,...,nk], true) 
  else ([],false)

File.push (E,r) (l, b) = 
  if b then 
    (fun F -> F(r) undefined or F(r) = Directory(l), F[r:=Directory(l)])
  else
    (fun F -> l = [] && F(r) != File(_), F)

PullPush:
  Assume 
    pull (E,r) F = (l, b)
    push (E,r) (l, b) F = phi,F'
  We analyze two cases. 
  Case b = true:
    By the definition of pull we have 
      F(r) = Directory(l)
    By the definition of push we have
      F' = F[r:=Directory(l)] 
      phi = (fun F -> F(r) undefined or F(r) = Directory(l))
    We immediately have phi(F') and F' = F. 
  Case b = false:
    By the definition of pull we have 
      F(r) != File(_)
    By the definition of push we have 
      F' = F
      phi = (fun F -> F(r) != File(_))
    We immediatelt have phi(F') and F' = F.
        
PushPull:
  Assume
    push (E,r) (l, b) F = phi,F'
    phi(G1++F'++G2)
    pull (E,r) (G1++F'++G2) = (l',b')
  We analyze two cases.
  Case b = true:    
    By the definition of push we have 
      phi = (fun F -> F(r) undefined or F(r) = Directory(l))
      F' = F[r:=Directory(l)]
    By phi(G1++F'++G2) and assumption (3) we have       
      (G1++F'++G2)(r) = Directory(l)
    By the definition of pull we have 
      l' = l and b' = true
    Hence, l' = l and b iff b', as required. 
  Case b = false:
    By the definition of push we have
      phi = (fun F -> F(r) != File(_))
      F' = F
    By phi(G1++F'++G2) we have 
      l = []
      (G1++F'++G2)(r) != File(_) 
    By the definition of pull we have
      l' = [] and b' = false 
    Hence, l' = l and b iff b', as required. 

+------+
| PATH |
+------+ 

(e::s).pull (E,r) F = 
  let n = [[e]] (E,r) in 
  s.pull (E,r/n) F 

(e::s).push (E,r) (v,d) = 
  let n = [[e]] (E,r) in 
  s.push (E,r/n) (v,d)

PullPush:
  Assume 
    pull (E,r) F = (v,d)
    push (E,r) (v,d) F = phi,F'
  By the definition of pull we have 
    n = [[e]] (E,r)
    v,d = s.pull (E,r/n) F
  By the definition of push we also have  
    phi,F' = s.push (E,r/n) (v,d) F
  By PullPush for s we obtain
    F' = F and phi(F') 
  as required. 

PushPull:
  Assume
    push (E,r) (v,d) F = phi,F'
    phi(G1++F'++G2)
    pull (E,r) (G1++F'++G2) = (v',d')
  By the definition of push we have 
    n = [[e]] (E,r)
    phi,F' = s.push (E,r/n) (v,d)
  By the definition of pull we also have 
    v',d' = s.pull (E,r/n) (G1++F'++G2)
  By PushPull for s we obtain 
    v' = v and valid(d') iff valid(d)
  as required.

+------+
| PAIR |
+------+ 

<x:s1,s2>.pull (E,r) F = 
  let v1,d1 = s1.pull (E,r) F in 
  let v2,d2 = s2.pull (E[x:=v1],r) F in
  ((v1,v2),(valid(d1) && valid(d2),d1,d2))

<x:s1,s2>.push (E,r) ((v1,v2),(b,d1,d2)) F = 
  let phi1,F1 = s1.push (E,r) (v1,d1) F in 
  let phi2,F2 = s1.push (E[x:=v1],r) (v2,d2) F in 
  let phi = (fun F -> (b = valid(d1) && valid(d2)) && phi1(F) && phi2(F)) in 
  (phi, F1++F2)

PullPush:
  Assume 
    pull (E,r) F = ((v1,v2),(b,d1,d2))
    push (E,r) ((v1,v2),(b,d1,d2)) F = phi,F'
  By the definition of pull we have 
    v1,d1 = s1.pull (E,r) F
    v2,d2 = s2.pull (E[x:=v1],r) F
    b = valid(d1) && valid(d2)
  By the definition of push we have
    phi1,F1 = s1.push (E,r) (v1,d1) F
    phi2,F2 = s2.push (E[x:=v1],r) (v2,d2) F in 
    F' = F1++F2
    phi = (fun F -> (b = valid(d1) && valid(d2)) && phi1(F) && phi2(F))
  By PullPush for s1 and s2 we have 
    F1 = F and phi1(F1)
    F2 = F and phi2(F2)
  By assumption (1) we also have 
    F = F1++F2
  Hence, F' = F and phi(F'), as required. 
  
PushPull:
  Assume
    push (E,r) ((v1,v2),(b,d1,d2)) F = phi,F'
    phi(G1++F'++G2)
    pull (E,r) (G1++F'++G2) = ((v1',v2'),(b',d1',d2'))
  By the definition of push we have 
    phi1,F1 = s1.push (E,r) (v1,d1) F
    phi2,F2 = s2.push (E[x:=v1],r) (v2,d2) F
    F' = F1++F2
    phi = (fun F -> (b = valid(d1) && valid(d2)) && phi1(F) && phi2(F))
  By the definition of phi we have 
    b = valid(d1) && valid(d2)
    phi1(G1++F'++G2)
    phi2(G1++F'++G2)
  By assumption (2) we have 
    (G1++(F1++F2)++G2) = (G1++F1++(F2++G2)) 
                       = ((G1++F1)++F2++G2)
  Hence we also have
    phi1(G1++F1++(F2++G2))
    phi2((G1++F1)++F2++G2)
  Moreover, by the definition of pull we have 
    v1',d1' = s1.pull (E,r) (G1++F1++(F2++G2))
    v2',d2' = s2.pull (E[x:=v1],r) ((G1++F1)++F2++G2)
    b' = valid(d1') && valid(d2')
  By PushPull for s1 and s2 we obtain
    v1' = v1 and valid(d1') iff valid(d1)
    v2' = v2 and valid(d2') iff valid(d2)
  It follows that b' iff b. 

+---------------+
| COMPREHENSION |
+---------------+ 
    
[ s | x in e ].pull (E,r) F = 
  let [n1,...,nk] = [[e]] (E,r) in 
  let vi,di = s.pull (E[x:=ni],r) F for i from 1 to k in 
  let b = valid(d1) && ... && valid(dk) in 
  ([v1,...,vk],(b,[d1,...,dk]))

[ s | x in e ].push (E,r) ([v1,...,vj],(b,[d1,...,dl]) F = 
  let [n1,...,nm] = [[e]] (E,r) in 
  let k = min(j,l,m) in 
  let phii,Fi = s.push (E[x:=ni],r) (vi,di) F for i from 1 to k in 
  let phi = (fun F -> j = l = m = k 
                   && (b = valid(d1) && ... && valid(dk))
                   && phi1(F) && ... && phik(F)) in 
  (phi,F1++...++Fk)

PullPush:
  Assume 
    pull (E,r) F = ([v1,...,vk],(b,[d1,...,dk]))
    push (E,r) ([v1,...,vk],(b,[d1,...,dk])) F = phi,F'
  By the definition of pull we have 
    [[e]] (E,r) = [n1,...,nk] 
    vi,di = s.pull (E[x:=ni],r) F for i from 1 to k
    b = valid(d1) && ... && valid(dk)
  By the definition of push we have
    phii,Fi = s.push (E[x:=ni],r) (vi,di) F for i from 1 to k
    F' = F1++...++F2
    phi = (fun F -> j = l = k 
                 && (b = valid(d1) && ... && valid(dk))
                 && phi1(F) && ... && phik(F))
  By PullPush for s (k times) we have 
    Fi = F and phii(Fi) for i from 1 to k
  By assumption (1) (k times) we also have 
    F = F1++...++Fk
  Hence, F' = F and phi(F'), as required. 
  
PushPull:
  Assume
    push (E,r) ([v1,...,vj],(b,[d1,...,dl])) F = phi,F'
    phi(G1++F'++G2)
    pull (E,r) (G1++F'++G2) = ([v1',...,vo'],(b,[d1',...,dp']))
  By the definition of push we have 
    [[e]] (E,r) = [n1,...,nm]
    k = min(j,l,m)
    phii,Fi = s.push (E[x:=ni],r) (vi,di) F for i from 1 to k 
    F' = F1++...++Fk
    (fun F -> j = l = k 
           && (b = valid(d1) && ... && valid(dk))
           && phi1(F) && ... && phik(F))
  By the definition of phi we have 
    j = l = m = k &&
    b = valid(d1) && ... && valid(dk)
    phii(G1++F'++G2) for i from 1 to k
  By assumption (2) we have 
    (G1++(F1++...++Fk)++G2) = (G1++F1++(F2++...++Fk++G2)) 
                              ...
                            = ((G1++F1++...++F(k-1))++Fk++G2)
  Hence we also have
    phi1(G1++F1++(F2++...++Fk++G2))
    ...
    phik((G1++F1++...++F(k-1))++Fk++G2)
  Moreover, by the definition of pull we have 
    k = o = p 
    v1',d1' = s.pull (E[x:=ni,r) (G1++F1++(F2++G2))
    ...
    vk',dk' = s.pull (E[x:=nk],r) ((G1++F1++...++F(k-1))++Fk++G2)
    b' = valid(d1') && ... && valid(dk')
  By PushPull for s (k times) we obtain
    vi' = vi and valid(di') iff valid(di) for 1 from 1 to k
  It follows that [v1,...,vk] = [v1',...,vk'] and b' iff b.
