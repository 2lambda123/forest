+------------+
| DATA MODEL |
+------------+

n ::= ...            -- STRINGS

p,q ::=              -- PATHS
  | .                -- current
  | ..               -- ancestor
  | b                -- PADS-described name
  | p/p              -- concatenation
  | /p               -- rooted path
  | x::p             -- path binder

-- question: do we also want XPath-like operators?
  | //b              -- descendant

r,s ::=              -- NORMAL PATHS
  | /n1/ ... /nk

m ::=                -- METADATA
    { owner : int;
      group : int;
      permissions : string; 
      created : int; 
      accessed : int;
      modified : int; }

T ::= -- FILESYSTEM CONTENTS
  | file(n)
  | dir({n1,...,nk})
  | link(p)

F ::= -- FILESYSTEM
  | { r |-> m * T }

Definition: F is WELL-FORMED if and only if it is a path-prefix-closed
finite map from normal paths to T and for all normal paths r in dom(F) 
either 
  (1) F(r) = m * dir{n1,...,nk} or 
  (2) F(r) = m * file(n) and r/n not in dom(F)
  (3) F(r) = m * link(p) and r/n not in dom(F)

+--------+
| SYNTAX |
+--------+

s ::=                -- SPECIFICATION
    | k              -- constant (e.g., dir, file, link, csv, xml, ascii, etc.)
    | Adhoc(b)       -- PADS-described data
    | ^e             -- symbolic link
    | Pred(e)        -- predicate
    | Computed(e)    -- computed value
    | Transform(e,s) -- transformation
    | e : s          -- path 
    | <x:s, s>       -- dependent pair
    | s|s            -- union
    | U (x in e) . s -- structural recursion
    | ~s             -- negation 

e ::= ...

+-----------+
| SEMANTICS |
+-----------+

We assume a collection of type-indexed evaluation functions for expressions

  eval_tau : env * F * norm path * exp -> env * tau

The judgment E; F; r |= s ==> v * d relates an environment E, file
system F, normal path r, specification s, value v, and parse
descriptor d.  The judgment is a total function from tuples (E,F,r,s)
to non-empty sets of pairs (v,d). We maintain the invariant that r in
dom(F).

Parse Descriptors d have the following shape:

type header = bool
type 'a pd  = header * 'a

We use the function valid to determine if the data described by a was
parsed successfully:

fun valid (x:'a pd) : header = pi_1 x
fun desc (x:'a pd) : header = pi_2 x

We also assume a standard typing judgment for expressions E |- e : tau

=========
= QUERY =
=========

This judgement provides a facility for users to parse using
specifications and arbitrary path expresions.

eval_norm_path({},F,/,e) = E',r
E';F;r |= s ==> (v,d)
-------------------------------
F;e |= s ==> (v,d)

============
= CONSTANT =
============

----------------------------
E;F;r |= k ==> check_k(F(r))

Here are several instances of check_k:

  * check_any(m,_) = ((),(true,m))
    - RP: unit
    - PD: meta pd

  * check_True(m,c) = (c,(true,m))
    - RP: contents 
    - PD : meta pd
    -- JNF: what do folks think of this "raw" rep?

  * check_dir(m,dir(cs)) = (cs,(true,m)) 
  * check_dir(m,_) = ({},(false,m)) 
    - RP: string set  
    - PD: meta pd

  * check_file(m,file(n)) = (n,(true,m))
  * check_file(m,_) = ("",(false,m))
    - RP: string 
    - PD: meta pd 

  * check_link(m,link(p)) = (p,(true,m)) 
  * check_link(m,_) = (/.,(false,m))
    - RP: path 
    - PD: meta pd

  * check_csv(m,file(n)) = (v,(true,m)) when valid_csv(n) = v 
  * check_csv(m,_) = (empty_csv,(false,m)) 
    - RP: csv_value 
    - PD: meta pd

=========
= ADHOC =
=========
RP: b_{RP} 
PD: (b_{PD} * meta) pd

F(r) = (m,file(n'))
b(E,n') = (v,d)
-----------------------------------------
E;F;r |= Adhoc(b) ==> (v,(valid d,(d,m)))

F(r) = (m,dir(_)) or (m,link(_))
b(E,"") = (v,d)
---------------------------------------
E;F;r |= Adhoc(b) ==> (v,(false,(d,m)))

========
= LINK =
========
RP: norm_path 
PD: meta pd

F(r) = m,link(p)
eval_norm_path(E,F,r,e) = (_,r')
eval_norm_path({},F,r,p) = (_,r'')
r' = r'' 
----------------------------------------------------------
E;F;r |= ^e ==> (r'',(b,m))

F(r) = m,file(_) or 
F(r) = m,dir(_)  
--------------------------------
E;F;r |= ^e ==> (/,(false,m))

=============
= PREDICATE = 
=============
RP: unit
PD: unit pd

-------------------------------------------------
E;F;r |= Pred(e) ==> ((),(eval_bool(E,F,r,e),()))

===========
= COMPUTE =
===========
RP: tau
PD: unit pd

E |- e : tau
eval_tau(E,F,r,e) = (_,t)
-------------------------------------
E;F;r |= Compute(e) ==> (t,(true,()))

=============
= TRANSFORM =
=============
RP: t_{RP}
PD: t_{PD} pd

E |- e : (s_{RP} * s_{PD}) -> (t_{RP} * t_{PD}) pd
eval_fun(E,F,r,e) = (_,f)
E;F;r |= s ==> (v,d)
--------------------------------------
E;F;r |= Transform[t](e,s) ==> f (v,d)

Notation: e @[t] s ~~> Transform[t](e,s)

========
= PATH = 
========
RP: s_{RP}
PD: (bool * norm_path * s_{PD}) pd 

(The bool component of the PD indicates if the path is in F.)

eval_norm_path(E,F,r,e) = (E',r')
r' in dom(F)
E';F;r' |= s ==> (v,d)
---------------------------------------------
E;F;r |= e : s ==> (v,(valid d,(true,r',d)))

--DPW: I assume we have functions to generate default reps and pds.

eval_norm_path(E,F,r,e) = (E',r')
r' not in dom(F)
--------------------------------------------------------------------
E;F;r |= e : s ==> (default_rep(s),(false,(false,r',default_pd(s))))

========
= PAIR = 
========
RP: s1_{RP} * s2_{RP}
PD: (s1_{PD} * s2_{PD}) pd

E;F;r |= s1 ==> (v1,d1)
E[x:=v1,x_d:=d1];F;r |= s2 ==> (v2,d2)
------------------------------------------------------------------
E;F;r |= <x:s1, s2> ==> ((v1,v2),(valid d1 && valid d2, (d1,d2)))

=========
= UNION = 
=========
RP: s1_{RP} + s2_{RP} 
PD: (s1_{PD} + s2_{PD}) pd

E;F;r |= s1 ==> (v1,d1) 
valid d1 = true
--------------------------------------------
E;F;r |= s1|s2 ==> (inl v1,(true, inl d1))

E;F;r |= s1 ==> (v1,d1)
valid d1 = false
E;F;r |= s2 ==> (v2,d2)
-------------------------------------------
E;F;r |= s1|s2 ==> (inr v2,(valid d2, inr d2))

=================
= COMPREHENSION =
=================
RP: s_{RP} set
PD: (s_{PD} set) pd

E |- e : tau set
eval_tau_set(E,F,r,e) = (E',T) 
S = { (v,d) | t in T and E[x:=t];F;r |= s ==> (v,d) }
-- JNF: note that we do not add x_pd to E!
----------------------------------------------------------------
E;F;r |= { s | x in e } ==> (FST S, (&& (VALID (SND S)), DESC (SND S)))

-- We lift {fst,snd,valid,desc,&&} to sets in the obvious way:
  FST : ('a * 'b) set -> 'a set
  SND : ('a * 'b) set -> 'b set
  VALID : ('a pd) set -> header set
  DESC : ('a pd) set -> 'a set
  && : bool set -> bool

============
= NEGATION =
============
RP: s_{RP}
PD: s_{PD} pd

E;F;r |= s ==> (v,d)
--------------------------------------------
E;F;r |= ~s ==> (v,(not(valid d),desc d))

=================
= DERIVED FORMS = 
=================

The RP and PDs for derived forms stated here are for illustrative
purposes only. They are computed from the primitives.

  * where clauses
    RP: s_{RP}
    PD: s_{PD}
    x:s where e =def= 
      (fun ((v1,_),(b,(d1,()))) -> (v1,(b,d1)))
      @[s_{RP},s_{PD}]
      <x:s,Pred e>

===============================
= Example #1: empty directory =
===============================

F = / => (m1, dir{foo,bar})
    /foo => (m2, dir{baz})
    /bar => (m3, dir{})
    /foo/baz => (m4, file("hello world!"))

JNF: we'd like to write this

  EmptyDir =def= < dir, y:{ x:True | x in "./*" } > where |y| = 0

but it's not syntactically correct. What we'd actually write:

  EmptyDir =def= y:< dir, { x:True | x in "./*" } > where |pi_2(y)| = 0

Do we care about this little bit of clunkiness?

Some examples involving EmptyDir 

{};F;/bar |= EmptyDir ==> < {},{} >, (true,(m3,{}))

  sub-derivations:

  {};F;/foo/bar |= dir ==> {},(true,m3)
  {};F;/foo/bar |= { x : True | x in "./*" } ==> {},(true,{})


{};F;/foo |= EmptyDir ==> <{baz},{file("hello world!")}>, 
                          (false,(m2,{(true,/foo/baz,m4)}))

  sub-derivations:
  
  {};F;/foo |= dir ==> {baz},(true,m2)
  {};F;/foo/baz => { x : True | x in "./*" } ==> {file("hello world!")},
                                                 (true,{(true,/foo/baz,m4)})

================================================================================
MINEFIELD : The examples below this may be out of sync with the above calculus
================================================================================

===================================
= Example #2: exact specification =
===================================

F = 
  / => dir{foo,bar}
  /foo => dir{baz}
  /bar => dir{}
  /foo/baz => file("hello world!")

s_F = 
 "/" : 
    < dir,
      "foo" : < dir, 
                "baz" : file >,
      "bar" : < dir, 
                empty > > 

{};F;/ |= s_F ==> 
  (< {foo,bar}, 
     < ("foo", < {baz}, ("baz" : "hello world!")> ),
       ("bar", < {}, dir {} >) > >, 
   d)
  and ok d = true

===================================
= Example #3: singleton directory =
===================================

F = 
  / => dir{foo,bar}
  /foo => file("hello world!")
  /bar => dir{baz}
  /bar/baz => file("goodbye world!")

singleton1 = < dir, x:("*" : True)*, Pred(|x| = 1)>

or shorter...

singleton2 = < x:("*" : True)*, Pred(|x| = 1)>
singleton3 = < x:dir, Pred(|x| = 1)>

or even shorter...

singleton4 = x:("*" : true)* where |x| = 1
singleton5 = x:dir where |x| = 1

Let's try the simplest one first...

{};F;/ |= singleton5 ==> ({foo,bar},where_fd(dir_pd(true),pred_pd(false)))
{};F;/bar |= singleton5 ==> ({baz},where_fd(dir_pd(true),pred_pd(true)))

{};F;/ |= singleton4 ==> ( { ("foo", file("hello world!")), ("bar", dir{baz}) }, 
                             where_pd(...,pred_pd(false))
{};F;/bar |= singleton4 ==> ( { ("baz": file("goodbye world!")) }, 
                              where_pd(...,pred_pd(true))

========================================
= Directories with specified contents  =
========================================

Directory only containing files with extension ".exe".

s1 = < dir, x:("*.exe" : file)*, y:("*" : file)*, Pred(|x| = |y|) > 

Observe that s1 is not so nice when the directory contains both .exe
and non-.exe files because the y part of the representation contains
all files not just the non-.exe files. Here is a refinement of s1 that
excludes those files:

s2 = < dir, x:("*.exe" : file)*, y:((/regexp_complement "*.exe"/ : file)* ), Pred(|y| = 0)>

Can we remove the predicate negate the y part?

s3 = < dir, x:("*.exe" : file)*, y:~((/regexp_complement "*.exe"/ : file)+) >

Directory only containing items that match a spec s_arg 

s4 = < dir, x:("*" : s_arg)*, y:("*" : True)*, Pred(|x| = |y|) > 

Directory containing two .exe files and at least one .txt file.

s5 = < dir, x:("*.exe" : file)*, y:("*.txt" : file)*, Pred(|x| = 2 /\ |y| >= 1)>

===========================
= Multiple path wildcards =
===========================

Any number of directories, each with at least one text file:

s1 = ( "*" : !( "*.txt" : file ) )*

All of the text files in any number of directories. The rep flattens
the nesting structure:

s2 = U( x in "*/*.txt" ) . { x : file } || {}

     { x : file | x in "*/*.txt"} ~~> U( x in "*/*.txt" ) . { x : file } 

s2 = ("*/*.txt" : True)*

Here's a version, where we do the iteration explicitly (i.e., not in
the expression language for paths):

( "*/*.dir" / ( "*.txt" : file ))*

s1 = U (d in dirs("*")) . U (f in d/"*.txt") . { f : file } || {}
s2' = U (d in dirs("*")) . U (f in d/"*.txt") . { f : file } || {}

/d = dir{a.txt,b.txt}
/d/a.txt = file("hello")
/d/b.txt = file("world")


=======================
= More (Simple) Sugar = 
=======================

{ s | x in e1, y in e2 } =def= U (x in e1) . U (y in e2) . { s }

< s1,s2 > =def= < _:s1, _:s2 >

(e : s)+ =def=
  (fun ((vh,vt),pair_pd(d,D)) -> ({vh} U vt,srec_pd({d} U D))) 
  @ 
  < (e : s),(e : s)* > 

EmptyDir =def= ~(!("*" : True))

False =def= ~True

 -- s? = s | True

========
= Todo =
========
 - recursion operator

================================================================================
BONEYARD : Everything below here is deprecated
================================================================================

=====================
= Old Derived Forms =
=====================

  * Empty tau set
    RP: tau set 
    PD: ()
    { }_tau =def= Compute({}_tau)

  * Full union 
    where s1_{RP} = s2_{RP}
    RP: s1_{RP} 
    PD: s1_{PD} + s2_{PD}
    s1 || s2 =def= 
      (fun (v,pd) -> match v with 
        | inl v' -> (v',pd)
        | inr v' -> (v',pd))
      @[s1_{RP},s1_{PD} + s2_{PD}]
      (s1 | s2)

  * Comprehension
    RP: s_{RP} set
    PD: s_{PD} set
    { s | x in e } =def= U (x in e) . { s }

  * Path set Kleene star
    RP: s_{RP} set
    PD: s_{PD} set + ()
    (e :* s) =def= U (x in e) . ({ x : s } || {})

=================
= SINGLETON SET = 
=================
RP: s_{RP} set 
PD: s_{PD} pd

E;F;r |= s ==> (v,d)
------------------------------------
E;F;r |= { s } ==> ({v},(valid d,d))

==========
= CHOOSE = 
==========

--JNF: removed this because we don't have a compelling use case for it

RP : e_{RP} option where s_{RP} = e_{RP} set
PD : choose_pd of (bool * s_{PD})
ok: (fun (choose_pd(b,d)) -> b && s_{ok} d) 

E;F;r |= s ==> ({v1,...,vk},d)
i in 1..k
---------------------------------------
E;F;r |= Choose(s) ==> (Some vi,choose_pd(true,d))

E;F;r |= s ==> ({},d)
---------------------------------------
E;F;r |= Choose(s) ==> (None,choose_pd(false,d))

  * Some path
    RP: norm_path * s_{RP}
    PD: choose_pd of 
          (srec_pd of 
            (union_pd of 
               (singleton_pd of (path_pd of s_{PD}) + compute_pd)))

    !(e : s) =def= Choose ( (e : s)* )


========
= TRUE =
========
JNF: removed this because it is redundant (see k_any)

RP: file system contents
PD: true_pd of bool

--------------------------------------
E;F;r |= True ==> (F(r),true_pd(true))
