+------------+
| DATA MODEL |
+------------+
n ::= ...            -- STRINGS

p,q ::=              -- PATHS
  | .                -- current
  | ..               -- ancestor
  | b                -- PADS-described name
  | p/p              -- concatenation
  | /p               -- rooted path
  | x $ p             -- path binder

r,s ::=              -- NORMAL PATHS
  | /n1/ ... /nk

m ::=                -- METADATA
    { owner : int;
      group : int;
      permissions : string; 
      created : int; 
      accessed : int;
      modified : int; }

T ::= -- FILESYSTEM CONTENTS
  | file(n)
  | dir({n1,...,nk})
  | link(p)

F ::= -- FILESYSTEM
  | { r |-> m * T }

Definition: F is WELL-FORMED if and only if it is a path-prefix-closed
finite map from normal paths to T and for all normal paths r in dom(F) 
either 
  (1) F(r) = m * dir{n1,...,nk} or 
  (2) F(r) = m * file(n) and r/n not in dom(F)
  (3) F(r) = m * link(p) and r/n not in dom(F)

+--------+
| SYNTAX |
+--------+
s ::=                -- SPECIFICATION
    | k              -- constant (e.g., dir, file, link, csv, xml, ascii, etc.)
    | Adhoc(b)       -- PADS-described data
    | ^e             -- symbolic link
    | Pred(e)        -- predicate
    | Computed(e)    -- computed value
    | Transform(e,s) -- transformation
    | e :: s         -- path 
    | <x:s, s>       -- dependent pair
    | s|s            -- union
    | { s | x in e } -- structural recursion
    | ~s             -- negation 

e ::= ...

+-----------+
| SEMANTICS |
+-----------+
We assume a collection of type-indexed evaluation functions for expressions

  eval_tau : env * F * norm path * exp -> env * tau

The judgment E; F; r |= s ==> v * d relates an environment E, file
system F, normal path r, specification s, value v, and parse
descriptor d.  The judgment is a total function from tuples (E,F,r,s)
to non-empty sets of pairs (v,d). We maintain the invariant that r in
dom(F).

Parse Descriptors d have the following shape:

type header = bool
type 'a pd  = header * 'a

We use the function valid to determine if the data described by a was
parsed successfully:

fun valid (x:'a pd) : header = pi_1 x
fun desc (x:'a pd) : header = pi_2 x

We also assume a standard typing judgment for expressions E |- e : tau

=========
= QUERY =
=========

This judgement provides a facility for users to parse using
specifications and arbitrary path expresions.

eval_norm_path({},F,/,e) = E',r
E';F;r |= s ==> (v,d)
-------------------------------
F;e |= s ==> (v,d)

======================================
= No RP --> PD Functional Dependency =
======================================

DAVE: I decided that we didn't need to enforce this invariant in this
part of the theory.  It just seemed messy.  So now there is no such
functional dependency.  The rep and pd types can be calculated from
the pads description.

============
= CONSTANT =
============

----------------------------
E;F;r |= k ==> check_k(F(r))

Here are several instances of check_k:

  * check_any(m,_) = ((),(true,m))
    - RP: unit
    - PD: meta pd

  * check_True(m,c) = (c,(true,m))
    - RP: contents
    - PD : meta pd
    -- JNF: what do folks think of this "raw" rep?

  * check_dir(m,dir(cs)) = (cs,(true,m)) 
  * check_dir(m,_) = ({},(false,m)) 
    - RP: string set
    - PD: meta pd

  * check_file(m,file(n)) = (n,(true,m))
  * check_file(m,_) = ("",(false,m))
    - RP: string
    - PD: meta pd 

  * check_link(m,link(p)) = (p,(true,m)) 
  * check_link(m,_) = (/.,(false,m))
    - RP: path
    - PD: meta pd

  * check_csv(m,file(n)) = (v,(true,m)) when valid_csv(n) = v 
  * check_csv(m,_) = (empty_csv,(false,m)) 
    - RP: csv_value
    - PD: meta pd

=========
= ADHOC =
=========

RP: b_{RP}
PD: (b_{PD} * meta) pd

F(r) = (m,file(n'))
b(E,n') = (v,d)
-----------------------------------------
E;F;r |= Adhoc(b) ==> (v,(valid d,(d,m)))

F(r) = (m,dir(_)) or (m,link(_))
b(E,"") = (v,d)
---------------------------------------
E;F;r |= Adhoc(b) ==> (v,(false,(d,m)))

========
= LINK =
========
RP: norm_path
PD: meta pd

F(r) = m,link(p)
eval_norm_path(E,F,r,e) = (_,r')
eval_norm_path({},F,r,p) = (_,r'')
r' = r'' 
----------------------------------------------------------
E;F;r |= ^e ==> (r'',(true,m))

F(r) = m,file(_) or 
F(r) = m,dir(_)  
--------------------------------
E;F;r |= ^e ==> (/,(false,m))

=============
= PREDICATE = 
=============
RP: unit
PD: unit pd

-------------------------------------------------
E;F;r |= Pred(e) ==> ((),(eval_bool(E,F,r,e),()))

===========
= COMPUTE =
===========

RP: tau 
PD: unit pd

E |- e : tau
eval_tau(E,F,r,e) = (_,t)
-------------------------------------
E;F;r |= Compute(e) ==> (t,(true,()))

=============
= TRANSFORM =
=============
RP: t_rep
PD: t_pd 

E |- e : (s_{RP} * s_{PD}) -> (t_rep * t_pd)
exists x . t_pd = x pd
eval_fun(E,F,r,e) = (_,f)
E;F;r |= s ==> (v,d)
--------------------------------------
E;F;r |= Transform[t_rep,t_pd](e,s) ==> f (v,d)

Notation: e @[t_rep,t_pd] s ~~> Transform[t_rep,t_pd](e,s)

========
= PATH = 
========
RP: s_{RP}
PD: (bool * norm_path * s_{PD}) pd 

(The bool component of the PD indicates if the path is in F.)

eval_norm_path(E,F,r,e) = (E',r')
r' in dom(F)
E';F;r' |= s ==> (v,d)
---------------------------------------------
E;F;r |= e :: s ==> (v,(valid d,(true,r',d)))

--DPW: I assume we have functions to generate default reps and pds.

eval_norm_path(E,F,r,e) = (E',r')
r' not in dom(F)
--------------------------------------------------------------------
E;F;r |= e :: s ==> (default_rep(s),(false,(false,r',default_pd(s))))

========
= PAIR = 
========
RP: s1_{RP} * s2_{RP}
PD: (s1_{PD} * s2_{PD}) pd

E;F;r |= s1 ==> (v1,d1)
E[x:=v1,x_d:=d1];F;r |= s2 ==> (v2,d2)
------------------------------------------------------------------
E;F;r |= <x:s1, s2> ==> ((v1,v2),(valid d1 && valid d2, (d1,d2)))

=========
= UNION = 
=========
RP: s1_{RP} + s2_{RP} 
PD: (s1_{PD} + s2_{PD}) pd

E;F;r |= s1 ==> (v1,d1) 
valid d1 = true
--------------------------------------------
E;F;r |= s1|s2 ==> (inl v1,(true, inl d1))

E;F;r |= s1 ==> (v1,d1)
valid d1 = false
E;F;r |= s2 ==> (v2,d2)
-------------------------------------------
E;F;r |= s1|s2 ==> (inr v2,(valid d2, inr d2))

=================
= COMPREHENSION =
=================
RP: s_{RP} set
PD: (s_{PD} set) pd

E |- e : tau set
eval_tau_set(E,F,r,e) = (E',T) 
S = { (v,d) | t in T and E[x:=t];F;r |= s ==> (v,d) }
-- JNF: note that we do not add x_pd to E!
----------------------------------------------------------------
E;F;r |= { s | x in e } ==> (FST S, (&& (VALID (SND S)), DESC (SND S)))

-- We lift {fst,snd,valid,desc,&&} to sets in the obvious way:
  FST : ('a * 'b) set -> 'a set
  SND : ('a * 'b) set -> 'b set
  VALID : ('a pd) set -> header set
  DESC : ('a pd) set -> 'a set
  && : bool set -> bool

============
= NEGATION =
============
RP: s_{RP}
PD: s_{PD} 

E;F;r |= s ==> (v,d)
--------------------------------------------
E;F;r |= ~s ==> (v,(not(valid d),desc d))
