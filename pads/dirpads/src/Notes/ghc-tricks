GHCI options:
Babylon:/Users/kfisher/pads/dirpads/language-c-quote>
~/sw/ghc-head/bin/ghci -package parsec -XQuasiQuotes -XTemplateHaskell -XDeriveDataTypeable -XScopedTypeVariables -XMultiParamTypeClasses -XFunctionalDependencies -XFlexibleInstances -XUndecidableInstances -XNamedFieldPuns -XRecordWildCards -XStandaloneDeriving
or
Prelude> :set -XScopedTypeVariables
Prelude> :set -XTemplateHaskell
etc

Modules to load: 
:m + Language.Haskell.TH
:m + Monad


Updating head version:
./darcs-all pull -a
perl boot
./configure --prefix /Users/kfisher/ghc-headXXX
make
make install

To uninstall GHC, execute
  /Library/Frameworks/GHC.framework/Tools/Uninstaller


{- 
PRINTING result of pads compiler:
let d = (make_pads_declarations [$pads|Foo = (Pint, '|', Pint)|]) 
*Examples.First Language.Haskell.TH> :t d
d :: Q [Dec]
*Examples.First Language.Haskell.TH> runQ d >>= print
[TySynD Foo [] (ConT GHC.Unit.())]

*Examples.First Language.Haskell.TH> :m + Monad
*Examples.First Language.Haskell.TH Monad> liftM ppr_list (runQ d)
type Foo = (GHC.Types.Int, GHC.Unit.(), GHC.Types.Int)
type Foo_pd = (Language.C.Padsc.Base_pd,
               (Language.C.Padsc.Base_pd,
                Language.C.Padsc.Base_pd,
                Language.C.Padsc.Base_pd))


z = "3+4"
r = parseExp z
Right v = r
resultS = liftM ppr (return v)

str = "let b = True in if b then 3+4 else x"
parse_result = parseExp str
Right te = parse_result
teQ :: IO Exp = return te



Is there a way to get the system to show the TH representation
of declarations and types?
 -- runQ [d| type T = () |] >>= print
 -- runQ [t| Int -> Int |] >>= print
*Language.Pads.Quote> runQ [t|PadscT|] >>=print
ConT Language.Pads.Padsc.PadscT
-}

To update cabal:
darcs pull -a
follow instructions in readmes
remember to do -w to set which version of ghc system is for.

To install a package for head version of ghc:
Babylon:/Users/kfisher> ~/.cabal/bin/cabal install parsec -w ~/sw/ghc-head/bin/ghc --with-haddock=/Users/kfisher/sw/ghc-head/bin/haddock

To install local package for head version of ghc
~/.cabal/bin/cabal install  -w ~/sw/ghc-head/bin/ghc --with-haddock=/Users/kfisher/sw/ghc-head/bin/haddock

*****************************************************************
To generate docs during cabal build:

In the default .cabal/config file you should see an option called
"documentation", that will be commented out, as well as set to False.
Uncommenting that line and setting the value to True should build
documentation the next time you install a package.

To re-install a package that doesn't have any documentation built, this
command should suffice:

$ cabal install <package> --reinstall

Also of use are the fields underneath the "install-dirs user" section
of .cabal/config.  You can override the values listed there to provide
your own installation paths for package data.

What you'll need to do to get that is install the hscolour package.
From that point, you'll be able to generate documentation with

$ cabal haddock --hyperlink-source

Unfortunately, "cabal install" doesn't seem to accept the
--hyperlink-source argument, so to replicate this functionality you'll
need to do:

$ cabal unpack <package>
$ cd <package-version>
$ cabal configure
$ cabal haddock --hyperlink-source
$ cabal build
$ cabal install --only

This process will not do any dependency resolution, so it's not ideal.

It looks like this has already been reported as a bug:
http://hackage.haskell.org/trac/hackage/ticket/517
So other people are running into the same problem :)

--trevor elliott
*****************************************************************



*****************************************************************
Loading packages into running ghci:
:set -package parsec

-- To install documentation, uncomment out doc flag in .cabal and set to True
-- To tell cabal which version of haddoc to use.
~/.cabal/bin/cabal install parsec -w ~/sw/ghc-head/bin/ghc --reinstall --with-haddock=/Users/kfisher/sw/ghc-head/bin/haddock

To access GHC parser:

*Language.C.Padsc Language.Haskell.TH Language.Haskell.TH.Syntax> :set -package ghc
package flags have changed, resetting and loading new packages...
Loading package Cabal-1.6.0.3 ... linking ... done.
Loading package hpc-0.5.0.3 ... linking ... done.
Loading package ghc-6.10.4 ... linking ... done.
Prelude> :t parseModule
Prelude>:m +Parser
Prelude Parser> :t parseModule



GETTING GHC TO TELL YOU MORE:
kfisher-laptop:/Users/kfisher/pads/dirpads/language-c-quote>ghci -dppr-debug
GHCi, version 6.10.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer ... linking ... done.
Loading package base ... linking ... done.
Prelude> :i Int
data ghc-prim:GHC.Types.Int{(w) tc 3J}
  = ghc-prim:GHC.Types.I#{(w) d 6c} ghc-prim:GHC.Prim.Int#{(w) tc 3G}
  	-- Defined in ghc-prim:GHC.Types

***************************************************************
TUPLES
How should we deal with tuples and type classes?  We want to be able to make each pads
type an instance of various type classes (Data, Typeable, Pads, Default, Show, etc).
We don't know in advance how large tuples might be.  Type classes provide
the conditional form for instance declarations:
  instance (Pads a, Pads b) => Pads (a,b)
but a separate instance declaration is required for each arity tuple.  
Existing libraries seem to include an instance for each tuple size they think
is plausible.  Unfortunately, we don't know how large tuples we are going to get.
In cases where the description is generated automatically, they could get to be quite large...

We could introduce a newtype for each tuple we process and then make this newtype an
instance of the various type classes.  For top-level pads tuples, this choice seems reasonable
as we have a name.  On the other hand, it seems unreasonable, as every pads tuple of the
the same arity will be have in the same way.  (except parsing and unparsing, which we are
generating and so aren't involved in type classes).  If the user wanted a distinc type,
s/he could have always used a record type instead, which argues against generating a new
type.

Is there a way to test if a given instance declaration exists when we are generating code?

RECORDS
DERIVING/GENERATING TYPE CLASS INSTANCES

Proposal:
1. Allow deriving declarations to be separated from datatype declarations.
 data Color = Red | Blue
 ...
 type Color derives Eq

This way, derived instances can be generated in a different code module from the original,
which would be useful if the original module is not in the user's control.  It may result
in multiple dictionaries being generated for the same type, but all these dictionaries
would be the same, so the only issue would be one of code bloat, not semantics.  

2. Allow deriving declarations for tuple type constructor (family)
  type (*) derives Eq

This allows us to get ride of the finite families of instance declarations for some
number of tuple arities that currently abound.  This declaration conceptually generates an infinite
collection of dictionaries, but the compiler would instead create such dictionaries on demand.
During the stage of compilation when the compiler is inserting dictionaries,
it checks if the necessary dictionary already exists.  If it does, it uses it.  If not, it generates it.
If a tuple appears inside a datatype/record/type declaration, then the arity 
is fixed and the dictionary can be generated at that point. 

The intended semantics for the "type (*) derives Eq" declaration is a point-wise lifting
of the == function on each element of the tuple.  The point-wise lifting is often the
right implementation for tuples but not always, leading to (3).

3. Allow arbitrary type classes to be derivable by specifying a derivable clause in 
the definition of the type class:
  class Foo a where
    bar :: a -> String
    derivable [with baz]
Intuitively, if the [with baz] clause is omitted, then the compiler generates the
point-wise lifting of the methods of the class for any type declared to derive the class.
If the [with baz] clause is present, then baz is a template haskell function that
takes as an argument the TH representation of the type deriving class Foo and returns
the TH representation of the dictionary implementation for the type.  Using this mechanism,
we could specify that the derived implementation of the show method for the 
(*) (family of) type constructors starts with a left-paren, etc.  

This proposal would also mean that record declarations could easily pick up the point-wise
lifting of methods for any class marked as derivable.  

This change makes it so that no type classes needed to be "built-in" to the compiler.


********************************************************************************************
The module Data.Typeable has 7 type classes for various arity functions, each
mapping to TypeRep

********************************************************************************************
How do we make records instance of type classes?
Can records derive instance declarations?  
  Yes--- but only for built in type classes.  
  But, we can make it an instance of Typeable and Data
Why can't any class that wants to be defined pointwise be used in a deriving class?
Why can't deriving clauses be given anywhere, ie
data Color = Red | Blue
...
type Color derives Eq

then we could say
type (*) derives Eq  -- This would generate the pointwise solution.
                     -- wouldn't do the right thing for show

instance Show * => Show (*) where
  show ...

What if we wanted to define an implementation that would work for any arity?
  before, each, after

This has the effect of separating the scope of the instance declaration from the scope of the original type,
so two different people could ask to derive a particular dictionary.  On the other hand, the derived
dictionaries would be identical, and the deriving could be done once. 

Could the compiler generate an appopriate point-wise definition when it detects it needs one that doesn't already exist,
ie, when it goes to insert a dictionary and discovers one doesn't exist?

What about nested tuples?
Could always create dictionaries on demand...

What about cases where the code to generate for a tuple isn't entirely pointwise, such as show, but
it is still generic?

Is it true that if the compiler needs a given dictionary, it always has the know-how to construct one?

When you declare a new class, you could also define a deriver for it.  
The deriver should be a template haskell function that is given a representation of the type to be specialized
and produces the representation of the dictionary for the class, specialized to the supplied type.
