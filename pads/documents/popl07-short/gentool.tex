\section{The Generic Tool Framework}
\label{sec:gen-tool}

An essential benefit of \padsml{} is that it can provide users with a
high return-on-investment for describing their data. While the
generated parser and printer alone are enough to justify the user's
effort, we aim to increase the return by enabling users to easily
construct data analysis tools.
% However, there is a limit, both in resources and expertise, to the
% range of tool generators that we can develop.  Indeed, new and
% interesting data analysis tools are constantly being developed, and
% we have no hope of integrating even a fraction of them into the
% \padsml{} system ourselves.
To this end, we provide a simple framework for others to develop tool
generators.

The techniques of type-directed programming, known variously as
\textit{generic} or \textit{polytypic} programming, provide a
convenient conceptual starting point in designing a tool framework.
In essence, any tool generator is a function from a description to the
corresponding tool. As \padsml{} descriptions are types, a tool
generator is a type-directed function.

Support for some form of generic programming over data representations
and parse descriptors is an essential first step in supporting the
development of tool generators. While a full-blown generic programming
system like Generic Haskell~\cite{hinze+:generic-haskell} would be
useful in this context, \ocaml{} lacks a generic programming facility.
Yet, we can still achieve some of the benefits of generic programming
even without such a facility, as a number of useful data processing
tools can be specified genericly using only the \padsml\ compiler and
the \ocaml\ module system. 

In particular, many of the tools we have encountered 
perform their computations in a single pass over the representation
and corresponding parse descriptor, visiting each value in the data
with a pre-, post-, or in-order traversal.  This paradigm arises naturally
as it scales to very large data sets. It can be
abstracted in a manner similar to the generic functions of Lammel and
Peyton-Jones~\cite{lammel+:syb}. For each format description, we generate a
format-dependent traversal mechanism that implements a generalized
fold over the representation and parse descriptor corresponding to
that format. Then, tool developers can write a format-independent,
\emph{generic tool} by specifying the behaviour of the tool for each
\padsml{} type constructor. The traversal mechanism interacts with
generic tools through a signature that every generic tool must match.

The generic tool architecture of \padsml{} delivers a number of
benefits over the fixed architecture of \padsc{}. In \padsc{}, all
tools are generated from within the compiler. Therefore, developing a
new tool generator requires understanding and modifying the compiler.
Furthermore, the user selects the set of tools to generate when compiling the description.  In \padsml{}, tool generators can be
developed independent of the compiler and they can be developed more
rapidly because the ``boilerplate'' code to traverse data need not be
replicated for each tool generator. In addition, the user controls
which tools to ``generate'' for a given data format, and the choice
can differ on a program-by-program basis.

\subsection{The Generic-Tool Interface}
\label{sec:gentool-interface}

\begin{figure}
\begin{code}\scriptsize
\kw{module} \kw{type} S = \kw{sig}
 \kw{type} state
 ...
 \kw{module} Record : \kw{sig}
   \kw{type} partial_state
   \kw{val}  init          : (string * state) list -> state
   \kw{val}  start         : state -> Pads.pd_header 
                        -> partial_state
   \kw{val}  project       : state -> string -> state
   \kw{val}  process_field : partial_state -> string
                        -> state -> partial_state
   \kw{val}  finish        : partial_state -> state
 \kw{end}

 \kw{module} Datatype : \kw{sig}
   \kw{type} partial_state
   \kw{val}  init            : unit -> state
   \kw{val}  start           : state -> Pads.pd_header 
                          -> partial_state
   \kw{val}  project         : state -> string -> state option
   \kw{val}  process_variant : partial_state -> string 
                          -> state -> partial_state
   \kw{val}  finish          : partial_state -> state
 \kw{end}
  ...
\kw{end}
\end{code}
\vskip -2ex
\caption{Excerpt of generic-tool interface \texttt{Generic\_tool.S}.}
\label{fig:gentool-interface}
\end{figure}

The interface between format-specific traversals and generic tools is
specified as an \ocaml{} signature.  For every type constructor in
\padsml{}, the signature describes a sub-module that implements the
generic tool for that type constructor.  In addition, it specifies an
(abstract) type for auxiliary state that is threaded through the
traversal. \figref{fig:gentool-interface} contains an
excerpt of the signature that includes the signatures of the
\cd{Record} and \cd{Datatype} modules.  The signatures of other
modules are quite similar.

The \cd{Record} module includes a type \cd{partial_state} that allows
tools to represent intermediate state in a different form than the
general state. The \cd{init} function forms the state of the record
from the state of its fields. The \cd{start} function receives the PD
header for the data element being traversed and begins processing the
element. Function \cd{project} takes a record's state and the name of
a field and returns that field's state. Function \cd{process_field}
updates the intermediate state of the record based on the name and
state of a field, and \cd{finish} converts the finished intermediate
state into general tool state.  Note that any of these functions could
have side effects.

Although the \cd{Datatype} module is similar to the \cd{Record} module,
there are some important differences. The \cd{Datatype} \cd{init} function 
does not
start with the state of all the variants. Instead, a variant's state is
added during processing so that only variants that have been
encountered will have corresponding state. For this reason,
\cd{project} returns a \cd{state option}, rather than a \cd{state}.
This design is essential for supporting recursive datatypes as trying
to initialize the state for all possible variants of the datatype
would cause the \cd{init} function to loop infinitely.
\cut{
\begin{figure}
\begin{code}\scriptsize
\kw{module} Traverse (Tool : Generic_tool.S) :
\kw{sig}
  \kw{val} init : unit -> Tool.state
  \kw{val} traverse : rep -> pd -> Tool.state -> Tool.state
\kw{end}
\end{code}
\caption{The signature of the Traversal functor within the signature \texttt{Type.S}.}
\label{fig:traversal-interface}
\end{figure}
}

The following code snippet gives the signature of the
traversal functor as it would appear in the signature \cd{S} from
\secref{sec:padsml-impl}. 
\begin{code}\scriptsize
\kw{module} Traverse (Tool : Generic_tool.S) :
\kw{sig}
  \kw{val} init : unit -> Tool.state
  \kw{val} traverse : rep -> pd -> Tool.state -> Tool.state
\kw{end}
\end{code}%
\vskip -2ex
\noindent
The functor takes a generic tool generator and produces
a format-specific tool with two functions: \cd{init}, to create the initial
state for the tool, and \cd{traverse}, which traverses the
representation and parse descriptor for the type and updates the given
tool state.

\subsection{Example Tools}
\label{sec:gentool-motivation-ex}

We have used this framework to implement a variety of tools useful for processing ad hoc data, including an \xml{} formatter, an accumulator tool for generating statistical overviews of the data, and a data printer for debugging.  We briefly describe these tools to illustrate the flexibility of the framework.

The \xml{} formatter converts any data with a \padsml{} description
into a canonical \xml{} format.  This conversion is useful because it
allows analysts to exploit the many useful tools that exist for
manipulating data in \xml{}. 

The accumulator tool provides a statistical summary of data.
Such summaries are useful for developing a quick understanding of data quality.  In particular, after receiving a new batch of data, analysts might want to know the frequency of errors, or which fields are the most corrupted. 
The accumulator tool tracks the distribution of the top $n$
distinct legal values and the percentage of errors. 
It operates over data sources
whose basic structure is a series of records of the same type, 
providing a summary based on viewing many records
in the data source.    More complex accumulator programs and a number of other statistical algorithms can easily be implemented using the tool generation infrastructure.

Finally, as an aid in debugging \padsml{} descriptions, we have implemented a simple printing tool.  In contrast to the printer generated by the \padsml{} compiler, the output of this tool corresponds to the in-memory
representation of the data rather than its original format, which may have delimiters \etc{} that are not present in the representation.  This format is often more readable than the raw data.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../thesis.tex"
%%% End: 
