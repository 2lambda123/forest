\subsection{The Pads Language, Compiler and Automated Tool Generation}

In preparation for this proposal, we have developed a prototype
domain-specific language called
\pads{}~\cite{fisher+:pads,fisher+:popl06,mandelbaum+:pads-ml}, 
which is capable of describing
the formats of individual binary files and application log files.
\pads{} specifications are a form of extended type declaration that
simultaneously describe (1) the syntax of a data format, (2) additional
semantic properties of the data (such as value ranges or other constraints)
and (3) an internal, parsed representation of the data.  
%Figure~\ref{figure:clf} presents a small fragment of a \pads{} 
%description for a web log to give the reader what our domain specific
%language is like.

% \begin{figure}
% \begin{small}
% \begin{code}
% \kw{Punion} client\_t \{
%   Pip       ip;      /- 135.207.23.32
%   Phostname host;    /- www.research.att.com
% \};
% \mbox{}
% \kw{Punion} auth\_id\_t \{
%   Pchar unauthorized : unauthorized == '-';
%   Pstring(:' ':) id;
% \};
% \mbox{}
% \kw{Pstruct} version\_t \{
%   "HTTP/";
%   Puint8 major; '.';
%   Puint8 minor;
% \};
% \mbox{}
% \kw{Penum} method\_t \{
%     GET,    PUT,  POST,  HEAD,
%     DELETE, LINK, UNLINK
% \};
% \mbox{}
% bool chkVersion(version\_t v, method\_t m) \{
%   \kw{if} ((v.major == 1) && (v.minor == 1)) \kw{return} true;
%   \kw{if} ((m == LINK) || (m == UNLINK)) \kw{return} false;
%   \kw{return} true;
% \};
% \mbox{}
% \end{code}
% \end{small}
% \caption{Fragment of \pads{} description for Web Log data.}
% \label{figure:clf}
% \end{figure}

These specifications have a well-defined semantics and can play a
valuable role as documentation of the data produced, managed and
accumulated by monitoring systems.  More importantly, though, these
specifications can serve as inputs to a compiler that automatically
generates high-performance and reliable modules that perform key data
processing tasks, such as parsing, printing, error detection, data
traversal, format translation and statistical profiling.  Such
generated libraries can subsequently be linked to other components of
the monitor system, including the traffic sniffer and CoMon
visualization and query engine.  The end result we envision is a 
highly customized, automatically generated and evolvable
suite of high-performance network monitoring
tools.  However, in order to realize this vision, we must engage
in a number of important research subtasks. 

\paragraph*{Algorithms for Efficient Context-free and Non-context-free Data Processing.}
To make \pads{} a {\em universal language} for describing the data used by
networked applications, we must combine the expressive power of conventional 
{\em context-free} languages with various {\em non-context-free} features.  
For instance, most binary formats used by networked applications
contain length fields (fields, which when parsed,
describe the size or length of other fields in the data), a non-context-free feature,
or computed constraints (such as integer or floating point relations) another non-context-free
feature.  Currently, despite a wealth of research in automatic parser generation over the years,
handling such a combination of features efficiently is an important open problem of tremendous
theoretical and practical importance.  We will design new grammatical specifications
and automaton-based algorithms to solve this problem.

\paragraph*{Design of Archive Specification Language.}  
Our prototype \pads{} language can describe the syntax and semantic properties
of individual files.  However, diagnosing problems or simply monitoring
the health of applications in networked systems
will usually involve navigating and analyzing {\em sets of files},
not just individual logs.  After all, even individual
applications can generate complex sets of log files. 
As an example, consider the Coral content
distribution system~\cite{coral}, a typical distributed application.
Coral is currently running on the PlanetLab system~\cite{planetlab}, a
testbed with hundreds of machines distributed world-wide.
Coral generates a complex set of log files that
reside in a multi-level archive.  At the top-level, a series of subdirectories
contain information pertinent to each PlanetLab machine.  At the next level down,
another series of directories contains information for each time slice.  In the
time slice directories themselves sit four different log files, each containing different 
kinds of basic Coral information.

We propose to design a specification language for {\em entire archives} of 
system and application data, such as those used by Coral and other similar
applications.  This specification language will allow us to describe the structure and
properties expected of multi-level file systems, including the file hierarchy, the
naming conventions of directories (and the meta-data contained within those names), data 
ownership, permissions and formats of the files.

\paragraph*{Tool Generation for Archive Specifications.}  In addition to our archive
specification language design, we will develop a compiler capable of automatically
generating archive processing libraries, interfaces and tools from these specifications.  
These tools will 
include tools for ingesting, traversing and processing data residing in an archive
as well as tools to support archive querying, forensic analysis and visualization through CoMon.