\appendix

\section{Host Language}
\label{app:host-lang}

\subsection{Well-Formedness Rules}
\label{app:well-form}

\fbox{$\wfd \pctxt \ity$}

\[
\infer{\wfd \pctxt a}{}
\quad
\infer{
  \wfd \pctxt {\ity \iarrowi \ity'}
}{
  \wfd \pctxt \ity &
  \wfd \pctxt {\ity'}
}
\quad
\infer{
  \wfd \pctxt {\ity \iprodi \ity'}
}{
  \wfd \pctxt \ity &
  \wfd \pctxt {\ity'}
}
\]

\[%\quad
\infer{
  \wfd \pctxt {\isum \ity {\ity'}}
}{
  \wfd \pctxt \ity &
  \wfd \pctxt {\ity'}
}
\quad
\infer{
  \wfd \pctxt {\iseqty \ity}
}{
  \wfd \pctxt \ity
}
\quad
\infer{
  \wfd \pctxt {\ierrty \ity}
}{
  \wfd \pctxt \ity
}
\]

\[%\quad
\infer{
  \wfd \pctxt {\forall \ityvar.\ity}
}{
  \wfd {\pctxt,\ityvar} \ity
}
\quad
\infer{
  \wfd \pctxt  \ityvar
}{
  \ityvar \in \pctxt
}
\quad
\infer{
  \wfd \pctxt {\imu \ityvar \ity}
}{
  \wfd {\pctxt,\ityvar} \ity
}
\]

\fbox{$\wfd \pctxt \ctxt$}

\[
\infer{
  \wfd \pctxt \cdot
}{}
\quad
\infer{
  \wfd \pctxt {\ctxt,x:\ity}
}{
  \wfd \pctxt \ctxt & x \not\in \dom \ctxt & \wfd \pctxt \ity
}
\]

\fbox{$\wfd \ctxt \rctxt$}

\[
\infer{\wfd \ctxt \cdot}{}
\quad
\infer{
  \wfd \ctxt {\rctxt,\ptyvar=\pmu \ptyvar \ty}
}{
  \wfd \ctxt \rctxt \quad \ptyvar \not\in \dom \rctxt &
  \ddck[\pmu \ptyvar \ty, \rctxt;\ctxt,\kty,\con]
}
\]

\subsection{Typing Rules}
\label{app:hl-typing}

Constants are assigned types with the interface $\Icty$ and operators
with $\Iopty$. Some example constants and their types are show below.
\[
\begin{array}{ll}
 \Icty(\itrue) = \iboolty &
 \Icty(\ifalse) = \iboolty \\
 \Icty(\ierr) = \invty &
 \Icty(\data) = \ibitsty \\
 \Icty(\off) = \ioffty
\end{array}
\]

We use contexts $\pctxt$ to record the names of open type variables
and contexts $\ctxt$ to record the types of variables. The syntax of
$\pctxt$ and $\ctxt$ is as follows:
\begin{bnf}
\mathit{\pctxt} & \::= . \| \ctxt,\ityvar
\mathit{\ctxt}  & \::= . \| \ctxt,x{:}\ity
\end{bnf}

The typing judgment has the form $\stsem[e, pctxt;\ctxt, \ity]$. When
the type-variable context $\pctxt$ is empty, we write $\stsem[e,
\ctxt, \ity]$ as an abbreviation.
% Note that \textit{T-Generalize} can only be used in the premise of a
% \texttt{let} expression.

\[
  \infer[Const]{
    \stsem[\const,\pctxt;\ctxt,\Icty(\const)]
  }{
    \wfd \pctxt \ctxt
  }
\quad
  \infer[Var]{
    \stsem[\var,\pctxt;\ctxt,\ity]
  }{
    \wfd \pctxt \ctxt & \ctxt(\var) = \ity
  }
\]
\[%\quad
  \infer[Op]{
    \stsem[\iop e,\pctxt;\ctxt,\ity]
  }{
    \Iopty({op}) = \ioparrow {\ity'} \ity &
    \stsem[e,\pctxt;\ctxt,\ity']
  }
\]

\[%\qquad
%   \infer[Abs]{
%     \stsem[\ilam{\nrm \var}{\ity'}{e},
%     \ctxt,\ity' \iarrowi \ity]
%   }{
%     \stsem[e,\pctxt;\ectxt{\var{:}\ity'},\ity] &
%     {\rm FTV}(\ity') \in \pctxt
%   }
% \quad
  \infer[Fun]{
    \stsem[\ifun {\nrm f} {\nrm x} e,
           \pctxt;\ctxt,\ity' \iarrowi \ity]
  }{
    \stsem[e,\pctxt;\ectxt{f{:}\ity' \iarrowi \ity,x{:}\ity'},\ity]
  }  
\quad
  \infer[App]{
    \stsem[\iapp{e}{e'},\pctxt;\ctxt,\ity]
  }{
    \stsem[e,\pctxt;\ctxt,\ity' \iarrowi \ity] &
    \stsem[e',\pctxt;\ctxt,\ity']
  }
\]

\[%\qquad
  \infer[Let]{
    \stsem[{\ilet {\nrm x} {e'} \; e},
           \pctxt;\ctxt,\ity]
  }{
%    \begin{array}{c}
      \stsem[e',\pctxt;\ctxt,\ity'] &
      \stsem[e,\pctxt;\ectxt{x{:}\ity'},\ity]
%    \end{array}
  }  
% \quad
%   \infer[LetRec]{
%     \stsem[{\iletfun {\nrm f} {\nrm x} e \; \iin \; e'},
%            \ctxt,\ity]
%   }{
%     \stsem[e,\pctxt;\ectxt{f{:}\ity_1 \iarrowi \ity_2,x{:}\ity_1},\ity_2] &
%     \stsem[e',\pctxt;\ectxt{f{:}\ity_1 \iarrowi \ity_2},\ity] 
%   }
\]

\[%\qquad
  \infer[Cond]{
    \stsem[\iif e \; \ithen {e_1} \; \ielse {e_2},\pctxt;\ctxt,\ity]
  }{       
    \stsem[e,\pctxt;\ctxt,\iboolty] &
    \stsem[e_1,\pctxt;\ctxt,\ity] &
    \stsem[e_2,\pctxt;\ctxt,\ity]
  }
\]
\[%\quad
  \infer[Pair]{
    \stsem[\ipair {e_1}{e_2},\pctxt;\ctxt,\iprodty {\ity_1} {\ity_2}]
  }{       
    \stsem[e_1,\pctxt;\ctxt,\ity_1] &
    \stsem[e_2,\pctxt;\ctxt,\ity_2]
  }
\quad
  \infer[Proj]{
    \stsem[\ipi{\nrm i}{e},\pctxt;\ctxt,\ity_i]
  }{
    \stsem[e,\pctxt;\ctxt,\ity_1 \iprodi \ity_2] 
  }
\]

\[%\quad
  \infer[InL]{
    \stsem[\iinl e,\pctxt;\ctxt,\isum \ity {\ity'}]
  }{
    \stsem[e,\pctxt;\ctxt,\ity] &
    \wfd \pctxt {\ity'}
  }
\quad
  \infer[InR]{
    \stsem[\iinr e,\pctxt;\ctxt,\isum \ity {\ity'}]
  }{
    \stsem[e,\pctxt;\ctxt,\ity'] &
    \wfd \pctxt {\ity}
  }
\]

\[%\qquad
  \infer[Case]{
    \stsem[\icaseg{e}{\nrm x}{e_l}{\nrm y}{e_r}
    ,\pctxt;\ctxt,\ity]
  }{
    \stsem[e,\pctxt;\ctxt,\isum {\ity_l} {\ity_r}] &
    \stsem[e_l,\pctxt;\ectxt{x{:}\ity_l},\ity] &
    \stsem[e_r,\pctxt;\ectxt{y{:}\ity_r},\ity]
  }
\]

\[
  \infer[Empty]{
    \stsem[\ieseq,\pctxt;\ctxt,\iseqty \ity]
  }{
    \wfd \pctxt \ctxt & \wfd \pctxt \ity
  }
\]
\[%\quad
  \infer[Seq]{
    \stsem[\iarr{e_1 \cdots e_n},\pctxt;\ctxt,\iseqty \ity]
  }{
    \wfd \pctxt \ctxt & \stsem[e_i,\pctxt;\ctxt,\ity] \quad 
    \mbox{(for $i=1 \ldots n$)}
  }
\]

\[
  \infer[Append]{
    \stsem[\iappend e {e'},\pctxt;\ctxt,\iseqty \ity]
  }{
    \stsem[e,\pctxt;\ctxt,\iseqty \ity] &
    \stsem[e',\pctxt;\ctxt,\iseqty \ity]
  }
\]
\[%\quad
  \infer[Sub]{
    \stsem[\isub e {\nrm {e'}},\pctxt;\ctxt,\isum \ity \iunitty]
  }{
    \stsem[e,\pctxt;\ctxt,\iseqty \ity] &
    \stsem[e',\pctxt;\ctxt,\iintty]    
  }
\]

\[
  \infer[Roll]{
    \stsem[e,\pctxt;\ctxt,\imu \ityvar \ity]
  }{
    \stsem[e,\pctxt;\ctxt,\ity[\imu \ityvar \ity/\ityvar]]
  }
  \quad
  \infer[Unroll]{
    \stsem[e,\pctxt;\ctxt,\ity[\imu \ityvar \ity/\ityvar]]
  }{
    \stsem[e,\pctxt;\ctxt,\imu \ityvar \ity]
  }
\]

\[%\qquad
  \infer[Generalize]{
    \stsem[v,\pctxt;\ctxt,\forall \ityvar.\ity]
  }{
    \stsem[v,{\pctxt,\ityvar;\ctxt},\ity] & 
    (\ityvar \not\in {\rm FTV}(\ctxt))
  }
\]
\[%\quad
  \infer[Instantiate]{
    \stsem[\expr,{\pctxt;\ctxt},{\ity[\ity'/\ityvar]}]
  }{
    \stsem[\expr,\pctxt;\ctxt,\forall \ityvar.\ity]
  }
\]

\subsection{Evaluation Rules}
\label{app:hl-evaluation}

\begin{bnf}
\name{Evaluation} \meta{E} \::= 
  [] \| \iop{E} \| \iapp E e \| \iapp v E \\
\name{Contexts} \meta{} \| &
  \ilet {\nrm x} E \; e \nlalt
  \iif E \; \ithen {e_1} \; \ielse {e_2} \nlalt
  \ipair E e \| \ipair v E \| \ipi{\nrm i}{E} \nlalt
  \iinld \ity E \| \iinrd \ity E \nlalt
  \icaseg E {\nrm x} e {\nrm x} {e'} \nlalt
  \iarr{\vec v \, E \, \vec{e}} \| 
  \iappend E e \| \iappend v E \nlalt
  \isub e E \| \isub v E \\
\end{bnf}

We specify the implementation of an operator with
$\mathcal{O}({op},v)$. Most of the rules are standard, although the
sequence rules are new. Append appends the contents of the second
array to that of the first array, while Sub extracts the element at
index i, if i is within the bounds of the array. If not, the
expression fails.

\[
\infer[Op]{
  \iop v \stepsto v'
}{
  \mathcal{O}({op},v) = v'
}
% \quad
% \infer[App]{
%   \iapp v {v'} \stepsto e[v'/x]
% }{
%   (v = \ilam {\nrm x} {} e)
% }
\quad
\infer[App]{
  \iapp v {v'} \stepsto e[v/f][v'/x]
}{
  (v = \ifun {\nrm f}{\nrm x} e)
}
\]
\[%\quad
\infer[Let]{
  \ilet {\nrm x} v \; e
  \stepsto e[v/x]
}{}
% \quad
% \infer[LetRec]{
%   \iletfun {\nrm f} {\nrm x} e \; \iin \; e'
%   \stepsto e'[{\ifun {\nrm f} {\nrm x} e}/f]
% }{}
\]

\[
\infer[{IfTrue}]{
  \iif \itrue \; \ithen e \; \ielse {e'} \stepsto
  e
}{}
\]
\[%\quad
\infer[{IfFalse}]{
  \iif \ifalse \; \ithen e \; \ielse {e'} \stepsto
  e'
}{}
\]

\[
\infer[Proj1]{
  \ipi 1 {\ipair v {v'}} \stepsto v
}{}
\quad
\infer[Proj2]{
  \ipi 2 {\ipair v {v'}} \stepsto v'
}{}
\]

\[
\infer[CaseL]{
  \icaseg{\iinl v}{\nrm x}{e_l}{\nrm y}{e_r}
  \stepsto {e_l}[v/x]
}{}
\]

\[%\quad
\infer[CaseR]{
  \icaseg{\iinr v}{\nrm x}{e_l}{\nrm y}{e_r}
  \stepsto {e_r}[v/y]
}{}
\]

\[
\infer[Append]{
  \iappend {\iarr{\vec v_1}} {\iarr{\vec v_2}} \stepsto
  {\iarr{\vec v_1 \, \vec v_2}}
}{}
\quad
\infer[EmptySub]{
  \isub \ieseq {\nrm i} \stepsto \iinr{\iuval}
}{}
\]

\[
\infer[SubIn]{
  \isub {\iarr{v_0 \ldots v_{n-1}}} {\nrm i}
  \stepsto \iinl {v_{i}}
}{
  0 \leq i < n
}
\quad
\infer[SubOut]{
  \isub {\iarr{v_0 \ldots v_{n-1}}} {\nrm i}
  \stepsto \iinr{\iuval}
}{
  i \geq n
}
\]

\[
\infer[Step]{
  E[e] \stepsto E[e']
}{
  e \stepsto e'
}
\]

\section{Helper Functions}
\label{app:asst-functions}

\trversion{
%% Maps pads base types to implementation language base types
\begin{description}
\item $\Ikind : {Const} \rightarrow {Kind}$.
\item $\Irty : {Const} \rightarrow {Type}$.
% \item $\Ipdty : {Const} \rightarrow {Type}$.
\item $\Iimp : {Const} \rightarrow {Expression}$.
\end{description}
}

In defining the parsing functions, we use the following helper functions:
\begin{description}
\item $\codefont {Eof} : \ibitsty \iprodi \ioffty \iarrowi \iboolty$

\item $\codefont{scanMax} : \iintty$

\item $\ifun {max} {\ictup{m,n}} {\codefont{\iif {m>n}\; \ithen m\; \ielse n}}$
\item $\ifun {pos} n {\codefont{\iif {n=0}\; \ithen 0\; \ielse 1}}$
\item $\ifun {isOk} p {\codefont{pos(p.h.nerr) = 0}}$
\item $\ifun {isErr} p {\codefont{pos(p.h.nerr) = 1}}$

\item $\ifun {max\_ec} {\ictup{ec_1, ec_2}} {}$ \\
  $\begin{array}{l}
    \iif {\codefont{ec_1} = \iecpc \iori \codefont{ec_2} = \iecpc}\; \ithen \iecpc \\
    \ielse{} \iif {\codefont{ec_1} = \iecerr \iori \codefont{ec_2} = \iecerr}\; \ithen \iecerr \\
    \ielse \iok
   \end{array}$
\end{description}

We define for each \ddc{} type a pair of constructor functions, one to build a representation and another to build a parse descriptor.
The type of PD headers is $\iintty
  \iprodi \iecty \iprodi \ispty$. We refer to the projections using
  dot notation as $\codefont{nerr}$, $\codefont{ec}$ and
  $\codefont{sp}$, respectively. A span is a pair of offsets, referred
  to as $\codefont{begin}$ and $\codefont{end}$, respectively. Array
  bodies have type $\iintty \iprodi \iintty \iprodi (\iseq \ity)$ (for
  element type $\ity$). We refer to the projections as
  $\codefont{neerr}$, $\codefont{length}$ and $\codefont{elts}$,
  respectively.  

\small
\begin{itemize}
\renewcommand{\labelitemi}{}

\item %[Unit:]
\item $\ifun {R_{unit}} \iuval \iuval$
\item $\ifun {P_{unit}} \off {\itup{\itup{0,\iok,\ipair \off \off},\iuval}}$

\item %[Bottom:]
\item $\ifun {R_{bottom}} \iuval \ierr$
\item $\ifun {P_{bottom}} \off ((1,\iecpc,\ipair \off \off),())$

\item %[Pair:]
\item $\ifun {R_{\gS}} {\ipair {r_1} {r_2}} {\itup {\codefont{r_1,r_2}}}$
\item $\ifun{H_{\gS}} {\ictup{h_1,h_2}}{}$ \\
  $\begin{array}{l}
    \ilet {nerr} {\codefont{pos \itup{{h_1}.{nerr}} + pos \itup{{h_2}.{nerr}}}}\\
    \ilet {ec} {\iif {\codefont{h_2.ec} = \iecpc}\; \ithen {\iecpc}\\
    \quad \ielse {\codefont{max\_ec} \iappi \codefont{h_1.ec} \iappi \codefont{h_2.ec}}} \\
    \ilet {sp} {\ictup{h_1.sp.begin, h_2.sp.end}} \\
    \quad \ictup {nerr,ec,sp}
  \end{array}$

\item $\ifun {P_{\gS}} {\ictup{p_1, p_2}} {\ictup {H_{\gS} \itup{p_1.h,p_2.h},\itup{p_1,p_2}}}$

\item %[Sum:]
\item $\ifun {R_{+left}} r {\iinl {\codefont r}}$
\item $\ifun {R_{+right}} r {\iinr {\codefont r}}$

\item $\ifun {H_+} h {\ictup{pos(h.nerr),h.ec,h.sp}}$
\item $\ifun {P_{+left}} p {\ictup{\codefont{H_+} \iappi p.h, \iinl p}}$
\item $\ifun {P_{+right}} p {\ictup{\codefont{H_+} \iappi p.h, 
      \iinr  p}}$

\item %[Intersection:]
\item $\ifun {R_{\&}} {\ictup {r,r'}} {\ictup {r,r'}}$
\item $\ifun {H_{\&}} {\ictup {h_1, h_2}} {}$ \\
    $\begin{array}{l}
      \ilet {nerr} {\codefont{pos \itup{{h_1}.{nerr}} + pos \itup{{h_2}.{nerr}}}}\\
      \ilet {ec} {\iif {\codefont{h_1.ec} = \iecpc \iandi \codefont{h_2.ec} = \iecpc}\; \ithen {\iecpc}\\
      \quad \ielse{\codefont{max\_ec} \iappi \codefont{h_1.ec} \iappi \codefont{h_2.ec}}} \\
      \ilet {sp} {\ictup{h_1.sp.begin, max \itup{h_1.sp.end, h_2.sp.end}}} \\
      \quad \ictup {nerr,ec,sp}
    \end{array}$

\item $\ifun {P_{\&}} {\ictup {p_1,p_2}} {\ictup{H_{\&} \iappi 
      \itup{p_1.h, p_2.h},\itup{p_1,p_2}}}$

\item %[Set:]
\item $\ifun {R_{set}} {\ictup{c,r}} {
    \iif {\codefont c} \; \ithen {\iinl {\codefont r}} \; \ielse {\iinr {\codefont r}}
  }$ 
\item $\ifun {P_{set}} {\ictup {c, p}} {}$ \\
    $\begin{array}{l}
      \iif {\codefont c} \; \ithen {\ictup{(pos(p.h.nerr),p.h.ec,p.h.sp),p}} \\
      \ielse {\ictup {(1 + pos(p.h.nerr),\maxec \iecerr {p.h.ec},p.h.sp),p}}
    \end{array}$
 \end{itemize}

 \begin{itemize}
 \renewcommand{\labelitemi}{}

\item %[Array:] 
\item $\ifun {R_{seq\_init}} {\iuval} {\ictup{0,\ieseq}}$   
\item $\ifun {P_{seq\_init}} \off {\ictup{(0,\iok,\ipair \off
      \off),(0,0,\ieseq)}}$

\item $\ifun {R_{seq}} {\ictup{r, r_e}} 
  {\ictup{r.len+1,\iappend{r.elts} {\iarr{r_e}}}}$
\item $\ifun {H_{seq}} {\ictup{h, h_s, h_e}} {}$ \\
  $\begin{array}{l}
      \ilet {eerr} {
        \codefont{\iif {h.neerr = 0 \mathrel{and} h_e.nerr > 0}}\\
        \codefont{\quad \ithen 1 \;  \ielse 0}
      }\\
      \ilet {nerr} {\codefont{h.nerr + pos(h_s.nerr) + eerr}}\\
      \ilet {ec} {\iif{\codefont{h_e.ec} = \iecpc}\; \ithen {\iecpc}\\
      \quad \ielse{\maxec {\codefont{h.ec}} {\codefont{h_e.ec}}
          }} \\
      \ilet {sp} {\ictup{h.sp.begin,h_e.sp.end}} \\
      \quad \ictup {nerr,ec,sp}
    \end{array}$

\item $\ifun{P_{seq}} {\ictup{p, p_s, p_e}}{}$ \\ 
  $\begin{array}{l}
    \codefont{(H_{seq} \iappi \itup{p.h,p_s.h,p_e.h},}\\ 
    \codefont{\itup{p.neerr + pos(p_e.h.nerr), p.len + 1,\iappend {p.elts}
        {\iarr{p_e}}})}
  \end{array}$

\item %[Compute:]
\item $\ifun{R_{compute}} r {\codefont r}$
\item $\ifun{P_{compute}} \off {\ictup{\itup{0,\iok,\ipair \off \off},\iuval}}$

\item %[Absorb:]
\item $\ifun {R_{absorb}} p {\iif {\pdok p}\; 
    \ithen {\iinl \iuval}\; \ielse {\iinr \ierr}}$
\item $\ifun {P_{absorb}} p {\ictup{p.h,\iuval}}$

\item %[Scan:]
\item $\ifun{R_{scan}} r  {\codefont{\iinl r}}$
\item $\ifun{P_{scan}} {\itup{i,p}} {}$ \\
$\begin{array}{l}
\ilet {nerr} {\codefont{pos(i) + pos(p'.h.nerr)}}\\
\ilet {ec} {\iif {\codefont{nerr = 0}}\; \ithen \iok\; \ielse \iecerr} \\
\ilet {hdr} {\ictup{nerr,ec,(p.sp.begin - i,p.sp.end)}} \\
\quad \ictup{hdr,\iinl {\ictup{i,p}}}
\end{array}$

\item $\ifun {R_{scan\_err}} {()} {\iinr \ierr}$
\item $\ifun {P_{scan\_err}} \off {\ilet {hdr} {\ictup{1,\iecpc,(\off,\off)}}}$\\
  \verb+ +$\ictup{hdr,\iinr \iuval}$
%% \item[Transform:]
%% \item \fnm{P_T} (h,b) = (h,(???,b))
\end{itemize}

\trversion{
\begin{lemma}[Function Types]
  $\stsem[\codefont{isOk},
  \codefont{pos}{:}\iintty \iarrowi \iintty,
  \forall \ga.\ipty \ga \iarrowi \iboolty]$.
\end{lemma}
}

\section{Meta-theory}
\label{app:meta-theory}
\begin{condition}[Conditions on Base-type Interfaces]
\label{cond:base-types}
  \begin{enumerate}
  \item $\dom {\Ikind} = \dom {\Iimp}$.
  \item If $\Ikind(C) = {\ity \iarrowi \kty}$ then $\Iopty(C) =
    \ioparrow \ity {\kTrans[\kty,\pbase e]}$ (for any $e$).
  \item If $\stsem[v,,\ity]$ and $\Iopty(C) = \ioparrow \ity
    {\kTrans[\kty,\pbase e]}$ then
    $\stsem[\Iimp(C)(v),,{\kTrans[\kty,\pbase e]}]$.
    \label{cond:closed-op}
  \item If $\stsem[v,,\ity]$, $\Ikind(C) = \iarrow \ity \kty$ and
    $\Iimp(C)(v) \sapp \spair<\data,\off> \kstepsto \spair<\off',r,p>$
    then $\corr {\pbase v} r p $.
  \end{enumerate}
\end{condition}
\noindent
Note that by condition~\ref{cond:closed-op}, base type parsers must
be closed.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "semantics"
%%% End: 
