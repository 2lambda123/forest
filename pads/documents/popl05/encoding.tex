\section{Encoding DDLs in the DDC}
\label{sec:encodings}

We can better understand the data description languages described
earlier by translating their constructs into the types of \ddc{}. We
start with the translation of \ipads{}, which captures many of the
common features of DDLs. We then discuss some features not found in
\ipads{}, giving them semantics in \ddc{} as well. Next, we list features
of \datascript{} and \packettypes{} that we can encode in \ddc{}.
Finally, we briefly discuss some limitations of \ddc{}.

\subsection{\ipads{} Translation}
\label{sec:trans-sl}

\trversion{
\begin{figure*}
{\small
\fbox{$\ctxt \turn \mathit{prog} \cipads \ty \; \text{prog}$}

\[
 \infer[\text{Prog-One}]{ 
    \ctxt \turn \itmv \cipads \ty \; \text{prog}
  }{
    \ctxt \turn \itmv \cipads \ty : \kty
  }
\quad
  \infer[\text{Prog-Def}]{ 
    \ctxt \turn \ga = \itmv; \; \mathit{prog} \cipads \ty \; \text{prog}
  }{
    \ctxt \turn \mathit{prog}[\itmv/\ga] \cipads \ty \; \text{prog}
  }
\quad
  \infer[\text{Prog-RecDef}]{ 
    \ctxt \turn  \Prec{}\; \ga = \itmv; \; \mathit{prog} \cipads \ty \; \text{prog}
  }{
    \ctxt \turn \mathit{prog}[\Prec{}\; \ga.\itmv/\ga] \cipads \ty \; \text{prog}
  }
\]

\fbox{$\ctxt \turn \itmv  \cipads \ty : \kind$}

\[
  \infer[\text{Base}]{ 
    \ctxt \turn \Pbase e \cipads \pbase e : \kty
  }{
    \ctxt \turn e : \ity & (\Ikind(C) = \ity \to \kty)
  }
\quad
  \infer[\text{Pfun}]{ 
    \ctxt \turn \Pfun (x:\ity) = \itmv \cipads \plam x
    \ity \ty : \ity \to \kind
  }{
    \ectxt{x{:}\ity} \turn \itmv \cipads \ty : \kind
  }
\quad
  \infer[\text{App}]{ 
    \ctxt \turn \itmv \; e \cipads \ty \; e : \kind
  }{
    \ctxt \turn \itmv \cipads \ty : \ity \to \kind & \ctxt \turn e : \ity
  }
\]

\[
  \infer[\text{Pstruct}]{
    \begin{array}{l}
    \ctxt \turn \Pstruct \{x_1{:}\itmv_1 \dots x_n{:}\itmv_n\}
    \cipads \\
    \qquad \gS \; x_1{:}\ty_1. \cdots \gS \; x_{n-1}{:}\ty_{n-1}.\ty_n : \kty      
    \end{array}
  }{ 
    \begin{array}{c}
%       \ctxt_1 = \ctxt \quad \ity_{i-1} = \iprod{\itsem[\ty_{i-1}]} {\itpdsem[\ty_{i-1}]}\\
%       \ctxt_i = \ctxt_{i-1},x_{i-1}{:} \ity_{i-1} \quad 
%       (\text{for} \; i = 2 \ldots n) \\
%       \ctxt_i \turn \itmv_i \cipads \ty_i : \kty \quad
%       (\text{for} \; i = 1 \ldots n)
      \ctxt_i = \ctxt,x_1{:}\ity_1, \dots, x_{i-1}{:} \ity_{i-1} \\
      \ity_{i} = \iprod{\itsem[\ty_{i}]} {\itpdsem[\ty_{i}]} \quad
      \ctxt_i \turn \itmv_i \cipads \ty_i : \kty
    \end{array}
  }
\quad
  \infer[\text{Punion}]{
    \begin{array}{l}
      \ctxt \turn \Punion \{x_1{:}\itmv_1 \dots x_n{:}\itmv_n\}
      \cipads \\
      \ty_1 + \dots + \ty_n + \pfalse : \kty
    \end{array}
  }{ 
    \ctxt \turn \itmv_i \cipads \ty_i : \kty
  }
\]

\[
  \infer[\text{Palt}]{
    \ctxt \turn \Palt \{x_1{:}\itmv_1 \dots x_n{:}\itmv_n\} \cipads
    \ty_1 \& \dots \& \ty_n: \kty
  }{ 
    \ctxt \turn \itmv_i \cipads \ty_i : \kty
  }
\quad
  \infer[\text{Popt}]{
    \ctxt \turn \Popt \; \itmv \cipads
     \psum \ty {} \ptrue : \kty
  }{
    \ctxt \turn \itmv \cipads \ty : \kty
  }
\quad
  \infer[\text{Pwhere}]{
    \begin{array}{l}
      \ctxt \turn \itmv \; \Pwhere \, x.e \cipads  \\
      \qquad
      \pset x \ty {\iif {\pdok {x.\codefont{pd}}} \; \ithen e \; \ielse
        \itrue}
    \end{array}
  }{ 
     \ctxt \turn \itmv \cipads \ty : \kty & 
     \stsem[e,\ectxt{x{:}\iprod{\itsem[\ty]} {\itpdsem[\ty]}},\iboolty]
  }
\]

\[
  \infer[\text{Parray}]{
    \ctxt \turn \iParray{\itmv}{{\itmv_{sep}}}{{\itmv_{term}}}{} \cipads 
    \pseq \ty {\pscan {\ty_s}} {\pterm f {\ty_t}} : \kty
  }{ 
       \begin{array}{lr}
         \ctxt \turn \itmv \cipads \ty : \kty & 
         \ctxt \turn \itmv_{sep} \cipads \ty_s : \kty \\ 
         \ctxt \turn \itmv_{term} \cipads \ty_t : \kty &
         (f = \ilam x{}\ifalse)\\
       \end{array}
  }
\quad
  \infer[\text{Pcompute}]{ 
    \ctxt \turn \Pcompute{} \; e \cipads \pcompute e \ity : \kty
  }{
    \stsem[e,\ctxt,\ity]
  }
\]

\[
  \infer[\text{Plit}]{ 
    \ctxt \turn \Plit \const \cipads 
    \pscan {\pabsorb {\pset \var \ty {\ivar = \iconst}}} : \kty
  }{
    \stsem[\const,\ctxt,\ity] & \defty \ity \ty
  }
\quad
  \infer[\text{Var}]{ 
    \ctxt \turn \ga \cipads \ga
  }{}    
\quad
  \infer[\text{Prec}]{ 
    \ctxt \turn \Prec{}\; \ga.\itmv \cipads \pmu \ga \ty
  }{
    \ctxt \turn \itmv \cipads \ty
  }
\]
}
  \caption{Encoding \ipads{} in \ddc{}}
  \label{fig:encode-ipads}
\end{figure*}

 \reminder{Add poly. context to all typing judgments that appear in
   premises. See email (subject:Prec) for details on how to fix translation}
}

\poplversion{
\begin{figure*}
{\small
\fbox{$ \mathit{prog} \cipads \ty \; \text{prog}$}

\[
 \infer[\text{Prog-One}]{ 
     \itmv \cipads \ty \; \text{prog}
  }{
     \itmv \cipads \ty
  }
\quad
  \infer[\text{Prog-Def}]{ 
     \ga = \itmv; \; \mathit{prog} \cipads \ty \; \text{prog}
  }{
     \mathit{prog}[\itmv/\ga] \cipads \ty \; \text{prog}
  }
\quad
  \infer[\text{Prog-RecDef}]{ 
      \Prec{}\; \ga = \itmv; \; \mathit{prog} \cipads \ty \; \text{prog}
  }{
     \mathit{prog}[\Prec{}\; \ga.\itmv/\ga] \cipads \ty \; \text{prog}
  }
\]

\fbox{$ \itmv  \cipads \ty$}

\[
  \infer[\text{Base}]{ 
     \Pbase e \cipads \pbase e
  }{}
\quad
  \infer[\text{Pfun}]{ 
     \Pfun (x:\ity) = \itmv \cipads \plam x
    \ity \ty
  }{
    \itmv \cipads \ty
  }
\quad
  \infer[\text{App}]{ 
     \itmv \; e \cipads \ty \; e
  }{
     \itmv \cipads \ty
  }
\quad
  \infer[\text{Pstruct}]{
    \begin{array}{l}
     \Pstruct \{x_1{:}\itmv_1 \dots x_n{:}\itmv_n\}
    \cipads \\
    \qquad \gS \; x_1{:}\ty_1. \cdots \gS \; x_{n-1}{:}\ty_{n-1}.\ty_n
   \end{array}
  }{ 
    \itmv_i \cipads \ty_i
  }
\]

\[
  \infer[\text{Punion}]{
    \begin{array}{l}
       \Punion \{x_1{:}\itmv_1 \dots x_n{:}\itmv_n\}
      \cipads \\
      \qquad \ty_1 + \dots + \ty_n + \pfalse
    \end{array}
  }{ 
     \itmv_i \cipads \ty_i
  }
\quad
  \infer[\text{Palt}]{
     \Palt \{x_1{:}\itmv_1 \dots x_n{:}\itmv_n\} \cipads
    \ty_1 \& \dots \& \ty_n
  }{ 
     \itmv_i \cipads \ty_i
  }
\quad
  \infer[\text{Popt}]{
     \Popt \; \itmv \cipads
     \psum \ty {} \ptrue
  }{
     \itmv \cipads \ty
  }
\]

\[
  \infer[\text{Pwhere}]{
    \begin{array}{l}
       \itmv \; \Pwhere \, x.e \cipads  \\
      \qquad
      \pset x \ty {\iif {\pdok {x.\codefont{pd}}} \; \ithen e \; \ielse
        \itrue}
    \end{array}
  }{ 
    \itmv \cipads \ty
  }
\quad
  \infer[\text{Parray}]{
     \iParray{\itmv}{{\itmv_{sep}}}{{\itmv_{term}}}{} \cipads 
    \pseq \ty {\pscan {\ty_s}} {\pterm f {\ty_t}}
  }{ 
    \itmv \cipads \ty & 
    \itmv_{sep} \cipads \ty_s &
    \itmv_{term} \cipads \ty_t &
    (f = \ilam x{}\ifalse)
  }
\]

\[
  \infer[\text{Pcompute}]{ 
     \Pcompute{} \; e{:}\ity \cipads \pcompute e \ity
  }{}
\quad
  \infer[\text{Plit}]{ 
     \Plit \const \cipads 
    \pscan {\pabsorb {\pset \var \ty {\ivar = \iconst}}}
  }{
    \defty \const \ty
  }
\quad
  \infer[\text{Var}]{ 
     \ga \cipads \ga
  }{}    
\quad
  \infer[\text{Prec}]{ 
     \Prec{}\; \ga.\itmv \cipads \pmu \ga \ty
  }{
     \itmv \cipads \ty
  }
\]
}
  \caption{Encoding \ipads{} in \ddc{}}
  \label{fig:encode-ipads}
\end{figure*}
}

In Section~\ref{sec:ddc-example}, we gave an example of how an
\ipads{} description would appear in \ddc{} and informally described
how \ipads{} is encoded in \ddc{}. In \figref{fig:encode-ipads}, we
formalize this translation. The judgment ${prog} \cipads \ty\;
\text{prog}$ indicates that the \ipads{} program ${prog}$ is encoded
as \ddc{} type $\ty$, while $\itmv \cipads \ty$ does the same
for \ipads{} types $\itmv$.

As much of the translation is straightforward, we mention only a few
important points. We translate base type by punning the \ipads{} name
to produce a \ddc base type. We add $\pbot$ as the last branch of the
\ddc{} sum when translating \Punion{} so that the parse will fail in
the event that none of the branches match, rather than simply returning
the result of the last branch. This behaviour is based directly on the
actual \pads{} language. In the translation of \Pwhere{}, we add host
language code that only checks the constraint if the underlying value
parsed with no errors. For \Parray{}s, we add simple error recovery by
scanning for the separator type.  This behaviour allows us to
skip erroneous elements easily. We use the $\pscann$ type in the same way for
\Plit, as literals often appear as field separators in \Pstruct{}s.
We also absorb the literal as its value is known statically.  We use the
function ${\rm Ty}(c)$ to determine the correct parser for the particular
literal. For example, a string literal would require a \Pstring{}
parser.

\subsection{Beyond \ipads{}}

We now give semantics to three features not found in \ipads{}:
\pads{} switched unions, \packettypes{} overlays, and \datascript{} arrays.

A switched union, like a \Punion, indicates variability in the data
format with a set of alternative formats (branches). However, instead
of trying each branch in turn, the switched union takes an expression that
determines which branch to use. Typically, this expression depends upon data read earlier in the parse. Each branch is preceded by a tag,
and the first branch whose tag matches the expression is selected.
If none match then the default branch $\itmv_{\text{def}}$ is chosen.
The syntax of a switched union is $\Pswitch{}\;e\;\{\overrightarrow{e
  \Rightarrow x{:}\itmv}\; \itmv_{\text{def}}\}$.

To aid in our translation of \Pswitch{}, we define a simpler
construct that allows us to choose between two types conditionally:
$\iif e\; \ithen {\itmv_1}\; \ielse {\itmv_2}$. 

\trversion{
Our first attempt to
translate the conditional relies on \ddc{} sums:
\[
\infer{
  \iif e\; \ithen {\itmv_1}\; \ielse {\itmv_2} 
  \cipads \psum
  {\pset y {\psum {\pset x \ptrue {!e}} {} {\ty_1}} e}
  {} {\ty_2}
}{
  \itmv_1 \cipads \ty_1 &
  \itmv_2 \cipads \ty_2
}
\]
If $e$ is true, then the nested constraint will fail causing the left
branch of the nested sum to fail and $\ty_1$ will be used to parse
the data. As $e$ is true, the second constraint will succeed, leaving
us with the left branch of the root sum. Conversely, if $e$ is false,
the first constraint will be satisfied, but the second will not,
causing us to parse the data with $\ty_2$. 

Unfortunately. while this seems to work, it will fail if there is an
error in $\ty_1$ when $e$ is true. The error will cause errors in the
set type despite the satisfaction of its constraint, thereby causing
the parser to use $\ty_2$. To address this problem, we use products:
}
\[
\infer{
  \iif e\; \ithen {\itmv_1}\; \ielse {\itmv_2} 
  \cipads 
  ({\psum {\pset x \ptrue {!e}} {} {\ty_1}}) \iprodi
  ({\psum {\pset x \ptrue {e}} {} {\ty_2}})
}{
  \itmv_1 \cipads \ty_1 &
  \itmv_2 \cipads \ty_2
}
\]
Exactly one element of the pair will be the $\iunitty$ value,
while the other will be the result of the parse. With this definition,
we encode the \Pswitch{} as a syntactic sugar for a series of
cascading conditional types.

\[
\begin{array}{l}
\Pswitch{}\;e\;\{e_1 \Rightarrow x_1{:}\itmv_1 \dots 
    e_n \Rightarrow x_n{:}\itmv_n\; \itmv_{\text{def}}\} 
    = \\
\quad    \iif {e = e_1}\; \ithen {\itmv_1}\; \ielse{}\\
\quad    \iif {e = e_2}\; \ithen {\itmv_2}\; \ielse{}\\
\quad    \dots\\
\quad    \iif {e = e_n}\; \ithen {\itmv_1}\; \ielse{}\\
\quad    \itmv_{\text{def}}
\end{array}
\]

Next, we consider the {\it overlay} construct found in \packettypes{}.
An overlay allows us ``to merge two type specifications by embedding
one within the other, as is done when one protocol is {\it
  encapsulated} within another. Overlay[s] introduce additional
substructure to an already existing field.''~\cite{sigcomm00}.  For
example, consider a network packet from a fictional protocol FP, where
the packet body is represented as a simple byte-array. 
\begin{code}
FPPacket = \Pstruct \{
  header : FPHeader;
  body   : \Pbyte \Parray{}(\Peof,\Peof);
\}\linebreak

IPinFP = \Poverlay FPPacket.body \Pwith IPPacket
\end{code}
The overlay creates a new type \cd{IPinFP} where the body field is
an \cd{IPPacket} rather than a simple byte array.

We've developed a translation of the overlay syntax into \ddc{}. Although
overlays are conceptually intuitive,
we discovered a critical subtlety when formalizing their semantics. 
Any expressions in the original
type that refer to the overlayed field may no longer be well typed
in the new type. We thought to disallow such expressions in the
overlayed type. However, we found this to be a difficult, if not
impossible task. More importantly, such a restriction is unnecessary.
Instead, we designed the translation so that the new type is
checked for well formedness after the overlay process, an easy task
in the \ddc{} framework.

Finally, we introduce \datascript{}-style arrays for binary data, which are
parameterized by an optional length field, instead of a separator and
terminator. The syntax of an array named $\mathit{id}$ with elements
of type $\itmv$ is $\itmv\; \mathit{id}[\mathit{length}]$. If the user
supplies the length of the sequence, the array parser reads
exactly that number of elements.  Otherwise, the parser continues
until an element constraint is violated or the input is completely
consumed.

The first case can be encoded in a straightforward manner with \ddc{}
sequences: 
\[
  \infer{
    \itmv \; [\mathit{length}] \cipads 
    \pseq \ty {\ptrue{}} {\pterm {\mathtt{f}} {\pfalse{}}} : \kty
  }{ 
    \itmv \cipads \ty & 
    (\mathtt{f} = \codefont{isLength}\; \mathit{length})
  }
\]
As binary data has no separators, we use $\ptrue$. The function {\tt
  isLength} is a curried function taking a length and a pair of representation
and PD arrays and returning a boolean indicating whether both arrays
have the specified length. As there is no lookahead-terminator, we use
$\pfalse$ (thereby guaranteeing that the array will not be terminated
because of lookahead).

For the second case, we need a way to terminate if the next element
will not parse correctly without consuming it. We cannot use the
termination predicate as it can only look at elements that have
already been parsed and hence consumed from the input. Therefore, we
need a way to encode the notion of a failed element parse in the
terminator type. To do so, we define $\pnot \ty$ to be:

 {\small
\[
\pset x {\psum \ty {} \ptrue} {\icaseg {x.rep} {\_}
  {\ifalse} {\_} {\itrue}}
\]}%
\noindent
This type attempts to parse a $\ty$. On success, the representation will be a left
injection. The constraint in the set type will therefore fail. If a
$\ty$ cannot be parsed, the sum will default to $\ptrue$, the rep will
be a right injection, and the constraint will succeed. The use of the
sum in the underlying type is critical as it allows the set-type to be
error free even if parsing a $\ty$ fails.

With $\pnotn$, we can encode the unbounded \datascript{} array as
follows:
\[
  \infer{
    \ctxt \turn {dty} \; [{length}] \cipads 
    \pseq \ty {\ptrue{}} {\pterm {\ilam x {} \ifalse} {\pnot \ty}} : \kty
  }{ 
    \ctxt \turn {dty} \cipads \ty : \kty 
  }
\]
Note that the termination predicate is trivially false, as we use the
lookahead-terminator exclusively to terminate the array.

While there are many more features that we can encode, space prevents us from
detailing them here. To give a sense of what is possible, we
briefly list those features of \datascript{} and \packettypes{} for
which we have found encodings in \ddc{}:
\begin{itemize}
\item \packettypes{}: arrays, where clauses, structures, overlays,
  and alternation.
\item \datascript{}: set types (enumerations and bitmask sets),
  arrays, constraints, value-parameterized types (which they refer to
  as ``type parameters''), and (monotonically increasing) labels.
\end{itemize}

There are features from these and other data description languages
that we cannot implement in \ddc{} as it stands.  An example is a label construct that permits the user to rewind the input. However, we do not view these limitations of
\ddc{} as problematic. Like the simple-typed lambda calculus, \ddc{}
is intended to capture many common language features, while providing
a convenient and effective basis for extension with new features.

% Indeed, the two main features of \datascript{} that cannot currently
% be encoded in \ddc{}, require only straightforward modifications or
% additions.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "semantics"
%%% End: 
