\section{Encoding DDLs in the DDC}

\subsection{IPADS Translation}
\label{sec:trans-sl}

Note that contexts always contain surface-language types, not pads
types. Formally, the form of $\gG$ is:
\begin{bnf}
\name{}  &\gG & \::= . \| \gG,x {:} \ity
\end{bnf}

We now define some syntactic sugar for multi-argument versions of type
constructors that only take one or two arguments. Some of these
abbreviations take a list of bindings $b$, each of the form $x{:}t$.

\begin{align*}
  &\begin{array}{l}
    \plamA{x{:}\ity}{\ty} = \plam{x}{\ity}{\ty} \\
    \plamA{x{:}\ity,\vec{b}}{\ty} = \plam{x}{\ity}{\plamA{\vec{b}}{\ty}}
  \end{array}
  &
  &\begin{array}{l}
    \gS^* x:\ty,y:\ty' = \gS x:\ty.\ty' \\
    \gS^* x:t,\vec b   = \gS x:\ty.\gS^* \vec b
  \end{array}
  \\ \\
  &\begin{array}{l}
    +^* \ty,\ty' = \ty + \ty'\\
    +^* \ty,\vec{\ty} = \ty + (+^* \vec{\ty})
  \end{array}
  &
  &\begin{array}{l}
    \&^* \ty,\ty' =\pand \ty {\ty'}\\
    \&^* \ty,\vec{\ty} = \pand \ty {(\&^* \vec{\ty})}
  \end{array}
\end{align*}

The function $\Ikind$ provides the kind of base types $C$.

%\begin{figure}
\fbox{$
  \begin{array}{l}
    \ctxt \turn {prog} \Longrightarrow \ty \; {prog} \\
    \ctxt \turn {pty}  \Longrightarrow \ty : \kind
  \end{array}
$}

\[
 \infer[\text{Prog-One}]{ 
    \ctxt \turn {pty} \Longrightarrow \ty \; {prog}
  }{
    \ctxt \turn {pty} \Longrightarrow \ty : \kty
  }
\]

\[
  \infer[\text{Prog-Def}]{ 
    \ctxt \turn \ga = {pty}; \; {prog} \Longrightarrow \ty \; {prog}
  }{
    \ctxt \turn {prog}[{pty}/\ga] \Longrightarrow \ty \; {prog}
  }
\]

\[
  \infer[\text{Prog-RecDef}]{ 
    \ctxt \turn  \Prec{}\; \ga = {pty}; \; {prog} \Longrightarrow \ty \; {prog}
  }{
    \ctxt \turn {prog}[\Prec{}\; \ga.{pty}/\ga] \Longrightarrow \ty \; {prog}
  }
\]

\[
  \infer[\text{Base}]{ 
    \ctxt \turn \Pbase e \Longrightarrow \pbase e : \kty
  }{
    \ctxt \turn e : \ity & (\Ikind(C) = \ity \to \kty)
  }
\]

\[
  \infer[\text{Pfun}]{ 
    \ctxt \turn \Pfun (x:\ity) = {pty} \Longrightarrow \plam x
    \ity \ty : \ity \to \kind
  }{
    \ectxt{x{:}\ity} \turn {pty} \Longrightarrow \ty : \kind
  }
\]

\[
  \infer[\text{App}]{ 
    \ctxt \turn {pty} \; e \Longrightarrow \ty \; e : \kind
  }{
    \ctxt \turn {pty} \Longrightarrow \ty : \ity \to \kind & \ctxt \turn e : \ity
  }
\]

\[
  \infer[\text{Pstruct}]{
    \ctxt \turn \Pstruct \{\vec x:\vec {{pty}}\} \Longrightarrow
    \gS^* \vec x{:}\vec \ty : \kty
  }{ 
    \begin{array}{c}
      \ctxt_1 = \ctxt \quad \ity_{i-1} = \iprod{\itsem[\ty_{i-1}]} {\itpdsem[\ty_{i-1}]}\\
      \ctxt_i = \ctxt_{i-1},x_{i-1}{:} \ity_{i-1} \quad 
      (\text{for} \; i = 2 \ldots n) \\
      \ctxt_i \turn {pty}_i \Longrightarrow \ty_i : \kty \quad
      (\text{for} \; i = 1 \ldots n)
    \end{array}
  }
\]

\[
  \infer[\text{Punion}]{
    \ctxt \turn \Punion \{\vec x:\vec {{pty}}\} \Longrightarrow
    +^* (\vec \ty,\pfalse) : \kty
  }{ 
    \begin{array}{c}
      \ctxt \turn {pty}_i \Longrightarrow \ty_i : \kty \quad
      (\text{for} \; i = 1 \ldots n)
    \end{array}
  }
\]

\[
  \infer[\text{Palt}]{
    \ctxt \turn \Palt \{\vec x:\vec {{pty}}\} \Longrightarrow
    \&^* \vec \ty : \kty
  }{ 
    \begin{array}{c}
      \ctxt \turn {pty}_i \Longrightarrow \ty_i : \kty \quad
      (\text{for} \; i = 1 \ldots n) \\
    \end{array}
  }
\]

\[
  \infer[\text{Popt}]{
    \ctxt \turn \Popt \; {pty} \Longrightarrow
     \psum \ty {} \ptrue
  }{
    \ctxt \turn {pty} \Longrightarrow \ty : \kty
  }
\]

\[
  \infer[\text{Pwhere}]{
    \begin{array}{l}
      \ctxt \turn {pty} \; \Pwhere \, x.e \Longrightarrow  \\
      \qquad
      \pset x \ty {\iif {\pdok {x.\codefont{pd}}} \; \ithen e \; \ielse
        \itrue}
    \end{array}
  }{ 
     \ctxt \turn {pty} \Longrightarrow \ty : \kty & 
     \stsem[e,\ectxt{x{:}\iprod{\itsem[\ty]} {\itpdsem[\ty]}},\iboolty]
  }
\]

\[
  \infer[\text{Parray}]{
    \ctxt \turn \iParray{{pty}}{{pty_{sep}}}{{pty_{term}}}{} \Longrightarrow 
    \pseq \ty {\pscan {\ty_s}} {\pterm f {\ty_t}} : \kty
  }{ 
       \begin{array}{lr}
         \ctxt \turn {pty} \Longrightarrow \ty : \kty & 
         \ctxt \turn {pty}_{sep} \Longrightarrow \ty_s : \kty \\ 
         \ctxt \turn {pty}_{term} \Longrightarrow \ty_t : \kty &
         (f = \ilam x{}\ifalse)\\
       \end{array}
  }
\]

\[
  \infer[\text{Pcompute}]{ 
    \ctxt \turn \Pcompute{} \; e \Longrightarrow \pcompute e \ity : \kty
  }{
    \stsem[e,\ctxt,\ity]
  }
\]

\[
  \infer[\text{Plit}]{ 
    \ctxt \turn \Plit \const \Longrightarrow 
    \pscan {\pabsorb {\pset \var \ty {\ivar = \iconst}}} : \kty
  }{
    \stsem[\const,\ctxt,\ity] & \defty \ity \ty
  }
\]  

\[
  \infer[\text{Var}]{ 
    \ctxt \turn \ga \Longrightarrow \ga
  }{}    
\]

\[
  \infer[\text{Prec}]{ 
    \ctxt \turn \Prec{}\; \ga.{pty} \Longrightarrow \pmu \ga \ty
  }{
    \ctxt \turn {pty} \Longrightarrow \ty
  }
\]

%   \caption{Encoding \ipads{} in the \ddc{}}
%   \label{fig:encode-ipads}
% \end{figure}

\subsection{Sketches of Other DDLs}
The syntax of a \datascript{}-style array named ${id}$ with elements of
type ${dty}$ is ${dty}\;{id}[{length}]$, with length optional. If the
user supplies the length of the sequence then the array parser reads
exactly that number of elements. Otherwise, the parser continues until
an element constraint is violated or the input is completely consumed.

The first case be encoded in a straightforward manner with \ddc{}
sequences: 
\[
  \infer{
    \ctxt \turn {dty} \; [{length}] \Longrightarrow 
    \pseq \ty {\ptrue{}} {\pterm f {\pfalse{}}} : \kty
  }{ 
    \ctxt \turn {dty} \Longrightarrow \ty : \kty & 
    (f = \codefont{isLength} \; {length})
  }
\]
As binary data has no separators, we use $\ptrue$. The function {\tt
  isLength} is a curried function taking a length and a pair of Rep
and PD arrays and returning a boolean indicating whether both arrays
have the specified length. As there is no lookahead-terminator, we use
$\pfalse$ (thereby guaranteeing that the array will not be terminated
due to lookahead).

For the second case, we need a way to terminate if the next element
will not parse correctly without consuming it. We cannot use the
termination predicate as it can only look at elements that have
already been parsed and hence consumed from the input. Therefore, we
need a way to encode the notion of a failed element parse in the
terminator type. To do so, we introduce a new \ddc{} type $\pnot \ty$,
which we encode in \ddc{} as {\small
\[
\pset x {\psum \ty {} \ptrue} {\icaseg {x.rep} {\_}
  {\ifalse} {\_} {\itrue}}
\]}
\noindent
It attempts to parse a $\ty$. On success, the Rep will be a left
injection. The constraint in the set type will therefore fail. If a
$\ty$ cannot be parsed, the sum will default to $\ptrue$, the Rep will
be a right injection, and the constraint will succeed. The use of the
sum in the underlying type is critical as it allows the set-type to be
error free even if parsing a $\ty$ fails.

With $\pnotn$, we can encode the unbounded \datascript{} array as
follows:
\[
  \infer{
    \ctxt \turn {dty} \; [{length}] \Longrightarrow 
    \pseq \ty {\ptrue{}} {\pterm {\ilam x {} \ifalse} {\pnot \ty}} : \kty
  }{ 
    \ctxt \turn {dty} \Longrightarrow \ty : \kty 
  }
\]
Note that the termination predicate is trivially false, as we use the
lookahead-terminator exclusively to terminate the array.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "semantics"
%%% End: 
