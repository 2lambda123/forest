\section{Encoding DDLs in the DDC}
\label{sec:encodings}

We can better understand the data description languages described
earlier by translating their constructs into the types of \ddc{}. We
begin with the translation of \ipads{}, which captures many of the
common features of DDLs. Then, we introduce some features not found in
\ipads{} and give their semantics with \ddc{}.  Next, we list features
of \datascript{} and \packettypes{} which we can encode in \ddc{},
without detaling the translation. Finally, we briefly discuss some
features not encodeable in \ddc{} and explain these limitations.

\subsection{IPADS Translation}
\label{sec:trans-sl}

\begin{figure*}
{\small
\fbox{$\ctxt \turn \mathit{prog} \cipads \ty \; \text{prog}$}

\[
 \infer[\text{Prog-One}]{ 
    \ctxt \turn \mathit{pty} \cipads \ty \; \text{prog}
  }{
    \ctxt \turn \mathit{pty} \cipads \ty : \kty
  }
\quad
  \infer[\text{Prog-Def}]{ 
    \ctxt \turn \ga = \mathit{pty}; \; \mathit{prog} \cipads \ty \; \text{prog}
  }{
    \ctxt \turn \mathit{prog}[\mathit{pty}/\ga] \cipads \ty \; \text{prog}
  }
\quad
  \infer[\text{Prog-RecDef}]{ 
    \ctxt \turn  \Prec{}\; \ga = \mathit{pty}; \; \mathit{prog} \cipads \ty \; \text{prog}
  }{
    \ctxt \turn \mathit{prog}[\Prec{}\; \ga.\mathit{pty}/\ga] \cipads \ty \; \text{prog}
  }
\]

\fbox{$\ctxt \turn \mathit{pty}  \cipads \ty : \kind$}

\[
  \infer[\text{Base}]{ 
    \ctxt \turn \Pbase e \cipads \pbase e : \kty
  }{
    \ctxt \turn e : \ity & (\Ikind(C) = \ity \to \kty)
  }
\quad
  \infer[\text{Pfun}]{ 
    \ctxt \turn \Pfun (x:\ity) = \mathit{pty} \cipads \plam x
    \ity \ty : \ity \to \kind
  }{
    \ectxt{x{:}\ity} \turn \mathit{pty} \cipads \ty : \kind
  }
\quad
  \infer[\text{App}]{ 
    \ctxt \turn \mathit{pty} \; e \cipads \ty \; e : \kind
  }{
    \ctxt \turn \mathit{pty} \cipads \ty : \ity \to \kind & \ctxt \turn e : \ity
  }
\]

\[
  \infer[\text{Pstruct}]{
    \begin{array}{l}
    \ctxt \turn \Pstruct \{x_1{:}\mathit{pty}_1 \dots x_n{:}\mathit{pty}_n\}
    \cipads \\
    \qquad \gS \; x_1{:}\ty_1. \cdots \gS \; x_{n-1}{:}\ty_{n-1}.\ty_n : \kty      
    \end{array}
  }{ 
    \begin{array}{c}
%       \ctxt_1 = \ctxt \quad \ity_{i-1} = \iprod{\itsem[\ty_{i-1}]} {\itpdsem[\ty_{i-1}]}\\
%       \ctxt_i = \ctxt_{i-1},x_{i-1}{:} \ity_{i-1} \quad 
%       (\text{for} \; i = 2 \ldots n) \\
%       \ctxt_i \turn \mathit{pty}_i \cipads \ty_i : \kty \quad
%       (\text{for} \; i = 1 \ldots n)
      \ctxt_i = \ctxt,x_1{:}\ity_1, \dots, x_{i-1}{:} \ity_{i-1} \\
      \ity_{i} = \iprod{\itsem[\ty_{i}]} {\itpdsem[\ty_{i}]} \quad
      \ctxt_i \turn \mathit{pty}_i \cipads \ty_i : \kty
    \end{array}
  }
\quad
  \infer[\text{Punion}]{
    \begin{array}{l}
      \ctxt \turn \Punion \{x_1{:}\mathit{pty}_1 \dots x_n{:}\mathit{pty}_n\}
      \cipads \\
      \ty_1 + \dots + \ty_n + \pfalse : \kty
    \end{array}
  }{ 
    \ctxt \turn \mathit{pty}_i \cipads \ty_i : \kty
  }
\]

\[
  \infer[\text{Palt}]{
    \ctxt \turn \Palt \{x_1{:}\mathit{pty}_1 \dots x_n{:}\mathit{pty}_n\} \cipads
    \ty_1 \& \dots \& \ty_n: \kty
  }{ 
    \ctxt \turn \mathit{pty}_i \cipads \ty_i : \kty
  }
\quad
  \infer[\text{Popt}]{
    \ctxt \turn \Popt \; \mathit{pty} \cipads
     \psum \ty {} \ptrue
  }{
    \ctxt \turn \mathit{pty} \cipads \ty : \kty
  }
\quad
  \infer[\text{Pwhere}]{
    \begin{array}{l}
      \ctxt \turn \mathit{pty} \; \Pwhere \, x.e \cipads  \\
      \qquad
      \pset x \ty {\iif {\pdok {x.\codefont{pd}}} \; \ithen e \; \ielse
        \itrue}
    \end{array}
  }{ 
     \ctxt \turn \mathit{pty} \cipads \ty : \kty & 
     \stsem[e,\ectxt{x{:}\iprod{\itsem[\ty]} {\itpdsem[\ty]}},\iboolty]
  }
\]

\[
  \infer[\text{Parray}]{
    \ctxt \turn \iParray{\mathit{pty}}{{pty_{sep}}}{{pty_{term}}}{} \cipads 
    \pseq \ty {\pscan {\ty_s}} {\pterm f {\ty_t}} : \kty
  }{ 
       \begin{array}{lr}
         \ctxt \turn \mathit{pty} \cipads \ty : \kty & 
         \ctxt \turn \mathit{pty}_{sep} \cipads \ty_s : \kty \\ 
         \ctxt \turn \mathit{pty}_{term} \cipads \ty_t : \kty &
         (f = \ilam x{}\ifalse)\\
       \end{array}
  }
\quad
  \infer[\text{Pcompute}]{ 
    \ctxt \turn \Pcompute{} \; e \cipads \pcompute e \ity : \kty
  }{
    \stsem[e,\ctxt,\ity]
  }
\]

\[
  \infer[\text{Plit}]{ 
    \ctxt \turn \Plit \const \cipads 
    \pscan {\pabsorb {\pset \var \ty {\ivar = \iconst}}} : \kty
  }{
    \stsem[\const,\ctxt,\ity] & \defty \ity \ty
  }
\quad
  \infer[\text{Var}]{ 
    \ctxt \turn \ga \cipads \ga
  }{}    
\quad
  \infer[\text{Prec}]{ 
    \ctxt \turn \Prec{}\; \ga.\mathit{pty} \cipads \pmu \ga \ty
  }{
    \ctxt \turn \mathit{pty} \cipads \ty
  }
\]
}
  \caption{Encoding \ipads{} in \ddc{}}
  \label{fig:encode-ipads}
\end{figure*}

In Section~\ref{sec:ddc-example}, we gave an example of how an
\ipads{} description would appear in \ddc{} and informally described
how \ipads{} is encoded in \ddc{}. In \figref{fig:encode-ipads}, we
formalize this translation. The judgment $\ctxt \turn {prog} \cipads
\ty\; \text{prog}$ indicates that the \ipads{} program ${prog}$ is encoded as \ddc{}
type $\ty$ in context $\ctxt$, while $\ctxt \turn \mathit{pty} \cipads
\ty$ does the same for \ipads{} types $\mathit{pty}$.

The function $\Ikind$ provides the kind of base types $C$.

struct, union, 

\subsection{Sketches of Other Features and DDLs}

PT has overlays. Here's example. We've developed translation of
overlay syntax. Relatively straightforward. Formalism allows us to
check them for well-formedness.
\\
\noindent
Switched unions:
\begin{code}
  if p then T1 else T2 =
    \{y:\{x:unit|!p\} + T1 | p\} +  T2\linebreak

  if p then T1 else T2 =
    S y:(\{x:unit|!p\} + T1).(\{x:unit| p\} + T2)\linebreak
  
  switch(e)\{
    c1 => T1
    c2 => T2
    ...
    default => Tdef
  \} \(\cipads{}\)
  (\(\gl\) c. 
   if c = c1 then T1 else
   if c = c2 then T2 else
   ...
   Tdef) e
\end{code}

In addition, we've looked at these features.

Features of other languages that we can encode:
\begin{itemize}
\item \datascript{}: primitive types, set types (enums and bitmask
  sets), arrays (greedy and fixed size), constraints, type parameters
  (by which they mean ...),
  non-overlapping lables.
\item \packettypes{}: arrays (fixed size and greedy), where clauses,
  structures, overlays, alternation.
\end{itemize}
% Note, as far as I can tell, neither \packettypes{} nor \datascript{}
% supports greedy arrays that include erroneous records.

The syntax of a \datascript{}-style array named ${id}$ with elements of
type ${dty}$ is ${dty}\;{id}[{length}]$, with length optional. If the
user supplies the length of the sequence then the array parser reads
exactly that number of elements. Otherwise, the parser continues until
an element constraint is violated or the input is completely consumed.

The first case be encoded in a straightforward manner with \ddc{}
sequences: 
\[
  \infer{
    \ctxt \turn {dty} \; [{length}] \cipads 
    \pseq \ty {\ptrue{}} {\pterm f {\pfalse{}}} : \kty
  }{ 
    \ctxt \turn {dty} \cipads \ty : \kty & 
    (f = \codefont{isLength} \; {length})
  }
\]
As binary data has no separators, we use $\ptrue$. The function {\tt
  isLength} is a curried function taking a length and a pair of rep
and PD arrays and returning a boolean indicating whether both arrays
have the specified length. As there is no lookahead-terminator, we use
$\pfalse$ (thereby guaranteeing that the array will not be terminated
due to lookahead).

For the second case, we need a way to terminate if the next element
will not parse correctly without consuming it. We cannot use the
termination predicate as it can only look at elements that have
already been parsed and hence consumed from the input. Therefore, we
need a way to encode the notion of a failed element parse in the
terminator type. To do so, we define $\pnot \ty$ to be:
 {\small
\[
\pset x {\psum \ty {} \ptrue} {\icaseg {x.rep} {\_}
  {\ifalse} {\_} {\itrue}}
\]}
\noindent
This type attempts to parse a $\ty$. On success, the rep will be a left
injection. The constraint in the set type will therefore fail. If a
$\ty$ cannot be parsed, the sum will default to $\ptrue$, the rep will
be a right injection, and the constraint will succeed. The use of the
sum in the underlying type is critical as it allows the set-type to be
error free even if parsing a $\ty$ fails.

With $\pnotn$, we can encode the unbounded \datascript{} array as
follows:
\[
  \infer{
    \ctxt \turn {dty} \; [{length}] \cipads 
    \pseq \ty {\ptrue{}} {\pterm {\ilam x {} \ifalse} {\pnot \ty}} : \kty
  }{ 
    \ctxt \turn {dty} \cipads \ty : \kty 
  }
\]
Note that the termination predicate is trivially false, as we use the
lookahead-terminator exclusively to terminate the array.


There are things we can't do as well, but we're happy with it ...

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "semantics"
%%% End: 
