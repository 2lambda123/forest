\section{\ipads{}:  An Idealized DDL}
\label{sec:ipads}

In this section, we define \ipads{}, an idealized data description
language.  \ipads{} captures the essence of \pads{} in a fashion
similar to the way that MinML~\cite{harper:plbook} captures the essence of ML or Featherweight
Java~\cite{igarasi+:featherweight} captures the essence of Java.  The main goal of this section is to introduce
the reader to the form and function of \ipads{} by giving its syntax
and walking through a couple of examples.  Though the syntax differs,
the structure of \pads{}' relatives \blt, \packettypes, and
\datascript{} are similar.  Later sections will show how to give a
formal semantics to \ipads.

\paragraph*{Preliminary Concepts.}
Like \pads, \packettypes, \datascript, and \blt, \ipads{} data
descriptions are types.  These types specify both the external data
format (a sequence of bits or characters) and a mapping into an
internal data structure in the host programming language.  In \pads,
the host language is C; in \ipads, the host language is an extension
of the polymorphic lambda calculus.  For the most part, however, the
specifics of the host language are unimportant.

A complete \ipads{} description (program), is a sequence of type definitions
terminated by a single type.  This terminal type describes the
entirety of a data source and it normally makes use of the previous 
type definitions to do so.  \ipads{} type definitions can have one of
two forms.  The form ($\alpha = pty$) introduces the type identifier
$\alpha$ and binds it to \ipads{} type $pty$.
The type identifier may be used in
subsequent types.  The second form  ($\Prec{}\; \alpha = pty$) introduces
a recursive type definition.  In this case, $\alpha$ may appear in 
$pty$.~\footnote{For technical reasons, 
we require that recursive definitions be {\it contractive} ---
$\alpha$ can only appear inside another type constructor such as a
record or union.  See Section~\ref{sec:ddc-kinding} for further details.}

Complex \ipads{} descriptions are built by gluing a collection of base
types together using \ipads{} type constructors.  In our examples, we
assume \ipads{} contains a wide variety of base types including base
types for integers (\Puint{} is an ASCII representation of an unsigned
32-bit integer), characters (\Pchar), strings (\Pstring), dates
(\Pdate), ip addresses (\Pip) and others.  In general, these base
types may parameterized.  For instance, we will assume \Pstring{} is
parameterized by a string argument that signals termination of the
string.  For instance, \Pstring({\tt " "}) describes any sequence of
characters that is eventually terminated by a space character. Note,
though, that the space character is not considered part of the string
that has just been read -- it will be part of the next object.
Similarly, \padskw{Puint16$\_$FW}{\tt (3)} is an unsigned 16-bit
integer described in exactly {\tt 3} characters in the data source.
In general, we write $\pbase{e}$ for some base type parameterized by a
(host language) expression $e$.

When interpreted as a parser, each of these base types reads
the external data source and generates a pair of data structures
in the host language.  The first data structure is the
{\em internal representation} of the data source and
the second is the {\em parse descriptor}, which contains meta-data collected during parsing.
For instance, \Puint{} reads a series of digits from the
data source and generates an unsigned 32-bit integer as its
internal representation.  \Pstring{} generates a 
host language string as its internal representation.  
\Pdate{} might read dates in a multitude of
different formats, but always generates a record
with time, day, month, and year fields as its internal 
representation.  Whenever an \ipads{} parser encounters
an unexpected character or bit-sequence, it sets the internal representation to
$\ierr$ (\ie{} null) and notes the error in the
parse descriptor.

\paragraph*{An \ipads{} Example.}
\ipads{} contains a rich collection of type constructors for creating
sophisticated descriptions of ad hoc data.  We present most of these
constructors through a series of examples.  The first example, shown
in its entirety in \figref{fig:ipads-clf}, describes the Common Web
Log Format~\cite{wpp}, which web servers use to log the requests they
receive.  \figref{fig:ipads-clf-data} shows a couple of sample
records.  Briefly, each line in a log file represents one request, and
a complete log may contain any number of requests.  A request begins
with an IP address and is followed by two optional ids.  In the
example, the ids are missing and dashes stand in for them.  Next,
surrounded by square brackets, is a date.  After the date, a string in
quotation marks describes the web request that was made.  Finally, the
line ends with a pair of integers denoting the response code and the
number of bytes returned to the client.

The \ipads{} description of web logs is most easily read from bottom to top.
The terminal type, which describes the entire web log source, is an array type.
All arrays in \ipads{} takes three arguments: the description
of the elements in the array (in this case, {\tt entry$\_$t}),
the description of the separator that appears in between each element
(in this case, a newline character \Peor{} as there is one entry per line), and 
the description of the terminator (in this case, the end-of-file character).
In \pads{} itself there is a much wider selection of separators and
termination conditions, but these additional variations are of little semantic 
interest so we omit them from \ipads.  
The internal host-language data structure corresponding to
an array is a sequence (list) of elements.
The separator and terminator characters are not 
represented internally.

The contents of each line in a web log, 
{\tt entry$\_$t}, are described using a
\Pstruct.  Like an array, a \Pstruct{} describes a sequence of 
objects in a data source.  The result of parsing a \Pstruct{} is
represented as a record of objects in the host language.  The elements
of a \Pstruct{} are either named fields (\eg {\tt client : \Pip{}}) or
anonymous fields (\eg{} {\tt " "}).  Reading from the beginning of {\tt
entry$\_$t}, the \Pstruct{} declares that the first thing on the line
is an IP address (\Pip) and immediately following it is a space
character ({\tt " "}).  Next, the data source should contain an {\tt
authid$\_$t} followed by another space character and so on.

The last field of {\tt entry$\_$t} is quite different from the others.
It is a \Pcompute{} type, meaning it does not match any characters in
the data source, but it does form a part of the internal data structure
that may be used by host programs.  The argument of a \Pcompute{}
field is an arbitrary host language expression that determines the value of the associated field.  In this case, the
field {\tt academic} computes a boolean that indicates whether 
the web request came from an academic site.  To do so, it uses the
host language function {\tt getdomain}, which operates over the
internal representation of IP addresses.  Notice that the computation
depends upon a host language value constructed earlier --- the value
stored in the {\tt client} field.  In general, later fields in a \Pstruct{} may
reference and depend upon fields that appear earlier in the \Pstruct{}.

The {\tt entry$\_$t} description depends upon the type {\tt authid$\_$t} to
describe the two fields {\tt remoteid} and {\tt localid}.  The {\tt
authid$\_$t} type is a \Punion{} with two branches.  Unions are
represented internally as sum types.  If the data source can be
described by the first branch (a dash), then the internal
representation is the left/first injection into the sum.  If the data
source cannot be described by the first branch, but can be described
by the second branch then the internal representation is the second
injection into the sum.  Otherwise, there is an error.

Finally, the {\tt response$\_$t} type is a \Pfun, a user-defined
parameterized type.  The parameter of {\tt response$\_$t} is a host
language integer.  The body of the \Pfun{} is a \padskw{Puint16$\_$FW}
where \padskw{FW}, the fixed width, is the argument of the function.  In
addition, the value of the fixed-width integer is constrained by the
\Pwhere{} clause.  In this case, the \Pwhere{} clause demands that
the fixed-width integer {\tt y} that is read from the source lie 
between 100 and 599.
Any value outside this range will be considered a semantic error.
In general, a \Pwhere{} clause may be attached to 
any type specification.  The expression in the \Pwhere{} clause
is an arbitrary host language expression with boolean type.

% Note that ${pty} \; \Pwhere{} \, x.e$ binds $x$ in $e$. 

\begin{figure}

\begin{code}
response\_t =
  \Pfun(x:int) =
    \padskw{Puint16\_FW}(x) \Pwhere{} y.100 <= y and y < 600;
\(\qquad\)
authid\_t = \Punion{} \{
  unauthorized : "-";
  id           : \Pstring (" ");
\};
\(\qquad\)
entry\_t = \Pstruct{} \{
  client   : \Pip{};             " ";
  remoteid : authid\_t;        " ";
  localid  : authid\_t;        " [";
  date     : \Pdate("]");      "] \(\backslash\)"";
  request  : \Pstring("\(\backslash\)"");   "\(\backslash\)" ";
  response : response\_t 3;    " "; 
  length   : \Puint{};
  academic : \Pcompute 
              (getdomain client) == "edu";
\};
\(\qquad\)
entry\_t \Parray{}(\Peor, \Peof)
\end{code}

\caption{\ipads{} Common Web Log Format Description}
\label{fig:ipads-clf}

\end{figure}

\begin{figure*}
\begin{code}
 207.136.97.49 - - [15/Oct/1997:18:46:51 -0700] "GET /tk/p.txt HTTP/1.0" 200 30
 tj62.aol.com - - [16/Oct/1997:14:32:22 -0700] "POST /scpt/confirm HTTP/1.0" 200 941
\end{code}
\caption{Sample Common Web Log Data}
\label{fig:ipads-clf-data}

\end{figure*}



\paragraph*{A Recursive \ipads{} Example.}
Figure~\ref{fig:ipads-newick} presents a second \ipads{} example.
In this example, \ipads{} describes the Newick format, a flat
representation of tree-structured data.  The leaves of the trees
are string names that describe an ``entity''.   In our variant of Newick, 
leaf names may be omitted if the user chooses.  If the leaf name does appear,
it is followed by a colon and a number.  The number describes the ``distance''
from the parent node.  Microbiologists often use
distances to describe the
number of genetic mutations that have to occur to move from the parent 
to the child.  An internal tree node may have any number of (comma-separated)
children within parentheses.  Distances follow the closed-paren
of the internal tree node.

The Newick format and other formats that describe tree-shaped 
hierarchies~\cite{geneontology,newick}
provide strong motivation for including recursion in \ipads.  
We have not been able to find any useable description of Newick data as
simple sequences (structs and arrays) and alternatives (unions); some
kind of recursive description appears essential.
The definition of the type {\tt tree\_t} introduces recursion.
The rest of the format description uses types we have seen before such as
\Pstruct, \Parray{}, and \Punion.


\begin{figure}

\begin{code}
node\_t = \Popt \Pstruct \{
                name : \Pstring(":"); ":";
                dist : \Puint;  
              \};
\(\qquad\)
\Prec tree\_t =
  \Punion \{
    internal : 
      \Pstruct \{
        "(";
        branches : tree\_t \Parray(",",")");
        "):";
        dist : \Puint;
      \};
    leaf : node\_t;
  \};
\(\qquad\)
\Pstruct \{
  body : tree\_t;
  ";";
\}
\(\qquad\)
(* Example data:
   (B:3,(A:5,C:10,E:2):12,D:0):32;
*)

\end{code}
\caption{\ipads{} Newick Format Description}
\label{fig:ipads-newick}

\end{figure}

\paragraph*{Formal Syntax.}
Figure~\ref{fig:ipads-syntax} summarizes the formal syntax of \ipads.
In the examples we have discussed, we have allowed ourselves to
abbreviate this syntax in places.  For instance, in general, we omit
``\padskw{Plit}'' from ``\Plit{c}{}'' when specifying constant
(singleton) types in our examples.  In addition, formally, every field
of a structure is labeled.  However, rather than write ``$x :
\Plit{c};$'' we write ``$c;$'' instead.  In addition, formally, all
base types \Pbase{} have a single parameter whereas we have omitted
parameters for base types such as \Puint.  Also, expressions $e$ and
types $\sigma$ are taken from the host language, which is detailed in
Section~\ref{sec:host-lang}. Notice, however, that we use
$x$ for host language expression variables and $\alpha$ for \ipads{}
type variables. \reminder{Should we add Palt to syntax chart and
  mention it here?}


\begin{figure}
\begin{bnf}
  \name{Programs} \meta{prog} \::= \nont {pty} \| \nont {spec}; \; \nont {prog}\\
  \mname{Type Definitions}{2} \meta{spec} \::= \alpha = \nont {pty}
  \|  \Prec{} \; \alpha = \nont {pty} \\ \\
  \name{Types} \meta{pty} \::= 
    \pbase{e} \| \alpha \| \Plit{\const} \nlalt
    \Pfun{} (\var:\ity) = \nont{pty} \| \nont {pty}\; e \nlalt
    \Pstruct{} \{\overrightarrow {\nont {field}}\} \| 
    \Punion{} \{\overrightarrow {\nont {field}}\} \nlalt
    \nont{pty} \; \Pwhere{} \, x.e \| 
% \Palt{} \{\vec {\nont{field}}\} \|
    \Popt{}\; \nont{pty} \nlalt 
    \iParray{\nont{pty}}{\nont{pty}}{\nont{pty}}{} \| 
    \Pcompute{} \; e \nlalt
    \Prec{} \; \alpha . \nont {pty}
    \\
  \name{Fields} \meta{field}  \::= \var : \nont {pty}
%     \\
%   \mname{Host Lang. Expressions}{2} \meta{e}  \::= ... \\ \\
%   \mname{Host Lang. Types}{2} \meta{\sigma}  \::= ...
\end{bnf}
\caption{\ipads{} Syntax}
\label{fig:ipads-syntax}
\end{figure}


% \subsection{Example}
% \begin{itemize}
% \item Use two data sources, one buggy one not.
% \item explain data.
% \item show IPADS desc. of data source.
% \item explain remaining features.
% \end{itemize}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "semantics"
%%% End: 
