\section{Applications of the Semantics}
\label{sec:applications}

In the previous section, we described a number of ways in which our
semantics helps us understand what the each DDL is. In this section,
we will provide examples of how the \ddc{} taught us about what
shouldn't be and questions about what \pads{} should be. In addition,
our work on recursive typs in \ddc{} helped guide us in adding
recursive types to the actual \pads{} implementation. We describe the
implementation in \pads{} and the contributions of \ddc{} in the
second part of this section.

% The semantics of \ddc{} was based upon the implementation of \pads{}.
% In the course of defining the semantics, the high-level view afforded
% us by the semantics highlighted a number of bugs and potential
% improvements in the \pads{} implementation. We briefly discuss them
% below.

\subsection{Bug Hunting}

We begin with two examples of how the semantics helped keep \pads{}
from what it shouldn't be. First, we present an example of bug that we
noticed. In our semantics, the error accounting for each type is done
inside of the PD constructor functions. We defined the logic inside
these functions based on the actual implementation in \pads{}. In the
process, the methodology behind the error accounting became clear,
including that each subcomponent adds 1 to the error count of its
parent if and only if it had errors. However, when we got to arrays,
we noticed a deviation from this methodology. Further examination
revealed that the deviation was in fact a subtle bug. We were only
able to find it due to the conciseness provided by the semantics.

%   Arbitrary behaviour of error accounting for arrays with regard
%   to element errors. The implementation only counts an element error
%   if it is the first error to occur. Therefore, whether or not element
%   errors affect the overall count depends on arbitrary other errors.
%   The semantics highlighted this error as it was inconsistent with the
%   error accounting of other types. Counting it exactly once would
%   parallel the other types, if we consider the array data-structure
%   (in the array rep) as one subelement of the rep.
Secondly, the semantics help us avoid potential non-termination of
array parsers. In the original implementation of \pads{} arrays,
arrays were not guaranteed to terminate, a bug that was only uncovered
when it hung a real program. With the formal semantics we can prove
that the parsers generated by the compiler always terminate, ensuring
that this bug does not resurface.


\subsection{Challenging Assumptions}

Next, we present a number of design choices that the semantics
challenges us to defend. The \pads{}/C implementation includes a
number of optimization that are potentially unsafe or undesirable.
For example, \pads{}/C does not record an ending offset in a PD unless
the parse contained an error. Yet, from the semantics we see that
recording the entire span of an element is desirable even for
error-free values.  A second example are the semantics of \Pomit{}
with respect to field scope. Currently, we allow omitted fields to be
accessed just as other fields during parsing, by saving their values
in temporary variables.  They are not available otherwise, however, as
they are not saved in the output rep. While this semantics can be very
useful, it discourages any simple understanding of \Pomit{}. Instead,
the \ddc{} makes the value unavailable anywhere, returning the
$\iunitty$ value for the $\pabsorbn$ type. A final example is the
semantics of constrained types (\Pwhere{} clauses and field
constraints).

In \pads{}/C, if a field's constraint is violated its rep is still
valid. This design required a lot of consideration in formalizing the
semantics, due to the potential safety problem of providing the
semantically invalid value to the user.  The dilemma is that the user
should be able to get at the erroneous value somehow, if only for
debugging purposes. In the semantics, we choose to inject the value
into a sum, to force the user check the valeus tag before using it.
different choice. However, in \C{}, there is no way to force such a
check. Therefore, we left the value alone. The semantics highlights
that in a different language binding, we might make a different
decision.  Again, in the words of Landin ``we must systematize their
design so that a new language is a point chosen from a well-mapped
space, rather than a laboriously devised construction.''

\subsection{Distinguishing the Essential from the Accidental}

In in his 1965 paper, P.J. Landin asks ``Do the idiosyncracies [of a
language] reflect basic logical properties of the situations that are
being catered for?  Or are they accidents of history and personal
background that may be obscuring fruitful developments?''  The
semantics helped us answer this question with regard to the \Pomit{}
and \Pcompute{} qualifiers of \pads{}.  Originally, they were only
intended for use within \Pstructs{}, as type qualifiers for fields.
Quite by accident, they soon appeared in \Punion{}s as well, but
spread no further. Yet, for simplicity, we chose to encode \Pomit{}
and \Pcompute{} in \ddc{} with their own, first class types
($\pabsorbn$ and $\pcomputen$, respectively). Due to this choice, we
discovered that both can encode more \pads{} features than just the
qualifiers for which we had originally intended them. In this case,
then, the \ddc{} highlighed that the restriction of \Pomit{} and
\Pcompute{} to mere type qualifers for \Punion{} and \Pstruct{} fields
was an ``accident of history,'' rather than a ``basic logical
property'' of data description.

We conclude with an example of another feature to which Landin's
question applies, but for which we do not yet know the answer and must
leave it as an interesting avenue of future work. The \Punion{}
construct chooses between branches by searching for the first one
without errors. However, this semantics ignores situations in which
the correct branch in fact has errors. Often, this behaviour will lead
to parsing nothing and flagging a panic, rather than parsing the
correct branch to the best of its ability. Clearly, a more robust
\Punion{} would be desireable. Unfortunately, the design of such a
\Punion{} is far from obvious. Once we leave a black-and-white model,
there is a lot of gray from which to choose. The question, then, is
whether the current semantics is an essential feature of such a union
construct, or whether its an accident of history that leaves room for
improvement.

\subsection{Principled Language Extension: Adding Recursion to \pads{}}

From the theory we learned:
\begin{itemize}
\item Type checking: types should be contractive (not yet implemented)
\item Compilation: insert forward declaration and use function name for
  references to types.
\item rep and PD type: need indirection, but don't need special reps
  and pds for recursive types. So, recursion works as modifier of
  other types.
\end{itemize}

We add the construct \cd{Precur id} to \pads{}. It inserts all
necessary forward declarations and ensures that data from the type is
referenced through pointers. Here is the Newick format in the extended
version of \pads{}:

\begin{code}
Popt Pstruct node\{
  Pstring(:":":) name; ":";
  Puint32 dist;
\};\linebreak

Precur itree;\linebreak

Punion tree \{
  itree internal;
  node leaf;
\};\linebreak

Pstruct itree\{
  "(";
  tree[] branches: Psep(",") && Pterm(")");
  ")";
\};
\end{code}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "semantics"
%%% End: 
