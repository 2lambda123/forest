\section{Applications of the Semantics}
\label{sec:applications}

The semantics of \ddc{} was based upon the implementation of \pads{}.
In the course of defining the semantics, the high-level view afforded
us by the semantics, highlighted a number of bugs and potential
improvements in the \pads{} implementation. We briefly discuss them
below.

Bugs:
\begin{itemize}
\item Potential non-termination of array parsers. In the original
  implementation of \pads{} arrays, arrays were not guaranteed to
  compile. With the formal semantics we can prove that the parsers
  generated by the compiler always terminate, ensuring that this big
  not resurface.

\item Arbitrary behaviour of error accounting for arrays with regard
  to element errors. The implementation only counts an element error
  if it is the first error to occur. Therefore, whether or not element
  errors affect the overall count depends on arbitrary other errors.
  The semantics highlighted this error as it was inconsistent with the
  error accounting of other types. Counting it exactly once would
  parallel the other types, if we consider the array data-structure
  (in the array rep) as one subelement of the rep.
\end{itemize} 

Insights:

Try to order according to Landin quote. Mention snippets of quote as needed.

PADS/C makes choices for optimizations that are potentially
unsafe. Semantics highlights this.
\begin{itemize}
\item We should include begining and end locations in the PDs even when there
   is no error.

 \item The semantics of Pomit with regard to field scope: Currently,
   we allow omitted fields to be accessed just as other fields during
   parsing.  They are not available otherwise, however, so not in
   unparse functions or in the in-memory validation functions. For
   consistency, we make them unavailable anywhere.
\end{itemize}


\begin{itemize}     
 \item Refer back to Landin quote.  Absorb and compute types are not
   specific to Pstructs: Compute should definitely also be in unions
   because it allows default values.  Literals, which we are
   representing as absorbs in structs, are also very useful in unions,
   although they have a very different semantics.  In unions, they
   play the role of data constants, with only the tag being recorded
   in the in-memory representation.  So I think absorbs are also
   important in unions.

   Absorbs are essentially also being used in array separators.

   So, I think it is useful to have them as stand alone constructs.  Like
   None, though, they'll be most useful in certain contexts, however.

 \item If a field's constraint is violated its rep is still
   valid. This needed a lot of thought in formalizing the
   semantics. Potential safety problem.
   The pd should indicate a constraint error, but the user should be
   able to get at the erroneous value somehow, if only for debugging
   purposes.
   IN a different language binding, might make different choice.
\end{itemize}

Future work:
\begin{itemize}
 \item. Unions are brittle w.r.t. errors. Lets examine min-error model
   as opposed to no-error model.(also array termination and
   separator). Also, consider how this clarifies need for distinction
   b/w panic and err.
 \end{itemize}

\subsection{Foundation for Extending Implementation with Recursion}

From the theory we learned:
\begin{itemize}
\item Type checking: types should be contractive (not yet implemented)
\item Compilation: insert forward declaration and use function name for
  references to types.
\item rep and PD type: need indirection, but don't need special reps
  and pds for recursive types. So, recursion works as modifier of
  other types.
\end{itemize}

We add the construct \cd{Precur id} to \pads{}. It inserts all
necessary forward declarations and ensures that data from the type is
referenced through pointers. Here is the Newick format in the extended
version of \pads{}:

\begin{code}
Popt Pstruct node\{
  Pstring(:":":) name; ":";
  Puint32 dist;
\};\linebreak

Precur itree;\linebreak

Punion tree \{
  itree internal;
  node leaf;
\};\linebreak

Pstruct itree\{
  "(";
  tree[] branches: Psep(",") && Pterm(")");
  ")";
\};
\end{code}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "semantics"
%%% End: 
