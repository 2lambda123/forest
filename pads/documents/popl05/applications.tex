\section{Applications of the Semantics}
\label{sec:applications}

The development of \ddc{} and defining a semantics for \ipads{}
has had a substantial impact on the real \pads{} implementation.

% In the previous section, we described a number of ways in which our
% semantics helps us understand what the each DDL is. In this section,
% we will provide examples of how the \ddc{} taught us about what
% shouldn't be and questions about what \pads{} should be. In addition,
% our work on recursive typs in \ddc{} helped guide us in adding
% recursive types to the actual \pads{} implementation. We describe the
% implementation in \pads{} and the contributions of \ddc{} in the
% second part of this section.

% The semantics of \ddc{} was based upon the implementation of \pads{}.
% In the course of defining the semantics, the high-level view afforded
% us by the semantics highlighted a number of bugs and potential
% improvements in the \pads{} implementation. We briefly discuss them
% below.

\subsection{Bug Hunting}

We developed our semantics in part by going line-by-line through
key parts of the \pads{} implementation to uncover implicit invariants in the
code.  In the process of trying to understand and formalize these
invariants we realized that our error accounting methodology was
inconsistent, particularly in the case of arrays.   When we realized
the problem, we were able to formulate a clear rule to apply universally:
each subcomponent adds 1 to the error count of its
parent if and only if it has errors.  If we had not tried to 
formalize our semantics, it is unlikely we would have made the
error accounting rule precise, leaving our implementation buggy 
and inconsistent.

The semantics also helped us avoid potential non-termination of
array parsers. In the original implementation of \pads{} arrays,
it was possible to write non-terminating arrays, a bug that was only uncovered
when it hung a real program.  We have fixed the bug and
used the semantics to verify our fix.~\footnote{The offending code
was {\tt nothing array(nothing,eof)} where {\tt nothing}
is a type that does not consume any input.  A careful read of
the \ddc{} semantics of arrays, which has now been implemented
in \pads{}, shows that array parsing terminates after an iteration
in which the array parser reads nothing.}
%With the formal semantics we can prove
%that the parsers generated by the compiler always terminate, ensuring
%that this bug does not resurface.



% We begin with two examples of how the semantics helped keep \pads{}
% from what it shouldn't be. First, we present an example of bug that we
% noticed. In our semantics, the error accounting for each type is done
% inside of the PD constructor functions. We defined the logic inside
% these functions based on the actual implementation in \pads{}. In the
% process, the methodology behind the error accounting became clear,
% including that each subcomponent adds 1 to the error count of its
% parent if and only if it had errors. However, when we got to arrays,
% we noticed a deviation from this methodology. Further examination
% revealed that the deviation was in fact a subtle bug. We were only
% able to find it becuase of the conciseness provided by the semantics.

%   Arbitrary behaviour of error accounting for arrays with regard
%   to element errors. The implementation only counts an element error
%   if it is the first error to occur. Therefore, whether or not element
%   errors affect the overall count depends on arbitrary other errors.
%   The semantics highlighted this error as it was inconsistent with the
%   error accounting of other types. Counting it exactly once would
%   parallel the other types, if we consider the array data-structure
%   (in the array representation) as one subelement of the representation.
% Secondly, the semantics help us avoid potential non-termination of
% array parsers. In the original implementation of \pads{} arrays,
% arrays were not guaranteed to terminate, a bug that was only uncovered
% when it hung a real program. With the formal semantics we can prove
% that the parsers generated by the compiler always terminate, ensuring
% that this bug does not resurface.


% \subsection{Challenging Assumptions}

% Next, we present a number of design choices that the semantics
% challenges us to defend. The \pads{}/C implementation includes a
% number of optimization that are potentially unsafe or undesirable.
% For example, \pads{}/C does not record an ending offset in a PD unless
% the parse contained an error. Yet, from the semantics we see that
% recording the entire span of an element is desirable even for
% error-free values.  A second example are the semantics of \Pomit{}
% with respect to field scope. Currently, we allow omitted fields to be
% accessed just as other fields during parsing, by saving their values
% in temporary variables.  They are not available otherwise, however, as
% they are not saved in the output representation. While this semantics
% can be very useful, it discourages any simple understanding of
% \Pomit{}. Instead, the \ddc{} makes the value unavailable anywhere,
% returning the $\iunitty$ value for the $\pabsorbn$ type.


\subsection{Principled Implementation Extension: Recursion}

Unlike the rest of \pads{}, the semantics of recursive types
preceded the implementation. We used the semantics to guide
our design decisions in the implementation, particularly in 
preventing the user from writing down non-contractive types and in implementing the parsers with recursive functions.
\trversion{
the
following two respects:
\begin{itemize}
\item Static semantics. The user is not allowed to write down a
  non-contractive type. The recursion always passes through another
  type constructor.
\item Parser generation. We implement the parsers with recursive
  functions.
  
% \item Representation and parse descriptor type. We don't need
%   special representation and PD types for recursive types. However, we
%   need to interpret the names of recursive types as 
%   pointers and as the underlying type itself. While this is
%   implicit in the semantics, it must be done explicitly by the
%   compiler in the implementation.
\end{itemize}
}

\subsection{Distinguishing the Essential from the Accidental}

In his 1965 paper, P.J. Landin asks ``Do the idiosyncracies [of a
language] reflect basic logical properties of the situations that are
being catered for?  Or are they accidents of history and personal
background that may be obscuring fruitful developments?''  

The semantics helped us answer this question with regard to the \Pomit{}
and \Pcompute{} qualifiers of \pads{}.  Originally, these qualifiers
were only intended to be used on fields within \Pstruct{}s.
By an accident of the implementation, they appeared in \Punion{}s
as well, but spread no further. However, when designing \ddc{},
we followed the {\em principle of orthogonality},
which suggests that every linguistic concept
be defined independently of every other.  In particular, we observed that
``omitting'' data from, or including (``computing'') data in,
the internal representation is not dependent upon 
the idea of structures or unions.  Furthermore, we found that
developing these concepts as first-class constructors
$\pabsorbn$ and $\pcomputen$ in \ddc{} allowed us to encode
the semantics of other \pads{} features (\eg, literals) elegantly.
%Consequently, we encourage future language designers to think of and
%implement these ideas as first-class constructors.

% Yet, for simplicity, we chose to
% encode \Pomit{} and \Pcompute{} in \ddc{} with their own, first class
% types ($\pabsorbn$ and $\pcomputen$, respectively). Because of this
% choice, we discovered that both can encode more \pads{} features than
% just the qualifiers for which we had originally intended them. In this
% case, then, the \ddc{} highlighed that the restriction of \Pomit{} and
% \Pcompute{} to mere type qualifers for \Punion{} and \Pstruct{} fields
% was an ``accident of history,'' rather than a ``basic logical
% property'' of data description.

Another accident in the
\pads{} implementation is that there is no guarantee that
certain features are ``safe.''  This is due in part to the fact that
the \pads{} host language is \C{} and in part to the desire to implement
certain optimizations.  As an example, when a 
semantic error in a \Pwhere{} clause is detected, the parser sets a flag.  
However, the \C{} programmer is not forced to check this flag before using 
the value in question and therefore can unknowingly process invalid data.  The 
semantics of \ddc{} deviates from the \C{} implementation here as it suggests
constrained types be implemented as values with a sum type.  A lambda
calculus programmer is required to perform a case on the sum and
hence will always be informed of an error.
%For the sake of safety, we believe the \C{} interface should be reworked 
%here to match the semantics.  
Perhaps more importantly, the \C{} implementation does not serve as a
proper guide for the integration of \pads{} ideas with a safe language like ML.
For this purpose, the \ddc{} is much more appropriate.

% As an aside, we are currently designing an ML binding for 
% pads~\cite{fernandez+:padst}
% and in this and other places, the \ddc{} is a
% superior guide than the implementation.

% This and several other deviations
% Hence, in this respect,
% the current \pads{} integration with \C{} is a 
% poor model from which to design

% can easily forget to check , involves
% constrained types (\Pwhere{} clauses).  In \pads{}/C, 
% it is easy for programmer to forget to check to check a
% parse descriptor to determine whether or not aif a field's constraint
% is violated, its representation is still valid. 

% This design required a lot of
% consideration in formalizing the semantics, because of the potential
% safety problem of providing the semantically invalid value to the
% user.  The dilemma is that the user should be able to get at the
% erroneous value somehow, if only for debugging purposes. In the
% semantics, we choose to inject the value into a sum, to force the user
% check the valeus tag before using it.  different choice. However, in
% \C{}, there is no way to force such a check. Therefore, we left the
% value alone. The semantics highlights that in a different language
% binding, we might make a different decision.  Again, in the words of
% Landin ``we must systematize their design so that a new language is a
% point chosen from a well-mapped space, rather than a laboriously
% devised construction.''


We conclude with an example of another feature to which Landin's
question applies, but for which we do not yet know the answer. The \Punion{}
construct chooses between branches by searching for the first one
without errors. However, this semantics ignores situations in which
the correct branch in fact has errors. Often, this behavior will lead
to parsing nothing and flagging a panic, rather than parsing the
correct branch to the best of its ability.  The process of
developing a semantics brought this fact to our attention and
it now seems clear we would like a more robust
\Punion, but we are not currently sure how to design one. 
% would be desireable. Unfortunately, the design of such a
% \Punion{} is far from obvious. Once we leave a black-and-white model,
% there is a lot of gray from which to choose. The question, then, is
% whether the current semantics is an essential feature of such a union
% construct, or whether its an accident of history that leaves room for
% improvement.

% We now briefly describe the actual implementation. We add the
% construct \cd{Precur id} to \pads{}. It inserts all necessary forward
% declarations and ensures that representation and PD of the recursive
% type is referenced through pointers. Here is the Newick format in the
% extended version of \pads{}:

% \begin{code}
% Popt Pstruct node\{
%   Pstring(:":":) name; ":";
%   Puint32 dist;
% \};\linebreak

% Precur itree;\linebreak

% Punion tree \{
%   itree internal;
%   node leaf;
% \};\linebreak

% Pstruct itree\{
%   "(";
%   tree[] branches: Psep(",") && Pterm(")");
%   ")";
% \};
% \end{code}

% We note that the \cd{Precur} keyword need not appear before the actual
% definition of \cd{itree} as the compiler can automatically make the
% necessary modifications to all types that are declared recursive
% with\cd{Precur}.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "semantics"
%%% End: 
