\section{\ddc{} Semantics}
\label{sec:ddc-sem}

The primitives of \ddc{} are deceptively simple.  Each captures a
simple concept, often familiar from type theory. However, in reality,
each primitive is multi-faceted. Each simultaneously describes a
collection of valid bit strings, two datatypes in the host language --
one for the data representation (rep) itself and one for its parse
descriptor (PD) -- and a transformation from bit strings, including
invalid ones, into data and corresponding meta-data.

\cut{
With the \ddc{} semantics, we seek to explain to data description
language users the process by which a bit stream is converted into an
in-memory representation. For the analyst, the data format already
existed, with a specific meaning. We precisely specify the transform
so the analyst knows how that meaning is mapped into the host
language. Also, it is critical that \ddc{} include error reporting and
error handling mechanisms because errors are an intrinsic
characteristic of ad hoc data.
}

We give semantics to well formed types with three semantic functions
that each precisely convey a particular facet of a type's meaning.
The functions $\itsem[\cdot]$ and $\itpdsem[\cdot]$ describe the {\it
  representation semantics} of \ddc{}, detailing the types of the
in-memory representation of the data and its meta-data -- the rep and
PD types, respectively. The function $\trans[\cdot,,]$ describes the
{\it parsing semantics} of \ddc{}, defining a function in the
\implang{} language that parses bit strings to produce structured data
and meta-data. We do not directly define the set of valid bit strings
for each type, but rather define it to be those strings for which the PD
indicates no errors when parsed.

We begin this section with a kinding judgment that determines whether
a type is well formed. In the remainder of the section, we formalize
the three-fold semantics of well formed \ddc{} types.

\cut{
\begin{table}
  \begin{center}
    \renewcommand{\arraystretch}{1.35}
    \begin{tabular}{l l}
      $\ddck[\ty,{\rctxt;\ctxt},\kind,\mcon]$ & {\it \ddc{}-type
        kinding}\\
      $\itsem[\ty] = \ity$ & {\it representation types of \ddc{} types}\\
      $\itpdsem[\ty] = \ity$ & {\it pd types of \ddc{} types}\\
      $\trans[\ty,\ctxt,\gk] = e$   & {\it \ddc{}-type semantics} \\
      $\kTrans[\gk,\ty] = \ity$     & {\it parser type} \\
      $\ptyc \rctxt = \ctxt$     & {\it context parser type}\\
      $\stsem[e,{\pctxt;\ctxt},\ity]$ & {\it \implang expression typing} \\
      $e \stepsto e'$ & {\it \implang expression evaluation}
    \end{tabular}
    \caption{Translations and Judgments}
    \label{tab:judg-list}
  \end{center}
\end{table}
For reference, we provide in
\tblref{tab:judg-list} a listing of all the functions and judgments
defined in this section and a brief description of each.  
}

\subsection{\ddc{} Kinding}
\label{sec:ddc-kinding}

% In essence, we
% need this well-formedness judgment to ensure two things: first, that
% type abstractions are applied to expressions of the correct type, and
% second, that higher-order primitives do not appear as direct subcomponents
% of basic primitives.

% The essential difference between type abstractions and basic types
% is that type constructors cannot directly describe a data source.
% They must always be fully applied first.  Therefore, we use the
% kinding system to differentiate between type constructors and ???
% types.  

\begin{figure*}[t]
\small
\fbox{$\ddck[\ty,\rctxt;\ctxt,\kind,\mcon]$}\\
\[
\infer[\text{Unit}]{
    \ddck[\ptrue,\rctxt;\ctxt,\kty,\con]
  }{\wfd {} \ctxt}
\quad 
\infer[\text{Bottom}]{
    \ddck[\pfalse,\rctxt;\ctxt,\kty,\con]
  }{\wfd {} \ctxt}
\quad 
\infer[\text{Const}]{
    \ddck[\pbase{e},\rctxt;\ctxt,\kty,\con]
  }{
    \begin{semcond}
      \stsem[e,\ctxt,\ity] &
      (\vlet {\ity \iarrowi \kty} {\Ikind(C)})
    \end{semcond}
  }
\]

\[
\infer[\text{Abs}]{
    \ddck[\plam{\var}{\ity}{\ty},
         \rctxt;\ctxt,\ity \iarrowi \kind,\mcon]
  }{
    \ddck[\ty,\rctxt;\ectxt{\var{:}\ity},\kind,\mcon]
  }
\quad
\infer[\text{App}]{
  \ddck[\papp{\ty}{e},\rctxt;\ctxt,\gk,\mcon]
}{
  \ddck[\ty,\rctxt;\ctxt,\ity \iarrowi \gk,\mcon] &
  \stsem[e,\ctxt,\ity]
}
\quad
\infer[\text{Prod}]{
    \ddck[\psig{x}{\ty}{\ty'},\rctxt;\ctxt,\kty,\con]
  }{       
    \ddck[\ty,\rctxt;\ctxt,\kty,\mcon] &
    \ddck[\ty',\rctxt;
          \ectxt {x{:}\iprod {\itsem[\asub \rctxt \ty]} 
              {\itpdsem[\asub \rctxt \ty]}},
          \kty,\mcon']
  }
\]

\[
\infer[\text{Sum}]{
    \ddck[\psum{\ty}{e}{\ty'},\rctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\rctxt;\ctxt,\kty,\mcon] & \ddck[\ty',\rctxt;\ctxt,\kty,\mcon'] 
  }
\quad
  \infer[\text{Intersection}]{
    \ddck[\pand \ty {\ty'},\rctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\rctxt;\ctxt,\kty,\mcon] & \ddck[\ty',\rctxt;\ctxt,\kty,\mcon'] 
  }
\quad
  \infer[\text{Set}]{
    \ddck[\pset x \ty e,\rctxt;\ctxt,\kty,\con]
  }{ 
    \ddck[\ty,\rctxt;\ctxt,\kty,\mcon] & 
    \stsem[e,
    \ectxt{x{:}\iprod{\itsem[\asub \rctxt \ty]} 
      {\itpdsem[\asub \rctxt \ty]}},\iboolty]
  }
\]

\[\infer[\text{Seq}]{
    \ddck[\pseq \ty {\ty_s} {\pterm e {\ty_t}},\rctxt;\ctxt,\kty,\con]
  }{
    \begin{array}{c}
    \ddck[\ty,\rctxt;\ctxt,\kty,\mcon] \qquad
    \ddck[{\ty_s},\rctxt;\ctxt,\kty,\mcon_s] \qquad
    \ddck[{\ty_t},\rctxt;\ctxt,\kty,\mcon_t] \\
    \stsem[e,\ctxt,
    \iprod {\itsem[{\ty_m}]}      
    {\itpdsem[{\ty_m}]}
    \iarrowi \iboolty]
    \quad (\ty_m = \asub \rctxt {\pseq \ty {\ty_s} {\pterm e {\ty_t}}})
    \end{array}
  }
\quad
  \infer[\text{Var}]{
    \ddck[\ptyvar,{\rctxt;\ctxt},\kty,\ncon]
  }{\wfd {} \ctxt \quad \ptyvar \in \dom \rctxt}
\quad
  \infer[\text{Rec}]{
    \ddck[\pmu \ptyvar \ty,\rctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,{\rctxt,\ptyvar {=} \pmu \ptyvar \ty;\ctxt},\kty,\con]
  }
\]

\[
  \infer[\text{Compute}]{       
    \ddck[\pcompute{e}{\ity},\rctxt;\ctxt,\kty,\con]
  }{
    \stsem[e,\ctxt,\ity]
  }      
\quad
\infer[\text{Absorb}]{
    \ddck[\pabsorb{\ty},\rctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\rctxt;\ctxt,\kty,\mcon]
  }
\quad
  \infer[\text{Scan}]{
    \ddck[\pscan{\ty},\rctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\rctxt;\ctxt,\kty,\mcon]
  }
\]
\caption{\ddc{} Kinding Rules}
\label{fig:ddc-kinding}
\end{figure*}

The kinding judgment defined in \figref{fig:ddc-kinding} determines
well-formed \ddc{} types, assigning kind $\kty$ to basic types and
kind $\ity \iarrowi \kind$ to type abstractions. There are two
contexts in which the kinding judgment is made. Context $\rctxt$ is an ordered list of mappings between type variables and recursive types.
\[
\rctxt \mathrel{::=} \cdot \bnfalt \rctxt,\ptyvar{=}\pmu \ptyvar \ty
\]
This context serves two purposes: first, to ensure the well-formedness
of types with free type variables, and, second, to provide mappings
between recursive type variables and their associated types. 
This second purpose leads us to consider a context $\rctxt$ to be a
substitution from type variables to types. Application of such a
substitution has the form $\asub \rctxt \ty$.

The second context is a finite partial map that binds expression
variables to their types and has the familiar form:
\[
\ctxt \mathrel{::=} \cdot \bnfalt \ctxt,{\var{:}\ity}
\]
To ensure that recursive types are well-formed, 
we cannot allow types such as $\pmu \ptyvar
\ptyvar$. More generally, we need to ensure that
recursive type variables are separated from their binder by at least
one basic primitive, such as a product or sum, a condition which we call {\it contractiveness}. To this end, we annotate every judgment with a contractiveness
indicator, which can be one of $\con$, $\ncon$, or $\mcon$. The use of
$\con$ indicates that the type is contractive, while $\ncon$,
indicates that it is not and $\mcon$ indicates that it may be either
one. We also assign an ordering to $\mcon$ of $\ncon < \con$. 

As the rules are otherwise mostly straightforward, we highlight
just two of them. Base types $C$ are assigned a kind by the function
$\Ikind$. While their kind does not differentiate them from type
abstractions, they are not well formed when not applied.  Also note
that, once applied, all base types have kind $\kty$. The product rule
shows that the name of the first component is bound to a pair of a rep and corresponding PD.
The types of these values are determined by the semantic functions defined in the
next section.  Note that $\rctxt$ is applied to the type before
translating it to a \implang{} type, thereby closing it, as open \ddc{}
types do not translate into well formed \implang{} types.

\subsection{Representation Semantics}
\label{sec:intty-sem}

\begin{figure}
\fbox{$\itsem[\ty] = \ity$}
\[
\begin{array}{lcl} 
\itsem[\ptrue] & = & \iunitty \\
\itsem[\pfalse] & = & \invty \\
\itsem[\pbase{e}] & = & \isum {\Irty(C)} \invty   \\
\itsem[\plam{\var}{\ity}{\ty}] & = & \itsem[\ty] \\
\itsem[\papp \ty e] & = & \itsem[\ty] \\
\itsem[\psig \var {\ty_1} {\ty_2}]  & = & \iprod {\itsem[\ty_1]} {\itsem[\ty_2]}    \\
\itsem[\psum {\ty_1} e {\ty_2}]     & = & \isum {\itsem[\ty_1]} {\itsem[\ty_2]} \\
\itsem[\pand {\ty_1} {\ty_2}]  & = & \iprod {\itsem[\ty_1]}{\itsem[\ty_2]}\\
\itsem[\pset x \ty e] & = & \isum {\itsem[\ty]}{\itsem[\ty]}\\
% field names: length, elts
\itsem[\pseq \ty {\ty_{\text{sep}}} {\pterm e {\ty_{\text{term}}}}] & = & 
    \iprod \iintty {(\iseq{\itsem[\ty]})}             \\
%% \itsem[\pcase e c {\ty_1} {\ty_2}]       & = & \isum {\itsem[\ty_1]} {\itsem[\ty_2]}\\
\itsem[\ptyvar] & = & \ptyvar \\
\itsem[\pmu \ptyvar \ty] & = & \imu{\ptyvar}{\itsem[\ty]} \\
\itsem[\pcompute e \ity]                 & = & \ity \\
\itsem[\pabsorb \ty]                     & = & \isum \iunitty \invty \\
\itsem[\pscan \ty] & = & \isum {\itsem[\ty]} \invty 
%% \pext{
%% \itsem[\ptransform e e \ty]              & = & \itsem[\ty]\\
%% }
\end{array}
\]
\caption{Representation Types}
\label{fig:rep-tys}
\end{figure}

In Figure~\ref{fig:rep-tys}, we present the representation type
of each \ddc{} primitive. While the primitives are
dependent types, the mapping to the \implang{} language erases the dependency because most conventional languages do not have dependent types. For all basic \ddc{} types in which expressions appear,
the translation simply drops the expressions to remove the dependency.
With these expressions gone, variables become useless, so we drop 
variable bindings as well, as in product and set types.
Similarly, as type abstraction and application are only relevant for
dependency, we translate them according to their underlying types.

In more detail,
the \ddc{} type $\ptrue$ consumes no input and produces only
the $\iunitty$ value.  Correspondingly, $\pfalse$ consumes no input,
but uniformly fails, producing the value $\invty$. The
function $\Irty$ maps each base type to a representation for
successfully parsed data. Note that this representation does not depend
on the argument expression. As base type parsers can fail, we sum this type
with $\invty$ to produce the actual representation.
Intersection types produce a pair of values, one for each sub-type,
because the representations of the subtypes need not be identical nor
even compatible. 
Set types produce sums, where a left branch indicates that the data
satisfies the constraint and the right indicates that it does not. In
the latter case, the parser returns the offending data rather than
$\ierr$ because the error is semantic rather than syntactic.
Sequences produce a \implang{} language sequence paired with its
length.  Recursive types generate recursive \implang{} data
structures. Note that the \implang{} type uses the same variable name
as the \ddc{} type, and so the type corresponding to the type variable
$\ptyvar$ is exactly $\ityvar$.
The output of a $\pcomputen$ is exactly the computed value, and,
therefore shares its type.  The output of $\pabsorbn$ is a sum
indicating whether parsing the underlying type succeeded or failed.
The type of $\pscann$ is similar, but also returns an element of the
underlying type in case of success.

\begin{figure}
\fbox{$\itpdsem[\ty] = \ity$}
\[ 
\begin{array}{lcl} 
%% %% example: \ua.(int * a) + None
%% %%          pd = \ua.pd_hdr  * ((pd_hdr * ([int]_pd * [a]_pd)) + [None]_pd)
%% %%             = \ua.pd_hdr  * ((pd_hdr * ([int]_pd * a)) + [None]_pd)
\itpdsem[\ptrue] & = & \ipty \iunitty \\                                                  
\itpdsem[\pfalse] & = & \ipty \iunitty \\                                                  
\itpdsem[\pbase{e}] & = & \ipty \iunitty\\
\itpdsem[\plam \var \ity \ty] & = & \itpdsem[\ty] \\
\itpdsem[\papp \ty e] & = & \itpdsem[\ty] \\
\itpdsem[\psig \var {\ty_1} {\ty_2}] & = & 
               \ipty {\iprod {\itpdsem[\ty_1]} {\itpdsem[\ty_2]}} \\
\itpdsem[\psum {\ty_1} e {\ty_2}] & = & 
               \ipty {(\isum {\itpdsem[\ty_1]} {\itpdsem[\ty_2]})} \\
\itpdsem[\pand {\ty_1} {\ty_2}] & = & \ipty {\iprod {\itpdsem[\ty_1]} {\itpdsem[\ty_2]}}    \\
\itpdsem[\pset x \ty e] & = & \ipty {\itpdsem[\ty]} \\
\itpdsem[\pseq \ty {\ty_{\text{sep}}} {\pterm e {\ty_{\text{term}}}}] & = & 
  \iapty {\itpdsem[\ty]} \\
\itpdsem[\ptyvar] & = & \ptyvar \\
\itpdsem[\pmu \ptyvar \ty] & = & \imu \ptyvar {\itpdsem[\ty]} \\
\itpdsem[\pcompute e \ity]            & = & \ipty \iunitty \\
\itpdsem[\pabsorb \ty]                & = & \ipty \iunitty \\
\itpdsem[\pscan{\ty}] & = & \ipty {(\isum {(\iprod \iintty
    {\itpdsem[\ty]})} \iunitty)}
\end{array}
\]
\caption{Parse Descriptor Types}
\label{fig:pd-tys}
\end{figure}

In \figref{fig:pd-tys}, we present the parse descriptor
type for each \ddc{} type. Each PD type has a header and body.
This common shape allows us to define functions that polymorphically
process PDs based on their headers. Each header stores the number of
errors encountered during parsing, an error code indicating the degree
of success of the parse -- success, success with errors, or failure --
and the span of data described by the descriptor.  Formally, the type
of the header  ($\tyface{pd\_hdr}$) is $\iintty \iprodi \iecty \iprodi
\ispty$.  Each body consists of subdescriptors corresponding to the
subcomponents of the representation and any type-specific meta-data. For types with neither subcomponents nor special meta-data, we
use $\iunitty$ as the body type.

We discuss a few of the more complicated parse descriptors in detail.
The parse descriptor body for sequences contains the parse descriptors of its elements,
the number of element errors, and the sequence length. Note that the
number of element errors is distinct from the number of sequence
errors, as sequences can have errors that are not related to their
elements (such as errors reading separators).  We introduce an
abbreviation for array PD body types, $\iaptyname \; \ity \triangleq
\iintty \iprodi \iintty \iprodi (\iseq \ity)$.
The $\pcomputen$ parse descriptors have no subelements because the
data they describe is not parsed from the data source.  The $\pabsorbn$ PD
type is $\iunitty$ as with the representation. We assume that just as
the user does not want the represenation to be kept, so too the parse
descriptor.  The $\pscann{}$ parse descriptor is either $\iunitty$, in case
no match was found, or records the number of bits skipped before the
type was matched along with the type's corresponding parse descriptor.


\begin{figure}
\small
\fbox{$\kTrans[\gk,\ty] = \ity$} 
    
\begin{align*}
  &\kTrans[\kty,\ty] = \extdom * \offdom \iarrowi \offdom * \itsem[\ty] * \itpdsem[\ty]
   \\
   &\kTrans[\ity \iarrowi \gk,\ty] = \ity \iarrowi \kTrans[\gk,\ty]
\end{align*}  
  \caption{Parser \Implang{} Types}
  \label{fig:parser-types}
\end{figure}

\subsection{Parsing Semantics of the \ddc{}}
\label{sec:parse-sem}

\begin{figure*}
\small
\fbox{$\trans[\ty,\ctxt,\gk] = e$} 

\[
\begin{array}{l}
  %% None 
\trans[\ptrue,\ctxt,\kty] =
  \lampair{\spair<\off,\newrep{unit}{},\newpd{unit}{\off}>}
\\[3pt] %\\
%% False 
\trans[\pfalse,,] =
  \lampair{\spair<\off,\newrep {bottom}{},\newpd {bottom}{\off}>}
\\[3pt] %\\ 
%% Const 
\trans[\pbase{e},\ctxt,\kty] =
  \lampair{\iapp {\iapp {\Iimp(C)} (e)} {\itup {\idata,\off}}}
\\[3pt] %\\
%% Abs 
\trans[\plam{\var}{\ity}{\ty},,] =
   \sfn{\nrm\var}{\ity}{\trans[\ty,\ectxt{\var{:}\ity},\kind]}
\\[3pt] %\\
%% App 
\trans[\papp{\ty}{e},\ctxt,\gk] =
  \trans[\ty,,] \sapp e  
\\[3pt]
%% Prod 
%\begin{array}{l}
\trans[\psig{x}{\ty}{\ty'},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampair{} \\
    \quad  \ilet {\spair<\off',r,p>} 
    {{\trans[\ty,,]} \sapp \spair<\idata,\off>} \\
    \quad  \ilet x {\ictup{r,p}}\\
    \quad  \ilet {\spair<\off'',r',p'>} 
    {{\trans[\ty',,]} \sapp \spair<\idata,\off'>} \\
    \quad \spair<\off'',\newrep {\gS}{r,r'},\newpd {\gS}{p,p'}>
  \end{array}  
%\end{array}
\\
%% Sum 
%\begin{array}{l}
  \trans[\psum{\ty}{e}{\ty'},,] = \\
  \begin{array}{l}  
  \lampair{} \\
  \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
  \quad \iif {\pdok p} \; \ithen {
    \def \r {\newrep {+left}{r}}
    \def \p {\newpd {+left}{p}}
    \spair<\off',\r,\p>} \\
  \quad \ielse {\ilet {\itup{\off',r,p}}{\trans[\ty',,] \sapp \spair<\idata,\off>}} \\
  \quad 
  {  % begin scope
    \def \r {\newrep {+right}{r}}
    \def \p {\newpd {+right}{p}}
    %% 
    \spair<\off',\r,\p>
  }\\ % end scope
  \end{array}
\\
%% Intersection 
  \trans[\pand{\ty}{\ty'},,] = \\
  \begin{array}{l}  
     \lampair{} \\
     \quad \ilet {\itup{\off',r,p}} {\trans[\ty,,] \sapp \spair<\idata,\off>} \\
     \quad \ilet {\itup{\off'',r',p'}} {\trans[\ty',,] \sapp \spair<\idata,\off>} \\
     \quad {\spair<\codefont{max}(\off',\off''),\newrep {\&}{r,r'},\newpd {\&}{p,p'}>}
   \end{array}
\end{array}
%\quad
\begin{array}{l}
%% Set 
  \trans[\pset{x}{\ty}{e},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampair{} \\
    \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
    \quad \ilet x {\ictup{r,p}}\\
    \quad \ilet c e \\
    \quad \spair<\off',\newrep {set} {c,r},\newpd {set} {c,p}>
  \end{array}
\\
%% Array 
\trans[\pseq{\ty}{\ty_s}{\pterm e {\ty_t}},,] = \\
  \begin{array}{l}  
    \lampair{}\\
      \quad \iletfun {isDone}{\itup{\off,r,p}}{\\
        \qquad \ior {\eofpred {\idata,\off}} {e\codefont {\sapp
          \spair<r,p>}} \iori \\
        \qquad \ilet {\itup{\off',r',p'}}{\trans[\ty_t,,] \spair<\idata,\off>}\\
        \qquad \pdok{p'}
      }\\
      \quad \iin \\
      \quad \iletfun {continue} {\itup{\off,\off',r,p}} {\\
        \qquad \iif  {\off = \off' \iori \isdone {\off',r,p}} \; \ithen {\itup{\off',\codefont{r,p}}} \\
        \qquad \ielse {
          \ilet {\itup{\off_s,r_s,p_s}}{\trans[\ty_s,,] \sapp \spair<\idata,\off'>}}\\
        \qquad \ilet {\itup{\off_e,r_e,p_e}}{\trans[\ty,,] \sapp \ictup{\idata,\off_s}}\\
        \qquad \mathtt{continue} \sapp \ictup{
            \off,\off_e,\newrep {seq} {r,r_e}, \newpd {seq} {p, p_s, p_e}
        }}\\
      \quad \iin
   \end{array}\\
  \begin{array}{l}  
      \quad \ilet {\mathtt{r}} {\newrep {seq\_init}{}}\\
      \quad \ilet {\mathtt{p}} {\newpd {seq\_init}{\off}}\\
      \quad \iif {\isdone{\off,r,p}} \; \ithen {\itup{\off,\codefont{r,p}}}\\
      \quad \ielse {\ilet {\itup{\off_e,r_e,p_e}}{\trans[\ty,,] \sapp
          \spair<\idata,\off>}} \\
      \quad \mathtt{continue} \sapp \ictup{\off,\off_e,
        \newrep {seq} {r,r_e}, \newpd {seq} {p, \newpd {unit} \off, p_e}}      
  \end{array}  
\end{array}
%\quad
\begin{array}{l}
%% Var
\trans[\ptyvar,,] = \codefont{f_\ptyvar}
\\[3pt]
%% Mu
\trans[\pmu \ptyvar \ty,,] = \\
  \begin{array}{l}
  \ifun {f_\ptyvar} {\itup{\data,\off}} {}\\
  \quad \ilet {\itup{\off',r,p}} 
  {\trans[\ty,,] \iappi \ictup{\data,\off}} \\ 
  \qquad \ictup{\off',r,p}
  \end{array}  
\\[3pt]
%% Compute
\trans[\pcompute e \ity,,] = \\
  \quad \lampair{\itup{\off,\newrep {compute} {\nrm e},\newpd {compute} \off}}
\\[3pt]
%% Absorb
\trans[\pabsorb \ty,,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \ilet {\itup {\off',r,p}} {\trans[\ty,,] \sapp \spair<\idata,\off>}\\
    \quad \itup{\off',\newrep {absorb} p,\newpd {absorb} p}   
  \end{array}  
\\
%% Scan
\trans[\pscan \ty,,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \iletfun {try} {i} {\\
      \qquad \ilet {\itup{\off',r,p}} {\trans[\ty,,] \sapp
        \codefont{\spair<\data,\off + i>}} \\
      \qquad \iif {\pdok p}\; \ithen \\
      \qquad {\ictup{\off',\newrep {scan} r,
        \newpd {scan} {i,p}}}\; \ielse {}\\
      \qquad \iif {\codefont{i = scanMax}}\; \ithen \\
      \qquad {\ictup{\off,\newrep {scan\_err} {},
        \newpd {scan\_err} {\off}}}\; \ielse {}\\
      \qquad \codefont {try \sapp (i+1)}
   }\\
   \quad \iin \sapp \codefont{try \sapp 0} \\
  \end{array}  
\end{array}
\]
%\caption{\ddc{} Semantics (cont.)}
\caption{\ddc{} Semantics}
\label{fig:ddc-sem}
\end{figure*}

\begin{figure}
\small
\begin{itemize}
\renewcommand{\labelitemi}{}

\item %[Unit:]
\item $\ifun {R_{unit}} \iuval \iuval$
\item $\ifun {P_{unit}} \off {\itup{\itup{0,\iok,\ipair \off \off},\iuval}}$

\item %[Bottom:]
\item $\ifun {R_{bottom}} \iuval \ierr$
\item $\ifun {P_{bottom}} \off ((1,\iecpc,\ipair \off \off),())$

\item %[Pair:]
\item $\ifun {R_{\gS}} {\ipair {r_1} {r_2}} {\itup {\codefont{r_1,r_2}}}$
\item $\ifun{H_{\gS}} {\ictup{h_1,h_2}}{}$ \\
  $\begin{array}{l}
    \ilet {nerr} {\codefont{pos \itup{{h_1}.{nerr}} + pos \itup{{h_2}.{nerr}}}}\\
    \ilet {ec} {\iif {\codefont{h_2.ec} = \iecpc}\; \ithen {\iecpc}\\
    \quad \ielse {\codefont{max\_ec} \iappi \codefont{h_1.ec} \iappi \codefont{h_2.ec}}} \\
    \ilet {sp} {\ictup{h_1.sp.begin, h_2.sp.end}} \\
    \quad \ictup {nerr,ec,sp}
  \end{array}$

\item $\ifun {P_{\gS}} {\ictup{p_1, p_2}} {\ictup {H_{\gS} \itup{p_1.h,p_2.h},\itup{p_1,p_2}}}$

\end{itemize}
\caption{Selected Constructor Functions. The type of PD headers is $\iintty
  \iprodi \iecty \iprodi \ispty$. We refer to the projections using
  dot notation as $\codefont{nerr}$, $\codefont{ec}$ and
  $\codefont{sp}$, respectively. A span is a pair of offsets, referred
  to as $\codefont{begin}$ and $\codefont{end}$, respectively.  The full collection of such constructor functions appears in \appref{app:asst-functions}.}
\label{fig:cons-funs}
%\caption{Constructor Functions (cont.)}
\end{figure}


The parsing semantics of a type $\tau$ is a function that transforms some amount of input into a pair of a representation and a parse descriptor, the types of which are determined by $\tau$.
\figref{fig:parser-types} specifies the \implang{} language types of the parsers generated from well-kinded \ddc{} types.  Note that parameterized \ddc{} types require their arguments before they can parse any input.

\figref{fig:ddc-sem} shows the parsing semantics function.  For each
type, the input to the corresponding parser is a bit string and an
offset which indicates the point in the bit string at which parsing
should commence.  The output is a new offset, a representation of the
parsed data, and a parse descriptor. Note that the bit string input is
never modified, and therefore not returned as an output.  In addition
to specifying how to handle correct data, each function describes how
to transform corrupted bit strings and to mark the detected errors in
a parse descriptor. The semantics function is partial, applying only
to well-formed \ddc{} types.

For any type, there are three steps to parsing: parsing the
subcomponents of the type (if any), assembling the resultant representation, and
tabulating meta-data based on subcomponent meta-data
(if any). For the sake of clarity, we have factored the latter two
aspects into separate representation and PD constructor functions which we define for
each type. For some types, we additionally factor the PD header
construction into a separate function. For example, the representation 
and PD constructors for $\ptrue$ are $\newrepf {unit}$ and $\newpdf
{unit}$, respectively, and the header constructor for products is
${\codefont{H_{\gS}}}$. Selected constructors are shown in
\figref{fig:cons-funs}. We have also factored out some commonly
occuring code into ``built-in'' functions, explained as needed and
defined formally in \appref{app:asst-functions}.

The PD constructors determine the error code and
calculate the error count.  There are three possible error codes:
$\iok$, $\iecerr$, and $\iecpc$, corresponding to the three possible results of a parse: 
it can succeed, parsing the data without errors; it can succeed,
but discover errors in the process; or, it can find an
unrecoverable error and fail.
\trversion{
Note that the the purpose of the $\iecpc$ code is to indicate to any
higher level elements that some form of error recovery is required.
Hence, the whole parse is marked as failed exactly when the parse ends
in failure.}
The error count is determined by subcomponent error counts and any errors associated directly with the type
itself.  
\trversion{
If a subcomponent has errors then the error count is
increased by one; otherwise its not increased at all. We use the
function $\codefont {pos}$, which maps all positive numbers to 1
(leaving zero as is), to assist in calculating the contribution of
subcomponents to the total error count.  Errors at the level of the
element itself - such as constraint violation in set types - are
generally counted individually.}

With this background, we can now discuss selected portions of the semantics.
%With this background, we can now understand the semantics. 
The semantics of $\ptrue$ and $\pfalse$ show that they do not consume any input, \ie{}, they do not change the offset. 
A look at their constructors shows that the parse
descriptor for $\ptrue$ always indicates no errors and a corresponding
$\iok$ code, while that of $\pfalse$ always indicates failure with an
error count of one and the $\iecpc$ error code. The semantics of base
types applies the implementation of the base type's parser, provided
by the function $\Iimp$, to the appropriate arguments.  Abstraction
and application are defined directly in terms of \implang language
abstraction and application.  Dependent pairs read the first element
at $\off$ and then the second at $\off'$, the offset returned from
parsing the first element.  Notice that we bind the pair of the
returned representation and parse descriptor to the variable $\codefont{x}$
before parsing the second element, implicitly mapping the 
\ddc{} variable $x$ to the \implang{} language variable $\codefont{x}$ in the process.
Finally, we combine the results
using the constructor functions, returning $\off''$ as the final
offset of the parse.

\trversion{
Sums first attempt to parse according to the left type, returning the resulting
value if it parses without errors. Otherwise, it parses according to
the right type. Intersections read both types starting at the same
point. They advance the stream to the maximum of the two offsets
returned by the component parsers. The construction of the parse
descriptor is similar to that of products. For set types, we call the
parser for the underlying type $\ty$, bind $\var$ to the resulting rep
and PD, and check whether constraint is satisfied. The result
indicates whether the data has a semantic error and is used in
constructing the representation and PD. For example, the PD constructor will add
one to the error count if the constraint is not satisfied. Notice that
we advance the stream independent of whether the constraint was
satisfied.
}
Sequences have the most complicated semantics because the number of subcomponents depends upon a combination of the data, the termination predicate, and the terminator type. Consequently, the sequence parser uses mutually
recursive functions $\codefont{isDone}$ and $\codefont{continue}$ to implement this open-ended semantics. 
Function $\codefont{isDone}$ determines if the parser
should terminate by checking whether the end of the source has been
reached, the termination condition $e$ has been satisfied, or the
terminator type can be read from the stream without errors at
$\off$.
Function $\codefont{continue}$ takes four
arguments: two offsets, a sequence representation, and a sequence PD.  The two
offsets are the starting and ending offset of the previous round of
parsing. They are compared to determine whether the parser is
progressing in the source, a check that is critical to ensuring that
the parser terminates. Next, the parser checks whether the sequence is
finished, and if so, terminates. Otherwise, it attempts to read a
separator followed by an element and then continues parsing the
sequence with a call to $\codefont{continue}$.

\trversion{
Finally, the body of the parser creates an initial sequence representation and PD and
then checks whether the sequence described is empty. If not, it reads
an element and creates a new rep and PD for the sequence.  Note that
it passes the PD for $\ptrue$ in place of a separator PD, as no
separator is read before the first element.  Finally, it continues
reading the sequence with a call to $\codefont{continue}$.

Because of  the iterative nature of sequence parsing, the representation and PD are constructed incrementally. The parser first creates an empty representation and PD
and then adds elements to them with each call to
$\codefont{continue}$. The error count for an array is the sum of the
number of separators with errors plus one if there were any element
errors. Therefore, in function ${\codefont{H_{seq}}}$ we first check
if the element is the first with an error, setting $\codefont{eerr}$
to one if so. Then, the new error count is a sum of the old,
potentially one for a separator error, and $\codefont{eerr}$. In
$\newpdf{seq}$ we calculate the element error count by unconditionally
adding one if the element had an error.
}
Recursive types are translated into recursive functions with a special
function name corresponding to the name of the bound type variable. A
recursive type variable is translated directly into this special name.
\trversion{We note that the body of the recursive function is somewhat
  redundant. However, the simpler encoding of $\ifun {f_\ptyvar}
  {\itup{\data,\off}} {\trans[\ty,,] \; \itup{\data,\off}}$ would have
  complicated the meta-theory.}

\trversion{
The definition of $\pcomputen$ just calls the compute constructors.
The representation constructor returns the value computed by $e$, while the PD
records no errors and reports a span of length 0, as no data is
consumed by the computation. The $\pabsorbn$ parser first parses the
underlying type and then calls the absorb constructors, passing only
the PD, which is needed by the rep constructor to determine whether an
error occured while parsing the underlying type. If so, the value
returned is a $\ierr$. Otherwise, it is $\iunitty$.  The absorb parse
descriptor duplicates the error information of its underlying type.


The semantics of the $\pscann$ type is to attempt to parse the underlying
type from the stream at an increasing scan-offset, $i$, from the original
offset $\off$,  until success is achieved
or a predefined maximum scan-offset (\cd{scan\_max}) is reached. Note
that, upon success, $i$ is passed to the PD constructor function,
which both records it in the PD and sets the error code based on
it. It is considered a semantic error for the value to be found at a
positive $i$, whereas it is a syntactic error for it not to be found at
all.
}
%\clearpage

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "semantics"
%%% End: 
