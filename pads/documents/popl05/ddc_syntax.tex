\section{A Data Description Calculus}
\label{sec:ddc}

At the heart of our work is a data description calculus (\ddc{}),
designed to capture the core features of data description languages.
Consequently, the syntax of \ddc{} is at a significantly lower level
of abstraction than that of \ipads{}.  Like \ipads{}, however, \ddc{}
presents a type-based model.  Each \ddc{} type describes the external
representation of a piece of data and implicitly specifies how to
transform that external representation into an internal one.  The
internal representation includes both the transformed value and a
\textit{parse descriptor} that characterizes the errors that occurred
during parsing. Syntactically, the primitives of the calculus are
similar to the types found in many dependent type systems, with a
number of additions specific to the domain of data description.
%We define each data description primitive orthogonally from the others, using composition to describe richer structures.
We base our calculus on a dependent type theory because as we have seen,
it is common in data description languages for expressions to appear within
types.

\cut{
Our choice to base our calculus on a specifically
\textit{dependent} type theory is due to the appearance in the data
descriptions of expressions $e$ taken from an abstract expression
language \footnote{In the next section we will specify one possible such
expression language}.

In order to understand the calculus, the types should be thought of
not merely as classifying values, but as transforming them from an
external representation to an internal one. Our description of the
individual primitives will be based on just such a conception of their
meaning.
}

\subsection{\ddc{} Syntax}
\begin{figure}
{\small
\begin{bnf}
  \name{Kinds} \meta{\gk} \::= \kty \| \ity \-> \gk 
                               \pext{\| \gk \-> \gk} \\
  \name{Types} \meta{\ty} \::= 
    \ptrue\| \pfalse \| \pbase{e} \| 
    \plam{\var}{\ity}{\ty} \| \papp{\ty}{e} \nlalt
%%        \|
%%       \pext{\plam{\ptyvar}{\gk}{\ty} \| \papp{\ty}{\ty} \nlalt}
%%       \pxpd{\ty}{e}
%%       \pext{\nlalt
%%         \ptransform{e}{e}{\ty} \| 
%%       }
    \psig x \ty \ty \| \psum \ty e \ty \| \pand \ty \ty \|
    \pset x \ty e \| \pseq \ty \ty {\pterm e \ty} \nlalt
    \ptyvar       \| \pmu{\ptyvar}{\ty} \| \pcompute e \ity \| \pabsorb \ty \| \pscan{\ty} 
\end{bnf}
}
\caption{\ddc{} Syntax}
\label{fig:ddc-syntax}
\end{figure}
\figref{fig:ddc-syntax} shows the syntax of \ddc{}. As with
\ipads{}, expressions $e$ and types $\ity$ belong to the host
language, defined in \secref{sec:host-lang}.
The most basic types are $\ptrue$ and $\pfalse$, both of which consume
no input and return unit as their
representation.  The difference between them is that
the former always succeeds, while the latter always fails, a
distinction recorded in the associated parse descriptors.
The syntax $\pbase e$ denotes a base type $C$ parameterized by 
expression $e$. The syntax $\ptyvar$ denotes a type variable
introduced in a recursive type.
% An instance of the \ddc{} will provide a set of base types $C$.
% Base types recognize and transform atomic values within the data
% source; typical examples include various kinds of integers and
% strings.  The parameter expression plays a type-dependent role,
% \eg{}, specifying digit lengths for integers or terminating
% conditions for strings.

We provide abstraction $\plam x {} \ty$ and application
$\papp \ty e$ so that we may parameterize types by expressions.
Dependent product types $\psig x {\ty_1} {\ty_2}$ describe a sequence
of values in which the second type may refer to the value of the first.
Sum types $\psum {\ty_1} {} {\ty_2}$
express flexibility in the data format, as they parse
data matching either $\ty_1$ or $\ty_2$. Sum-type parsers
are deterministic, transforming the data according to $\ty_1$
when possible and only attempting to
use $\ty_2$ if there is an error in $\ty_1$. Intersection types
$\pand {\ty_1} {\ty_2}$ describe data that match both $\ty_1$ and
$\ty_2$. They transform a single set of bits to produce
a pair of values, one from each type. Set types $\pset x \ty e$
transform data according to the underlying type $\ty$ and
then check that the constraint $e$ holds when $x$ is bound to the parsed value.


The type $\pseq \ty {\ty_s} {\pterm e {\ty_t}}$ represents a sequence
of values of type $\ty$. The type $\ty_s$ specifies the type of
the separator found between elements of the sequence. For sequences
without separators, we use $\ptrue$ as the separator type. 
Expression $e$ is a boolean-valued function that examines the parsed
sequence after each element is read to determine
if the sequence has completed. For example, a function that
checks if the sequence has $100$ elements would
terminate a sequence when it reaches length $100$.  The type 
$\ty_t$ denotes the type of the terminator expected after the last sequence
element. For sequences without terminators, we use
$\pfalse$ for $\ty_t$.

Recursive types $\pmu \ptyvar \ty$ describe recursive data formats.
The name $\ptyvar$ can be used in $\ty$ to refer to the recursive type
and causes a recursive call to $\ty$'s parser wherever it appears.

\ddc{} also has a number of ``active'' types.
These types describe actions to be taken during parsing
rather than strictly describing the data format. Type $\pcompute e
\ity$ allows us to include an element in the parsed output that
does not appear in the data stream (although it is likely dependent on
elements that do), based on the value of expression $e$.  In
contrast, type $\pabsorb \ty$ parses data according to type $\ty$
but does not return its result. This behavior is useful for data
that is important for parsing, but
uninteresting to users of the parsed data, such as a separator. The last of the ``active''
types is $\pscan \ty$, which scans the input for 
data that can be successfully transformed according to $\ty$. This type provides a form of error recovery
as it allows us to discard unrecognized data until the ``recovery'' type $\ty$ is found.

\subsection{\Implang{} Language}
\label{sec:host-lang}
\begin{figure}[tp]
\small
\begin{bnf}
%   \name{Variables} \meta{f,x,y} \\
%   \name{Bit}   \meta{b}   \::= 0 \| 1 \\ 
  \name{Bits}  \meta{B}   \::= \cdot \| 0\,B \| 1\,B \\ 
  \name{Constants} \meta{c} \::=
      () \| \itrue \| \ifalse \| 0 \| 1 \| -1 \| \dots \nlalt
      \ierr \| \data \| \off \| \iok \| \iecerr \| \iecpc \| \ldots \\

  \name{Values} \meta{v} \::= 
      \const \| % \ilam{\nrm \var}{\ity}{e} \| 
      \ifun {\nrm f} {\nrm x} e \| \ipair v v \nlalt
      \iinld{\ity}{v} \| \iinrd{\ity}{v} \|
      \iarr{\vec{v}} \\

  \name{Operators} \meta{op} \::= 
      = \; \| \; < \; \| \inotop % \| \isizeofop
      \| \ldots \\

  \name{Expressions} \meta{e} \::= 
      \const \| \var \| \iop{e} \|
%      \ilam {\nrm \var} \ity e \| 
      \ifun {\nrm f} {\nrm x} e \| 
      \iapp e e \nlalt
%      \iletfun {\nrm f} {\nrm x} e \; \iin \; e' \| 
      \ilet {\nrm x} e \; e \|
      \iif e \; \ithen e \; \ielse e \nlalt
      \ipair{e}{e} \| \ipi {\nrm i}{e} \|
      \iinld{\ity}{e} \| \iinrd{\ity}{e} \nlalt
      \icaseg{e}{\nrm x}{e}{\nrm x}{e} \nlalt
      \iarr{\vec e} \| \iappend e e \| \isub e {\nrm e}
      \\
      
  \name{Base Types} \meta{a} \::= 
      \iunitty \| \iboolty \| \iintty  \| 
      \invty \nlalt  \ibitsty \| \ioffty \| \iecty
  \\
  \name{Types} \meta{\ity} \::= 
      \ibasety \| \ityvar \| \iarrow \ity \ity \| \iprod \ity \ity \|
      \isum \ity \ity \nlalt
      \iseq \ity \| \forall \ityvar.\ity  \|
      \imu \ityvar \ity   
  
\end{bnf}
\caption{\Implang{} Language}
\label{fig:implang-syntax}
\end{figure}

In \figref{fig:implang-syntax}, we present the host language of \ddc{}, an
extension of the simple-typed polymorphic lambda calculus. 
We use this host language both to encode the parsing semantics of \ddc{} 
and to write the expressions that can appear within \ddc{} itself.

As the calculus is largely standard, we highlight only its
unusual features. The constants include bitstrings $\data$; offsets $\off$,
representing locations in bitstrings; and error codes $\iok$,
$\iecerr$, and $\iecpc$, indicating success, success with errors and
failure, respectively. We use the constant $\ierr$ to indicate a
failed parse.  
Because of its specific meaning, we forbid its use in user-supplied expressions
appearing in \ddc{} types. 
%We include a special $\isizeofop$ operator, which returns the size in the data
%source of its input. 
Our expressions include arbitrary length
sequences $\iarr{\vec e}$, sequence append $\iappend e
{e'}$, and sequence indexing $\isub e {\nrm i}$.

The type $\invty$ is the singleton type of the constant $\ierr$.
Types $\iecty$ and $\ioffty$ classify error codes and bit string
offsets, respectively. The remaining types have standard
meanings: function types, product types, sum types, sequence types
$\iseqty \ty$; polymorphic types $\forall \ityvar.\ity$ and type
variables $\ityvar$; and recursive types $\imu \ityvar \ity$.

We extend the formal syntax with some syntactic sugar 
for use in the rest of the paper: anonymous functions
$\ilam {\nrm x} \ity e$ for $\ifun {\nrm f} {\nrm x} e$, with $f
\not\in {\rm FV}(e)$; function bindings $\iletfun {\nrm f} {\nrm x} e
\; \iin \; e'$ for $\ilet {\nrm f} {\ifun {\nrm f} {\nrm x} e} \; e'$;
$\ispty$ for $\iprod \ioffty \ioffty$.  We often use
pattern-matching syntax for pairs in place of explicit projections, as
in $\lampair{\codefont e}$ and $\ilet {\itup{\off,r,p}} e\; e'$.  Although
we have no formal records with named fields, we use a dot notation for
commonly occuring projections. For example, for a pair $\mathtt x$ of
rep and PD, we use $\codefont{x.rep}$ and $\codefont{x.pd}$ for the
left and right projections of $\codefont{x}$, respectively. \cut{Generally,
the particular projection intended should be apparent from context,
and will be specified when it is not.} Also, sums and products are
right-associative. 
\trversion{Hence, for example, $a \iprodi b \iprodi c$ is
shorthand for $a \iprodi (b \iprodi c)$.}

We use standard judgments for the static semantics
($\stsem[e,{\ctxt},\ity]$) and operational semantics ($e
\stepsto e'$) of the \implang{} language. Details appear in \appref{app:host-lang}.

\subsection{Example}
\label{sec:ddc-example}

As an example, we present an abbreviated description of the common log
format as it might appear in \ddc{}. For brevity,
this description does not fully capture the semantics of the
\ipads{} description from \secref{sec:ipads}. Additionally, we
use the standard abbreviation $\ty * \ty'$ for non-dependent products and introduce a number of type abbreviations
in the form $\mathtt{name} = \ty$ before giving the type that describes the data source.

{\small
\[
\begin{array}{l}
\mathtt{S} = \plam {\mathtt{ch}} {} {\pset {\mathtt{c}}
  {\mathtt{Pchar}} {\mathtt{c = ch}}}\\
\\
\mathtt{response\_t} = \plam {\mathtt x} {} {
      \pset {\mathtt y} {\mathtt{Puint16\_FW(x)}} 
      {\codefont{100 \leq y \iandi y < 600}}
    }\\
\\
\mathtt{authid\_t} = 
\psum {\mathtt{S(``-")}} {} {\mathtt{Pstring(``\;")}}\\
\\
\mathtt{entry\_t} = \\ \;
\begin{array}{lll}
\psig {\mathtt{client}} {\mathtt{Pip}} {&\mathtt{S(``\;")}} &* \\
\psig {\mathtt{remoteid}} {\mathtt{authid\_t}} {&\mathtt{S(``\;")}} &* \\
\psig {\mathtt{response}} {
  \papp
    {\mathtt{response\_t}} 3
}{&\mathtt{S(``\;")}} &*\\
\multicolumn{3}{c}{
\pcompute {\codefont{getdomain\;client = ``edu"}} \iboolty}
\end{array}\\
\\
\pseq {\mathtt{entry\_t}} {\mathtt{S(``\backslash n")}}{
  \pterm {\ilam {\mathtt x} {} \ifalse} {\pfalse}
}
\end{array}
\]}%
\noindent
In the example, we define type constructor $\mathtt{S}$ to encode literals
with a set-type. We also use the following
informal translations: \Pwhere{} becomes a set-type, \Pstruct{} a
series of dependent products, \Punion{} a series of sums, and
\Parray{} a sequence. For this example, we assume that \Peor{} is a newline, and therefore specify the sequence
separator as such. As the array terminates at the end of the file, we
use $\ilam {\mathtt x} {} \ifalse$ and $\pfalse$ to indicate the
absence of termination condition and terminator, respectively.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "semantics"
%%% End: 
