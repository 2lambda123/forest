\documentclass{article}

\begin{document}

\begin{abstract}
  XQuery is a language for querying data stored in an XML format.
  While there are many implementations of XQuery for traditional
  database systems, there are none that support ad-hoc, or arbitrary,
  data sources. PADS is a language for describing ad-hoc data sources,
  automatically generating a C library to process the data based on
  the description. However, the actual processing programs must be
  written in C.
  
  The PADS/Galax project is designed to bring to users the benefits of
  both languages, by integrating the PADS implementation with Galax -
  an open-source XQuery implementation. With the resulting system,
  users can combine declarative, functional data queries written in
  XQuery with a declarative data description to achieve results
  usually achieved with a difficult-to-maintain, imperative program
  written in C.  Furthermore, PADS/Galax supports data sources ranging
  in size from bytes to Gigabytes.
  
  The design of PADS/Galax involved addressing three major problems:1)
  how to represent PADS-described data as XML, 2) how to bring data
  elements into memory, or discard them, as needed by Galax, and 3)
  how to provide these features with little or no user involvement. In
  this talk, I will describe my work here this summer, which focused
  on the latter two problems, while touching on the first. I will
  explain the goals of my work and describe the extent to which we
  have achieved those goals, including descriptions of our solutions
  to the problems described above.
\end{abstract}

\begin{enumerate}
\item PADS (Processing Arbitrary Data Streams) Review
  \begin{itemize}
  \item Declarative data-stream description language
  \item -> Descriptions closely resemble C header files.
  \item Generates data-parsing library from description.
  \item Detects \& recovers from non-fatal errors in data stream
  \end{itemize}
\item XQuery/Galax Review
\item Merge Example - PADS side
  \begin{itemize}
  \item data
  \item description
  \end{itemize}
\item Merge Example - XQuery side
  \begin{itemize}
  \item XML data
  \item query
  \item query result.
  \end{itemize}
\item Merge poses three problems
  \begin{enumerate}
  \item represent PADS-described data as XML
  \item bring data into memory, or discard it, as needed
  \item provide support with little or no user involvement
  \end{enumerate}
\item Summer goal: address problems 2,3 while extending 1 as
  necessary.
  \begin{itemize}
  \item Last summer: start 1,3
  \item bring system up-to-date (prob. 1)
  \item design mem. management system (prob. 2)
  \item integrate w/ compiler. (prob. 3)
  \end{itemize}
\item review: nodes
\item bring pads\_dm up to date
  \begin{itemize}
  \item use cursors
  \item support nodeids
  \end{itemize}
\item smart arrays - paging
  \begin{itemize}
  \item paging, with element as page granularity
  \item tmap, page-table for elements 
  \item (for finer granularity, group
    elements into fixed-size arrays)
  \end{itemize}
\item smart arrays - weak references
  \begin{itemize}
  \item data references can't be trusted
  \item challenge: irregular structure of elements. 
    \begin{itemize}
    \item finding element is not enough.
    \item store pointers in page members.
    \item guard with gen.
    \item -> gen invalidated when elt. evicted.
    \end{itemize}
  \end{itemize}
\item Rereading an element
  \begin{itemize}
  \item Pads elements are read in full.
  \item Designed incremental read function.
  \item non trivial due to the complexity of the array termination semantics.
  \item reread can't modify parse-descriptor.
  \end{itemize}
\item Demo slide, showing commands needed to get up
  and running.
\item challenges
  \begin{itemize}
  \item learning all the pieces
  \item dividing between macros and compiler
  \item dividing between type-specific code and polymorphic macros.
  \end{itemize}
\item thanks to Kathleen, Bob, and Mary!
\end{enumerate}

\end{document}
