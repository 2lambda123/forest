\newpage
\section{Bottom Line}
\label{sec:BottomLine}

\subsection{Version 1 complexity metric}

The PADS types that will be supported by the complexity metric in
version 1 are listed in table \ref{tab:v1Complexity}. The table
specifies the information that is needed for some of the PADS types.

\begin{longtable}{||l|l|l|}
\caption[Version 1 complexity metric]{Version 1 complexity metric}
\label{tab:v1Complexity}
\\\hline
\hline
PADS type & Length distribution & Value distribution \\\hline\hline

Base type &
\multicolumn{2}{l}{
\parbox[t]{11cm}{
The list of values of the base type is stored in the abstract
syntax tree resulting from the parse of the data. From this
list of values we can derive a length distribution and/or
a value distribution.
\vspace{0.5mm}}} \vline\\\hline

\textbf{Punion} &
\parbox[t]{5cm}{
A histogram of frequencies versus variant in the \textbf{Punion}.
\vspace{0.5mm}} &
\parbox[t]{6cm}{
Each subtype of the union will have its own distribution information
associated with it.
\vspace{0.5mm}} \\\hline

\textbf{Pstruct} &
\parbox[t]{5cm}{
No additional information at this time.
\vspace{0.5mm}} &
\parbox[t]{6cm}{
No additional information at this time.
\vspace{0.5mm}} \\\hline

\textbf{Pre} &
\parbox[t]{5cm}{
Not supported at this time
\vspace{0.5mm}} &
\parbox[t]{6cm}{
Not supported at this time
\vspace{0.5mm}} \\\hline

\textbf{Parray} &
\parbox[t]{5cm}{
A histogram of length of \textbf{Parray} versus frequency.
\vspace{0.5mm}} &
\parbox[t]{6cm}{
The element type will have its own distribution information
associated with it.
\vspace{0.5mm}}

\\\hline
\end{longtable}

\subsection{Version 2 complexity metric}

This section describes the complexity metric as coded during February,
2007. The metric is a function called \textsf{measure} having type
\textsf{Ty} $\rightarrow$ \textsf{Ty}. The function fills in complexity
information in the \textsf{AuxInfo} associated with each node of the
\textsf{Ty} structure. Two fields have been added to the \textsf{AuxInfo} type
to support the complexity metric:

\begin{verbatim}
type AuxInfo = { coverage : int
               , label    : Id option
               , typeComp : Complexity
               , dataComp : Complexity
               }
\end{verbatim}

The \textsf{typeComp} field records the complexity of the type itself,
regardless of the data scanned. The \textsf{dataComp} field records
the complexity of the data as viewed through the type.

The functions used in the computation of the complexity measure are
described in table \ref{tab:v2Abbreviations}, which also specifies an
abbreviation for the function. The abbreviations are used in this note
for brevity of notation.

\begin{longtable}{||l|l||}
\caption[Functions and abbreviations]{Functions and abbreviations}
\label{tab:v2Abbreviations}
\\\hline
\hline
Abbr & ML function \\\hline\hline
$\calR$ &
\parbox[t]{9cm}{
\scriptsize
(* Compute type and data complexity of a refined type *)\linebreak
fun refinedComp ( multiplier:int ) ( r:Refined ) : Complexity * Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\calR_\tau$ &
\parbox[t]{9cm}{
\scriptsize
(* Get type complexity of a refined type, assuming multiplier of 1 *)\linebreak
refinedTypeComp ( r : Refined ) : Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\calR_\delta$ &
\parbox[t]{9cm}{
\scriptsize
(* Get data complexity of a refined type, assuming multiplier of 1 *)\linebreak
refinedDataComp ( r : Refined ) : Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\calR_{\mathsf{opt}}$ &
\parbox[t]{9cm}{
\scriptsize
(* Complexity of refined option type, assuming multiplier 1 *)
fun refinedOptionComp ( ro : Refined option ) : Complexity * Complexity =
\normalsize
\vspace{0.5mm}} \\\hline

$\beta$ &
\parbox[t]{9cm}{
\scriptsize
(* Compute the complexity of a base type (e.g. Pint) *)\linebreak
fun baseComplexity ( ts : LToken list ) : Complexity * Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\mu$ &
\parbox[t]{9cm}{
\scriptsize
(* Compute the type and data complexity of an inferred type *)\linebreak
fun measure ( ty : Ty ) : Ty
\normalsize
\vspace{0.5mm}} \\\hline

$\mu_\tau$ &
\parbox[t]{9cm}{
\scriptsize
(* Compute the type complexity of an inferred type *)\linebreak
fun dataMeasure ( ty : Ty ) : Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\mu_\delta$ &
\parbox[t]{9cm}{
\scriptsize
(* Compute the data complexity of an inferred type *)\linebreak    
fun typeMeasure ( ty : Ty ) : Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\mathsf{card}$ &
\parbox[t]{9cm}{
\scriptsize
(* Complexity from the number of choices *)\linebreak
fun cardinalComplexity ( l : 'a list ) : Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\tau$ &
\parbox[t]{9cm}{
\scriptsize
(* Retrieve computed type complexity from a type *)\linebreak
fun getTypeComplexity ( ty : Ty ) : Complexity = $\sharp$typeComp (getAuxInfo ty)
\normalsize
\vspace{0.5mm}} \\\hline

$\delta$ &
\parbox[t]{9cm}{
\scriptsize
(* Retrieve computed data complexity from a type *)\linebreak
fun getDataComplexity ( ty : Ty ) : Complexity = $\sharp$dataComp (getAuxInfo ty)
\normalsize
\vspace{0.5mm}} \\\hline

\end{longtable}

\normalsize

\begin{longtable}{||l|l|l|l|}
\caption[Base types]{Base types}
\label{tab:v2Base}
\\\hline
\hline
Sub type & Type complexity & Data complexity & Notes \\\hline\hline

\textsf{Ptime} &
      $\left(\frac{1}{60}\right) \cdot \left(\frac{1}{60}\right) \cdot \left(\frac{1}{24}\right)$ &
      $\left(\frac{1}{60}\right) \cdot \left(\frac{1}{60}\right) \cdot \left(\frac{1}{24}\right)$ &
\parbox[t]{5cm}{
This is a much oversimplified case. In order to do better, we need to
have a regular expression identified with the time, and analyze the
complexity of the regular expression. See section
\ref{sec:RegularExpressions}.
\vspace{0.5mm}} \\\hline

\textsf{Pmonth} & $\left(\frac{1}{12}\right)$ & $\left(\frac{1}{12}\right)$ &
\parbox[t]{5cm}{
Again an oversimplification of month, need also regular expressions here
eventually.
\vspace{0.5mm}} \\\hline

\textsf{Pip} &
    $\left(\frac{1}{255}\right)$ &
    $\left(\frac{1}{255}\right)^\mathrm{maxlen}$
\footnote{$\mathrm{maxlen}$ is the maximum length of the token address seen} &
\parbox[t]{5cm}{
Perhaps we should use average length? Maximum length gives us a worst
case complexity. On the other hand, IP address are often all of the same
length, namely four number in the range 0 through 255.
\vspace{0.5mm}} \\\hline

\textsf{Pint} &
    $\left(\frac{1}{10}\right)$ &
    $\left(\frac{1}{10}\right)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{
This assumes integers are a sequence of digits 0 \ldots 9.
\vspace{0.5mm}} \\\hline

\textsf{Pstring} &
    $\left(\frac{1}{68}\right)$ &
    $\left(\frac{1}{68}\right)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{
There are 68 characters that make up strings.
\vspace{0.5mm}} \\\hline

\textsf{Pgroup} & 0 & 0 &
\parbox[t]{5cm}{
Don't know how to handle this one yet.
\vspace{0.5mm}} \\\hline

\textsf{Pwhite} & $\frac{1}{2}$ & $\left(\frac{1}{2}\right)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{
White space can have either blank or tab characters (2 possibilities).
\vspace{0.5mm}} \\\hline

\textsf{Other} & $\frac{1}{256}$ & $\frac{1}{256}$ &
\parbox[t]{5cm}{
A single ASCII character.
\vspace{0.5mm}} \\\hline

\textsf{Pempty} & 0 & 0 &
\parbox[t]{5cm}{
Not sure about this one.
\vspace{0.5mm}} \\\hline

\textsf{Error} & \textsf{impossible} & \textsf{impossible} &
\parbox[t]{5cm}{
Not sure about this one.
\vspace{0.5mm}} \\\hline

\textsf{PbXML} &
      $\left(\frac{1}{52}\right)$ &
      $\left(\frac{1}{52}\right)^\mathrm{maxlen} $ &
\parbox[t]{5cm}{
XML seems to handled as a fancy string type. There are 52 possible XML
characters.  Should consider sum of two string lengths?
\vspace{0.5mm}} \\\hline

\textsf{PeXML} &
      $\left(\frac{1}{52}\right)$ &
      $\left(\frac{1}{52}\right)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{
XML seems to handled as a fancy string type. There are 52 possible XML
characters.  Should consider sum of two string lengths?
\vspace{0.5mm}} \\\hline

\end{longtable}

\begin{longtable}{||l|l|l|l|}
\caption[Refined base types]{Refined base types}
\label{tab:v2RefinedBase}
\\\hline
\hline
Type & Type complexity & Data complexity & Notes \\\hline\hline

\textsf{StringME} &
    $\left(\frac{1}{68}\right)$ &
    $\left(\frac{1}{68}\right)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{
There are 68 characters that make up strings.
\vspace{0.5mm}} \\\hline

\textsf{Int (min, max)} &
    $\log (\mathrm{max} - \mathrm{min} + 1)$ &
    $\log (\mathrm{max} - \mathrm{min} + 1)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{
\vspace{0.5mm}} \\\hline

\textsf{IntConst n} & $\log n$ & $\log n$ &
\parbox[t]{5cm}{
The data and type complexity are the same for a constant.
\vspace{0.5mm}} \\\hline

\textsf{StringConst s} & $\mathrm{size} s$ & $\mathrm{size} s$ &
\parbox[t]{5cm}{
The data and type complexity are the same for a constant.
\vspace{0.5mm}} \\\hline

\textsf{Enum rl} &
$\sum_{r\in rl} \calR_\tau (r)$
\footnote{The summation is using the \textsf{combine} operation
defined on the type \textsf{Complexity}} &
$\sum_{r\in rl} \calR_\delta (r)$ &
\parbox[t]{5cm}{
The recursion here is in support of the requirement of
\textit{compositionality}.
\vspace{0.5mm}} \\\hline

\textsf{LabelRef i} & 0 & 0 &
\parbox[t]{5cm}{
Not sure what to do about this one.
\vspace{0.5mm}} \\\hline

\end{longtable}

\begin{longtable}{||l|l|l|l|}
\caption[Structure types]{Structured types}
\label{tab:v2Structured}
\\\hline
\hline
Type & Type complexity & Data complexity & Notes \\\hline\hline

\footnotesize\textsf{Pstruct (a,ts)}\normalsize &
    $\sum_{t} \mu_\tau (t)$ &
    $\sum_{t} \mu_\delta (t)$ &
\parbox[t]{4cm}{
\footnotesize
Should this be product instead of sum?
Sum defined using \textsf{combine} operation.
\normalsize
\vspace{0.5mm}} \\\hline

\footnotesize\textsf{Punion (a,ts)}\normalsize &
    $\mathsf{card} (ts) + \sum_{t} \mu_\tau (t)$ &
    $\mathsf{card} (ts) + \sum_{t} \mu_\delta (t)$ &
\parbox[t]{4cm}{
\footnotesize
Sum defined using \textsf{combine} operation.
\normalsize
\vspace{0.5mm}} \\\hline

\footnotesize\textsf{Parray (a,ls,f,b,l)}\normalsize &
    $\tau (f) + \tau (l) + \mathsf{maxlen} \cdot \tau (b)$ &
    $\delta (f) + \delta (l) + \mathsf{maxlen} \cdot \delta (b)$ &
\parbox[t]{4cm}{
\footnotesize
\textsf{ls} = list of array length and linenumbers,
\textsf{f} = type of first token,
\textsf{b} = type of body tokens,
\textsf{l} = type of last token.
\textsf{maxlen} is the maximum from the list \textsf{ls}.
Should we use \textsf{maxlen} as an exponent instead of a multiplier?
\normalsize
\vspace{0.5mm}} \\\hline

\footnotesize\textsf{RefinedBase (a,r,ts) }\normalsize &
$\tau (\calR (\mathrm{maxlen}, (r)))$ &
$\delta (\calR (\mathrm{maxlen}, (r)))$ &
\parbox[t]{4cm}{
\footnotesize
\textsf{maxlen} is the maximum token length from the list \textsf{ls}.
\normalsize
\vspace{0.5mm}} \\\hline

\footnotesize\textsf{Switch (a,id,ts) }\normalsize &
$\sum_{s \in ss} \calR_\tau (s) + \sum_{b \in bs} \mu_\tau (b)$ &
$\sum_{b \in bs} \mu_\tau (b)$ &
\parbox[t]{4cm}{
\footnotesize
\textsf{ss = map} $\sharp$ \textsf{1 ts} are the \textit{switch types},
and \textsf{bs = map} $\sharp$ \textsf{2 ts} are the \textit{branch types}.
Why is data complexity not considered in the switch types?
\normalsize
\vspace{0.5mm}} \\\hline

\footnotesize\textsf{Rarray (a,os,ot,b,ol) }\normalsize &
$\mathsf{tlen} + \mathsf{tterm} + \mathsf{tsep} + \mu_\tau (b)$ &
$\mathsf{dlen} + \mathsf{dterm} + \mathsf{dsep} + \mu_\delta (b)$ &
\parbox[t]{4cm}{
\footnotesize
For the optional \textit{length} field
$\mathsf{(tlen,dlen)} = \calR_{\mathsf{opt}} (\mathsf{ol})$.
For the optional \textit{terminator} field
$\mathsf{(tterm,dterm)} = \calR_{\mathsf{opt}} (\mathsf{ot})$.
For the optional \textit{separator} field
$\mathsf{(tsep,dsep)} = \calR_{\mathsf{opt}} (\mathsf{os})$.
\textsf{b} is the type of the \textit{body} of the array.
\normalsize
\vspace{0.5mm}} \\\hline

\end{longtable}
