\newpage
\section{Bottom Line}
\label{sec:BottomLine}

\subsection{Version 2 complexity metric}

This section describes the complexity metric as coded during March,
2007. The metric is a function called \textsf{measure} having type
\textsf{Ty} $\rightarrow$ \textsf{Ty}. The function fills in complexity
information in the \textsf{AuxInfo} associated with each node of the
\textsf{Ty} structure. Two fields have been added to the \textsf{AuxInfo} type
to support the complexity metric:

\begin{verbatim}
type AuxInfo = { coverage : int
               , label    : Id option
               , typeComp : Complexity
               , dataComp : Complexity
               }
\end{verbatim}

The \textsf{typeComp} field records the complexity of the type itself,
regardless of the data scanned. The \textsf{dataComp} field records
the complexity of the data as viewed through the type.

The functions used in the computation of the complexity measure are
described in table \ref{tab:v2Abbreviations}, which also specifies an
abbreviation for the function. The abbreviations are used in this note
for brevity of notation.

\begin{longtable}{||l|l||}
\caption[Functions and abbreviations]{Functions and abbreviations}
\label{tab:v2Abbreviations}
\\\hline
\hline
Abbr & ML function \\\hline\hline
$\calR$ &
\parbox[t]{9cm}{
\scriptsize
(* Compute type and data complexity of a refined type *)\linebreak
fun refinedComp ( multiplier:int ) ( r:Refined ) : Complexity * Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\calR_\tau$ &
\parbox[t]{9cm}{
\scriptsize
(* Get type complexity of a refined type, assuming multiplier of 1 *)\linebreak
refinedTypeComp ( r : Refined ) : Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\calR_\delta$ &
\parbox[t]{9cm}{
\scriptsize
(* Get data complexity of a refined type, assuming multiplier of 1 *)\linebreak
refinedDataComp ( r : Refined ) : Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\calR_{\mathsf{opt}}$ &
\parbox[t]{9cm}{
\scriptsize
(* Complexity of refined option type, assuming multiplier 1 *)
fun refinedOptionComp ( ro : Refined option ) : Complexity * Complexity =
\normalsize
\vspace{0.5mm}} \\\hline

$\beta$ &
\parbox[t]{9cm}{
\scriptsize
(* Compute the complexity of a base type (e.g. Pint) *)\linebreak
fun baseComplexity ( ts : LToken list ) : Complexity * Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\mu$ &
\parbox[t]{9cm}{
\scriptsize
(* Compute the type and data complexity of an inferred type *)\linebreak
fun measure ( ty : Ty ) : Ty
\normalsize
\vspace{0.5mm}} \\\hline

$\mu_\tau$ &
\parbox[t]{9cm}{
\scriptsize
(* Compute the type complexity of an inferred type *)\linebreak
fun dataMeasure ( ty : Ty ) : Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\mu_\delta$ &
\parbox[t]{9cm}{
\scriptsize
(* Compute the data complexity of an inferred type *)\linebreak    
fun typeMeasure ( ty : Ty ) : Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\mathsf{card}$ &
\parbox[t]{9cm}{
\scriptsize
(* Complexity from the number of choices *)\linebreak
fun cardinalComplexity ( l : 'a list ) : Complexity
\normalsize
\vspace{0.5mm}} \\\hline

$\tau$ &
\parbox[t]{9cm}{
\scriptsize
(* Retrieve computed type complexity from a type *)\linebreak
fun getTypeComplexity ( ty : Ty ) : Complexity = $\sharp$typeComp (getAuxInfo ty)
\normalsize
\vspace{0.5mm}} \\\hline

$\delta$ &
\parbox[t]{9cm}{
\scriptsize
(* Retrieve computed data complexity from a type *)\linebreak
fun getDataComplexity ( ty : Ty ) : Complexity = $\sharp$dataComp (getAuxInfo ty)
\normalsize
\vspace{0.5mm}} \\\hline

\end{longtable}

\normalsize

\begin{longtable}{||l|l|l|l|}
\caption[Base types]{Base types}
\label{tab:v2Base}
\\\hline
\hline
Sub type & Type complexity & Data complexity & Notes \\\hline\hline

\textsf{PbXML} & 1 & $\left(\frac{1}{52}\right)^\mathrm{maxlen} $ &
\parbox[t]{5cm}{
XML seems to handled as a fancy string type. There are 52 possible XML
characters.
\vspace{0.5mm}} \\\hline

\textsf{PeXML} & 1 & $\left(\frac{1}{52}\right)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{
XML seems to handled as a fancy string type. There are 52 possible XML
characters.
\vspace{0.5mm}} \\\hline

\textsf{Ptime} & 1 &
      $\left(\frac{1}{60}\right) \cdot \left(\frac{1}{60}\right) \cdot \left(\frac{1}{24}\right)$ &
\parbox[t]{5cm}{
This is a much oversimplified case. In order to do better, we need to
have a regular expression identified with the time, and analyze the
complexity of the regular expression. See section
\ref{sec:RegularExpressions}.
\vspace{0.5mm}} \\\hline

\textsf{Pdate} & 1 & $\left(\frac{1}{365}\right)$ &
\parbox[t]{5cm}{ One of possible 365 days.
\ref{sec:RegularExpressions}.
\vspace{0.5mm}} \\\hline

\textsf{Ppath} & 1 & $\left(\frac{1}{256}\right)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{ Are there really 256 characters that can make up a path?
\ref{sec:RegularExpressions}.
\vspace{0.5mm}} \\\hline

\textsf{Purl} & 1 & $\left(\frac{1}{256}\right)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{ Are there really 256 characters that can make up a path?
\ref{sec:RegularExpressions}.
\vspace{0.5mm}} \\\hline

\textsf{Pip} & 1 & $\left(\frac{1}{256}\right)^\mathrm{maxlen}$
\footnote{$\mathrm{maxlen}$ is the maximum length of the token address seen} &
\parbox[t]{5cm}{
Calculation should take into account groups of three.
\vspace{0.5mm}} \\\hline

\textsf{Pint} & 1 & $\left(\frac{1}{10}\right)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{
This assumes integers are a sequence of digits 0 \ldots 9.
\vspace{0.5mm}} \\\hline

\textsf{Pstring} & 1 & $\left(\frac{1}{64}\right)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{
There are 64 characters that make up strings.
\vspace{0.5mm}} \\\hline

\textsf{Pgroup} & 1 & 1 &
\parbox[t]{5cm}{
Don't know how to handle this one yet.
\vspace{0.5mm}} \\\hline

\textsf{Pwhite} & 1 & $\left(\frac{1}{2}\right)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{
White space can have either blank or tab characters (2 possibilities).
\vspace{0.5mm}} \\\hline

\textsf{Other} & 1 & $\frac{1}{256}$ &
\parbox[t]{5cm}{
A single ASCII character.
\vspace{0.5mm}} \\\hline

\textsf{Pempty} & 1 & 1 &
\parbox[t]{5cm}{
Not sure about this one.
\vspace{0.5mm}} \\\hline

\textsf{Error} & 1 & 1 &
\parbox[t]{5cm}{
Not sure about this one.
\vspace{0.5mm}} \\\hline

\end{longtable}

\begin{longtable}{||l|l|l|l|}
\caption[Refined base types]{Refined base types}
\label{tab:v2RefinedBase}
\\\hline
\hline
Type & Type complexity & Data complexity & Notes \\\hline\hline

\textsf{StringME} & 1 & $\left(\frac{1}{64}\right)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{
There are 64 characters that make up strings.
\vspace{0.5mm}} \\\hline

\textsf{Int (min, max)} & 1 & $\log (\mathrm{max}- \mathrm{min}+1)^\mathrm{maxlen}$ &
\parbox[t]{5cm}{
\vspace{0.5mm}} \\\hline

\textsf{IntConst n} & 1 & $\log n$ &
\parbox[t]{5cm}{
The data and type complexity are the same for a constant.
When $n$ is zero, we use a complexity of one.
When $n$ is negative, we negate it to make a positive, and then take the $\log$.
\vspace{0.5mm}} \\\hline

\textsf{StringConst s} & 1 & $\mathrm{size} s$ &
\parbox[t]{5cm}{
Should have length multiplied by 8?
\vspace{0.5mm}} \\\hline

\textsf{Enum rl} & 1 & $\sum_{r\in rl} \calR_\delta (r)$
\footnote{The summation is using the \textsf{combine} operation
defined on the type \textsf{Complexity}} &
\parbox[t]{5cm}{
The recursion here is in support of the requirement of
\textit{compositionality}.
\vspace{0.5mm}} \\\hline

\textsf{LabelRef i} & 1 & 1 &
\parbox[t]{5cm}{
Not sure what to do about this one.
\vspace{0.5mm}} \\\hline

\end{longtable}

\begin{longtable}{||l|l|l|l|}
\caption[Structure types]{Structured types}
\label{tab:v2Structured}
\\\hline
\hline
Type & Type complexity & Data complexity & Notes \\\hline\hline

\footnotesize\textsf{Pstruct (a,ts)}\normalsize &
\footnotesize
$\sum_{t} \mu_\tau (t)$
\normalsize &
\footnotesize
$\sum_{t} \mu_\delta (t)$
\normalsize &
\parbox[t]{3cm}{
\footnotesize
Sum defined using \textsf{combine} operation.
\normalsize
\vspace{0.5mm}} \\\hline

\footnotesize\textsf{Punion (a,ts)}\normalsize &
\footnotesize
$\mathsf{card} (ts) + \sum_{t} \mu_\tau (t)$
\normalsize &
\footnotesize
$\mathsf{card} (ts) + \sum_{t} \mu_\delta (t)$
\normalsize &
\parbox[t]{3cm}{
\footnotesize
Sum defined using \textsf{combine} operation.
\normalsize
\vspace{0.5mm}} \\\hline

\footnotesize\textsf{Parray (a,ls,f,b,l)}\normalsize &
\footnotesize
$\tau (f) + \tau (l) + \mathsf{maxlen} \cdot \tau (b)$
\normalsize &
\footnotesize
$\delta (f) + \delta (l) + \mathsf{maxlen} \cdot \delta (b)$
\normalsize &
\parbox[t]{3cm}{
\footnotesize
\textsf{ls} = list of array length and linenumbers,
\textsf{f} = type of first token,
\textsf{b} = type of body tokens,
\textsf{l} = type of last token.
\textsf{maxlen} is the maximum from the list \textsf{ls}.
Should we use \textsf{maxlen} as an exponent instead of a multiplier?
\normalsize
\vspace{0.5mm}} \\\hline

\footnotesize\textsf{RefinedBase (a,r,ts) }\normalsize &
\footnotesize
$\tau (\calR (\mathrm{maxlen}, r))$
\normalsize &
\footnotesize
$\delta (\calR (\mathrm{maxlen}, r))$
\normalsize &
\parbox[t]{3cm}{
\footnotesize
\textsf{maxlen} is the maximum token length from the list \textsf{ls}.
\normalsize
\vspace{0.5mm}} \\\hline

\footnotesize\textsf{Switch (a,id,ts) }\normalsize &
\footnotesize
$\sum_{b \in bs} \mu_\tau (b) + \sum_{s \in ss} \calR_\tau (s)$
\normalsize &
\footnotesize
$\sum_{b \in bs} \mu_\delta (b) + \sum_{s \in ss} \mu_\delta (s)$
\normalsize &
\parbox[t]{3cm}{
\footnotesize
$\mathsf{ss} = \mathsf{map} \sharp 1 \mathsf{ts}$ are the
\textit{switch types}, and $\mathsf{bs} = \mathsf{map} \sharp 2 \textsf{ts}$
are the \textit{branch types}.
\normalsize
\vspace{0.5mm}} \\\hline

\footnotesize\textsf{Rarray (a,os,ot,b,ol) }\normalsize &
\footnotesize
$\mathsf{tlen} + \mathsf{tterm} + \mathsf{tsep} + \mu_\tau (b)$
\normalsize &
\footnotesize
$\mathsf{dlen} + \mathsf{dterm} + \mathsf{dsep} + \mu_\delta (b)$
\normalsize &
\parbox[t]{3cm}{
\footnotesize
For the optional \textit{length} field
$\mathsf{(tlen,dlen)} = \calR_{\mathsf{opt}} (\mathsf{ol})$.
For the optional \textit{terminator} field
$\mathsf{(tterm,dterm)} = \calR_{\mathsf{opt}} (\mathsf{ot})$.
For the optional \textit{separator} field
$\mathsf{(tsep,dsep)} = \calR_{\mathsf{opt}} (\mathsf{os})$.
\textsf{b} is the type of the \textit{body} of the array.
\normalsize
\vspace{0.5mm}} \\\hline

\end{longtable}
