\subsection{David P. Walker}

For his Ph.D. thesis at Cornell University, David Walker developed the
theory and implementation of Typed Assembly Language
(TAL)~\cite{morrisett+:tal-popl,morrisett+:tal,morrisett+:journal-stal}
together with his adviser Greg Morrisett.  TAL is like ordinary
assembly languages (to be specific, it implements the Intel IA32
Pentium architecture), except it is equipped with a strong type system
that enforces memory safety, powerful type safety and type abstraction
properties.  TAL binaries can be downloaded from untrusted sources and
our type checker can check then for safety before they are executed
locally.  This project demonstrated for the first time that there was
an automatic and efficient way to both generate provable safe
low-level programming languages and to check these programs for
safety.  TAL has had a profound effect on programming languages
research since its development and it has been cited in the
proceedings of every POPL conference (the premier conference in
programming languages) since it appeared.

Walker continues to develop type systems for low-level languages to check
safety of untrusted binaries and bytecode, for compiler intermediate
languages to help improve the robustness of compilers, and for
high-level languages to help programmers develop more secure and
reliable software.  Much of his research has been devoted to ensuring
memory safety properties of programs with explicit memory allocation
and deallocation using type
theory~\cite{crary+:capabilities,walker+:capabilities,smith+:alias-types,walker:thesis,ahmed+:hierarchical-storage}
as memory errors are the cause of a significant fraction of all errors
in low-level languages like C that are used to develop out operating
systems, servers and other critical software infrastructure.
Moreover, without memory safety, we can enforce no other significant
safety or security properties.  In addition to studying memory safety
properties, Walker has shown how to use related type-theoretic techniques
to enforce access control properties~\cite{walker:security} and
adherence to general software
protocols~\cite{mandelbaum+:refinements}.  Walker has also written a
chapter of an advanced textbook to be used in graduate courses on
programming languages to help teach this material to a broader
audience~\cite{walker:attapl}.

To complement his research on compile-time reasoning about program
security and reliability, Walker has begun to develop new techniques for defining,
implementing and reasoning about run-time enforcement of program properties.
For example, he developed a rich new theory of security monitors as formal
automata that transform untrusted program behavior as they execute~\cite{ligatti+:edit-automata}.  This theory allows security
architects to model a variety of different sorts of run-time
enforcement mechanisms, to prove that certain mechanisms can or cannot
enforce various security properties, and to compare the power of
different classes of security monitors.  His security automata may be
effectively implemented and deployed in existing systems
using aspect-oriented programming language
technology.  However, since aspect-oriented programming languages
are so new, there had been little analysis of their semantics.
In order to better understand aspect-oriented technologies and their
potential impact on security, Walker formalized and proved
safe the first higher-order, strongly-typed calculus of 
aspects~\cite{walker+:aspects}.  This calculus defines
both static typing rules and the execution behavior of aspect-oriented
programs.  Consequently, it may
serve as a starting point for analysis of deeper properties of programs.
Recently, he has used the calculus to study the design of a
refined type system that detects interference between aspects and
the mainline computation~\cite{dantas+:harmless-advice}.  He has also
formalized a type and effect system for detecting interference
between two security aspects~\cite{bauer+:non-interfering-monitors}.

