To give a feel for our feed declaration language, we work through a
series of examples of increasing sophistication. 

\subsection{CoMon Feeds}
We start by defining
a simple CoMon statistics feed in \figref{fig:simplecomon}.  This
version of the CoMon description specifies the \cd{simple\_comon} feed
using the \kw{base} feed constructor.  The \kw{sources} field
indicates that data for the feed comes from all of the locations
listed in \cd{sites}.  The \kw{schedule} field specifies that relevant
data is available from each source every minute, starting immediately.
When trying to fetch such data, the system may occasionally fail,
either because a remote machine is down or because of network
problems. To manage such errors, the schedule specifies that the
system should try to collect the data from each source for 10 seconds.
If the data does not arrive within that window, the system should give
up. Finally, the \kw{format} field indicates that the fetched data
conforms to the \padsml{}~\cite{mandelbaum+:pads-ml} descrition named
\cd{Source} defined in the file \cd{comon_format}.

\begin{figure}
\begin{code}
(* Simple CoMon distributed data description *)
\kw{let} sites = 
  [
    "http://pl1.csl.utoronto.ca:3121";
    "http://plab1-c703.uibk.ac.at:3121";
    "http://planet-lab1.cs.princeton.edu:3121"
  ] 
\kw{feed} simple_comon =
  \kw{base} \{|
    \kw{sources}  = \kw{all} sites;
    \kw{schedule} = every 1 min, starting now, 
               timeout 10.0 sec; 
    \kw{format}   = Comon_format.Source;  
  |\}
\end{code}
\vskip -2ex
\caption{Simple CoMon feed that fetches data from all sites every minute.}
\label{fig:simplecomon}
\end{figure}

In contrast to the \cd{simple\_comon} feed, which returns data from
all sites, the \cd{comon\_1} feed defined in \figref{fig:comon_1}
returns only a single value per time slice: that of the first site to
supply a complete set of data.
%
\begin{figure}
\begin{code}
\kw{feed} comon_1 =
  \kw{base} \{|
    \kw{sources}  = \kw{any} sites;
    \kw{schedule} = every 1 min, lasting 2 hours;
    \kw{format}   = Comon_format.Source;
  |\}
\end{code}
\vskip -2ex
\caption{CoMon feed fragment that fetches data from a single source.}
\label{fig:comon_1}
\end{figure}
%
This feature is particularly useful when monitoring the
behavior of replicated systems, such as those using
state machine replication, consensus protocols, or even
loosely-coupled ones such as Distributed Hash Tables (DHTs).
In these systems, the same data will be available from any
of the functioning nodes, so receiving results from the first
available node is sufficient. These kinds of monitoring systems
are useful in the face of partial network unreachability or
machine failure. Specifying this behavior at the language level
provides a simpler implementation than network-centric approaches such
as anycast. 

The schedule for \cd{comon\_1} indicates the system should fetch data
every minute for two hours, using the \cd{lasting} field do indicate
the desired duration of the feed.  It omits the \cd{starting} and
\cd{timeout} specifications, in which case the system uses default
settings of \cd{now} for the start time and 30 seconds for the
timeout.  

The \cd{simple\_comon} example hard-codes the set of locations from
which to gather performance data.  In reality, the CoMon system has an
internet-addressable configuration file that contains a list of hosts
to be queried, one per non-comment line. This list is periodically
updated to reflect the set of active nodes in PlanetLab. 

\figref{fig:feedcomon} specifies a version of the \cd{comon} feed that
depends upon this configuration information.  To do so, the
description includes an auxiliary feed \cd{nodes} that describes the
configuration information: it is available from the
\cd{config_location}, it should be fetched every two minutes, and its
format is described by the \padsml{} description \cd{source} given in
the file \cd{Comon\_format}, which appears in \figref{fig:nodepml}.
This \padsml{} description specifies that \cd{source} is a list of
new-line terminated records, each containing a \cd{nodeitem}.  In
turn, a \cd{nodeitem} is either a \cd{'#'} character followed by a
comment string, which should be tagged with the \cd{Comment}
constructor, or a domain-name, which should be tagged as
\cd{Data}. The description also defines a helper function \cd{is_node},
which returns true if the data item in question is a domain-name
rather than a comment.  Given this specification, the \cd{nodes} feed
logically yields a list of host names and comments every two minutes.
In fact, because of the possibility of errors, the feed actually
delivers a list option every two minutes: \cd{Some} if the list is
populated with data, \cd{None} if the data was unavailable at the
given time-slice.

Using the \cd{nodes} specification, we define the \cd{comon} feed as a
\textit{dependent} feed: each item in the \cd{nodes} feed defines a
possible source for the \cd{comon} feed.  The \cd{comon} \kw{source}
specification processes the \cd{nodelist} to handle errors and strip
out comment fields.  The code that handles this processing illustrates
that the \padsd{} domain-specific language is embedded in \ocaml{}.
We use \ocaml{} terms where necessary to specify simple
transformations.  In particular, the \cd{current} function checks if
the \cd{nodelist} is \cd{None}, signalling a fetching error, in which
case it uses the most recently cached list of nodes instead.  The
\kw{source} specification filters out comment fields, and then
converts the domain names to URLs with the required port using the
auxiliary function \cd{makeURL}.  The \kw{schedule} for this CoMon
feed is \cd{once} (with a timeout of sixty seconds) because the feed
gets created once for each nodelist.  Hence, each nodelist contributes
a single set of CoMon statistics to the overall \cd{comon} feed. As
before, the format of data fetched from each node matches the
description \cd{Comon\_format.Source}.







\begin{figure}
\begin{code}
(* CoMon distributed data description *)

(* Helper values and functions *)
\kw{let} config_location = 
  ["http://summer.cs.princeton.edu/status/ \\
    tabulator.cgi?table=slices/ \\
    table_princeton_comon&format=nameonly"]

\kw{let} makeURL (Nodelist.Data x) = 
     "http://" ^ x ^ ":3121"

\kw{let} old_locs = ref []
\kw{let} current list_opt =
  \kw{match} list_opt \kw{with}
    Some l ->  old_locs := l; l
  | None   -> !old_locs

(* Feed of nodes to query *)
\kw{feed} nodes =  
  \kw{base} \{|
    \kw{sources}  = \kw{all} config_location;
    \kw{schedule} = every 2 min;
    \kw{format}   = Nodelist.Source;
  |\}

(* Dependent CoMon feed of node statistics *)
\kw{feed} comon =
  \kw{foreach} nodelist \kw{in} nodes 
  \kw{create}
    \kw{base} \{|
      \kw{sources}  = \kw{all} (List.map makeURL 
                     (List.filter Nodelist.is_node 
                     (current nodelist)));
      \kw{schedule} = once, timeout 60.0 sec; 
      \kw{format}   = Comon_format.Source;
    |\}
\end{code}
\vskip -2ex
\caption{Comon program that uses a feed of node locations to drive
  data collection.}
\label{fig:feedcomon}
\end{figure}

\begin{figure}
\begin{code}
\kw{ptype} nodeitem =
  Comment of '#' * pstring_SE(peor)
| Data of pstring_SE(peor)

\kw{let} is_node item = 
  \kw{match} item \kw{with}
  Data _ -> true
  | _ -> false

\kw{ptype} source = 
    nodeitem precord plist (No_sep, No_term)
\end{code}
\vskip -2ex
\caption{\padsml{} description of CoMon configuration files, which
  contain one host name per non-commented line.}
\label{fig:nodepml}
\end{figure}

\subsection{\vizGems{} Example}
We now shift to an example drawn from AT\&T's \vizGems{} project.  Like
the earlier CoMon example, the \cd{stats} feed in \figref{fig:pulse}
monitors a collection of machines described in a configuration file.
The \cd{hostList} description has the same form as the \cd{nodes} feed
we saw earlier, except it draws the data from a local file and only
once a day.  Unlike the earlier example, we use a \textit{feed
comprehension} to clean up this feed before creating the \cd{stats} feed.
The comprehension filters
the list of hosts to remove comments using the \cd{is_node} function
and we use the built-in \cd{flatten} function to convert the feed of
lists of hosts into a simple feed of hosts.  We use the \cd{mk\_host}
function to remove the \cd{Data} constructor around the hostnames to
simplify down-stream processing.

The \cd{stats} feed depends upon the \cd{hosts} feed.  For each host
\cd{h} in \cd{hosts}, it creates a schedule consisting of a single
time corresponding to ``now'' with a timeout of one minute.  It uses
this schedule \cd{s} to describe a compound feed, which pairs two base
feeds: the first uses the Unix command \cd{ping} to collect network
statistics about the remote machine while the second performs a remote
shell invocation using \cd{ssh} to find out statistics about how long
the machine has been up.  Both of these feeds use the \kw{proc}
constructor in the \kw{sources} field to compute the data on the fly,
rather than reading it from a file.  The argument to \kw{proc} is a
string that is executed in a freshly constructed shell.  The pairing
constructor for feeds takes a pair of feeds and returns a feed of
pairs, with elements sharing the same scheduled fetch time being
paired. This semantics is very convenient in this case, as it produces
a feed that for each host returns a pair of its ping and uptime
statistics, grouping together the information for each host. 
Of course, the full \vizGems{} monitoring application
uses many more tools than just ping and uptime to probe the remote
machine; the corresponding feed description has many more branches than this simplified version.


\begin{figure}
\begin{code}
\kw{let} config_location = 
    [("file:///arrakis/config/machine_list")];

\kw{feed} hostList =  
  \kw{base} \{|
   \kw{sources}  = \kw{all} config_location;
   \kw{schedule} = every 1 day;
   \kw{format}   = Nodelist.Source;
 |\}

\kw{let} mk_host (Nodelist.Data h) = h

\kw{feed} hosts = 
    \{| mk_host n | n <- (flatten hostList), 
                   Nodelist.is_node n |\}

\kw{feed} stats =
  \kw{foreach} h \kw{in} hosts \kw{create}
  \kw{let} s = once, timeout 1 min \kw{in}
  (
   \kw{base} \{| 
      \kw{sources}  = \kw{proc} ("ping -c 1 " ^ h);   
      \kw{format}   = Ping.Source;  
      \kw{schedule} = s; |\},
   \kw{base} \{| 
      \kw{sources}  = \kw{proc} ("ssh " ^ h ^ " uptime");  
      \kw{format}   = Uptime.Source;  
      \kw{schedule} = s; |\}
  ) 
\end{code}
\vskip -2ex
\caption{Simplified version of \vizGems{} feed.}
\label{fig:pulse}
\end{figure}


\subsection{\vizGems{} Example, Version 2}
We now shift to an example drawn from AT\&T's \vizGems{} project.  Like
the earlier CoMon example, the \cd{stats} feed in \figref{fig:pulse2}
monitors a collection of machines described in a configuration file.
Before we discuss the \cd{stats} feed itself, we first explain some
auxiliary feeds that we use in the definition of the \cd{stats} feed.   

The \cd{raw\_hostLists} description has the same form as the \cd{nodes}
feed we saw earlier, except it draws the data from a local file every
two hours.  We use a \textit{feed comprehension} to define a clean
version of the feed, \cd{host\_lists}.  In the comprehension, the
built-in predicate \cd{is\_good} verifies that no errors occured in
fetching the current list of machines \cd{hl}, as would be expected
for a local file.  The function \cd{get\_hosts} takes \cd{hl} and uses
the built-in function \cd{get\_good} to unwrap the payload data from
the error infrastructure, an operation that is guaranteed to succeed
because of the \cd{is\_good} guard. The function \cd{get_hosts} then
selects the host name entries and unwraps them to produce a list of
unadorned host names.   

We next define a feed generator \cd{gen_stats} that yields an
integrated feed of performance statistics for each supplied host.  In
more detail, when given a host \cd{h}, \cd{gen_stats} creates a five
minute schedule with a one minute timeout. It then uses this schedule
to describe a compound feed, which pairs two base feeds: the first
uses the Unix command \cd{ping} to collect network statistics about
the route to \cd{h} while the second performs a remote shell
invocation using \cd{ssh} to gather statistics about how long the
machine has been up.  Both of these feeds use the \kw{proc}
constructor in the \kw{sources} field to compute the data on the fly,
rather than reading it from a file.  The argument to \kw{proc} is a
string that the system executes in a freshly constructed shell.  The
pairing constructor for feeds takes a pair of feeds and returns a feed
of pairs, with elements sharing the same scheduled fetch-time being
paired. This semantics conveniently produces a compound feed that for
each host returns a pair of its ping and uptime statistics, grouping
together the information for each host.  Of course, the full
\vizGems{} monitoring application uses many more tools than just ping
and uptime to probe remote machines; the full feed description has
many more branches than this simplified version. 

Finally, we define the feed \cd{stats}.  For each list of hosts in the
\cd{host_lists} feed, we generate a list of statistics feeds using a
list comprehension and the feed generator \cd{gen\_stats}.  Each item
in this list of feeds corresponds to the statistics feed for a single
host. The \kw{foreach...update} construct then merges this list of
feeds into a single feed with data for all the hosts.  This merged
feed delivers values for a given host list \cd{hl} until the next host
list \cd{hl}' arrives from the feed \cd{host\_lists}, at which point
it stops collecting data from the feeds generated from \cd{hl} and
starts gathering data from the machines in \cd{hl}'.



\begin{figure}
\begin{code}
\kw{let} config_locations =
  [("file:///arrakis/config/machine_list")];

\kw{feed} raw_hostLists =  
  \kw{base} \{|
   \kw{sources}  = \kw{all} config_locations;
   \kw{schedule} = every 2 hours; 
   \kw{format}   = Hosts.Source;   |\}

\kw{let} get_host (Hosts.Data h) = h
\kw{let} get_hosts hl =
    List.map get_host 
     (List.filter Hosts.is_node (get_good hl))

\kw{feed} host_lists = 
  \{| get_hosts hl | hl <- raw_hostLists, 
                    is_good hl |\}

\kw{feed} gen_stats (h) = 
  \kw{let} s = every 5 mins, timeout 1 min \kw{in}
  (
   \kw{base} \{| 
     \kw{sources}  =  \kw{proc} ("ping -c 1 " ^ h);   
     \kw{format}   = Ping.Source;  
     \kw{schedule} = s; |\},
   \kw{base} \{| 
     \kw{sources}  = \kw{proc} ("ssh " ^ h ^ " uptime");  
     \kw{format}   = Uptime.Source;  
     \kw{schedule} = s; |\}
  )

\kw{feed} stats =
  \kw{foreach} hl \kw{in} host_lists \kw{update}
     [ gen_stats h | h <- hl ]
\end{code}
\vskip -2ex
\caption{Simplified version of \vizGems{} feed.}
\label{fig:pulse2}
\end{figure}
