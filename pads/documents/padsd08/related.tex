%{\em Note: the following was taken from a grant proposal written with Vivek
%Pai....  }

One early and widely-used protocol for system monitoring is SNMP, the
simple network management protocol~\cite{snmprfc1157}, which is
supported by commercial tools such as HP's OpenView~\cite{openview}
and free tools such as MRTG~\cite{mrtg}. It provides an open protocol
format, where vendors supply  management information bases (MIBs)
that provide a hierarchical description of the hardware's monitoring
information. By separating the data description into the MIB, SNMP
can be more concise than XML, but it has poor support for ad-hoc
data, and is more difficult to update with new data types or even
changes to the data format.

For Grid or cluster environments, two popular monitoring tool are
Ganglia~\cite{ganglia} and Nagios~\cite{nagios}.  Ganglia focuses more
on continuous monitoring of usage information, and consolidates
information provided by OS tools like vmstat, iostat, uptime,
etc. Nagios focuses more on availability information, and logs (or
delivers) failure and recovery events. Ganglia uses raw data in XDR
for its native fields, and XML-encapsulated fields for extensions.
Nagios has no standard data format, but instead gathers all data by
periodically executing user-specified commands described in a
configuration file. The commands use standardized return values to
express status, and are typically restricted to no more than 4KB of
monitoring data.

What distinguishes PADS from systems like SNMP or Ganglia is the
ability to automatically parse and monitor virtually any kind of
ad-hoc data, from node-level information like that collected by
Ganglia or SNMP, all the way down to application-level data as well as
protocol-level data. These areas are the ones that are not well-served
by today's general-purpose monitoring systems. Moreover, the ability
to use the same data description to automatically build parsers,
in-situ tools, and monitoring systems represents an ease of use that
we believe is not available in other systems.

With the growth of distributed systems, research interest in building
scalable monitoring systems has followed, with tools such as
AVMON~\cite{avmon} and PSePR~\cite{psepr}. Both of these tools can
distribute the monitoring function itself, eliminating the need for a
centralized monitoring location. PADS can be interoperate with these
systems in two ways -- either by serving as the mechanism to manage
their ad-hoc data formats, or by providing late-binding to allow users
to query multiple locations in these monitoring systems.

%Another monitoring system of interest is PsEPR~\cite{psepr} (formerly
%known as Trumpet), which focuses on finding problems via several tests
%to gauge node health. What makes PsEPR interesting to consider is that
%its design is completely decentralized, and all information is pushed
%to all participating nodes via a publish/subscribe mechanism in the
%Jabber protocol~\cite{jabber}. While this approach can be more
%scalable in theory, it currently appears to be hitting the limits of
%Jabber messaging servers. In the event that we decide to support
%fully distributed monitoring (as opposed to replicated monitoring at
%several sites), we will examine the lessons of PsEPR when deciding how
%to proceed.

\subsection{Web Mash Ups}
There is a lot of recent work in web mash
ups\cite{ennals+:mashmaker,yahoopipes,swivel.com}.  These differ in
from our work in that they focus on the task of computing with web
data as opposed to the task of locating and fetching such data. As a
consequence, they have limited mechanisms for specifying schedules for
fetching data or locations other than those accessible from web
browsers.  Their focus is on end-user programming with relatively
small amounts of data: data that can be displayed to a user in a web
browser.  Thus the performance considerations are quite different.
Archiving the data is not an important consideration.  From the web
mash up paper:

``MashMaker is not intended to be used for `mission critical'
applications where data integrity is essential.  Instead, its focus is
on applications where it is more important to be able to produce
interesting data than to be certain that the data is correct.''

I think these tools are somewhat complimentary to our approach, in
that they focus on how to merge data, while we focus on how to get raw
data.  MashMaker does not have a good way of describing the raw data
it gets, treating it as a black box or hand writing scraping code, so
PADS/D could serve as a data feed for MashMaker.
The MashMaker paper contains a nice survey of work in this area that
we can reference.
