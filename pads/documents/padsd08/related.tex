%{\em Note: the following was taken from a grant proposal written with Vivek
%Pai....  }

Due to space constraints, we survey only the most closely related work.

\paragraph*{Provenance.}  The \padsd{} meta-data that tracks the
source location, arrival time and error status of data can be seen as
an instance of provenance information, a topic of increasing interest
in the database community.  Cheney~\etal{}~\cite{cheney-dbpl07} showed
how the programming language idea of dependency analysis leads to a
formal theory for tracking provenence.  Indeed, our Dependency
Correctness Theorem reuses the definition of dependency correctness
developed in their work.  Our system differs from theirs in several
ways, however.  They treat provenance abstractly, as a collection of
colors; we treat it concretely, as attestations of time, source
location and error-freeness.  They track provenance at the level of
individual tuples in a relational calculus; we track it at the level
of files, leading to reduced overhead.  They simply track the
provenance information; we permit programmer code to view and
respond to such information.

\paragraph*{Stream Processing.}
There has been a large body of work in data stream processing and work
flow management \cite{Golab03}. For instance, languages such as Lustre
\cite{CaspiPHP87}, SIGNAL \cite{AmagbegnonBG95} and Functional
Reactive Programmaing (FRP) \cite{ElliottH97,WanH00} are designed to
implement synchronous systems that react to continuous or discrete
signals. These signals are time-indexed values that can be composed or
decomposed using various combinators.  Our work on \padsd{} is
complimentary to these efforts in the sense that its primary purpose
is to provide a bridge between such systems and the messy, outside
world.  \padsd{} provides a way to internalize external, distributed
data and to handle various error conditions and provenance information
in comprehensive manner so that programmers can subsequently use, for
example, the elegant abstractions of events, behaviors and signals
drawn from FRP.


%While the some of the combinators in \padsd{} offers 
%additional expressiveness and convenience in the context of 
%distributed system monitoring and are hence novel in their own right, 
% The most fundamental difference between \padsd{} and the work in 
% stream processing, most notably FRP are as follows.
% First, the key contribution of the \padsd{} language is its ability to create
% feeds of various kinds based on user specification.  
% Therefore, \padsd{} provides a connection between the ``messy'' outside
% world and the elegant abstraction of events/behaviors/signals which are inputs
% to systems like FRP. In that sense, the \padsd{} system
% can be used as a front-end to FRP.
% Second, while most stream processing system operate on time-indexed values,
% \padsd{} values are indexed both on time and location. As a result, there are
% some interesting properties about our system which are absent in systems like FRP.
% Third, the structured meta data propagated with the streams is valuable
% information for data management and error handling. In fact, our generated tools
% make extensive use of the meta data as provenance information. To the best of
% our knowledge, the existing stream processing systems do not emphasize on
% the use of meta data, perhaps because they more or less assume the sanity 
% of the data whereas our feeds are created from the ``wild''. 

\paragraph*{Web Mashups.}
Web Mashup languages such as MashMaker~\cite{ennals+:mashmaker} 
and Yahoo Pipes~\cite{yahoopipes} allow web programmers to
extract data from web sites and RSS feeds and recombine them,
often using conventional functional programming paradigms such as
map and filter.  The focus is on end-user programming with relatively
small amounts of data that can be displayed to a user in a web
browser. Errors are generally ignored as completeness or absolute 
correctness of information is not critical in the domains of interest.
Unlike \padsd{}, which allows users to write rich descriptions
expressing the location, format, schedule and access mode of the data, 
Yahoo Pipes, for instance, acquires data through a fixed collection of 
black boxes.  For this reason, \padsd{} and mashup languages also have the 
potential to be complementary technologies, with \padsd{} descriptions
serving to define new ad hoc data sources for mashups.  In fact, this
idea motivated the design and implementation of the \padsd{} ad
hoc-to-RSS conversion tool. 

\paragraph*{Systems monitoring.}
One early and widely-used protocol for system monitoring is SNMP, the
simple network management protocol~\cite{snmprfc1157}, which is
supported by commercial tools such as HP's OpenView~\cite{openview}
and free tools such as MRTG~\cite{mrtg}. It provides an open protocol
format, where vendors supply management information bases (MIBs)
that provide a hierarchical description of the hardware's monitoring
information. By separating the data description into the MIB, SNMP
can be more concise than XML, but it has poor support for ad hoc
data, and it is more difficult to update with new data types or even 
changes to the data format.
For Grid or cluster environments, two popular monitoring tools are
Ganglia~\cite{ganglia} and Nagios~\cite{nagios}.  
%Ganglia focuses more
%on continuous monitoring of usage information and consolidates
%information provided by OS tools like vmstat, iostat, uptime,
%\etc{} Nagios focuses more on availability information, and logs (or
%delivers) failure and recovery events. 
Ganglia uses raw data in XDR
for its native fields and XML-encapsulated fields for extensions.
Nagios has no standard data format, but instead gathers all data by
periodically executing user-specified commands described in a
configuration file. The commands use standardized return values to
express status and are typically restricted to no more than 4KB of
monitoring data.
What distinguishes \padsd{} from systems like SNMP or Ganglia is the
ability to automatically parse and monitor virtually any kind of
ad hoc data, from node-level information like that collected by
Ganglia or SNMP, all the way down to application-level or even
protocol-level data. These areas are the ones that are not well served
by today's general-purpose monitoring systems. Moreover, the ability
to use the same data description to automatically build parsers, 
in situ tools, and monitoring systems directly from declarative
descriptions represents an ease of use not
available in other systems. 

% With the growth of distributed systems, research interest in building
% scalable monitoring systems has followed, with tools such as
% AVMON~\cite{avmon} and PSePR~\cite{psepr}. Both of these tools can
% distribute the monitoring function itself, eliminating the need for a
% centralized monitoring location. \padsd{} can interoperate with these
% systems in two ways -- either by serving as the mechanism to manage
% their ad-hoc data formats, or by providing late-binding to allow users
% to query multiple locations in these monitoring systems.

%Another monitoring system of interest is PsEPR~\cite{psepr} (formerly
%known as Trumpet), which focuses on finding problems via several tests
%to gauge node health. What makes PsEPR interesting to consider is that
%its design is completely decentralized, and all information is pushed
%to all participating nodes via a publish/subscribe mechanism in the
%Jabber protocol~\cite{jabber}. While this approach can be more
%scalable in theory, it currently appears to be hitting the limits of
%Jabber messaging servers. In the event that we decide to support
%fully distributed monitoring (as opposed to replicated monitoring at
%several sites), we will examine the lessons of PsEPR when deciding how
%to proceed.

%\paragraph*{Functional Programming.}
%The implementation of \padsd{} depends upon a tremendous body of past research
%in both functional stream processing and generic programming.  Rather than
%competing with these technologies, \padsd{} builds upon them and makes them
%highly accessible to off-the-shelf users in an important new
%domain -- that of distributed ad hoc data processing.

%\paragraph*{Reactive Functional Programming.}
%FRP~\cite{elliot+:frp} shares a tenuous relationship to work on \padsd{}
%in that both technologies arise from the need to perform processing
%on a schedule over time-indexed values.  However, 
%FRP focuses on the definition and implementation of {\em continuous} 
%time-varying values.  So far, we have not found use for such
%values in our domain, only for discrete time-indexed
%sequences of events.

%One can only hope Yahoo decides to add \padsd{} as an auxiliary interface
%to their system.
%and \padsd{} generic programming
%tools serving to define generic programs over entire classes of mashups.

% These differ in
% from our work in that they focus on the task of computing with web
% data as opposed to the task of locating and fetching such data. As a
% consequence, they have limited mechanisms for specifying schedules for
% fetching data or locations other than those accessible from web
% browsers.  Their focus is on end-user programming with relatively
% small amounts of data: data that can be displayed to a user in a web
% browser.  Thus the performance considerations are quite different.
% Archiving the data is not an important consideration.  From the web
% mash up paper:

% ``MashMaker is not intended to be used for `mission critical'
% applications where data integrity is essential.  Instead, its focus is
% on applications where it is more important to be able to produce
% interesting data than to be certain that the data is correct.''

% I think these tools are somewhat complimentary to our approach, in
% that they focus on how to merge data, while we focus on how to get raw
% data.  MashMaker does not have a good way of describing the raw data
% it gets, treating it as a black box or hand writing scraping code, so
% \padsd{} could serve as a data feed for MashMaker.
% The MashMaker paper contains a nice survey of work in this area that
% we can reference.



