\input{tools}

\subsection{The Single-Minded Implementer}

In addition to the off-the-shelf tools, \padsd{} includes an API for
manipulating generated feeds. The API provides 
users with a feed abstraction representing a potentially infinite
series of elements. This abstraction is related to that of a lazy
list, but extends it with support for provenance information. 
Therefore, we model the feed API on the
list APIs of functional languages
%, like \ocaml{} and \haskell{},
but provide two levels of abstraction. One level allows users to
manipulate feeds like any lazy list of data elements (ignoring
where they come from), while the other exposes the meta-data as well. 

% Need a new name for Feedmain module. I vote Feed and then Feed_core for the lower-level module.


\begin{figure}[t]
\begin{codebox}
\kw{let} (sample, \_) = \textit{Feed.split_every} 600. comon \kw{in}
\kw{let} select_load = \kw{function}
    Some \{Comon_format.Source.
          loads = (_, load::_)\} -> Some load
  | None -> None \kw{in}
\kw{let} loads    = \textit{Feed.map} select_load sample \kw{in}
\kw{let} load_tbl = \textit{Feed.fold} update empty_tbl loads 
\kw{in}  print_top 10 load_tbl
\end{codebox}
  \caption{Code fragment finding least loaded \planetlab nodes.}
\label{fig:sample-loads}
\end{figure}

%% \texttt{Feed.split\_every n}
%%   extracts the first \texttt{n} seconds of any feed. 
%%   Function \texttt{create} constructs an empty hash table; function 
%%   \texttt{update} adds
%%   an entry to the hash table; function
%%   \texttt{print\_top k} prints the \texttt{k} lowest loads from the table.

%% \begin{figure}[tb]
%% \begin{codebox}
%% \kw{let} deadline = Time.now() +. 600. \kw{in}
%% \kw{let} (sample, remainder) = \textit{Feed.split_when} 
%%    (fun () -> Time.now() > deadline) comon_feed \kw{in}
%% \kw{let} select_load = \kw{function}
%%     Some \{Comon_format.Source.
%%           loads = (_, load::_)\} -> Some load
%%   | None -> None \kw{in}
%% \kw{let} loads = \textit{Feed.map} select_load sample \kw{in}
%% \kw{let} load_tbl = \textit{Feed.fold} update (create ()) loads 
%% \kw{in}  print_top 10 load_tbl
%% \end{codebox}
%%   \caption{Code fragment for sampling \planetlab loads for 10 minutes. Function
%%   \texttt{print\_top k} selects the \texttt{k} lowest loads from the table.}
%% \label{fig:sample-loads}
%% %\vskip -2ex
%% \end{figure}

\begin{figure}[t]

\begin{codebox}
\kw{let} update_m  tbl adata =
  \kw{let} meta = Feed.get_meta adata \kw{in}
  \kw{let} data = Feed.get_contents adata \kw{in}
  \kw{match} meta, data \kw{with} 
    (h, Some basemeta), Some load ->
      \kw{let} location = Meta.get_link basemeta \kw{in}
      update tbl (location, data)
  | _ -> tbl \textit{ (* no change to tbl *)} \kw{in}
\kw{let} load_tbl = \textit{Feed.fold_m} update_m empty_tbl loads
\kw{in} print_top_with_loc 10 load_tbl
\end{codebox}
  \caption{Revised code fragment with provenance meta-data. }
\label{fig:sample-loads-prov}
\end{figure}

For example, consider \planetlab users looking for a desirable set of
nodes on which to run their experiments. 
They can use the API generated from the \comon description 
to monitor \planetlab for a few
minutes to find the least loaded nodes. \figref{fig:sample-loads}
shows an \ocaml{} code fragment that collects the nodes with the
lowest average loads over 10 minutes and then prints them. 
We omit the details for maintaining the table of top values, as it is
orthogonal to our discussion. 
First, we use \cd{Feed.split_every} to
split the feed when 600 seconds (10 minutes) have elapsed. Then, we
use \cd{Feed.map} to project the load data from the \comon
elements. Finally, we use \cd{Feed.fold} to collect the data
into a table. Function \cd{update} adds an entry to the table, and
\cd{empty_tbl} is the initially empty table.
After filling the table, \cd{print\_top 10}
processes each node's loads
and prints the ten lowest average loads.

However, if we want a report of the names of the nodes that have 
the lowest average loads, the above solution is not good enough
because the \comon data format does not include the node location in the data.
In such situations, provenance meta-data is essential. 
We therefore replace the last two lines of
\figref{fig:sample-loads} with the code in
\figref{fig:sample-loads-prov} that exploits the meta-data. First, we
give the
\cd{update_m} (update with meta) function that uses
meta-data to associate a location with every load in the table. It relies on the \cd{Meta} module, 
which \padsd{} provides to facilitate management of meta-data. Next, 
we show a call to the meta-aware fold \cd{fold_m}, which passes the 
payload and its meta-data to the folding
function.  Last, the call \cd{print_top_with_loc 10} prints the ten 
lowest average loads and their locations.

It should be clear from these examples that the single-minded implementer
has a number of new interfaces to master relative to the off-the-shelf
user, but gains a correspondingly higher degree of flexibility and can
still write relatively concise programs.


\subsection{The Generic Programmer}

% Motivate

Occasionally, users might want to develop functions that can
manipulate {\it any} feed. 
%This desire might arise because they
%have a number of different feeds to process in the same way, or 
%because they wish to provide a new tool for other \padsd{}
%users. 
Often, such functions can be written parametrically
in the type of the feed element, much like the feed
library functions discussed above. However, the behavior of many feed
functions depends on the structure of the feed and its
elements. Such functions can be viewed as {\it interpretations} of
feed descriptions. To support their development, we provide a
framework for writing feed interpreters.

% Examples

Two core examples of feed interpretation are the feed creator and the
provenance tracker. The behavior of these tools depends
essentially on the structure of the feed.  Functions like these
require as input a runtime representation of the feed,
complete with the details of the feed description that
they represent. The obvious choice for representing feed descriptions
in \ocaml is a datatype. However, standard \ocaml datatypes are not
sufficiently typeful to express the types of many generic feed
functions. For example, the feed creation function has the type:
%\begin{code}
\cd{feed\_create : 'a prefeed ->} \cd{'a feed}
%\end{code} 
where the type \cd{'a prefeed} is an AST of a feed description and feed 
elements have type \cd{'a}.
%
% Tools as interpreters
%
%%FIX ME:  we need to be more explicit in the paper about what the
%%problem is., ie, spelling out why the example shows that datatypes
%%won't work.
This limitation of datatypes has been widely discussed in the
literature, and various solutions have been 
proposed~\cite{padsml-padl,weirich:encodingtypecase,xi:popl03}. We have 
chosen to represent our AST using a variant of the Mogensen-Scott
encoding~\cite{mogensen:jfp,wand98} which exploits higher-order abstract syntax 
to encode variable binding in feed descriptions.  This implementation strategy 
exploits \ocaml's module system to type the encodings in $F_\omega$. 
Our earlier work on \padsml~\cite{padsml-padl} 
exploited a similar strategy,
but there we only sought to encode the \ocaml{} type of the data, not
the entire \padsml{} description, which is where higher-order abstract
syntax becomes useful.
% To effectively encode the dependency present in feeds
% descriptions, we instead 
% encodings~\cite{mogensen}, employing HOAS to encode variable binding
% in feed descriptions.
% Given that \ocaml is our target language, we follow
% the method used in \padsml{} to encode type
% representations~\cite{padsml-padl}. Because of space limitations, we
% do not provide details here.  


The result of our work is that developers
can interpret feed-description representations by case analysis on
their structure, while still achieving the desired static
guarantees. Moreover, we have successfully used this framework to
develop {\it all} of the tools presented in this paper, including the
feed creator. The compiler only infers appropriate
type declarations from feed descriptions and compiles the feed syntax
into our representations.  However, as one might expect, interfaces using
higher-order abstract syntax and Mogensen-Scott encodings are one step more
complex than those involving the more familiar maps and folds.  Consequently, the
learning curve for the generic programmer is one step steeper than
the curve for the single-minded implementor, and two (or perhaps ten) steps steeper
than the curve for the off-the-shelf user.

% There, we represent our AST using a
% Scott-encoded datatype, and leverage \ocaml's module system to, in
% essence, type the Scott encodings in $F_\omega$. However, in \padsml
% we only sought to encode the \ocaml type of data, not entire \padsml
% descriptions. To effectively encode the dependency present in feeds
% descriptions, we instead use a variant of Mogensen-Scott
% encodings~\cite{mogensen}, employing HOAS to encode variable binding
% in feed descriptions.


