Development of a formal semantics for \padsd{} has been an integral
part of our language design process.  It has been a medium through
which we have communicated our ideas to one another precisely. It has also
allowed us to experiment with the nuanced consequences of our decisions in the
small before implementing them.  Its purpose in this paper is to
provide system users with a way to calculate the expected contents of
any feed they would specify, including subtle details of the effects
of timeouts and errors.

The abstract syntax for our core calculus of feeds appears in
Figure~\ref{fig:syntax}.  The calculus of feeds depends upon a {\em
host language}, in which one may compute locations, schedules,
and constraints.  For the purposes of the
formalization, the host language is the simply-typed lambda calculus.
Figure~\ref{fig:host-language} presents the syntax we will use to
write down host language expressions.  To simplify the semantics,
the host language contains a collection of special constants 
including parsers ($\parser$), locations ($\loc$), times ($\atime$),
and schedules ($\schedule$).  It naturally also includes structured types
such as pairs, sums, lists, streams and functions, all of which are 
completely standard.

\begin{figure}[t]
\[
\begin{array}{lll}
\multicolumn{3}{l}{\mbox{(feed specs)}}\\ 
\multicolumn{3}{l}{\feed \ ::=}   \\  
% & x &  \mbox{feed variable} \\ %% no feed variables now
% & \bnfalt 
& \emptyfeed & \mbox{empty feed} \\
 \bnfalt & \computed{e_1}{x}{e_2} & \mbox{computed feed} \\
 \bnfalt & \letfeed{x}{e_1}{\feed_2} & \mbox{let feed} \\
 \bnfalt &     \mathtt{all \{ format=} e_1; & \mbox{all locations}\\ 
& \qquad     \mathtt{locs=} e_2; & \\
& \qquad     \mathtt{sched=} e_3; & \\
& \qquad     \mathtt{pp=} e_4; & \\
& \qquad     \mathtt{win=} e_5; \}  & \\
%\allfeed{e_1}{e_2}{e_3}{e_4}{e_5} &  \\
 \bnfalt &     \mathtt{any \{ format=} e_1; & \mbox{one of several locations}\\ 
& \qquad     \mathtt{locs=} e_2; & \\
& \qquad     \mathtt{sched=} e_3; & \\
& \qquad     \mathtt{pp=} e_4; & \\
& \qquad     \mathtt{win=} e_5; \}  & \\
% \bnfalt & \existsfeed{e_1}{e_2}{e_3}{e_4}{e_5} & \mbox{one of several location} \\
 \bnfalt & \feed_1 \unionfeed \feed_2 & \mbox{union feed} \\
 \bnfalt & \feed_1 \sumfeed \feed_2 & \mbox{sum feed} \\
 \bnfalt & (\feed_1, \feed_2) & \mbox{synchronous pair} \\
% & \bnfalt & \feed_1 cartesian \feed_2 & \mbox{cartesian pair -- use a symbol different from *} \\
% & \bnfalt & \feed_1 * \feed_2 & \mbox{continuous pair} \\
% & \bnfalt & \feed_1 {*}{*} \feed_2 & \mbox{local pair} \\
 \bnfalt & x{:}\feed_1 * \feed_2 & \mbox{dependent continuous pair} \\
 \bnfalt & x{:}\feed_1\, {*}{*} \, \feed_2 & \mbox{dependent local pair} \\
 \bnfalt &     \mathtt{foreach{*}}\; x \; 
    \mathtt{in}\; \feed_1 & \mbox{for each $x$ create continuous $\feed_2$} \\
 &   \quad \mathtt{create}\; \feed_2 \\
 \bnfalt &     \mathtt{foreach{*}{*}}\; x \; 
    \mathtt{in}\; \feed_1 & \mbox{for each $x$ create local $\feed_2$}\\
 &   \quad \mathtt{extend}\; \feed_2 \\
%\foreachcreate{x}{\feed_1}{\feed_2} & \mbox{for each $x$ create continuous $F_2$} \\
% \bnfalt & \foreachupdate{x}{\feed_1}{\feed_2} & \mbox{for each $x$ create local $F_2$} \\
 \bnfalt & \filterfeed{\feed}{e} & \mbox{filter out some elements} \\
% & \bnfalt & \ppfeed{\feed}{e} & \mbox{preprocess (eg, unzip) data} \\
% & \bnfalt & \remap{\feed}{e} & \mbox{direct feed to different locations/times} \\
% & \bnfalt & \refeed{\feed}{e} & \mbox{adapt feed to new schedule; 
%                                               fill missing entries with ``None''} \\
% & \bnfalt & \stutterfeed{\feed}{e} & \mbox{stutter on new schedule} \\
\end{array}
\]
\caption{Feed Language Syntax.}
\label{fig:syntax}
\end{figure}


\begin{figure}[t]
\[
\begin{array}{lrll}
\multicolumn{4}{l}{\mbox{(host-language base types)}}\\ 
\basety & ::= & \multicolumn{2}{l}{\boolty \bnfalt \stringty \bnfalt \locty \bnfalt \timety \bnfalt \schedulety} \\
\\
\multicolumn{4}{l}{\mbox{(host-language types)}}\\ 
\ty & ::= & \basety & \mbox{base types} \\
 & \bnfalt & \ty_1 * \ty_2 & \mbox{pair types} \\
 & \bnfalt & \optionty{\ty} & \mbox{option types}\\
 & \bnfalt & \ty_1 + \ty_2 & \mbox{union types} \\
 & \bnfalt & \listty{\ty} & \mbox{list types}\\
 & \bnfalt & \feedty{\ty} & \mbox{stream types}\\
 & \bnfalt & \ty_1 \arrow \ty_2 & \mbox{function types} \\
\\
\multicolumn{4}{l}{\mbox{(host-language values)}}\\ 
\data & ::=     & \constant & \mbox{generic constant} \\
 & \bnfalt & \parser & \mbox{parser (generated from PADS/ML)} \\
 & \bnfalt & \loc & \mbox{locations} \\
 & \bnfalt & \atime & \mbox{times} \\
 & \bnfalt & \schedule & \mbox{schedules} \\
 & \bnfalt & \none \bnfalt 
                           \some{\data} & \mbox{optional values}\\
 & \bnfalt & (\data_1,\data_2) & \mbox{pairs} \\
 & \bnfalt & \inl{\data} \bnfalt 
                           \inr{\data} & \mbox{union values} \\
 & \bnfalt & \nillist \bnfalt 
                           \conslist{\data_1}{\data_2} & \mbox{list values} \\
 & \bnfalt & \nilstream \bnfalt 
                           \consstream{\data_1}{\data_2} & \mbox{stream values} \\

& \bnfalt & \lambda x{:}\ty.\expression & \mbox{function values} \\
\\
\multicolumn{4}{l}{\mbox{(host-language expressions)}}\\ 
\expression & ::= & \generalvar & \mbox{variables} \\
 & \bnfalt & \data & \mbox{data values} \\
 & \bnfalt & \none \bnfalt 
              \some{\expression} & \mbox{option expressions}\\
 & \bnfalt & (\expression_1,\expression_2) \bnfalt e.1 \bnfalt e.2 
    & \mbox{pair expressions} \\
% & \bnfalt & \inl{\expression} \bnfalt 
%             \inr{\expression} & \mbox{union expressions} \\
% & \bnfalt & \expression_1 \; \expression_2 & \mbox{application expression} \\
 & \bnfalt & ... & \mbox{more typed lambda expressions} \\
\\
\multicolumn{4}{l}{\mbox{(feed meta-data:  a subset of host language values)}}\\ 
%\multicolumn{4}{l}{\mbox{(a special location (\generatedloc) is used when data is created artificially)}}\\ 
\meta & ::=     
& (\atime,\loc) & \mbox{base metadata} \\
& \bnfalt & (\atime,(\meta,\meta)) & \mbox{pair metadata} \\
& \bnfalt & (\atime,\inl{\meta}) & \mbox{sum metadata} \\
& \bnfalt & (\atime,\inr{\meta}) & \mbox{sum metadata} \\
\end{array}
\]
\caption{Host Language Syntax.}
\label{fig:host-language}
\end{figure}


\begin{figure*}[t]

% \[
% \infer[(\textit{t-var})]
% {\Gamma \turn x : \Gamma(x)}
% {}
% \]

\[
\infer[(\textit{t-empty})]
{\Gamma \turn \emptyfeed : \feedty{\ty}}
{}
\]

\[
\infer[(\textit{t-compute})]
{\Gamma \turn \computed{e_1}{x}{e_2} : \feedty{\optionty{\ty}}}
{
  \Gamma \turn e_2 : \schedulety &
  \Gamma,x{:}\timety \turn e_1 : \optionty{\ty} 
}
\]

\[
\infer[(\textit{t-let})]
{\Gamma \turn \letfeed{x}{e_1}{\feed_2} : \feedty{\ty_2}}
{
  \Gamma \turn e_1 : \ty_1 & 
  \Gamma,x{:}\ty_1 \turn \feed_2 : \feedty{\ty_2} 
}
\]

\[
\infer[(\textit{t-all})]
{\Gamma \turn \allfeed{e_1}{e_2}{e_3}{e_4}{e_5} : \feedty{\optionty{\ty}}}
{
 \begin{array}{c}
  \Gamma \turn e_1 : \optionty{\stringty} \arrow \optionty{\ty} \qquad
  \Gamma \turn e_2 : \listty{\locty} \\
  \Gamma \turn e_3 : \schedulety \qquad
  \Gamma \turn e_4 : \optionty{\stringty} \arrow \optionty{\stringty}  \qquad
  \Gamma \turn e_5 : \timety
 \end{array}
}
\]

\[
\infer[(\textit{t-any})]
{\Gamma \turn \existsfeed{e_1}{e_2}{e_3}{e_4}{e_5} : \feedty{\optionty{\ty}}}
{
 \begin{array}{c}
  \Gamma \turn e_1 : \optionty{\stringty} \arrow \optionty{\ty} \qquad
  \Gamma \turn e_2 : \listty{\locty} \\
  \Gamma \turn e_3 : \schedulety \qquad
  \Gamma \turn e_4 : \optionty{\stringty} \arrow \optionty{\stringty}  \qquad
  \Gamma \turn e_5 : \timety
 \end{array}
}
\]

\[
\infer[(\textit{t-union})]
{\Gamma \turn \feed_1 \unionfeed \feed_2  : \feedty{\ty}}
{
  \Gamma \turn \feed_1 : \feedty{\ty} &
  \Gamma \turn \feed_2 : \feedty{\ty}
}
\]

\[
\infer[(\textit{t-sum})]
{\Gamma \turn \feed_1 \sumfeed \feed_2  : \feedty{\ty_1 + \ty_2}}
{
  \Gamma \turn \feed_1 : \feedty{\ty_1} &
  \Gamma \turn \feed_2 : \feedty{\ty_2}
}
\]

\[
\infer[(\textit{t-synch-pair})]
{\Gamma \turn \feed_1 \spairfeed \feed_2  : \feedty{\ty_1 * \ty_2}}
{
  \Gamma \turn \feed_1 : \feedty{\ty_1} &
  \Gamma \turn \feed_2 : \feedty{\ty_2}
}
\]

% \[
% \infer[(\textit{t-local-pair})]
% {\Gamma \turn \feed_1 * \feed_2  : \feedty{\ty_1 * \ty_2}}
% {
%   \Gamma \turn \feed_1 : \feedty{\ty_1} &
%   \Gamma \turn \feed_2 : \feedty{\ty_2}
% }
% \]

\[
\infer[(\textit{t-cont-pair})]
{\Gamma \turn x{:}\feed_1 * \feed_2  : \feedty{\ty_1 * \ty_2}}
{
  \Gamma \turn \feed_1 : \feedty{\ty_1} &
  \Gamma,x{:}\ty_1 \turn \feed_2 : \feedty{\ty_2}
}
\]

\[
\infer[(\textit{t-local-pair})]
 {\Gamma \turn x{:}\feed_1 \allpairfeed \feed_2  : \feedty{\ty_1 * \ty_2}}
 {
   \Gamma \turn \feed_1 : \feedty{\ty_1} &
   \Gamma,x{:}\ty_1 \turn \feed_2 : \feedty{\ty_2}
 }
\]

\[
\infer[(\textit{t-foreachcont})]
{\Gamma \turn \foreachcreate{x}{\feed_1}{\feed_2}  : \feedty{\ty_2}}
{
  \Gamma \turn \feed_1 : \feedty{\ty_1} &
  \Gamma,x{:}\ty_1 \turn \feed_2 : \feedty{\ty_2}
}
\]

\[
\infer[(\textit{t-foreachlocal})]
{\Gamma \turn \foreachupdate{x}{\feed_1}{\feed_2}  : \feedty{\ty_2}}
{
  \Gamma \turn \feed_1 : \feedty{\ty_1} &
  \Gamma,x{:}\ty_1 \turn \feed_2 : \feedty{\ty_2}
}
\]


\[
\infer[(\textit{t-filter})]
{\Gamma \turn \filterfeed{\feed}{e} : \feedty{\ty}}
{
  \Gamma \turn \feed : \feedty{\ty} &
  \Gamma \turn e : \ty \arrow \boolty
}
\]

% \[
% \infer[(\textit{t-pp})]
% {\Gamma \turn \ppfeed{\feed}{e} : \feedty{\ty}}
% {
%   \Gamma \turn \feed : \feedty{\ty} &
%   \Gamma \turn e : ((\locty * \timety) * \stringty) \arrow \stringty
% }
% \]

% \[
% \infer[(\textit{t-redirect})]
% {\Gamma \turn \remapfeed{\feed}{e} : \feedty{\ty}}
% {
%   \Gamma \turn \feed : \feedty{\ty} &
%   \Gamma \turn e : \locty * \timety \arrow \locty * \timety
% }
% \]

\[
\infer[(\textit{t-reschedule})]
{\Gamma \turn \refeed{\feed}{e} : \feedty{\optionty{\ty}}}
{
  \Gamma \turn \feed : \feedty{\ty} &
  \Gamma \turn e : \schedulety
}
\]

\[
\infer[(\textit{t-stutter})]
{\Gamma \turn \stutterfeed{\feed}{e} : \feedty{\ty}}
{
  \Gamma \turn \feed : \feedty{\ty} &
  \Gamma \turn e : \schedulety
}
\]

\caption{Feed Language Typing.}
\label{fig:typing}
\end{figure*}

%\input{semantics1}

\input{semantics2}


