Developing a formal semantics for \padsd{} has been an
integral part of our language design process.  We have used the semantics to
communicate our ideas precisely and to explore the nuances of design
decisions. Furthermore, the semantics provides users with a tool to reason about the feeds
resulting from \padsd{} descriptions, including subtleties related to
timeouts and errors.

To express locations, schedules, and constraints, the feed calculus
depends upon a {\em host language}, which we take to be the
simply-typed lambda calculus.  Figure~\ref{fig:host-language} presents
its syntax, which includes a collection of constants to simplify the
semantics: strings ($\astring$), locations ($\loc$), times ($\atime$),
and schedules ($\schedule$).  We assume times may be added and
compared and we let $\infty$ represent a time later than all others.
We treat schedules as sets of times and use the notation $\atime
\in \schedule$ to refer to a time $\atime$ drawn from the set
$\schedule$.  We use a similar notation to refer to elements of a
list.  The host language also includes standard structured types such as
options, pairs, sums, lists and functions.
We omit the typing annotations from lambda expressions when they can
be reconstructed from the context.

\begin{figure}[t]
\[
\begin{array}{lrll}
\multicolumn{4}{l}{\mbox{(host-language base types)}}\\ 
\basety & ::= & \multicolumn{2}{l}{\boolty \bnfalt \stringty \bnfalt \locty \bnfalt \timety \bnfalt \schedulety} \\
\\
\multicolumn{4}{l}{\mbox{(host-language types)}}\\ 
\ty & ::= & \basety & \mbox{base types} \\
 & \bnfalt & \optionty{\ty} & \mbox{option types}\\
 & \bnfalt & \ty_1 * \ty_2 & \mbox{pair types} \\
 & \bnfalt & \ty_1 + \ty_2 & \mbox{sum types} \\
 & \bnfalt & \listty{\ty} & \mbox{list types}\\
% & \bnfalt & \feedty{\ty} & \mbox{stream types}\\
 & \bnfalt & \ty_1 \arrow \ty_2 & \mbox{function types} \\
\\
\multicolumn{4}{l}{\mbox{(host-language values)}}\\ 
\data & ::= & \boolf \bnfalt \boolt & \mbox{booleans} \\
 & \bnfalt & \astring \bnfalt \loc \bnfalt \atime \bnfalt \schedule &
 \mbox{strings, locations, times, schedules} \\
 & \bnfalt & \none \bnfalt 
                           \some{\data} & \mbox{optional values}\\
 & \bnfalt & (\data_1,\data_2) & \mbox{pairs} \\
 & \bnfalt & \inl{\data} \bnfalt 
                           \inr{\data} & \mbox{sum values} \\
 & \bnfalt & \nillist \bnfalt 
                           \conslist{\data_1}{\data_n} & \mbox{list values} \\
% & \bnfalt & \nilstream \bnfalt 
%                           \consstream{\data_1}{\data_2} & \mbox{stream values} \\

& \bnfalt & \lambda x{:}\ty.\expression & \mbox{function values} \\
\\
\multicolumn{4}{l}{\mbox{(host-language expressions)}}\\ 
\expression & ::= & \generalvar & \mbox{variables} \\
 & \bnfalt & \data & \mbox{data values} \\
 & \bnfalt & \none \bnfalt 
              \some{\expression} & \mbox{option expressions}\\
 & \bnfalt & (\expression_1,\expression_2) \bnfalt e.1 \bnfalt e.2 
    & \mbox{pair expressions} \\
% & \bnfalt & \inl{\expression} \bnfalt 
%             \inr{\expression} & \mbox{sum expressions} \\
% & \bnfalt & \expression_1 \; \expression_2 & \mbox{application expression} \\
 & \bnfalt & ... & \mbox{more typed lambda expressions} \\
%\\
%\multicolumn{4}{l}{\mbox{(feed meta-data:  a subset of host language values)}}\\ 
%\multicolumn{4}{l}{\mbox{(a special location (\generatedloc) is used when data is created artificially)}}\\ 
\end{array}
\]
\caption{Host Language Syntax.}
\label{fig:host-language}
\end{figure}


\subsection{Feed Syntax and Typing}

The abstract syntax for our feed calculus and its typing rules appear
in Figures~\ref{fig:syntax} and~\ref{fig:typing}, respectively.  The
feed typing judgment has the form $\Gamma \turn \feed :
\feedty{\sigma}$, which means that in context $\Gamma$ mapping
variables to host language types $\tau$, feed $\feed$ produces a
sequence of values of type $\sigma$.  As shown in \figref{fig:syntax},
we define $\sigma$ in terms of host language types, stratified to
facilitate the proof of semantic soundness.  Feed typing depends upon
a standard judgment for simply typing lambda calculus expressions:
$\Gamma \turn e : \ty$.  We discuss the syntax and typing for each
construct in turn.

Core feeds express the underlying structure of base feeds, describing
the data sources ($\mathtt{src}$), schedule ($\mathtt{sched}$), window
($\mathtt{win}$), preprocessing function ($\mathtt{pp}$), and file
format ($\mathtt{format}$).  The source field may contain
pseudo-locations that model the $\mathtt{proc}$ form found in the
implementation.  Instead of expressing time-out conditions in the
schedule as we did in the source language, the calculus requires such
conditions be specified in the window field, which slightly simplifies
the semantics.  The preprocessor and the format parser both map values
with option type to option type, where the value \texttt{None}
indicates a networking or data formatting error. (For the sake of
simplicity, we do not model the variety of error codes that the
implementation supports.)  Consequently, if the format intuitively
describes values of type $\tau$, the feed will return a sequence of
values of type $\optionty{\tau}$, allowing for the possibility of
errors.  The typing for core feeds reflects our choice to have their
semantics be a pair of the underlying schedule and the actual feed
elements.

The feed $\mathtt{all}\ \corefeed$ selects all the data from the core
feed \corefeed, while $\mathtt{any}\ \corefeed$ selects a
representative good value for each time in the schedule for \corefeed{}.
It inserts a \texttt{None} if no such value exists.  


The empty feed ($\emptyset$) contains no elements and has polymorphic
type a l\`a the empty list.  
The computed feed ($\computed{e_1}{x}{e_2}$) allows programmers to
generate a feed with schedule $e_2$ and elements $(\lambda x.e_1)\; \atime$,
where $\atime$ is drawn from the schedule. Likewise, the feed 
comprehension ($\comprehensionfeed{e}{x}{\feed}$) creates a
feed with elements $(\lambda x.e)\; v$ when $v$ is an element of $\feed$.
The feed
$\filterfeed{\feed}{e}$ eliminates elements $v$ from $\feed$ when
$e\; v$ is $\boolf$.  Let feeds $\letfeed{x}{e_1}{\feed_2}$
provide a convenient mechanism for binding intermediate values.
The union feed merges two feeds with the same type
into a single feed.  In contrast, the sum feed takes two feeds
with (possibly) different types and injects the elements of each feed
into a sum before merging the results into a single feed.  

The calculus also contains three different
pair constructors, each providing a different way to
combine elements from the subcomponent feeds.  The first pair, 
written $(\feed_1, \feed_2)$, is a {\em synchronous pair}.
Elements of $\feed_1$ are paired with elements of $\feed_2$
that are {\em scheduled} at exactly the same time, regardless of when those elements
actually {\em arrive}.  Synchronous pairs are most useful when the underlying
subcomponent feeds share the same schedule, as in the Arrakis example
from Section~\ref{sec:informal}.  Synchronous pairs lack a
dependent variant, however, because in our domain it is not sensible
to schedule the acquisition of an element that depends upon another
element scheduled at the same time.  To express dependencies, we 
use two forms of dependent pair, {\em continuous} and {\em local}.
In the continuous variant, each element $x$ of $\feed_1$ is paired 
with all elements of the feed $\feed_2$ that depend on $x$.  In the
local variant, each element $x$ of $\feed_1$
is paired with all elements of the feed $\feed_2$ {\em until the next
element $y$ of $\feed_1$ is scheduled}.  
The denotational semantics, presented
in the next subsection, makes this idea precise.  Local pairing
enables a paradigm in which programmers define an infinite feed $\feed_2$
that gets truncated and regenerated whenever a new element in $\feed_1$
is scheduled.

The final elements of the calculus include the $\mathtt{foreach}$ feeds
and the list comprehension feed.
Intuitively, a $\mathtt{foreach}$ is identical to a dependent pair in
which the first element of the pair is omitted from the data representation.
Consequently, there are two forms of $\mathtt{foreach}$ -- one for
each form of dependent pair.  The notation ${*}$ or ${**}$ serves as
a syntactic mnemonic for the connection.  The list comprehension
feed generates a feed of lists where each element of the list is
scheduled at the same time.  It is akin to the synchronous pair
operation. 

\begin{figure}[t]
\[
\begin{array}{lll}
\multicolumn{3}{l}{\mbox{(feed types)}}\\ 
\multicolumn{3}{l}{\sigma \ ::= \tau \bnfalt \optionty{\tau} 
  \bnfalt \sigma_1 * \sigma_2
  \bnfalt \sigma_1 + \sigma_2
  \bnfalt \listty{\sigma}
}   \\  
\\
\multicolumn{3}{l}{\mbox{(core feed spec)}}\\ 
\multicolumn{3}{l}{\corefeed \ ::= }\\
& \{ \ \mathtt{src=}\    e_1;    & \mbox{source specification} \\
& \ \ \ \mathtt{sched=}\  e_2;    & \mbox{schedule specification}\\
& \ \ \ \mathtt{win=}\    e_3;    & \mbox{time-out window specification} \\
& \ \ \ \mathtt{pp=}\     e_4;    & \mbox{pre-processor} \\
& \ \ \ \mathtt{format=}\ e_5; \} & \mbox{format specification}\\ 
\\
\multicolumn{3}{l}{\mbox{(feed specs)}}\\ 
\multicolumn{3}{l}{\feed \ ::=}   \\  
% & x &  \mbox{feed variable} \\ %% no feed variables now
% & \bnfalt 
         & \mathtt{all}\ \corefeed & \mbox{all sources}\\ 
 \bnfalt & \mathtt{any}\ \corefeed & \mbox{one of multiple sources}\\ 
 \bnfalt & \emptyfeed & \mbox{empty feed} \\
 \bnfalt & \computed{e_1}{x}{e_2} & \mbox{computed feed} \\
 \bnfalt & \comprehensionfeed{e}{x}{\feed} & \mbox{feed comprehension} \\
 \bnfalt & \filterfeed{\feed}{e} & \mbox{filter feed} \\
 \bnfalt & \letfeed{x}{e_1}{\feed_2} & \mbox{let feed} \\
 \bnfalt & \feed_1 \unionfeed \feed_2 & \mbox{union feed} \\
 \bnfalt & \feed_1 \sumfeed \feed_2 & \mbox{sum feed} \\
 \bnfalt & (\feed_1, \feed_2) & \mbox{synchronous pair} \\
% & \bnfalt & \feed_1 cartesian \feed_2 & \mbox{cartesian pair -- use a symbol different from *} \\
% & \bnfalt & \feed_1 * \feed_2 & \mbox{continuous pair} \\
% & \bnfalt & \feed_1 {*}{*} \feed_2 & \mbox{local pair} \\
 \bnfalt & x{:}\feed_1 * \feed_2 & \mbox{dependent continuous pair} \\
 \bnfalt & x{:}\feed_1\, {*}{*} \, \feed_2 & \mbox{dependent local pair} \\
 \bnfalt &     \mathtt{foreach{*}}\; x \; 
    \mathtt{in}\; \feed_1 & \mbox{for each $x$ create continuous $\feed_2$} \\
 &   \quad \mathtt{create}\; \feed_2 \\
 \bnfalt &     \mathtt{foreach{*}{*}}\; x \; 
    \mathtt{in}\; \feed_1 & \mbox{for each $x$ updatee local $\feed_2$}\\
 &   \quad \mathtt{update}\; \feed_2 \\
%\foreachcreate{x}{\feed_1}{\feed_2} & \mbox{for each $x$ create continuous $F_2$} \\
% \bnfalt & \foreachupdate{x}{\feed_1}{\feed_2} & \mbox{for each $x$ create local $F_2$} \\
% & \bnfalt & \ppfeed{\feed}{e} & \mbox{preprocess (eg, unzip) data} \\
% & \bnfalt & \remap{\feed}{e} & \mbox{direct feed to different locations/times} \\
% & \bnfalt & \refeed{\feed}{e} & \mbox{adapt feed to new schedule; 
%                                               fill missing entries with ``None''} \\
% & \bnfalt & \stutterfeed{\feed}{e} & \mbox{stutter on new schedule} \\
 \bnfalt & [\feed \bnfalt x \leftarrow e ] & \mbox{list comprehension feed} \\
\end{array}
\]
\caption{Feed Language Syntax.}
\label{fig:syntax}
\end{figure}


\begin{figure}[th]

% \[
% \infer[(\textit{t-var})]
% {\Gamma \turn x : \Gamma(x)}
% {}
% \]

\[
\infer[(\textit{t-core})]
{ \begin{array}{l}
  \Gamma \turn 
   \{
      \mathtt{src=} e_1;\
      \mathtt{sched=} e_2; \
      \mathtt{win=} e_3;\\ \qquad \ \ 
      \mathtt{pp=} e_4;\
      \mathtt{ format=} e_5; 
   \} 
   : \schedulety * (\feedty{\optionty{\ty}})
 \end{array}
}
{
 \begin{array}{c}
  \Gamma \turn e_1 : \listty{\locty} \quad \
  \Gamma \turn e_2 : \schedulety \quad \
  \Gamma \turn e_3 : \timety\\
  \Gamma \turn e_4 : \optionty{\stringty} \arrow \optionty{\stringty}  \\
  \Gamma \turn e_5 : \optionty{\stringty} \arrow \optionty{\ty} \\
 \end{array}
}
\]

\[
\infer[(\textit{t-all})]
{ \begin{array}{l}
  \Gamma \turn \mathtt{all}\ \corefeed{} : \feedty{\sigma}
 \end{array}
}
{
 \begin{array}{c}
  \Gamma \turn \corefeed{} : \schedulety * (\feedty{\sigma})
 \end{array}
}
\]

\[
\infer[(\textit{t-any})]
{ \begin{array}{l}
  \Gamma \turn \mathtt{any}\ \corefeed{} : \feedty{\sigma}
 \end{array}
}
{
 \begin{array}{c}
  \Gamma \turn \corefeed{} : \schedulety * (\feedty{\sigma})
 \end{array}
}
\]

\[
\infer[(\textit{t-empty})]
{\Gamma \turn \emptyfeed : \feedty{\sigma}}
{}
\]

\[
\infer[(\textit{t-compute})]
{\Gamma \turn \computed{e_1}{x}{e_2} : \feedty{\ty}}
{
  \Gamma \turn e_2 : \schedulety &
  \Gamma,x{:}\timety \turn e_1 : \ty 
}
\]

\[
\infer[(\textit{t-comph})]
{\Gamma \turn \comprehensionfeed{e}{x}{\feed} : \feedty{\ty}}
{
  \Gamma \turn \feed :  \feedty{\sigma} &
  \Gamma,x{:}\sigma \turn e : \ty 
}
\]

\[
\infer[(\textit{t-filter})]
{\Gamma \turn \filterfeed{\feed}{e} : \feedty{\sigma}}
{
  \Gamma \turn \feed : \feedty{\sigma} &
  \Gamma \turn e : \sigma \arrow \boolty
}
\]

\[
\infer[(\textit{t-let})]
{\Gamma \turn \letfeed{x}{e_1}{\feed_2} : \feedty{\sigma_2}}
{
  \Gamma \turn e_1 : \ty_1 & 
  \Gamma,x{:}\ty_1 \turn \feed_2 : \feedty{\sigma_2} 
}
\]

\[
\infer[(\textit{t-union})]
{\Gamma \turn \feed_1 \unionfeed \feed_2  : \feedty{\sigma}}
{
  \Gamma \turn \feed_1 : \feedty{\sigma} &
  \Gamma \turn \feed_2 : \feedty{\sigma}
}
\]

\[
\infer[(\textit{t-sum})]
{\Gamma \turn \feed_1 \sumfeed \feed_2  : \feedty{\sigma_1 + \sigma_2}}
{
  \Gamma \turn \feed_1 : \feedty{\sigma_1} &
  \Gamma \turn \feed_2 : \feedty{\sigma_2}
}
\]

\[
\infer[(\textit{t-synch-pair})]
{\Gamma \turn (\feed_1, \feed_2)  : \feedty{\sigma_1 * \sigma_2}}
{
  \Gamma \turn \feed_1 : \feedty{\sigma_1} &
  \Gamma \turn \feed_2 : \feedty{\sigma_2}
}
\]

% \[
% \infer[(\textit{t-local-pair})]
% {\Gamma \turn \feed_1 * \feed_2  : \feedty{\sigma_1 * \sigma_2}}
% {
%   \Gamma \turn \feed_1 : \feedty{\sigma_1} &
%   \Gamma \turn \feed_2 : \feedty{\sigma_2}
% }
% \]

\[
\infer[(\textit{t-cont-pair})]
{\Gamma \turn x{:}\feed_1 * \feed_2  : \feedty{\sigma_1 * \sigma_2}}
{
  \Gamma \turn \feed_1 : \feedty{\sigma_1} &
  \Gamma,x{:}\sigma_1 \turn \feed_2 : \feedty{\sigma_2}
}
\]

\[
\infer[(\textit{t-local-pair})]
 {\Gamma \turn x{:}\feed_1 \allpairfeed \feed_2  : \feedty{\sigma_1 * \sigma_2}}
 {
   \Gamma \turn \feed_1 : \feedty{\sigma_1} &
   \Gamma,x{:}\sigma_1 \turn \feed_2 : \feedty{\sigma_2}
 }
\]

\[
\infer[(\textit{t-foreachcont})]
{\Gamma \turn \foreachcreate{x}{\feed_1}{\feed_2}  : \feedty{\sigma_2}}
{
  \Gamma \turn \feed_1 : \feedty{\sigma_1} &
  \Gamma,x{:}\sigma_1 \turn \feed_2 : \feedty{\sigma_2}
}
\]

\[
\infer[(\textit{t-foreachlocal})]
{\Gamma \turn \foreachupdate{x}{\feed_1}{\feed_2}  : \feedty{\sigma_2}}
{
  \Gamma \turn \feed_1 : \feedty{\sigma_1} &
  \Gamma,x{:}\sigma_1 \turn \feed_2 : \feedty{\sigma_2}
}
\]


% \[
% \infer[(\textit{t-pp})]
% {\Gamma \turn \ppfeed{\feed}{e} : \feedty{\ty}}
% {
%   \Gamma \turn \feed : \feedty{\ty} &
%   \Gamma \turn e : ((\locty * \timety) * \stringty) \arrow \stringty
% }
% \]

% \[
% \infer[(\textit{t-redirect})]
% {\Gamma \turn \remapfeed{\feed}{e} : \feedty{\ty}}
% {
%   \Gamma \turn \feed : \feedty{\ty} &
%   \Gamma \turn e : \locty * \timety \arrow \locty * \timety
% }
% \]

%% \[
%% \infer[(\textit{t-reschedule})]
%% {\Gamma \turn \refeed{\feed}{e} : \feedty{\optionty{\ty}}}
%% {
%%   \Gamma \turn \feed : \feedty{\ty} &
%%   \Gamma \turn e : \schedulety
%% }
%% \]

%% \[
%% \infer[(\textit{t-stutter})]
%% {\Gamma \turn \stutterfeed{\feed}{e} : \feedty{\ty}}
%% {
%%   \Gamma \turn \feed : \feedty{\ty} &
%%   \Gamma \turn e : \schedulety
%% }
%% \]


\[
\infer[(\textit{t-listf})]
{\Gamma \turn [\feed \bnfalt x \leftarrow e ]  : \feedty{\listty{\sigma}}}
{
  \Gamma \turn e : \listty{\tau} &
  \Gamma,x{:}\tau \turn \feed : \feedty{\sigma} 
}
\]

\caption{Feed Language Typing.}
\label{fig:typing}
\end{figure}

%\input{semantics1}

\subsection{Feed Semantics}

The calculus of feeds has a denotational semantics that allows
programmers to calculate the contents of their feeds relative to
the uncertainty present in the networking environment.  The
principal semantic function is written
$\semantics{\feed}{\environment}{\universe}$,
where  $\environment$ is an {\em environment} mapping variables to values
and $\universe$ is a {\em universe} mapping pairs of
schedule time and location to arrival time and string option.
Intuitively, the universe models the network.
When $\universe (\atime_1, \ell) = (\atime_2, \mathtt{Some} \; \astring)$,
 the interpretation is that if the run-time system requests data
from location $\ell$ at time $\atime_1$ then string data $\astring$
will be returned at time $\atime_2$.  The time $\atime_2$ must be
later than $\atime_1$.
When $\universe (\atime_1, \ell) = (\infty, \mathtt{None})$,
networking errors have simply made location $\ell$ unreachable.

The result of the semantic function 
$\semantics{\feed}{\environment}{\universe}$
is a set of metadata/data pairs, where the 
metadata is coded as follows.
%   The metadata 
% we model is somewhat simplified relative to the implementation.
% The metadata for base feeds includes both the scheduled time of the
% associated data item and its location of origin -- such 
% information is also often referred to as the data's 
% {\em provenance}~\cite{provenancestuff}.  As shown
% below, the metadata for pair 
% and sum feeds is structured similarly to the data items themselves.  

\[
\begin{array}{lcll} 
\meta & ::=     
& (\atime,\loc) & \mbox{base metadata} \\
& \bnfalt & (\atime,(\meta_1,\meta_2)) & \mbox{pair metadata} \\
& \bnfalt & (\atime,\inl{\meta}) & \mbox{sum metadata} \\
& \bnfalt & (\atime,\inr{\meta}) & \mbox{sum metadata} \\
& \bnfalt & (\atime,[\meta_1,\ldots,\meta_k]) & \mbox{list metadata} \\
\end{array}
\]  

Since every metadata item contains a top-level time $\atime$, that
time can be used to serialize the set of items as a stream, and 
our implementation does just that.  Items scheduled at the
same time may appear in any order in the implementation's
serialized stream.  To refer to the top-level time in any metadata
item $\meta$, we write $\mytime{\meta}$. 

Our semantics for feeds depends upon a semantics for the simply-typed
host language, which we write $\esemantics{e}{\environment}$. We assume that
given environment $\environment$ with type $\Gamma$ 
and expression $e$ with type $\tau$ in $\Gamma$, 
$\esemantics{e}{\environment} = v$
and $\turn v : \tau$.

Figure~\ref{fig:semantics} presents the semantic definitions for feeds themselves.  In these definitions,
we use conventional set-theoretic notation to define the elements
that inhabit the feed.
The first definition shows that the empty feed is the empty set. The
second gives the definition of a computed feed.  Notice that a
dummy location ($\generatedloc$) occupies the position of location
metadata.  The feed comprehensions are defined in a similar way. 
The filter feed and the feed comprehensions together serve to model
the full power of the feed comprehensions found in our implementation.


The semantics of {\tt all} and {\tt any} feeds are somewhat more complex
because they describe the consequences of networking errors and time outs.
In the case for {\tt all}, a function {\tt timeout} is defined.  This
function checks the item arrival time $x_{at}$ and compares it to its
scheduled time ($x_t$) plus its window ($\esemantics{e_5}{\environment}$).  If
the arrival time exceeds its window, {\tt None} is returned. Otherwise,
its data argument ($x_s$, which may be {\tt None} due to other networking 
errors) is returned.  The {\tt timeout} is used in definition of an 
alternate universe $\universe'$, that retrieves data from the outside world,
checks for timeout, and applies the preprocessor 
($\esemantics{e_4}{\environment}$) before returning its final result.
The elements of the feed itself are pairs of base metadata $(\atime,\ell)$
with data defined by $\esemantics{e_1 \; (\universe'(\loc,\atime))}{\environment}$
where $e_1$ is the \pads{}-generated parser.
The semantics of an {\tt any} feed is defined by selecting one of the
good (non-error) elements of the corresponding {\tt all} feed at the same time,
if any exist.  If there are no good elements in 
 the corresponding {\tt all} feed, then the {\tt any} feed will contain a
{\tt None} item at the given time, and the dummy location $\generatedloc$
occupies the location slot in the metadata.

The two forms of disjunctive feed are easy to define.  The
union feed is simply the set-theorectic union of
its constituent feeds.  The sum feed injects the elements of its constituent
feeds into a sum and likewise takes their union.

More care must be taken when defining the semantics of pairs.
The synchronous pair $(\feed_1,\feed_2)$
is formed by finding all elements of $\feed_1$
at a given time (including erroneous elements) 
and all elements of  $\feed_2$ (again including erroneous elements) 
at that time and
generating their Cartesian product.  Notice that if schedules 
do not intersect, a synchronous pair will wind up isomorphic to the
empty feed.  Metadata from constituent feeds is paired together.
The scheduled time of the composite item is noncontroversial in this case --
it is the same as the scheduled times of the two underlying feeds.

The elements of the continuous dependent pair ($x{:}\feed_1 * \feed_2$)
are calculated by first determining the elements of $\feed_1$. 
For each element $v$ in $\feed_1$, it is possible to calculate
the elements of $\feed_2$ by binding $x$ to $v$ in $\feed_2$'s definition.
From this point, the elements of the composite feed include all elements
$x$ of $\feed_1$ paired with the corresponding elements of $\feed_2$ scheduled
later than $x$.  Like in the case for synchronous pairs, metadata from 
constitute feeds is paired together in the composite feed.  {\em Unlike}
in the case for synchronous pairs, the two elements of the pair do
not share a common schedule time.  We adopt the later time ({\em i.e.,}
the time of the element from $\feed_2$) as the schedule time for the
composite feed element.

The difference between the continuous pair and the local pair
comes in the third line of the definition of the local pair.
Here, the existence of another element $(\meta_1',v_1')$
in $\feed_1$ in addition to $(\meta_1,v_1)$ implies that the 
schedule time for the item under consideration in $\feed_2$
must fall between the schedule times for $v_1$ and $v_1'$
(otherwise that item from $\feed_2$ is not included in the
final composite feed). 

As discussed earlier, the semantics of the two variants of $\mathtt{foreach}$
follows the semantics of dependent pairs closely.  Notice, for instance,
the similarity between the conditions on the local {\tt foreach} with those
for the local dependent pair.  

The semantics of the list comprehension feeds are closely connected to the semantics of
the synchronous pairs in that each list in the generated feed of lists contains elements
scheduled for the same time.

As a sanity check on our semantic definitions, we have proven
that the values contained in each feed are pairs of meta-data and data
values with the appropriate type.  More specifically, if the feed typing
rules give feed $\feed$ type $\sigma$, then its data has type $\sigma$ and
its meta data has type $\metatype{\sigma}$ where $\metatype{\sigma}$ is
defined as follows.
\[
\begin {array} {lcl}
\metatype{\ty} & = & \timety * \locty \\
\metatype{\optionty{\ty}} & = & \timety * \locty \\
\metatype{\sigma_1 * \sigma_2} & = & \timety * (\metatype{\sigma_1} * \metatype{\sigma_2}) \\
\metatype{\sigma_1 + \sigma_2} & = & \timety * (\metatype{\sigma_1} + \metatype{\sigma_2}) \\
\metatype{\listty{\sigma}} & = & \timety * (\listty{\metatype{\sigma}}) \\
\end{array}
\]
%We state this property formally as follows.
\begin{theorem}[Semantic Soundness]
If $\Gamma \turn \feed : \feedty{\sigma}$ and
for all $x$ in $\dom(\Gamma)$, $\turn \environment(x) : \Gamma(x)$
and $\turn \universe : \timety * \locty \arrow \timety * (\optionty{\stringty})$
then
for all $(\meta,v) \in \semantics{\feed}{\environment}{\universe}$,
$\turn (\meta,v) : \metatype{\sigma} * \sigma$. 
\end{theorem}
The proof follows by induction on the structure of $\feed$.
\input{semantics2}


