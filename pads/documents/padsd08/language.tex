\input{syntax}
Developing a formal semantics for \padsd{} has been an integral part
of our language design process.  We have used the semantics to
communicate our ideas precisely and to explore the nuances of design
decisions. Furthermore, the semantics provides users with a tool to
reason about the feeds resulting from \padsd{} descriptions, including
subtleties related to synchronization, timeouts, errors and provenance.

To express locations, times, schedules and constraints, the feed calculus
depends upon a {\em host language}, which we take to be the
simply-typed lambda calculus.  Figure~\ref{fig:host-language} presents
its syntax, which includes a collection of constants to simplify the
semantics: strings ($\astring$), times ($\atime$) and locations
($\loc$).  We assume times may be added and 
compared and we let $\infty$ represent a time later than all others.
We assume that the set of locations includes the constant
$\generatedloc{}$, indicating the associated data was computed rather
than fetched.
We treat schedules as sets of times and use the notation $\atime
\in \schedule$ to refer to a time $\atime$ drawn from the set
$\schedule$.  We use a similar notation to refer to elements of a
list.  The host language also includes standard structured types such as
options, pairs, sums, lists and functions.
We omit the typing annotations from lambda expressions when they can
be reconstructed from the context.


\subsection{Feed Syntax and Typing}
The abstract syntax for our feed calculus and its typing rules appear
in Figures~\ref{fig:syntax} and~\ref{fig:typing}, respectively.  
The feed typing judgment has the form 
$\Gamma \turn \feed : \feedty{\sigma}$, 
which means that in the context $\Gamma$ mapping variables to host
language types $\tau$, $\feed$ is a feed of $\sigma$ values. 
The core typing judgment, which has the form 
$\Gamma \turn \corefeed{} : \corety{\sigma}$, conveys the same
information for core feeds.

\input{typing}

Intuitively, a feed carrying values of type $\sigma$ is a sequence of
payload values of type $\sigma$.  However, to record provenance
information, we pair each payload value with meta-data, so a feed is
actually a sequence of (meta-data, payload) pairs.  At the top-level,
meta-data consists of a triple of the scheduled time for the payload,
a \textit{dependency set} that records the origin and scheduled time of any data
that contributed to the payload, and a nested meta-data field whose
form depends upon the type of the payload.

Formally, we let 
$\meta$ range over top-level meta-data,
$\ds$ range over dependency sets, and 
$\nested$ range over ``nested'' meta-data:
\[
\begin{array}{lcll} 
\meta & ::= & (\atime,\ds,\nested) & \mbox{top-level meta-data} \\  
\\
\ds   & ::= & \{(\atime_1,\loc_1),\ldots,(\atime_n, \loc_n) \}  & \mbox{dependency set}\\ 
\\
\nested & ::=     
          & (\atime,\loc,\mathtt{None}) & \mbox{base meta-data (timeout)} \\
& \bnfalt & (\atime,\loc,\mathtt{Some}\; \atime) & \mbox{base meta-data (success)} \\
& \bnfalt & (\nested_1,\nested_2) & \mbox{pair meta-data} \\
& \bnfalt & \inl{\nested} & \mbox{sum meta-data} \\
& \bnfalt & \inr{\nested} & \mbox{sum meta-data} \\
& \bnfalt & [\nested_1,\ldots,\nested_k] & \mbox{list meta-data} \\
\end{array}
\] 
Given meta-data $\meta$, we write $\mytime{\meta}$, $\myds{\meta}$ and
$\myval{\meta}$ for the first, second and third projections (respectively) of $\meta$.
Base meta-data is a triple of the scheduled time, the location of origin 
and an optional arrival time where {\tt None} indicates the data did not arrive
in a timely fashion.

As shown in \figref{fig:syntax}, we define the feed payload type
$\sigma$ in terms of host 
language types, stratified to facilitate the proof of
semantic soundness.  
We use the function $\metatype{\sigma}$ to define the type of
meta-data associated with payload of type $\sigma$:
\[
\begin {array} {lcl}
\nestedtype{\ty} & = & \timety * \locty * (\optionty{\timety}) \\
\nestedtype{\optionty{\ty}} & = & \timety * \locty * (\optionty{\timety}) \\
\nestedtype{\sigma_1 * \sigma_2} & = & \nestedtype{\sigma_1} * \nestedtype{\sigma_2} \\
\nestedtype{\sigma_1 + \sigma_2} & = & \nestedtype{\sigma_1} + \nestedtype{\sigma_2} \\
\nestedtype{\listty{\sigma}} & = & \listty{\nestedtype{\sigma}} \\
\\
\metatype{\sigma} & = & \timety * \dsty * \nestedtype{\sigma} \\
\end{array}
\]
Feed typing depends upon a standard judgment for
typing lambda calculus expressions: $\Gamma \turn e : \ty$.  

With these preliminaries, we can now discuss the syntax and typing for
each of the feed constructs in \figref{fig:syntax}. 
Core feeds express the structure of base feeds, describing
the data sources ($\mathtt{src}$), schedule ($\mathtt{sched}$), window
($\mathtt{win}$), preprocessing function ($\mathtt{pp}$) and file
format ($\mathtt{format}$).  The source field describes the set of
locations from which to fetch data.  It may contain
pseudo-locations that model the $\mathtt{proc}$ form found in the
implementation.  Instead of having timeouts specified as part of
schedules, as we did in the surface language, the calculus separates
these two concepts into distinct fields, which simplifies the semantics.
If an item specified to arrive at time $\atime$ by schedule $e_2$ fails
to arrive within the window $e_3$, the feed pretends it received the
value \texttt{None}.  Otherwise, it wraps the received data string in
an option. As a result, the preprocessor $e_4$ maps a $\optionty{\stringty}$
to a $\optionty{\stringty}$, where a result of \texttt{None} indicates
either a network or preprocessing error.  Finally, the formatting
function $e_5$ parses the output of the preprocessor to produce a 
value of type $\optionty{\tau}$, where a \texttt{None} result
indicates a network, preprocessing or formatting error. (For the sake
of simplicity, we do not model the variety of error codes that the
implementation supports.)  

The feed $\mathtt{all}\ \corefeed$ selects all the data from the core
feed \corefeed.  The feed $\mathtt{any}\ \corefeed$ selects the first
good value to arrive from any location for each time in the schedule
for \corefeed{}, returning \texttt{None} paired with appropriate
meta-data if no such good value exists.    

The empty feed ($\emptyset$) contains no elements and has polymorphic
type a l\`a the empty list.  The singleton feed $\onefeed{e_v}{e_t}$
constructs a feed containing a single value $e_v$ at a single time
$e_t$.  The schedule feed $\sfeed{e}$ builds a feed whose elements 
are the times in the schedule $e$.
The union feed merges two feeds with the same type
into a single feed.  In contrast, the sum feed takes two feeds
with (possibly) different types and injects the elements of each feed
into a sum before merging the results into a single feed.  
The pair feed, written $(\feed_1, \feed_2)$, combines the elements of
the two nested feeds synchronously, matching elements that have the
same {\em scheduled} time, regardless of when those elements
actually {\em arrive}.
The list feed $[\feed \bnfalt x \leftarrow e ]$, in contrast, provides
$n$-way synchronization, where $n$ is the length of the input list
$e$.  Each element $e_i$ in $e$ defines a feed $\feed_i = \feed[x \mapsto e_i]$.
For each time $\atime$ with a value $v_i$ in each feed $\feed_i$, the
list feed returns the list $[v_1, \ldots, v_n]$ (and appropriate meta-data).  Note that if the
$\feed_i$ feeds share a schedule $s$, then each feed will have a value
for every time in the schedule $s$, even in the presence of errors, so
the synchronization will succeeed at each time in the schedule $s$.
The feed comprehension $\comprehensionfeed{\feed_2}{x}{\feed_1}$
creates a feed with elements $\feed_2[x \mapsto v]$ when $v$ is an
element of $\feed_1$. Note that the entry $v$ is a pair of meta-data
(with type $\metatype{\sigma}$) and payload data (with type $\sigma$).
The feed $\filterfeed{\feed}{e}$ eliminates elements $v$ from $\feed$ when
$e\; v$ is $\boolf$.  Let feeds $\letfeed{x}{e}{\feed}$
provide a convenient mechanism for binding intermediate values. 

\input{semantics2}

\subsection{Feed Semantics}
We give the semantics of our formal feed language in 
a denotational style in \figref{fig:semantics}.  The principal semantic functions are
$\csemantics{\corefeed}{\environment}{\universe}$ and
$\semantics{\feed}{\environment}{\universe}$, defining core feeds and
feeds, respectively.  In these definitions,
$\environment$ is an {\em environment} mapping variables to values
and $\universe$ is a {\em universe} mapping pairs of
schedule time and location to arrival time and a string option
representing the actual data.
Intuitively, the universe models the network.
When $\universe (\atime_s, \ell) = (\atime_a, \mathtt{Some} \; \astring)$,
 the interpretation is that if the run-time system requests data
from location $\ell$ at time $\atime_s$ then string data $\astring$
will be returned at time $\atime_a$.  The time $\atime_a$ must be
no earlier than $\atime_s$.
When $\universe (\atime_s, \ell) = (\infty, \mathtt{None})$,
networking errors have made location $\ell$ unreachable.

\cut{
Both semantic functions yield a set of (meta-data, payload) pairs,
as we saw in the previous section.
Every meta-data item contains a top-level time $\atime$ that
time can be used to serialize the set of items as a stream, and 
our implementation does just that.  Items scheduled at the
same time may appear in any order in the implementation's
serialized stream.  }

The semantic definitions for ${\cal C}$ and ${\cal F}$ use
conventional set-theoretic notations.  They depend upon a
semantics for the simply-typed host language, written
$\esemantics{e}{\environment}$, whose definition we omit. We assume
that given environment $\environment$ with type $\Gamma$ and
expression $e$ with type $\tau$ in $\Gamma$,
$\esemantics{e}{\environment} = v$ and $\turn v : \tau$.

The meaning of core feed \corefeed{} is the set of
(meta-data, payload) pairs for the feed.  To construct this set, the
function first computes the set of times in the schedule $S$, the
length of the window $W$, and the set of source locations $L$.  It
uses the \texttt{timeout} function to check whether the item arrival time
$x_{at}$ is within the window $W$
of the scheduled time ($x_t \in S$), returning \texttt{None} if
not. Otherwise, \texttt{timeout} returns its data argument ($x_s$),
which may be {\tt None} because of other networking errors.  
Similarly, the \texttt{arrival} function returns the arrival time
$\texttt{Some}\ x_{at}$ if the item arrived within the window and 
\texttt{None} otherwise. The function \texttt{meta} uses the 
\texttt{arrival} function to construct the meta-data for the item,
consisting of the scheduled time $\atime$, the dependency set of the scheduled
time and  source location $\{(\atime, \loc)\}$, and the nested
meta-data, which includes the scheduled 
time $\atime$, the source location $\loc$, and the actual arrival time
$\texttt{arrival}(\atime,\universe(\atime,\loc))$. (This apparent
redundancy in the meta-data goes away with non-core feeds.) 
Using the
\texttt{timeout} function, we define an alternate universe
$\universe'$ that retrieves data from the outside world using the
original universe $\universe$, checks for a
timeout, and applies the preprocessor
($\esemantics{e_{pp}}{\environment}$) before returning.  
The \texttt{val} function applies the formating function 
$\esemantics{e_{f}}{\environment}$ to the entry returned at time
$\atime$ for location $\loc$ in alternative universe $\universe'$.
Finally, the result is the set of all pairs of meta-data and payload
produced from each time $\atime$ in the schedule $S$ and location $\loc$
in the set $L$.

The semantics of the $\mathtt{all}\ \corefeed$ feed is simply the semantics
of the underlying core feed.
The semantics of the $\mathtt{any}\ \corefeed$ feed selects for each
time $\atime$ in the schedule $S$ of the core feed $\corefeed$ the
earliest good payload value from any location if one exists, or
\texttt{None} otherwise.  It then returns the set of all such values
$v_t$, paired with the appropriate meta-data.  
To compute this set, the function first computes
the meaning $A$ of the core feed $\corefeed{}$.  It extracts the
schedule $S$ from the meta data in $A$.  For each time $\atime$ in the
schedule, it computes the set $A_t$ of (meta-data, payload) pairs
fetched at time $\atime$.  For each such set, it computes the
dependency set $DS_t$, which collects the dependencies of all the
items fetched at time $\atime$.  The set $G_t$ collects all the good
items from $A_t$. If this set is non-empty, we use the function 
$\selectOne$ to choose the (meta-data, payload) pair $(m,v)$ with the
earliest arrival time from $G_t$.  (We assume that there is always one
such earliest item.)  In this case, we set the nested
meta-data $nest_t$ to be the nested meta-data of $m$, and the payload
value $v_t$ to be $v$.  If the set of good values is empty, then we set the nested
meta-data to indicate that at time $\atime$, we created (location =
$\generatedloc$) a payload value that had no actual
arrival time \texttt{None}.  In this case, the payload value $v_t$ is
just \texttt{None}. 

The meaning of the empty feed is the empty set.  
The meaning of the singleton feed $\onefeed{e_v}{e_t}$ is a single
pair, the payload portion of which is the meaning of $e_v$.  The
meta-data indicates $e_t$ is the scheduled time, the dependency
set is empty, the data came from $\generatedloc$ (a dummy location
indicating that the value was generated internally), and the arrival time
matched the scheduled time. 
A schedule feed $\sfeed{e}$ yields a feed with one payload value for
each $\atime$ in the meaning of the schedule $e$.  The corresponding
meta-data follows the same pattern as for the singleton feed.  
The union feed is simply the set-theorectic union of its constituent
feeds. The sum feed injects the elements of its constituent
feeds into a sum and likewise takes their union.  It also constructs
compound meta-data from the meta-data of the consituent feeds in the
obvious way.

The pair feed $(\feed_1,\feed_2)$ is formed by finding for each time
$\atime$ all elements
of $\feed_1$ at a time $\atime$ (including erroneous elements) and all
elements of $\feed_2$ at time $\atime$ (again including erroneous
elements) and generating their Cartesian product.  Notice that 
if the schedules do not intersect, the pair feed will empty.  The
meta-data is constructed by combining the meta-data for the paired
feeds.
The semantics of the list feed $[\feed \bnfalt x \leftarrow e ]$ is
similar to that of the pair feed except the synchronization is $n$-way
instead of pairwise, where $n$ is the length of the list $e$. 

The feed comprehension $\comprehensionfeed{\feed_2}{x}{\feed_1}$
contains payload values $v_2$ taken from the meaning of feed $\feed_2$
when $x$ is mapped to (meta-data, payload) pairs drawn from the meaning
of feed $\feed_1$.  The dependency set for the feed
comprehension includes the dependency sets of {\em both} $\feed_1$ and
$\feed_2$. 
The filter feed $\filterfeed{\feed}{e}$ selects those
(meta-data, payload) pairs from 
the meaning of $\feed$  that satisfy the predicate $e$.
Finally, the let feed $\letfeed{x}{e}{\feed}$ returns the meaning
of feed $\feed$ when $x$ is mapped to the meaning of $e$. 

\subsection{Feed Properties}
We have used our semantics to prove two key properties of our calculus.
The first property, {\em Type Soundness}, serves as an important check
on the basic structure of our definitions:  Do the sets of values given
by the denotational semantics have the types ascribed by our typing rules?
The second property, {\em Dependency Correctness}, guarantees the semantics
adequately captures provenance meta-data.  To be more specific, it demonstrates
that a feed item depends exclusively on the locations and times mentioned
in its dependency set.  This theorem is crucial for users who need to
track down problems in their distributed system -- when they find their
incoming data is bad, they need to know exactly where (and when) to look 
to find malfunctioning equipment or software.

\paragraph*{Type Soundness.}
The type soundness theorem states that values
contained in the semantics of each feed are (meta-data, payload) pairs
with the appropriate type.  More specifically, if the feed typing
rules give feed $\feed$ type $\feedty{\sigma}$, 
then its data has type $\sigma$ and its meta data has type $\metatype{\sigma}$.
A similar statement is true of core feeds.

\begin{theorem}[Type Soundness]
\begin{itemize}
\item If $\Gamma \turn \feed : \feedty{\sigma}$ and
for all $x$ in $\dom(\Gamma)$, $\turn \environment(x) : \Gamma(x)$
and $\turn \universe : \timety * \locty \arrow \timety * (\optionty{\stringty})$
then
for all $(\meta,v) \in \semantics{\feed}{\environment}{\universe}$,
$\turn (\meta,v) : \metatype{\sigma} * \sigma$. 
\item If $\Gamma \turn \corefeed : \corety{\sigma}$ and
for all $x$ in $\dom(\Gamma)$, $\turn \environment(x) : \Gamma(x)$
and $\turn \universe : \timety * \locty \arrow \timety * (\optionty{\stringty})$
then
for all $(\meta,v) \in \csemantics{\corefeed}{\environment}{\universe}$,
$\turn (\meta,v) : \metatype{\sigma} * \sigma$. 
\end{itemize}
\end{theorem}
\noindent
We have proven the theorem by induction on the structure of $\feed$.

\paragraph*{Dependency Correctness.}  The {\em Dependency Correctness}
theorem states that feed elements depend exclusively on the times and
locations mentioned in their dependency set.  In order to make this
notion precise, we first need to define what it means for two universes
to be equal relative to a dependency set $\ds$.  Intuitively,
this definition simply states that the universes are equal at the
times and locations in $\ds$ and unconstrained elsewhere.

\begin{definition}[Equal Universes Relative to a Dependency Set]
$\ueq{\universe_1}{\ds}{\universe_2}$ if and only if for all
$(\atime,\loc) \in \ds$, $\universe_1(\atime,\loc) = \universe_2(\atime,\loc)$.
\end{definition}

\noindent
Now, we need a similar definition of feed equality.  In the following
definitions, let $S_1$, $S_2$ range over denotations of core feeds and feeds.

\begin{definition}[Feed Subset Relative to a Dependency Set]
$\fsubset{S_1}{\ds}{S_2}$ if and only if for all
$(\meta,v) \in S_1$ such that
$\myds{\meta} \subseteq \ds$, $(\meta,v) \in S_2$.
\end{definition}

\begin{definition}[Feed Equality Relative to a Dependency Set]
$\feq{S_1}{\ds}{S_2}$ if and only if 
$\fsubset{S_1}{\ds}{S_2}$ and
$\fsubset{S_2}{\ds}{S_1}$
\end{definition}

\noindent
Finally, {\em Dependency Correctness} states that if two universes
$\universe_1$ and $\universe_2$ are identical at locations and times in $\ds$
(but arbitrarily different elsewhere) then the elements of any feed $\feed$
that depend upon the locations and times in $\ds$ do not change when
$\feed$ is interpreted in universe $\universe_1$ 
as opposed to in $\universe_2$.

\begin{theorem}[Dependency Correctness]
\begin{itemize}
\item
If $\ueq{\universe_1}{\ds}{\universe_2}$ then
$\feq{\csemantics{\corefeed}{\environment}{\universe_1}}{\ds}{\csemantics{\corefeed}{\environment}{\universe_2}}$.
\item 
If $\ueq{\universe_1}{\ds}{\universe_2}$ then
$\feq{\semantics{\feed}{\environment}{\universe_1}}{\ds}{\semantics{\feed}{\environment}{\universe_2}}$.
\end{itemize}
\end{theorem}

\noindent
The proof of dependency correctness is by induction on the structure of feeds.  




