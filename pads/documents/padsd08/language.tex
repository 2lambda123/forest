\input{syntax}
Developing a formal semantics for \padsd{} has been an integral part
of our language design process.  We have used the semantics to
communicate our ideas precisely and to explore the nuances of design
decisions. Furthermore, the semantics provides users with a tool to
reason about the feeds resulting from \padsd{} descriptions, including
subtleties related to synchronization, timeouts and errors.

To express locations, times, schedules and constraints, the feed calculus
depends upon a {\em host language}, which we take to be the
simply-typed lambda calculus.  Figure~\ref{fig:host-language} presents
its syntax, which includes a collection of constants to simplify the
semantics: strings ($\astring$), times ($\atime$) and locations
($\loc$).  We assume times may be added and 
compared and we let $\infty$ represent a time later than all others.
We assume that the set of locations includes the constant
$\generatedloc{}$, indicating the associated data was computed rather
than fetched.
We treat schedules as sets of times and use the notation $\atime
\in \schedule$ to refer to a time $\atime$ drawn from the set
$\schedule$.  We use a similar notation to refer to elements of a
list.  The host language also includes standard structured types such as
options, pairs, sums, lists and functions.
We omit the typing annotations from lambda expressions when they can
be reconstructed from the context.


\subsection{Feed Syntax and Typing}
The abstract syntax for our feed calculus and its typing rules appear
in Figures~\ref{fig:syntax} and~\ref{fig:typing}, respectively.  
The feed typing judgment has the form 
$\Gamma \turn \feed : \feedty{\sigma}$, 
which means that in the context $\Gamma$ mapping variables to host
language types $\tau$, $\feed$ is a feed of $\sigma$ values. 
The core typing judgment, which has the form 
$\Gamma \turn \corefeed{} : \corety{\sigma}$, conveys the same
information for core feeds.

Intuitively, a feed carrying values of type $\sigma$ is a sequence of
payload values of type $\sigma$.  However, to record provenance
information, we pair each payload value with meta-data, so a feed is
actually a sequence of (meta-data, payload) pairs.  At the top-level,
meta-data consists of a triple of the scheduled time for the payload,
a \textit{dependency set} that records the origin and scheduled time of any data
that contributed to the payload, and a nested meta-data field whose
form depends upon the type of the payload.

Formally, we let 
$\meta$ range over top-level meta-data,
$\ds$ range over dependency sets, and 
$\nested$ range over ``nested'' meta-data:
\[
\begin{array}{lcll} 
\meta & ::= & (\atime,\ds,\nested) & \mbox{top-level meta-data} \\  
\\
\ds   & ::= & \{(\atime_1,\loc_1),\ldots,(\atime_n, \loc_n) \}  & \mbox{dependency set}\\ 
\\
\nested & ::=     
          & (\atime,\loc,\mathtt{None}) & \mbox{base meta-data (timeout)} \\
& \bnfalt & (\atime,\loc,\mathtt{Some}\; \atime) & \mbox{base meta-data (success)} \\
& \bnfalt & (\nested_1,\nested_2) & \mbox{pair meta-data} \\
& \bnfalt & \inl{\nested} & \mbox{sum meta-data} \\
& \bnfalt & \inr{\nested} & \mbox{sum meta-data} \\
& \bnfalt & [\nested_1,\ldots,\nested_k] & \mbox{list meta-data} \\
\end{array}
\] 
Given meta-data $\meta$, we write $\mytime{\meta}$, $\myds{\meta}$ and
$\myval{\meta}$ for the first, second and third projections (respectively) of $\meta$.
Base meta-data is a triple of the scheduled time, the location of origin 
and an optional arrival time where {\tt None} indicates the data did not arrive
in a timely fashion.

As shown in \figref{fig:syntax}, we define the feed payload type
$\sigma$ in terms of host 
language types, stratified to facilitate the proof of
semantic soundness.  
We use the function $\metatype{\sigma}$ to define the type of
meta-data associated with payload of type $\sigma$:
\[
\begin {array} {lcl}
\nestedtype{\ty} & = & \timety * \locty * (\optionty{\timety}) \\
\nestedtype{\optionty{\ty}} & = & \timety * \locty * (\optionty{\timety}) \\
\nestedtype{\sigma_1 * \sigma_2} & = & \nestedtype{\sigma_1} * \nestedtype{\sigma_2} \\
\nestedtype{\sigma_1 + \sigma_2} & = & \nestedtype{\sigma_1} + \nestedtype{\sigma_2} \\
\nestedtype{\listty{\sigma}} & = & \listty{\nestedtype{\sigma}} \\
\\
\metatype{\sigma} & = & \timety * \dsty * \nestedtype{\sigma} \\
\end{array}
\]
Feed typing depends upon a standard judgment for
typing lambda calculus expressions: $\Gamma \turn e : \ty$.  

With these preliminaries, we can now discuss the syntax and typing for
each feed construct in \figref{fig:syntax} in turn. 
Core feeds express the structure of base feeds, describing
the data sources ($\mathtt{src}$), schedule ($\mathtt{sched}$), window
($\mathtt{win}$), preprocessing function ($\mathtt{pp}$), and file
format ($\mathtt{format}$).  The source field may contain
pseudo-locations that model the $\mathtt{proc}$ form found in the
implementation.  Instead of expressing time-out conditions in the
schedule as we did in the source language, the calculus requires such
conditions be specified separately in the window field, which simplifies
the semantics.  The preprocessor and the format parser both map values
with option type to option type, where the value \texttt{None}
indicates a networking or data formatting error. (For the sake of
simplicity, we do not model the variety of error codes that the
implementation supports.)  Consequently, if a core feed intuitively
describes values of type $\sigma$, the feed will actually return a
sequence of values of type $\optionty{\sigma}$, allowing for the
possibility of errors.  

The feed $\mathtt{all}\ \corefeed$ selects all the data from the core
feed \corefeed, while $\mathtt{any}\ \corefeed$ selects the first
good value to arrive for each time in the schedule for \corefeed{}.
It returns a \texttt{None} paired with appropriate meta-data if no
such value exists.   

The empty feed ($\emptyset$) contains no elements and has polymorphic
type a l\`a the empty list.  The singleton feed $\onefeed{e_v}{e_t}$
constructs a feed containing a single value $e_v$ at a single time
$e_t$.  The schedule feed $\sfeed{e}$ builds a stream of
time values, one for each time on the schedule $e$.
The union feed merges two feeds with the same type
into a single feed.  In contrast, the sum feed takes two feeds
with (possibly) different types and injects the elements of each feed
into a sum before merging the results into a single feed.  
The pair feed, written $(\feed_1, \feed_2)$, combines elements from
the two nested feeds synchronously.  
The list feed $[\feed \bnfalt x \leftarrow e ]$, in contrast, provides
$n$-way synchronization, where $n$ is the length of the input list
$e$.  Each element $e_i$ in $e$ defines a feed $\feed_i = \feed[x \mapsto e_i]$.
The list feed returns lists of elements, one element from each
$\feed_i$, synchronized on the scheduled time.  The feed comprehension
$\comprehensionfeed{\feed_2}{x}{\feed_1}$ computes a feed $\feed_2$
for each entry $x$ in the source feed $\feed_1$.




The computed feed ($\computed{e_1}{x}{e_2}$) allows programmers to
generate a feed with schedule $e_2$ and elements $(\lambda x.e_1)\; \atime$,
where $\atime$ is drawn from the schedule. Likewise, the feed 
comprehension ($\comprehensionfeed{e}{x}{\feed}$) creates a
feed with elements $(\lambda x.e)\; v$ when $v$ is an element of $\feed$.
The feed
$\filterfeed{\feed}{e}$ eliminates elements $v$ from $\feed$ when
$e\; v$ is $\boolf$.  Let feeds $\letfeed{x}{e_1}{\feed_2}$
provide a convenient mechanism for binding intermediate values. 

\input{typing}


The calculus also contains three different
pair constructors, each providing a different way to
combine elements from the subcomponent feeds.  The first pair, 
written $(\feed_1, \feed_2)$, is a {\em synchronous pair}.
Elements of $\feed_1$ are paired with elements of $\feed_2$
that are {\em scheduled} at exactly the same time, regardless of when those elements
actually {\em arrive}.  Synchronous pairs are most useful when the underlying
subcomponent feeds share the same schedule, as in the Arrakis example
from Section~\ref{sec:informal}.  Synchronous pairs lack a
dependent variant, however, because in our domain it is not sensible
to schedule the acquisition of an element that depends upon another
element scheduled at the same time.  To express dependencies, we 
use two forms of dependent pair, {\em continuous} and {\em local}.
In the continuous variant, each element $x$ of $\feed_1$ is paired 
with all elements of the feed $\feed_2$ that depend on $x$.  In the
local variant, each element $x$ of $\feed_1$
is paired with all elements of the feed $\feed_2$ {\em until the next
element $y$ of $\feed_1$ is scheduled}.  
The denotational semantics, presented
in the next subsection, makes this idea precise.  Local pairing
enables a paradigm in which programmers define an infinite feed $\feed_2$
that gets truncated and regenerated whenever a new element in $\feed_1$
is scheduled.


The final elements of the calculus include the $\mathtt{foreach}$ feeds
and the list comprehension feed.
Intuitively, a $\mathtt{foreach}$ is identical to a dependent pair in
which the first element of the pair is omitted from the data representation.
Consequently, there are two forms of $\mathtt{foreach}$ -- one for
each form of dependent pair.  The notation ${*}$ or ${**}$ serves as
a syntactic mnemonic for the connection.  The list comprehension
feed generates a feed of lists where each element of the list is
scheduled at the same time.  It is akin to the synchronous pair
operation. 


%\input{semantics1}

\input{semantics2}

\subsection{Feed Semantics}
We give the semantics of our formal feed language in 
a denotational style.  The principal semantic functions are
$\csemantics{\corefeed}{\environment}{\universe}$ and
$\semantics{\feed}{\environment}{\universe}$, defining core feeds and
feeds, respectively.  In these definitions,
$\environment$ is an {\em environment} mapping variables to values
and $\universe$ is a {\em universe} mapping pairs of
schedule time and location to arrival time and a string option
representing the actual data.
Intuitively, the universe models the network.
When $\universe (\atime_1, \ell) = (\atime_2, \mathtt{Some} \; \astring)$,
 the interpretation is that if the run-time system requests data
from location $\ell$ at time $\atime_1$ then string data $\astring$
will be returned at time $\atime_2$.  The time $\atime_2$ must be
no earlier than $\atime_1$.
When $\universe (\atime_1, \ell) = (\infty, \mathtt{None})$,
networking errors have made location $\ell$ unreachable.

The semantic functions yield a set of meta-data/data pairs, where the 
meta-data is coded as follows.
\textbf{begin new}

\textbf{end new}
%   The meta-data 
% we model is somewhat simplified relative to the implementation.
% The meta-data for base feeds includes both the scheduled time of the
% associated data item and its location of origin -- such 
% information is also often referred to as the data's 
% {\em provenance}~\cite{provenancestuff}.  As shown
% below, the meta-data for pair 
% and sum feeds is structured similarly to the data items themselves.  
%
\[
\begin{array}{lcll} 
\meta & ::=     
& (\atime,\loc) & \mbox{base meta-data} \\
& \bnfalt & (\atime,(\meta_1,\meta_2)) & \mbox{pair meta-data} \\
& \bnfalt & (\atime,\inl{\meta}) & \mbox{sum meta-data} \\
& \bnfalt & (\atime,\inr{\meta}) & \mbox{sum meta-data} \\
& \bnfalt & (\atime,[\meta_1,\ldots,\meta_k]) & \mbox{list meta-data} \\
\end{array}
\]  
%
Since every meta-data item contains a top-level time $\atime$, that
time can be used to serialize the set of items as a stream, and 
our implementation does just that.  Items scheduled at the
same time may appear in any order in the implementation's
serialized stream.  To refer to the top-level time in any meta-data
item $\meta$, we write $\mytime{\meta}$. 

Figure~\ref{fig:semantics} presents the semantic definitions for ${\cal
  C}$ and ${\cal F}$, using conventional set-theoretic notations.
The semantics depends upon a semantics for the simply-typed host
language, written $\esemantics{e}{\environment}$, whose definition we
omit. We assume that given environment $\environment$ with type
$\Gamma$ and expression $e$ with type $\tau$ in $\Gamma$,
$\esemantics{e}{\environment} = v$ and $\turn v : \tau$.

The meaning of core feed \corefeed{} is a pair consisting of the
meaning of the schedule of \corefeed{} (written $S$) and the set of
meta-data/data pairs for the feed. To calculate this data, the
\texttt{timeout} function checks whether the item arrival time
$x_{at}$ is within the window ($\esemantics{e_{win}}{\environment}$)
of the scheduled time ($x_t \in S$), returning \texttt{None} if
not. Otherwise, \texttt{timeout} returns its data argument ($x_s$),
which may be {\tt None} because of other networking errors.  Using the
\texttt{timeout} function, we define an alternate universe
$\universe'$ that retrieves data from the outside world, checks for a
timeout, and applies the preprocessor
($\esemantics{e_{pp}}{\environment}$) before returning.  The feed data
is then pairs of base meta-data $(\atime,\ell)$ with data defined by
$\esemantics{e_{f} \; (\universe'(\loc,\atime))}{\environment}$ where
$e_f$ is the \pads{}-generated parser.



The semantics of both the $\mathtt{all}\ \corefeed$ and the
$\mathtt{any}\ \corefeed$ feeds first computes the meaning $(S,A)$ of the
core feed $\corefeed{}$.  The \texttt{all} feed simply returns the
data component $A$.  The \texttt{any} feed returns a set with one
element for each time $\atime$ in the schedule $S$.  If the data $A$
contains at least one good value at time $t$, the \texttt{any} feed
picks the earliest arriving member of this set, using the function
$\selectOne{}$.  Otherwise, the feed adds  
error value $((\atime,\generatedloc), \none)$ for $\atime$.

The meaning of the empty feed is the empty set.  Computed feeds yield
one value per time in the given schedule.  The dummy location
($\generatedloc$) in the computed feed meta-data indicates the value had no physical
source.  Feed comprehensions also use the dummy location.  The filter feed and feed
comprehensions together model the full power of the feed
comprehensions found in our implementation. The semantics for
\texttt{let}, union and sum feeds are all straightforward.  The union
feed is simply the set-theorectic union of its constituent feeds.  The
sum feed injects the elements of its constituent feeds into a sum and
likewise takes their union.

We must take more care when defining the semantics of pairs.  The
synchronous pair $(\feed_1,\feed_2)$ is formed by finding all elements
of $\feed_1$ at a given time (including erroneous elements) and all
elements of $\feed_2$ at that time (again including erroneous
elements) and generating their Cartesian product.  Notice that if
the schedules do not intersect, a synchronous pair will empty.
%Meta-Data from constituent feeds is paired together.
The scheduled time of the composite item is the same as the scheduled
times of the two underlying feeds. 

The elements of the continuous dependent pair ($x{:}\feed_1 *
\feed_2$) are calculated by first determining the elements of
$\feed_1$.  For each element $v$ in $\feed_1$, we calculate the
elements of $\feed_2$ by binding $x$ to $v$ in $\feed_2$'s definition.
The elements of the composite feed include all elements $x$ of
$\feed_1$ paired with the corresponding elements of $\feed_2$
scheduled later than $x$.  As with synchronous pairs, we pair the
meta-data from the constituent feeds in the composite feed. Unlike 
synchronous pairs, the two elements of the pair
do not share a schedule time.  We adopt the later time ({\em
  i.e.,} the time of the element from $\feed_2$) as the schedule time
for the composite feed element.

Continuous and local dependent pairs differ in that local dependent
pairs suppress further data dependent upon item $v_1$ from $\feed_1$
when the next item $v_1'$ from feed $\feed_1$ arrives.  In the
semantics, the existence of another element $(\meta_1',v_1')$
in $\feed_1$ after $(\meta_1,v_1)$ implies that the 
schedule time for the item under consideration in $\feed_2$ ($v_2$) 
must fall between the schedule times for $v_1$ and $v_1'$
(otherwise $v_2$ is not included in the final composite feed). 

The semantics for the two variants of $\mathtt{foreach}$ are defined
in terms of the two variants of dependent pairs, simply dropping the
first component of each item in the pair feed in both cases.  The semantics
of the list comprehension feed extends the semantics of synchronous
pairs to lists: each list in the resulting feed contains the elements
of the generated list with the same scheduled time.

We have proven a soundness theorem for the semantics: the values
contained in each feed are pairs of meta-data and data 
values with the appropriate type.  More specifically, if the feed typing
rules give feed $\feed$ type $\feedty{\sigma}$, 
then its data has type $\sigma$ and
its meta data has type $\metatype{\sigma}$ where $\metatype{\sigma}$ is
defined as follows.
\[
\begin {array} {lcl}
\metatype{\ty} & = & \timety * \locty \\
\metatype{\optionty{\ty}} & = & \timety * \locty \\
\metatype{\sigma_1 * \sigma_2} & = & \timety * (\metatype{\sigma_1} * \metatype{\sigma_2}) \\
\metatype{\sigma_1 + \sigma_2} & = & \timety * (\metatype{\sigma_1} + \metatype{\sigma_2}) \\
\metatype{\listty{\sigma}} & = & \timety * (\listty{\metatype{\sigma}}) \\
\end{array}
\]
%We state this property formally as follows.
\begin{theorem}[Semantic Soundness]
If $\Gamma \turn \feed : \feedty{\sigma}$ and
for all $x$ in $\dom(\Gamma)$, $\turn \environment(x) : \Gamma(x)$
and $\turn \universe : \timety * \locty \arrow \timety * (\optionty{\stringty})$
then
for all $(\meta,v) \in \semantics{\feed}{\environment}{\universe}$,
$\turn (\meta,v) : \metatype{\sigma} * \sigma$. 
\end{theorem}
The proof follows by induction on the structure of $\feed$.

\begin{definition}[Equal Universes Relative to a Dependency Set]
$\ueq{\universe_1}{\ds}{\universe_2}$ if and only if for all
$(\atime,\loc) \in \ds$, $\universe_1(\atime,\loc) = \universe_2(\atime,\loc)$.
\end{definition}

Let $S_1$, $S_2$ range over denotations of feeds.

\begin{definition}[Feed Subset Relative to a Dependency Set]
$\fsubset{S_1}{\ds}{S_2}$ if and only if for all
$(\meta,v) \in S_1$ such that
$\myds{\meta} \subseteq \ds$, $(\meta,v) \in S_2$.
\end{definition}

\begin{definition}[Feed Equality Relative to a Dependency Set]
$\feq{S_1}{\ds}{S_2}$ if and only if 
$\fsubset{S_1}{\ds}{S_2}$ and
$\fsubset{S_2}{\ds}{S_1}$
\end{definition}

\begin{theorem}[Dependency Correctness]
If $\ueq{\universe_1}{\ds}{\universe_2}$ then
$\feq{\semantics{\feed}{\environment}{\universe_1}}{\ds}{\semantics{\feed}{\environment}{\universe_2}}$
\end{theorem}

The proof of dependency correctness is by induction on the structure of feeds.  I
checked out a couple of cases to see how the proof goes and it seemed plausible to
me that I would be able to prove it completely.   
Then I fleshed out all the rules.  I need to proof-read the rules and then go back
and do the full proof start-to-finish.  However, the proof could definitely
fail for the cases of pairs and lists -- I think those cases will need to be revised,
but as of writing this note (1pm feb 19) I haven't had a chance to go back.  





