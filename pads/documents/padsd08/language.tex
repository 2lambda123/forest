
\input{syntax}


Developing a formal semantics for \padsd{} has been an
integral part of our language design process.  We have used the semantics to
communicate our ideas precisely and to explore the nuances of design
decisions. Furthermore, the semantics provides users with a tool to reason about the feeds
resulting from \padsd{} descriptions, including subtleties related to
synchronization, timeouts and errors.

To express locations, schedules, and constraints, the feed calculus
depends upon a {\em host language}, which we take to be the
simply-typed lambda calculus.  Figure~\ref{fig:host-language} presents
its syntax, which includes a collection of constants to simplify the
semantics: strings ($\astring$), locations ($\loc$), times ($\atime$),
and schedules ($\schedule$).  We assume times may be added and
compared and we let $\infty$ represent a time later than all others.
We treat schedules as sets of times and use the notation $\atime
\in \schedule$ to refer to a time $\atime$ drawn from the set
$\schedule$.  We use a similar notation to refer to elements of a
list.  The host language also includes standard structured types such as
options, pairs, sums, lists and functions.
We omit the typing annotations from lambda expressions when they can
be reconstructed from the context.


\subsection{Feed Syntax and Typing}

The abstract syntax for our feed calculus and its typing rules appear
in Figures~\ref{fig:syntax} and~\ref{fig:typing}, respectively.  The
feed typing judgment has the form $\Gamma \turn \feed :
\feedty{\sigma}$, which means that in context $\Gamma$ mapping
variables to host language types $\tau$, feed $\feed$ produces a
sequence of values of type $\sigma$.  As shown in \figref{fig:syntax},
we define $\sigma$ in terms of host language types, stratified to
facilitate the proof of semantic soundness.  Feed typing depends upon
a standard judgment for simply typing lambda calculus expressions:
$\Gamma \turn e : \ty$.  We discuss the syntax and typing for each
construct in turn.



Core feeds express the underlying structure of base feeds, describing
the data sources ($\mathtt{src}$), schedule ($\mathtt{sched}$), window
($\mathtt{win}$), preprocessing function ($\mathtt{pp}$), and file
format ($\mathtt{format}$).  The source field may contain
pseudo-locations that model the $\mathtt{proc}$ form found in the
implementation.  Instead of expressing time-out conditions in the
schedule as we did in the source language, the calculus requires such
conditions be specified in the window field, which slightly simplifies
the semantics.  The preprocessor and the format parser both map values
with option type to option type, where the value \texttt{None}
indicates a networking or data formatting error. (For the sake of
simplicity, we do not model the variety of error codes that the
implementation supports.)  Consequently, if the format intuitively
describes values of type $\tau$, the feed will return a sequence of
values of type $\optionty{\tau}$, allowing for the possibility of
errors.  The typing for core feeds reflects our choice to have their
semantics be a pair of the underlying schedule and the actual feed
elements.

The feed $\mathtt{all}\ \corefeed$ selects all the data from the core
feed \corefeed, while $\mathtt{any}\ \corefeed$ selects a
representative good value for each time in the schedule for \corefeed{}.
It inserts a \texttt{None} if no such value exists.  


The empty feed ($\emptyset$) contains no elements and has polymorphic
type a l\`a the empty list.  
The computed feed ($\computed{e_1}{x}{e_2}$) allows programmers to
generate a feed with schedule $e_2$ and elements $(\lambda x.e_1)\; \atime$,
where $\atime$ is drawn from the schedule. Likewise, the feed 
comprehension ($\comprehensionfeed{e}{x}{\feed}$) creates a
feed with elements $(\lambda x.e)\; v$ when $v$ is an element of $\feed$.
The feed
$\filterfeed{\feed}{e}$ eliminates elements $v$ from $\feed$ when
$e\; v$ is $\boolf$.  Let feeds $\letfeed{x}{e_1}{\feed_2}$
provide a convenient mechanism for binding intermediate values.
The union feed merges two feeds with the same type
into a single feed.  In contrast, the sum feed takes two feeds
with (possibly) different types and injects the elements of each feed
into a sum before merging the results into a single feed.  

\input{typing}


The calculus also contains three different
pair constructors, each providing a different way to
combine elements from the subcomponent feeds.  The first pair, 
written $(\feed_1, \feed_2)$, is a {\em synchronous pair}.
Elements of $\feed_1$ are paired with elements of $\feed_2$
that are {\em scheduled} at exactly the same time, regardless of when those elements
actually {\em arrive}.  Synchronous pairs are most useful when the underlying
subcomponent feeds share the same schedule, as in the Arrakis example
from Section~\ref{sec:informal}.  Synchronous pairs lack a
dependent variant, however, because in our domain it is not sensible
to schedule the acquisition of an element that depends upon another
element scheduled at the same time.  To express dependencies, we 
use two forms of dependent pair, {\em continuous} and {\em local}.
In the continuous variant, each element $x$ of $\feed_1$ is paired 
with all elements of the feed $\feed_2$ that depend on $x$.  In the
local variant, each element $x$ of $\feed_1$
is paired with all elements of the feed $\feed_2$ {\em until the next
element $y$ of $\feed_1$ is scheduled}.  
The denotational semantics, presented
in the next subsection, makes this idea precise.  Local pairing
enables a paradigm in which programmers define an infinite feed $\feed_2$
that gets truncated and regenerated whenever a new element in $\feed_1$
is scheduled.


The final elements of the calculus include the $\mathtt{foreach}$ feeds
and the list comprehension feed.
Intuitively, a $\mathtt{foreach}$ is identical to a dependent pair in
which the first element of the pair is omitted from the data representation.
Consequently, there are two forms of $\mathtt{foreach}$ -- one for
each form of dependent pair.  The notation ${*}$ or ${**}$ serves as
a syntactic mnemonic for the connection.  The list comprehension
feed generates a feed of lists where each element of the list is
scheduled at the same time.  It is akin to the synchronous pair
operation. 


%\input{semantics1}

\input{semantics2}

\subsection{Feed Semantics}
We give the semantics of our formal feed language in 
a denotational style.  The principal semantic functions are
$\csemantics{\corefeed}{\environment}{\universe}$ and
$\semantics{\feed}{\environment}{\universe}$, defining core feeds and
feeds, respectively.  In these definitions,
$\environment$ is an {\em environment} mapping variables to values
and $\universe$ is a {\em universe} mapping pairs of
schedule time and location to arrival time and a string option
representing the actual data.
Intuitively, the universe models the network.
When $\universe (\atime_1, \ell) = (\atime_2, \mathtt{Some} \; \astring)$,
 the interpretation is that if the run-time system requests data
from location $\ell$ at time $\atime_1$ then string data $\astring$
will be returned at time $\atime_2$.  The time $\atime_2$ must be
no earlier than $\atime_1$.
When $\universe (\atime_1, \ell) = (\infty, \mathtt{None})$,
networking errors have made location $\ell$ unreachable.

The semantic functions yield a set of metadata/data pairs, where the 
metadata is coded as follows.
%   The metadata 
% we model is somewhat simplified relative to the implementation.
% The metadata for base feeds includes both the scheduled time of the
% associated data item and its location of origin -- such 
% information is also often referred to as the data's 
% {\em provenance}~\cite{provenancestuff}.  As shown
% below, the metadata for pair 
% and sum feeds is structured similarly to the data items themselves.  
%
\[
\begin{array}{lcll} 
\meta & ::=     
& (\atime,\loc) & \mbox{base metadata} \\
& \bnfalt & (\atime,(\meta_1,\meta_2)) & \mbox{pair metadata} \\
& \bnfalt & (\atime,\inl{\meta}) & \mbox{sum metadata} \\
& \bnfalt & (\atime,\inr{\meta}) & \mbox{sum metadata} \\
& \bnfalt & (\atime,[\meta_1,\ldots,\meta_k]) & \mbox{list metadata} \\
\end{array}
\]  
%
Since every metadata item contains a top-level time $\atime$, that
time can be used to serialize the set of items as a stream, and 
our implementation does just that.  Items scheduled at the
same time may appear in any order in the implementation's
serialized stream.  To refer to the top-level time in any metadata
item $\meta$, we write $\mytime{\meta}$. 

Figure~\ref{fig:semantics} presents the semantic definitions for ${\cal
  C}$ and ${\cal F}$, using conventional set-theoretic notations.
The semantics depends upon a semantics for the simply-typed host
language, written $\esemantics{e}{\environment}$, whose definition we
omit. We assume that given environment $\environment$ with type
$\Gamma$ and expression $e$ with type $\tau$ in $\Gamma$,
$\esemantics{e}{\environment} = v$ and $\turn v : \tau$.

The meaning of core feed \corefeed{} is a pair consisting of the
meaning of the schedule of \corefeed{} (written $S$) and the set of
metadata/data pairs for the feed. To calculate this data, the
\texttt{timeout} function checks whether the item arrival time
$x_{at}$ is within the window ($\esemantics{e_{win}}{\environment}$)
of the scheduled time ($x_t \in S$), returning \texttt{None} if
not. Otherwise, \texttt{timeout} returns its data argument ($x_s$),
which may be {\tt None} because of other networking errors.  Using the
\texttt{timeout} function, we define an alternate universe
$\universe'$ that retrieves data from the outside world, checks for a
timeout, and applies the preprocessor
($\esemantics{e_{pp}}{\environment}$) before returning.  The feed data
is then pairs of base metadata $(\atime,\ell)$ with data defined by
$\esemantics{e_{f} \; (\universe'(\loc,\atime))}{\environment}$ where
$e_f$ is the \pads{}-generated parser.



The semantics of both the $\mathtt{all}\ \corefeed$ and the
$\mathtt{any}\ \corefeed$ feeds first computes the meaning $(S,A)$ of the
core feed $\corefeed{}$.  The \texttt{all} feed simply returns the
data component $A$.  The \texttt{any} feed returns a set with one
element for each time $\atime$ in the schedule $S$.  If the data $A$
contains at least one good value at time $t$, the \texttt{any} feed
picks the earliest arriving member of this set, using the function
$\selectOne{}$.  Otherwise, the feed adds  
error value $((\atime,\generatedloc), \none)$ for $\atime$.

The meaning of the empty feed is the empty set.  Computed feeds yield
one value per time in the given schedule.  The dummy location
($\generatedloc$) in the computed feed metadata indicates the value had no physical
source.  Feed comprehensions also use the dummy location.  The filter feed and feed
comprehensions together model the full power of the feed
comprehensions found in our implementation. The semantics for
\texttt{let}, union and sum feeds are all straightforward.  The union
feed is simply the set-theorectic union of its constituent feeds.  The
sum feed injects the elements of its constituent feeds into a sum and
likewise takes their union.

We must take more care when defining the semantics of pairs.  The
synchronous pair $(\feed_1,\feed_2)$ is formed by finding all elements
of $\feed_1$ at a given time (including erroneous elements) and all
elements of $\feed_2$ at that time (again including erroneous
elements) and generating their Cartesian product.  Notice that if
the schedules do not intersect, a synchronous pair will empty.
%Metadata from constituent feeds is paired together.
The scheduled time of the composite item is the same as the scheduled
times of the two underlying feeds. 

The elements of the continuous dependent pair ($x{:}\feed_1 *
\feed_2$) are calculated by first determining the elements of
$\feed_1$.  For each element $v$ in $\feed_1$, we calculate the
elements of $\feed_2$ by binding $x$ to $v$ in $\feed_2$'s definition.
The elements of the composite feed include all elements $x$ of
$\feed_1$ paired with the corresponding elements of $\feed_2$
scheduled later than $x$.  As with synchronous pairs, we pair the
metadata from the constituent feeds in the composite feed. Unlike 
synchronous pairs, the two elements of the pair
do not share a schedule time.  We adopt the later time ({\em
  i.e.,} the time of the element from $\feed_2$) as the schedule time
for the composite feed element.

Continuous and local dependent pairs differ in that local dependent
pairs suppress further data dependent upon item $v_1$ from $\feed_1$
when the next item $v_1'$ from feed $\feed_1$ arrives.  In the
semantics, the existence of another element $(\meta_1',v_1')$
in $\feed_1$ after $(\meta_1,v_1)$ implies that the 
schedule time for the item under consideration in $\feed_2$ ($v_2$) 
must fall between the schedule times for $v_1$ and $v_1'$
(otherwise $v_2$ is not included in the final composite feed). 

The semantics for the two variants of $\mathtt{foreach}$ are defined
in terms of the two variants of dependent pairs, simply dropping the
first component of each item in the pair feed in both cases.  The semantics
of the list comprehension feed extends the semantics of synchronous
pairs to lists: each list in the resulting feed contains the elements
of the generated list with the same scheduled time.

We have proven a soundness theorem for the semantics: the values
contained in each feed are pairs of meta-data and data 
values with the appropriate type.  More specifically, if the feed typing
rules give feed $\feed$ type $\feedty{\sigma}$, 
then its data has type $\sigma$ and
its meta data has type $\metatype{\sigma}$ where $\metatype{\sigma}$ is
defined as follows.
\[
\begin {array} {lcl}
\metatype{\ty} & = & \timety * \locty \\
\metatype{\optionty{\ty}} & = & \timety * \locty \\
\metatype{\sigma_1 * \sigma_2} & = & \timety * (\metatype{\sigma_1} * \metatype{\sigma_2}) \\
\metatype{\sigma_1 + \sigma_2} & = & \timety * (\metatype{\sigma_1} + \metatype{\sigma_2}) \\
\metatype{\listty{\sigma}} & = & \timety * (\listty{\metatype{\sigma}}) \\
\end{array}
\]
%We state this property formally as follows.
\begin{theorem}[Semantic Soundness]
If $\Gamma \turn \feed : \feedty{\sigma}$ and
for all $x$ in $\dom(\Gamma)$, $\turn \environment(x) : \Gamma(x)$
and $\turn \universe : \timety * \locty \arrow \timety * (\optionty{\stringty})$
then
for all $(\meta,v) \in \semantics{\feed}{\environment}{\universe}$,
$\turn (\meta,v) : \metatype{\sigma} * \sigma$. 
\end{theorem}
The proof follows by induction on the structure of $\feed$.




