In this section, we describe two examples that we will use throughout
the paper to motivate and explain our system.

AT\&T provides a web hosting service.  AT\&T's infrastructure for this
service includes a variety of components including routers, firewalls,
load balanacing machines, actual web servers, and databases,
replicated and geographically distributed.  Hence, a given web site
may be distributed across a variety of machines running a variety of
operating systems in a variety of locations.  When a customer signs up
for AT\&T's hosting service, part of the contract specifies what kinds
of monitoring AT\&T will provide for site.  The monitoring includes a
variety of resources, including network bandwidth, packet loss, cpu
utilization, disk utlization, memory usage, load averages, \etc{} For
each machine in the hosting service and each such resource, the
monitoring system archives the values at regular intervals and issues
alerts when the values exceed resource- and contract-specific levels.
The archive is used to track long-term behavior of the service,
allowing engineers to determine when more resources need to be
provisioned, for example, adding additional cpus, memory, or disk
space.  It also allows engineers to understand the ``normal'' behavior
for a particular site such as daily or seasonal cycles for a
particular site. 




%% Notes on the visgems example.
%smaug:/fs/swift/proj/vg/4yitzhak
% inventory file:
% labems-test-inv.txt
%    for each asset, defines its type: linux, ip address, password
%    url1, url2, ip,
%    systype(url,url-win,win32.i386,vmware, solaris.sun4,linux.i386,cisco,cisco3750, alteonsw, alteon,...), 
%    user, password, 
%    snmpcommunity(public,CompuLert,monitor, MT1HostingMgmt!,R1cd4Win+g1A, private), 
%    sysfunc(client,ems), 
%    servicelevel(os,man,mon,soss), 
%    need_tags(eastcoast), nets(ip/port), weight (1000,300),
%    ticketmodel(keep)
%    realid(esxhost-122)
%    scopeinv_port22(22), scopeinv_port443(443), scopeinv_port80(80)
%    implappend_protSNMP(version=1)
% class file:
% parameter.txt
%    for each asset, what type of info to collect and how
%    including what kind of scope machine (windows, linux) to use
%    bindings from inventory file are in scope in single brackets
%    what are double brackets: [[scopeinv_cpu]]?
%       the single brackets mean if there's an inventory entry with
%       that key, find it and replace the thing in brackets with the
%       value. if there's no entry, abort processing that metric
%       rule. the double brackets are similar except that the thing in
%       brackets is assumed to be a prefix. so in the above, the tool
%       searches the inventory for entries with key == scopeinv_cpu*
%       and for each one found, it generates a metric collection entry
%       in the schedule. this is how monitoring of multiple
%       filesystems, or multiple cpus is implemented. the scopes query
%       the assets and collect info about filesystems, and cpus which
%       are sent back to the main server that adds them to the
%       inventory. 
%          scopeinv_cpu
%          scopeinv_fs
%          scopeinv_iface
%          scopeinv_port

%    what are counts: count=10, count=5?
%       these are collection type specific. for example, in PING
%       rules, it means send 5 packets.  in calls to vmstat / mpstat /
%       etc, means collect 5 samples. 


%    what are inst parameters (inst=_total), etc
%       inst goes with the 'var' attribute: var=cpu_used and inst=0
%       would collect data for cpu usage on cpu #0 and return it as
%       metric: cpu_used.0 

%    what are labels used for?
%      CPU Used ([[scopeinv_cpu!All]])
%      CPU System
%      CPU User
%      Number of Threads
%      Pages In
%      Pages Out
%      Run Queue
%      Swap In
%      Swap Out
%      Used Memory
%      they are used for tools like WMI where it's simpler to override
%      the label of the returned stats instead of generating them on
%      the scope. 


%    what are val fields
%       val=* */%v *
%       collection specific, in this case it's a regular expression
%       that means the value is the text after a '/' and before a
%       space. 

%    What are file fields
%       file=loadavg
%       file=vmstat
%       file=stat
%       collection specific, in this case it tells the tool to look for /proc/loadavg etc

%    what are exclude fields?
%       exclude=*:top
%       collection specific, in this case it tells the top tool to not
%       include itself in the top process discovery. 


%    pipe separated
%    servicelevel: man, os, soss, mon, colo
%       monitor fewer things for less expensive levels of support
%    asset machine type: linux.i386
%    scope machine type: linux.i386
%    collected info
%       ping_loss (_main)
%       ping_time (_main)
%       cpu_free
%       cpu_sys
%       cpu_used
%       cpu_usr
%       cpu_wait
%       fs_used
%       memory_free (_total)
%       memory_total (_total)
%       memory_used (_total)
%       os_loadavg (_main)
%       os_nproc (_total)
%       os_nthread (_total)
%       os_nuser (_total)
%       os_pagein (_total)
%       os_pageout (_total)
%       os_runqueue (_total)
%       os_swapin (_total)
%       os_swapout (_total)
%       proc_topcpu (1)
%       swap_free (_total)
%       swap_total (_total)
%       swap_used (_total)
%       tcpip_inpkt
%       tcpip_outpkt
%       tcpip_inerrpkt
%       tcpip_outerrpkt
%       url_avail (_main)
%       url_time (_main)
%       port_avail
%       port_time
%       log.hardware
%       log.console
%       log.application
%       log.system
%       host_cpuused,....
%       pool_cpumax,...
%       guest_numvcpu,...
%       collection

%       any instance starting with '_' is meant to be special, as in
%       'overall' or 'main' metric instance. so you may have
%       cpu_used.0, cpu_used.1, ..., for each cpu and also
%       cpu_used._total that is the average of the individual ones.


%    y/n
%       the y/n is a boolean that says to report or not report the
%       stat value back to the server. you'd set it to 'n' when the
%       metric is't important, but you either need it to generate
%       another metric (using the CALC methods), or to generate an
%       alarm. for example, for network interfaces, we don't really
%       care to chart the in/out errors and discards since they are
%       usually 0. but we still monitor them and when errors do occur
%       we create an alarm. 

%    command: 
%      what is distinction between raw, cooked, and embedded?
%         - raw means run a simple command and return the output,
%         e.g. collect SNMP oid .a.b.c.d and return its value.
%         - cooked means runs a more elaborate tool that interacts with
%         the remote side. for example, most SSH collections are like
%         that because they run either multiple commands or need to
%         parse the results and perform calculations. 
%         - embedded is similar to cooked except that the remote end
%         is assumed to not be a full POSIX shell environment, so the
%         mechanism for collection needs to be a little
%         different. this happens for network switches that support a
%         limited shell type environment. 

%      PING:..., 
%        loss, time
%      SSH:...
%        mpstat, df, free, uptime, top, proc, uptime, netstat, sar,
%        swap, ibmhmc, vmwarei, vmwarevires
%      CALC:...
%        [[!scopeinv_cpu]]
%      PORT:...
%      URL:
%         url=
%      WMI:
%      NOOP
%      SNMP:
%         community
%         version
%         var, label, unit, helper, unique
%    units:
%        %,ms,GB,<empty>, pkts, mbps
%    number, counter
%    alarm spec:  >=100:1:2/2:1/3600:CLEAR:5:2/2
%       <vrange>:<severity>:<m hits/n collections>:<alarm refresh count/time>
%     or
%       CLEAR:<severity>:<m clears/n collections>
%     vrange can be >= v, <= v, [v1,v2], (v1,v2) (inclusive / exclusive intervals)
%     1/3600 means resend this alarm once every 3600 secs, e.g. 1hr.
%     so the above means: alarm if the value is >= 100 for 2 consecutive intervals,
%     refresh the alarm every hour while the condition persists, and clear the alarm
%     if you get 2 intervals < 100.



% scopemgr script assigns a scope based on inventory and class files
% and generates a schedule for the asset.  
% schedules are grouped by customer and scope
%  asset schedule file:
%  labems-test-sched.scope3.txt
% all schedules for a scope are concatentated it single schedule for
% scope

% vg_collector invoked with segment of scheduler for given asset
% examples:
%  ssh-schedule.txt
%  snmp-schedule.txt
% "XML code between <cfg> tags
% "vars" table with variables to collect and how to do it
% "alarms" table with threshold limits for these variables.

% scopes come in linux and windows flavors because hard to monitor
% windows machines from non-windows machines.

% scopes are assigned based on network reachablity and grouping by
% tags:
%  a scope will be assigned to an asset if their tag sets intersect
%  assignment also considers "cost" which accounts for bandwidth and
%  load issues.

% if a scope fails, tasks are reassigned to other scopes until it
% comes back on-line