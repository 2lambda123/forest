A {\em filestore} is a structured collection of data files housed in a
conventional hierarchical file system. Many applications use file
systems as a poor-man's database, and the correct execution of these
applications requires that the collection of files, directories, and
symbolic links stored on disk satisfy a variety of precise
invariants. Moreover, all of these structures must have acceptable
ownership, permission, and timestamp attributes. Unfortunately,
current programming languages do not provide support for documenting
assumptions about filestores, detecting errors, or safely loading from
and storing to them.

This paper describes the design, implementation, and semantics of
\forest{}, a novel domain-specific language for describing
filestores. The language uses a type-based metaphor to specify the
expected structure, attributes, and invariants of filestores.
\forest{} generates loading and storing functions that make it easy to
connect data on disk to an isomorphic representation in memory that
can be manipulated as if it were any other data structure.  \forest{}
also generates metadata that describes the degree to which the
structures on the disk conform to the specification, making error
detection easy. \forest{} essentially extends the type discipline of
programming languages to the untyped world of file systems.

We have implemented \forest{} as an embedded domain-specific language
in \haskell{}. Our implementation leverages \haskell{}'s 
generic programming infrastructure to provide a toolkit so that
third-party developers can build tools that work with
arbitrary \forest{} descriptions.  We show the use of this toolkit on
a number of examples including a file system visualizer, an access
checker, and description-directed variants of several standard UNIX
shell tools. Finally, we formalize a core fragment \forest{} in a
semantics inspired by classical tree logics and prove round-tripping
laws showing that the loading and storing functions behave correctly.
