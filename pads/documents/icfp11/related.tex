\section{Related Work}
\label{sec:related}

The work in this paper builds upon ideas developed in the \pads{} 
project~\cite{fisher+:pads,fisher+:toplas}. \pads{} uses extended
type declarations to describe the grammar of a document
and simultaneously to generate types for parsed data and a suite 
of data-processing tools.  The obvious difference between 
\pads{} (and other parser generators) and
\forest{} is that 
\pads{} generates infrastructure for processing strings (the insides
of a single file) whereas \forest{} generates infrastructure for 
processing entire filestores.  In addition,
\forest{} (and \padshaskell) is architecturally superior to 
previous versions of \pads{} in the tight integration with its host
language and
in its support for third-party generic programming and tool construction.

More generally, \forest{} shares high-level goals with other systems
that seek to make data-oriented programming simpler and more productive.
For example, Microsoft's LINQ~\cite{linq} extends the .NET languages
to enable querying
any data source that supports the \cd{IEnumerable} interface using
a simple, convenient syntax.  
LINQ differs from \forest{} in that it does not provide support for
declaratively specifying the structure of, and then ingesting, 
\filestores{}. As a second example,
{\em Type Providers}~\cite{syme+:type-providers}, an
experimental feature 
of F\#, help programmers materialize standard data sources equipped with
predefined schemas (such as \xml{} documents or databases) in memory in
an F\# program.  Type Providers
do not themselves provide a new means for describing data sources (as
\forest{} does). 
%Type Providers and \forest{} descriptions
%are complementary language
%features.\jnf{In what sense?}  In fact, it may be possible to define a new F\# Type Provider
%capable of interpreting \forest{} file system schema and ingesting
%the described data, thereby making any \forest{}-described data available
%in F\#.

Several XML-based languages for specifying file formats, file
organization and file locations have been proposed. One example of
such a language is XFiles~\cite{xml-file-sys}.  XFiles uses RDF
specifications to describe the location, permissions, ownership, and
other attributes of files, as well as the name of an application
capable of parsing specific files.  The key difference between XFiles
and \forest{} is that \forest{} is tightly integrated into a
general-purpose, conventional programming language.  \forest{}
declarations generate types, functions and data structures that
materialize the data within a surrounding \haskell{} program while
XFiles does not interoperate directly with a conventional programming
language.

A recent MSc thesis by Ntzik proposes using an extension of context
logic~\cite{context-logic} to reason about the effects of updates made
to file systems using standard POSIX commands~\cite{ntzik-msc}.  The
core goal of Ntzik's work is to create a new kind of Hoare Logic, and
consequently, it is quite different from \forest{}.  In addition,
technically, \forest{} is more closely related to classical tree
logics than to substructural logics such as context logic.
%, and
%leads to a simpler treatment of updates. 
%We plan to study the
%relationship to Ntzik's work in the future.

The round-tripping properties that core \forest{} programs obey are
based on laws that have been proposed in the context of well-behaved
bidirectional transformations, often called lenses~\cite{lenses}. As
far as we are aware, lenses for file systems have not been developed
but some of the same fundamental issues that arise in core \forest{}
have been studied by Hu and his colleagues, including handling data
with internal dependencies~\cite{MuAlgebraic2004} as well as graph
structures~\cite{hidaka-graphs}.
