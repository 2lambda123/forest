\section{A Core Calculus for \forest{}}
\label{sec:theory}

\begin{figure}
\[
\begin{array}{@{}l@{\;}r@{\;}r@{\;}l@{}}
\multicolumn{4}{@{}l}{\fbox{\textit{Basic definitions}}}\\[1.5ex]
\textit{Integers}     & n    & \in & \mathbb{Z}\\[1ex]
\textit{Strings}      & u    & \in & \Sigma^{\ast}\\[1ex]
\textit{Booleans}     & b    & \bnfdef & \True \bnfalt \False\\[1ex]
\textit{Values}       & v    & \bnfdef & n \bnfalt u \bnfalt b \bnfalt \att \bnfalt r \bnfalt\\
                      &      &         & () \bnfalt (v_1,v_2) \bnfalt \Just{v} \bnfalt \Nothing \bnfalt \List{v_1,\tdots,v_n}\\[1ex]
\textit{Types}        & \tau & \bnfdef & \typ{Int} \bnfalt \typ{Bool} \bnfalt \typ{()} \bnfalt (\tau_1,\tau_2) \bnfalt \typ{Maybe}~\tau \bnfalt \List{\tau}\\[1ex]
\textit{Environments} & \Env & \bnfdef & \ENil \bnfalt \Env,x\mapsto v\\[1ex]
\textit{Expressions}  & e    & \bnfdef & x \bnfalt \lambda x.~e \bnfalt e_1~e_2 \bnfalt \dots \\[2.5ex]
%
\multicolumn{4}{@{}l}{\fbox{\textit{Forest definitions}}}\\[1.5ex]
\textit{Attributes}     & \att & \bnfdef & v\\[1ex]
\textit{Paths}          & r    & \bnfdef & \PNil \mid \PCons{r}{u}\\[1ex]
\textit{Contents}       & T    & \bnfdef & \File{u} \bnfalt \Link{r} \bnfalt \Dir{ \Set{u_1,\tdots,u_n} }\\[1ex]
\textit{File systems}   & F    & \bnfdef & \Map{ \! r_1 \mapsto (\att_1,T_1), \tdots, r_n \mapsto (\att_k,T_n) \! }\\[1ex]
\textit{Specifications} & s    & \bnfdef & \Sk \bnfalt \SPath{e}{s} \bnfalt \SPair{x}{s_1}{s_2} \bnfalt \SComp{s}{x}{e} \bnfalt \SPred{e} \bnfalt \SOption{s}
\end{array}
\]
\caption{\forest{} calculus syntax}
\label{fig:csyntax}
\end{figure}

This section describes a core calculus that formalizes the essential
features of \forest{} precisely in a simple setting. It is inspired by
classical (\ie{}, not separating, substructural or ambient) unordered
tree logics, customized for file systems. We used this calculus to
investigate various features and prove theorems (such as the
round-tripping properties presented at the end of this section) as we
developed \forest{}.

\subsection{The Basics: File Systems and Their Specifications}

%\paragraph*{File system model.}
%
Figure~\ref{fig:csyntax} presents the formal file system
model. A path $r$ is a sequence of strings\footnote{For simplicity, we
  ignore the special path elements ``..'' and ``.''.  It would be easy
  to add these features, at the cost of complicating the semantics.}
and a file system $F$ is finite map from paths to pairs of attributes
$\att$ and file system contents $T$.  We leave attributes abstract but
expect that they include the usual fields: owner, group, date
modified, {\it etc.}  The attribute $\defaultatt$ contains default
values for all fields. The contents $T$ of a node in the file system
is either a file $\File{n}$ (where $n$ is the string contents of the
file), a symbolic link $\Link{r}$ (where $r$ is the path pointed to by
the link), or a directory $\Dir{\Set{n_1,\dots,n_k}}$ (with paths
$n_1$ to $n_k$). We write $\dom{F}$ for the set of paths $F$ is defined on, 
$F(r)$ for the contents at $r$, and $F(r) = \bot$ when $r$ is not
in $\dom{F}$.

A file system $F$ is {\em well-formed} if it encodes a tree with
directories at the internal nodes and files and symbolic links at the
leaves. More formally, $F$ is well-formed if the following conditions
hold:
%
\begin{itemize}
\item $\dom{F}$ is prefix-closed,
\item $F(r) = (\att,\Dir{ \Set{n_1,\dots,n_k} }) \implies$\\ \hspace*{3.3mm}$\forall i \in \{1,\dots,k\}.~\PCons{r}{n_i} \in \dom{F}$, and
\item $F(r) = (\att,\File{n_r}) \vee F(r) = (\att,\Link{r'}) \implies$\\ \hspace*{3.3mm}$\forall n.~\PCons{r}{n} \not\in \dom{F}$.
\end{itemize}
%
Note that although the structure of a well-formed file system is
tree-shaped, cycles can be also expressed using symbolic links that
point ``upwards'' in the file system.

%\paragraph{File system specifications.}
%
Figure~\ref{fig:csyntax} also presents the syntax of file
system specifications $s$.  We leave the syntax of expression language
abstract but assume that it contains values $v$, variables $x$, and
other operators (of course, in the full \forest{} language,
expressions can be arbitrary Haskell code).  An environment $\Env$
maps variables to values.  The semantic function
$\eval{e}{\Env,r}{\tau}$ evaluates an expression $e$ in the
environment $\Env$ at path $r$, yielding a value $v$ of type $\tau$.

\reviewer{One aspect of the language that I was not clear on is how
  symbolic links work.  Based on the mini-semantics, a symbolic link
  to a directory does not extend the set of valid paths in the file
  system, though a Unix shell, for example, typically treats them that
  way.  How does Forest handle them?}

These file system specifications are parameterized over a collection
of constants $\Sk$, which include specifications for files (\pfile),
directories (\pdir), links (\plink), and \padshaskell{}-described
files (\SAdhoc{b}). The annotations $\tau_1$ and $\tau_2$ supply the
internal types of the the representation and the constant-specific
portion of the meta-data. The meta-variable $b$ ranges over
bidirectional functions: in the forward direction, such functions load
(parse) data; in the reverse direction they store (print) it.

To define the semantics of the overall language precisely,
we assume that each constant is associated with functions
$\loadkname{k}$ and $\storekname{k}$. For example, the $\loadkname{}$
function for the \pfile{} construct, which describes any file (but not
symbolic links or directories), is defined as follows:
%
\[
\loadkname{\pfile}~(\Env,F,r) =
\begin{cases}
  (n,(\True,\att)), \mathrm{if } F(r) = (\att,\File{n}) \\
  (\text{``}{\,}\text{''},(\False,\defaultatt)), \mathrm{otherwise}\\
\end{cases}
\]
%
The arguments to the function include an environment $\Env$, a file system $F$
to load from, and a path $r$ within that file system.
This function either returns the contents and attributes of the file at path $r$,
if it exists, or ``$\,$'' and default attributes if $F$ does not contain a
file at $r$.  The $\storekname{}$ function for \pfile{} is
defined as follows:
%
\[
\begin{array}{l}
\storekname{\pfile}~(\Env,F,r,v,d) =\\[.5ex]
\quad 
\begin{cases}
  (\FUpdate{F}{r}{(\att,\File{v})},            & \text{if}~d = (\True,\att)\\
   \; \phi' = \lambda F'.~ (F'(r) = (\att,\File{v})))\\[1ex]
  \FDelete{F}{r},                              & \text{if}~d = (\False,\att)~\wedge\\
   \; \phi' = \lambda F'.~ F'(r) \neq (\us,\File{\us})) & \;\;\; F(r) = (\us,\File{\us})\\[1ex]
  F,              & \text{otherwise}\\
   \; \phi' = \lambda F'.~ F'(r) \neq (\us,\File{\us}))\\
\end{cases}
\end{array}
\]
%
The arguments to the store function include an environment $\Env$, an
existing file system $F$ to store into, a path $r$ to store at, a
representation $v$ for the data to store, and the metadata $d$ associated
with that representation.  The store function
produces two results: an updated file system $F'$ and a predicate
$\phi'$ that records the constraints needed to ensure
consistency. In this case, the $\storekname{}$ function for \pfile{}
overwrites the contents of the file system $F$ at path $r$ with
$(\att,\File{v})$ if $d$ is valid (and contains $\att$), deletes the
contents of $F$ at $r$ if $d$ is not valid but $F(r)$ contains a file,
and otherwise returns $F$ unchanged. The predicate $\phi'$ requires
that $F'(r)$, the contents of the new file system $F'$ at $r$, be
$\File{v}$ in the first case and that $F'(r)$ not be a file in the other
two cases. These constraints must be satisfied in order to guarantee
the round-tripping properties presented at the end of this section.

\reviewer{For most of the paper, the generation of predicates by the
  store judgment is mysterious and undermotivated.  It would help to
  explain more clearly early on why it's present in the judgment, even
  before the current paragraph explaining the motivation for
  predicates.}

%The load functions for the \plink{} and \pdir{} constants
%are similar. The load function for \SAdhoc{b}{} reads the file system
%in the same way as \pfile{}, but invokes $b$ parser to produce the
%final representation.

In the \forest{} surface syntax, records and paths are specified using
a single construct (and similarly for comprehensions) while the core
calculus models (dependent) records, paths, and comprehensions as
independent, orthogonal constructs.  Path specifications are written
$\SPath{e}{s}$, where $e$ is a path name (to be appended to the
current path) and $s$ specifies a fragment of the file system at that
path. Record specifications are written \SPair{x}{s_1}{s_2}, where $x$
may appear in $s_2$. Comprehension specifications are written
$\SComp{s}{x}{e}$, where $e$ is an expression that describes a set of
values, $x$ is a variable, and $s$, which may depend on $x$, specifies
a fragment of the file system for each value of $x$.  For example, the
specification
\begin{center}
\cd{\{c \kw{is} "c.txt" :: C, d \kw{is} "d.txt" :: D c\}} 
\end{center}
is encoded in the calculus as
%
\(
\SPair{x\,}{\,(\SPath{\texttt{"}\mathtt{c.txt}\texttt{"}}{C})}{(\SPath{\texttt{"}\mathtt{d.txt}\texttt{"}}{D\; x})} 
\).
Similarly, the comprehension
\begin{center}
\cd{[c :: C | c <- \kw{matches} (GL "*")]} 
\end{center}
is encoded as: \(\SPair{x}{\pdir}{\SComp{\SPath{y}{C}}{y}{x}}
\). Predicate specifications $\SPred{e}$ succeed when $e$ evaluates to
\True{} and fail when $e$ evaluates to \False{} under the current
environment.  A \forest{} constraint of the form \cd{s \kw{where} e}
is encoded in the calculus using a dependent pair and a predicate:
$\SPair{x}{s}{\SPred{e[x/\mathtt{this}]}}$. Finally, maybe
specifications are written as $\SOption{s}$ in the calculus.

\begin{figure}
\[
\begin{array}{l|l|l}
\hline
& & \\[-.85em]
s & \repty{s} & \mdty{s} \\[.5ex]
\hline
& & \\[-.85em]
\Sk & \tau_1 &  \md{\tau_2} \\[.5ex]
\SPath{e}{s} & \repty{s} & \mdty{s} \\[.5ex]
\SPair{x}{s_1}{s_2} & (\repty{s_1}, \repty{s_2}) & \md{(\mdty{s_1}, \mdty{s_2})} \\[.5ex]
\SComp{s}{x}{e} & \List{\repty{s}} & \md{\List{\mdty{s}}}\\[.5ex]
\SPred{e} & () & \md{()}\\[.5ex]
\SOption{s} & \typ{Maybe}~\repty{s} & \md{(\typ{Maybe}~\mdty{s})} 
\end{array}
\]
\caption{\forest{} calculus representation and metadata types}
\label{fig:ctypes}
\end{figure}

\begin{figure*}
\begin{minipage}[t]{.45\textwidth}
\vspace*{3em}
\fbox{$\load{\Env}{F}{r}{s}{v,d}$}
\vspace*{1em}
\[
\begin{array}{c}
\inferrule
{ }
{ \load{\Env}{F}{r}{\Sk}{ \loadk{k}{\Env}{F}{r} } }
\\[2em]
\inferrule
{ \load{\Env}{F}{\eval{\PCons{r}{e}}{\Env,r}{\mathit{path}}}{s}{v,d} }
{ \load{\Env}{F}{r}{\SPath{e}{s}}{v,d} }
\\[2em]
\inferrule
{ \load{\Env}{F}{r}{s_1}{ v_1,d_1 } \\\\
  \load{(\Env,x_{\REP} \mapsto v_1,x_{\MD} \mapsto d_1)}{F}{r}{s_2}{ v_2,d_2 }\\\\
  b = \valid{d_1} \wedge \valid{d_2} }
{ \load{\Env}{F}{r}{\SPair{x}{s_1}{s_2}}{ (v_1,v_2),(b, (d_1,d_2)) } }
\\[2em]
\inferrule
{ \eval{e}{\Env,r}{\List{tau}} = [w_1,\dots,w_k ]\\\\
  \forall i \in \{1,\dots,k\}.~\load{(\Env,x \mapsto w_i)}{F}{r}{s}{v_i,d_i}\\\\
  b = \textstyle\bigwedge_i^k \valid{d_i} \quad \mathit{vs} = [v_1,\dots,v_k] \quad \mathit{ds} = [d_1,\dots,d_k] }
{ \load{\Env}{F}{r}{ \SComp{s}{x}{e} }{ \mathit{vs},(b,\mathit{ds}) } }
\\[2em]
\inferrule
{ b = \eval{e}{\Env,r}{\mathit{bool}} }
{ \load{\Env}{F}{r}{ \SPred{e} }{ (),(b,()) } }
\\[2em]
\inferrule
{ r \not\in \dom{F} }
{ \load{\Env}{F}{r}{ \SOption{s_1} }{ \Nothing,(\True,\Nothing) } }
\\[2em]
\inferrule
{ r \in \dom{F} \quad \load{\Env}{F}{r}{s_1}{v_1,d_1} }
{ \load{\Env}{F}{r}{ \SOption{s_1} }{ \Just{v_1},(\valid{d_1},\Just{d_1}) } }
\end{array}
\]
\end{minipage}\hfill\vrule\hfill\begin{minipage}[t]{.5\textwidth}
\fbox{$\store{\Env}{F}{r}{v,d}{s}{F',\phi'}$}\\
\vspace*{1em}
\[
\begin{array}{c}
\inferrule
{ }
{ \store{\Env}{F}{r}{v,d}{\Sk}{ \storek{k}{\Env}{F}{r}{v,d} } }
\\[2em]
\inferrule
{ \store{\Env}{F}{\eval{\PCons{r}{e}}{\Env,r}{\mathit{path}}}{v,d}{s}{F',\phi'} }
{ \store{\Env}{F}{r}{v,d}{\SPath{e}{s}}{F',\phi' } }
\\[2em]
\inferrule
{ \store{\Env}{F}{r}{ v_1,d_1 }{s_1}{ F_1',\phi_1 } \\\\
  \store{(\Env,x_{\REP} \mapsto v_1, x_{\MD} \mapsto d_1)}{F}{r}{ v_2,d_2 }{s_2}{ F_2',\phi_2 } \\\\
  \phi' = \lambda F'.~ (b = \valid{d_1} \wedge \valid{d_2}) \wedge \phi_1'(F') \wedge \phi_2'(F') }
{ \store{\Env}{F}{r}{ (v_1,v_2),(b,(d_1,d_2)) }{\SPair{x}{s_1}{s_2}}{ F_1' \FAppend F_2',\phi' } }
\\[2em]
\inferrule
{ \mathit{vs} = [v_1,\dots,v_j] \quad \mathit{ds} = [d_1,\dots,d_l]\\\\
  \eval{e}{\Env,r}{\List{\tau}} = [w_1,\dots,w_m ] \quad  k = \min{(j,l,m)} \\\\
  \forall i \in \{1,\dots,k\}.~\store{(\Env,x \mapsto w_i)}{F}{r}{v_i,d_i}{s}{F_i',\phi_i'}\\\\
  \phi' = \lambda F'.~ (j = l = m) \wedge (b = \textstyle\bigwedge_i^k \valid{d_i}) \wedge (\textstyle\bigwedge_i^k \phi_i'(F')) }
{ \store{\Env}{F}{r}{\mathit{vs},(b,\mathit{ds})}{ \SComp{s}{x}{e} }{ F_1' \FAppend \dots \FAppend F_k',\phi' } }
\\[2em]
\inferrule
{ \phi' = \lambda F'.~ (b = \eval{e}{\Env,r}{\mathit{bool}}) }
{ \store{\Env}{F}{r}{(),(b,())}{ \SPred{e} }{ F,\phi' } }
\\[2em]
\inferrule
{ \store{\Env}{F}{r}{ v_1,d_1 }{ s_1 }{ F',\phi_1' }\\\\
  \phi' = \lambda F'.~ (b = \valid{d_1}) \wedge (r \in \dom{F'}) \wedge \phi_1'(F') }
{ \store{\Env}{F}{r}{ \Just{v_1},(b,\Just{d_1}) }{ \SOption{s_1} }{ F',\phi' } }
\\[2em]
\inferrule
{ \phi' = \lambda F'.~(d = \Nothing) \wedge b \wedge r \not\in \dom{F'} }
{ \store{\Env}{F}{r}{ \Nothing,(b,d) }{ \SOption{s_1} }{ \FDelete{F'}{r},\phi' } }
\\[2em]
\inferrule
{ \store{\Env}{F}{r}{ v_1,\defaultmd{s_1} }{ s_1 }{ F',\phi_1' }\\\\
  \phi' = \lambda F'.~ \False }
{ \store{\Env}{F}{r}{ \Just{v_1},(b,\Nothing) }{ \SOption{s_1} }{ F',\phi' } }
\\[2em]
\end{array}
\]
\end{minipage}
\centerline{\hfill (a) \hfill\hfill \hspace*{.05\textwidth} (b) \hfill}
\caption{\forest{} calculus semantics for (a) loading and (b) storing}
\label{fig:csemantics}
\end{figure*}

\subsection{Calculus Semantics}
%
The semantics of the calculus is organized into four separate
definitions, one for each of the four major artifacts generated by the
\forest{} compiler.

\paragraph*{Type Definitions.}
Figure~\ref{fig:csemantics} defines types for the representations
($\repty{s}$) and metadata ($\mdty{s}$) generated by specifications
$s$. The types for constants $\Sk$ are read off from their annotations
while the types for other specifications are constructed from their
structure in the obvious way---\eg, the type of representations for
\SPair{x}{s_1}{s_2} is a product $(\repty{s_1}, \repty{s_2})$. The
type constructor $\mathit{Md}$ provides a uniform representation for
metadata and is defined as follows:
\[
\begin{array}{lcl}
\md~{\tau} & = & (\typ{Header}, \tau) \\
\typ{Header} & = & \typ{Bool} 
\end{array}
\]
The function $\valid{d}$ extracts the boolean from the metadata
structure $d$, returning $\True$ if there are no errors in the
structure and $\False$ otherwise. 

\paragraph*{Semantics of Loading and Storing.}
The inference rules on the left side of
Figure~\ref{fig:csemantics} define the semantics of the load
function. Reading from right to left, the judgment 
$\load{\Env}{F}{r}{s}{v,d}$ states one can obtain the pair $(v,d)$ of
representation and metadata, by materializing components
of the filesystem $F$ in memory using the specification $s$
at path $r$ in environment $\Env$.  Reading from
left to right, this judgment may also be viewed
as a total function from $\Env$, $r$, $s$ and $F$ to $(v,d)$. The
judgment is total because when $F$ fails to match $s$, the load
function generates defaults in the representation $v$ and records
errors in the metadata $d$.  This design allows a programmer to
explore a file system fragment even when it does not match the
given specification exactly.

Let us examine a few of the inference rules that define the store
function in detail. The rule for constants $\Sk$ just invokes the
associated $\storekname{k}$ function. The rule for
$\SComp{s}{x}{e}$ comprehensions is more interesting: it first
evaluates $e$ to a list $[w_1,\dots,w_k]$ and then invokes the store
function for $s$ $k$ times in environments where $x$ is bound to each
$w_i$. It then collects up the results into lists of representations
$[v_1,\dots,v_k]$ and metadata $[d_1,\dots,d_k]$, which it uses as the
final result. The predicate $\SPred{e}$ construct tests whether an
expression $e$ is satisfied. It returns $()$ as the representation and
$(\eval{e}{\Env,r}{\mathit{bool}},())$ as the metadata. Finally,
$\SOption{s}$ invokes $s$'s load function if the current path $r$
exists in the file system, injecting the result into the maybe type
using $\mathsf{Just}$, and otherwise returns $\Nothing$.

The inference rules on the right side of
Figure~\ref{fig:csemantics} define the store function. The
judgment $\store{\Env}{F}{r}{v,d}{s}{F',\phi'}$ states that in
environment $\Env$ storing $(v,d)$ into file system $F$ using
specification $s$ yields the file system $F'$ and predicate
$\phi'$. The predicate $\phi'$ tracks the conditions on the file
system needed to ensure that it accurately reflects the information in
the representation and metadata.

As a simple example to illustrate why predicates are needed, consider
the specification $s = \SPair{x}{\pfile}{\pfile}$ and suppose that the
load function is called in an environment $\Env$ with a file system
$F$ and path $r$ where $F(r) = (\att,\File{n})$. The representation
returned by load will be a pair $(n,n)$ containing two copies of the
file contents at $r$ and the metadata will also contain a pair
$(\True,(\True,\att),(\True,\att)))$ with two copies of the metadata
associated with that file. Now suppose that we change the
representation to $(n,n')$, with $n \neq n'$, and we store the result
back to the file system. Unfortunately, because the representation is
inconsistent---it does not satisfy the dependency between the two
components of the pair implied by $s$---the store function cannot
produce a new file system containing the information in both $n$ and
$n'$. Thus, it must store one and discard the other.  The predicate
$\phi'$ generated by the store function provides a way to track and
report inconsistencies. In this case, the predicate will be equivalent
to the following:
%
\[
\phi' = \lambda F'.~ (F'(r) = (\att,\File{n})) \wedge (F'(r) = (\att,\File{n'})
\]
%
which is obviously not satisfiable when $n \not= n'$. 
\jnf{Say more to
  connect these to manifests?}
\dpw{Thought about it but decided not to. It didn't fit.}

Now that the overall structure of the store judgement has been
explained,
let us examine a few of the inference rules in detail. The rule for
constants $\Sk$ simply invokes the $\storekname{k}$ function. 
The rule for path specifications $\SPath{e}{s}$ passes off
control to the store function for $s$ after replacing the current path
$r$ with $\eval{\PCons{r}{e}}{\Env,r}{\mathit{path}}$. The rule for
dependent pairs $\SPair{x}{s_1}{s_2}$ is more interesting. Given a
pair $(v_1,v_2)$ as the representation, it first invokes the store
function for $s_1$ with $v_1$, producing an updated file system $F_1'$
and predicate $\phi_1'$. Next, it invokes the store function for $s_2$
with $v_2$ in an extended environment where $x$ is bound to $v_1$,
yielding another updated file system $F_2'$ and $\phi_2'$. It combines
the updated file systems using the following right-biased
concatenation operator,
%
\[
\begin{array}{l}
(F_1 \FAppend F_2)(r) = \\
\qquad 
\begin{cases}
  (\att_2,\Dir{N_1 \cup N_2}) & \text{if}~F_1(r) = (\att_1,\Dir{N_1}) \; \wedge \\
                              & \;\;\; F_2(r) = (\att_2,\Dir{N_2})\\
  F_1(r) & \text{if}~F_2(r) = \bot\\
  F_2(r) & \text{otherwise}\\
\end{cases}
\end{array}
\]
%
Finally, it combines the predicates using conjunction. The result is a
file system that contains the consistent changes made to the file
system by the store functions for $s_1$ and $s_2$ as well as a
predicate that checks for the consistency of all of their changes. 

\subsection{Formal Properties}

The first property of the \forest{} calculus is a basic type safety
property, which states that the load function for
specifications $s$ generates representations and metadata belonging to
$\repty{s}$ and $\mdty{s}$ respectively.
%
\begin{proposition}[Type Safety]
  If $\load{\Env}{F}{r}{s}{v,d}$ and $\repty{s} = \tau_{\mathcal{R}}$
  and $\mdty{s} = \tau_{\mathcal{M}}$ then $\turn v :
  \tau_{\mathcal{R}}$ and $\turn d : \tau_{\mathcal{M}}$,
\end{proposition}
%
The above property demonstrates that our type definitions are properly
aligned with the semantics of loading.  To ensure that the semantics
of loading is, in turn, aligned with the semantics of 
storing, we also prove the following two round-tripping
properties.
%

\deferproof{theorem}{loadstore}{LoadStore}{%
  Let $\Env$ be an environment, $F$ a file system, $r$ a path, $s$ a
  specification, $v$ a representation, and $d$ metadata.  If
\[
\begin{array}{c}
\load{\Env}{F}{r}{s}{v,d} \\
\store{\Env}{F}{r}{v,d}{s}{F',\phi}
\end{array}
\]
then $F = F'$ and $\phi'(F')$.}
%
{ The proof is by induction on $s$. For every constant $\Sk$, we
  assume that $\loadkname{k}$ and $\storekname{k}$ satisfy the theorem. 
\begin{description}
%%%
%%% CONST
%%%
\item[Case:] $s = \Sk$\\[1ex]
%
By the definitions of the load and store functions we have 
\[ 
\begin{array}{rcl}
v,d  &=& \loadk{k}{\Env}{F}{r}\\
F',\phi' &=& \storek{k}{\Env}{F}{r}{v,d}\\
\end{array}
\]
By the assumptions about the behavior of $\loadkname{k}$ and
$\storekname{k}$, we have $F' = F$ and $\phi'(F')$, which finishes the
case.

%%%
%%% PATH
%%%
\item[Case:] $s=\SPath{e}{s_1}$\\[1ex]
%
By the definitions of the load and store functions we have 
%
\[ 
\begin{array}{l}
\load{\Env}{F}{r'}{s_1}{v,d}\\
\store{\Env}{F}{r'}{v,d}{s_1}{F',\phi'}
\end{array} \hspace*{1cm}
\begin{array}{rcl}
r' & = & \eval{\PCons{r}{e}}{\Env,r}{\mathit{path}}\\
\\
\end{array}
\]
%
By the induction hypothesis applied to $s_1$ we have $F' = F$ and
$\phi'(F')$, which finishes the case.

%%%
%%% Pair
%%%
\item[Case:]$s = \SPair{x}{s_1}{s_2}$\\[1ex]
%
By the definitions of the load and store functions we have 
\[ 
\begin{array}{l}
\load{\Env}{F}{r}{s_1}{v_1,d_1}\\
\load{\Env'}{F}{r}{s_2}{v_2,d_2}\\
\store{\Env}{F}{r}{v_1,d_1}{s_1}{F_1',\phi_1'}\\
\store{\Env'}{F}{r}{v_2,d_2}{s_2}{F_2',\phi_2'}\\
\end{array} \hspace*{1cm}
\begin{array}{rcl}
\Env' &=& \Env,x_{\REP} \mapsto v_1, x_{\MD} \mapsto d_1\\
b &= & \valid{d_1} \wedge \valid{d_2}\\
v &=& (v_1,v_2)\\
d &=& (b,(d_1,d_2))\\
F' &=& F_1' \FAppend F_2'\\
\phi' &=& \lambda F'.~(b = \valid{d_1} \wedge \valid{d_2}) \wedge \phi_1'(F') \wedge \phi_2'(F')\\
\end{array}
\]
By the induction hypothesis applied to $s_1$, we have $F_1' = F$ and
$\phi_1'(F_1')$. Likewise, by the induction hypothesis applied to
$s_2$, we have $F_2' = F$ and $\phi_2'(F_2')$. We immediately have
$\phi'(F')$ and $F' = F$ as (\FAppend) is idempotent, which finishes
the case.

%%%
%%% Comprehension
%%%
\item[Case:] $s = \SComp{s_1}{x}{e}$\\[1ex]
%
By the definitions of the load and store functions we have 
\[ 
\begin{array}{l}
\eval{e}{\Env,r}{\List{tau}} = [w_1,\tdots,w_k ]\\
\forall i \in \{1,...,k\}.\,\load{(\Env, x \mapsto w_i)}{F}{r}{s_1}{v_i,d_i}\\
\forall i \in \{1,...,k\}.\,\store{(\Env, x \mapsto w_i)}{F}{r}{v_i,d_i}{s}{F_i',\phi_i'}\\
\end{array}\hspace*{.75cm}\begin{array}{rcl}
v &=& [v_1,\tdots,v_k]\\
b &= &\bigwedge_i^k \valid{d_i}\\
d &=& (b,[d_1,\tdots,d_k])\\
F' &=& F_1' \FAppend \tdots \FAppend F_k'\\
\phi' &=& \lambda F'.~(b = \bigwedge_i^k \valid{d_i}) \wedge (\bigwedge_i^k \phi_i'(F'))\\
\end{array}
\]
By the induction hypothesis applied to $s$ ($k$ times), we have $F_i'
= F$ and $\phi'_i(F_i')$ for $i$ from $1$ to $k$. We immediately have
$\phi'(F')$ and $F' = F$ as (\FAppend) is idempotent, which finishes
the case.

%%%
%%% Predicate
%%%
\item[Case:] $s = \SPred{e}$\\[1ex]
%
By the definition of the load and store functions we have
\[
\begin{array}{rcl}
v &=& ()\\
d &=& (b,())\\
b &=& \eval{e}{\Env,r}{\mathit{bool}}\\
\end{array}\hspace*{1cm}\begin{array}{rcl}
F' &=& F\\
\phi' &=& \lambda F'.~(b = \eval{e}{\Env,r}{\mathit{bool}})\\
\end{array}
\]
Thus, we immediately have $F' = F$ and $\phi'(F')$.

%%%
%%% Option
%%%
\item[Case:] $s = \SOption{s_1}$\\[1ex]
%
We analyze two subcases:
\begin{description}
\item[Subcase:] $r \in \dom{F}$\\[1ex]
%
By the definition of the load and store functions we have
\[ 
\begin{array}{l}
\load{\Env}{F}{r}{s}{v_1,d_1}\\
\store{\Env}{F}{r}{v_1,d_1}{s}{ F',\phi_1' }\\
\end{array}\hspace*{2cm}\begin{array}{rcl}
v &=& \Just{v_1}\\
d &=& (b,\Just{d_1})\\
b &=& \valid{d_1}\\
\phi' &=& \lambda F'.~(b = \valid{d_1}) \wedge (r \in \dom{F}) \wedge \phi_1'(F')\\
\end{array}
\]
%
By the induction hypothesis applied to $s_1$ we have $F' = F$ and
$\phi_1'(F')$. We immediately have $\phi'(F')$.

\item[Subcase:] $r \not\in \dom{F}$\\[1ex]
%
By the definition of the load and store functions we have 
\[ 
\begin{array}{rcl}
v &=& \Nothing\\
d &=& (b,d_1)\\
d_1 &=& \Nothing\\
b &=& \True\\
\end{array}\hspace*{1cm}\begin{array}{rcl}
F' &=& \FDelete{F}{r}\\
\phi' &=& \lambda F'.~(d_1 = \Nothing) \wedge b \wedge  (r \not\in \dom{F'})
\end{array}
\]
We immediately have $F' = F$ and $\phi'(F')$, which finishes the case
and the inductive proof. \hfill \qed
\end{description}
\end{description}
}

\deferproof{theorem}{storeload}{StoreLoad}{ 
%
  Let $\Env$ be an environment, $F$ and $F'$ file systems, $r$ a path,
  $s$ a specification, $v$ a representation, $d$ and $d'$ metadata,
  and $\phi'$ a predicate. If 
\[
\begin{array}{c}
\store{\Env}{F}{r}{v,d}{s}{F',\phi'}\\
\phi'(F')\\
\load{\Env}{F'}{r}{s}{v',d'}
\end{array}
\]
then $v' = v$ and $\valid{d} = \valid{d'}$.}
%
{ We will prove a slightly stronger result that implies the theorem:
  for all environments $\Env$, file systems $F$, $G_1$, $G_2$, and
  $F'$, paths $r$, specifications $s$, representations $v$ and $v'$,
  metadata $d$ and $d'$, and constraints $\phi'$, if 
%
\[
\begin{array}{c}
  \store{\Env}{F}{r}{v,d}{s}{F',\phi'}\\
  \phi'(G_1 \FAppend F' \FAppend G_2)\\
  \load{\Env}{(G_1 \FAppend F' \FAppend G_2)}{r}{s}{v',d'}
\end{array}
\]
%
then $v' = v$ and $\valid{d} = \valid{d'}$. 

The proof is by induction on $s$. For every constant $\Sk$, we assume
that $\loadkname{k}$ and $\storekname{k}$ satisfy the strengthened
property.
\begin{description}
%%%
%%% Constant
%%%
\item[Case]: $s = \Sk$\\[1ex]
%
By the definitions of the load and store functions we have 
\[ 
\begin{array}{rcll}
F',\phi &=& \storek{k}{\Env}{F}{r}{v,d}\\
v',d'  &=& \loadk{k}{\Env}{(G_1 \FAppend F' \FAppend G_2)}{rs}\\
\end{array}
\]
By assumptions about the behavior of $\loadkname{k}$ and
$\storekname{k}$, we have $v' = v$ and $\valid{d} = \valid{d'}$,
which finishes the case. 

%%%
%%% Path
%%%
\item[Case:] $s=\SPath{e}{s_1}$\\[1ex]
%
By the definitions of the load and store functions we have
\[
\begin{array}{l}
\store{\Env}{F}{r'}{v,d}{s_1}{F',\phi'}\\
\load{\Env}{(G_1 \FAppend F' \FAppend G_2)}{r'}{s_1}{v',d'}
\end{array}\hspace*{1cm}\begin{array}{rcl}
r' &=& \eval{\PCons{r}{e}}{\Env,r}{\mathit{path}}\\
\\
\end{array}
\]
%
By the induction hypothesis applied to $s_1$ we have $v' = v$ and
$\valid{d} = \valid{d'}$, which finishes the case.

%%%
%%% Pair
%%%
\item[Case:] $s = \SPair{x}{s_1}{s_2}$\\[1ex]
%
By the definition of the load function we have
\[
\begin{array}{l}
\store{\Env}{F}{r}{v_1,d_1}{s_1}{F_1',\phi_1'}\\
\store{(\Env, x \mapsto v_1)}{F}{r}{v_2,d_2}{s_2}{F_2',\phi_2'}\\
\end{array}\hspace*{1cm}\begin{array}{rcl}
v &=& (v_1,v_2)\\
d &=& (b,(d_1,d_2))\\
F' &=& F_1' \FAppend F_2'\\
\phi' &=& \lambda F'.~(b = \valid{d_1} \wedge \valid{d_2}) \wedge \phi_1'(F') \wedge \phi_2'(F')\\
\end{array}
\]
By $\phi'(G_1 \FAppend F' \FAppend G_2)$ we have
\[
\begin{array}{l}
b = \valid{d_1} \wedge \valid{d_2}\\
\phi_1'(G_1 \FAppend F' \FAppend G_2)\\
\phi_2'(G_1 \FAppend F' \FAppend G_2)\\
\end{array}
\]
%
As $(\FAppend)$ is associative we also have,
\[
\begin{array}{rcl}
(G_1\FAppend (F_1\FAppend F_2)\FAppend G_2) &=& (G_1\FAppend F_1\FAppend (F_2\FAppend G_2))\\
(G_1\FAppend (F_1\FAppend F_2)\FAppend G_2) &=& ((G_1\FAppend F_1)\FAppend F_2\FAppend G_2),\\
\end{array}
\]
and hence:
\[
\begin{array}{l}
\phi_1'(G_1\FAppend F_1\FAppend (F_2\FAppend G_2))\\
\phi_2'((G_1\FAppend F_1)\FAppend F_2\FAppend G_2)\\
\end{array}
\]
By the definition of the load function we have 
\[ 
\begin{array}{rcll}
\load{\Env}{(G_1 \FAppend F_1 \FAppend (F_2 \FAppend G_2))}{r}{s_1}{v_1',d_1'}\\
\load{(\Env, x \mapsto v_1)}{((G_1 \FAppend F_1) \FAppend F_2 \FAppend G_2)}{r}{s_2}{v_2',d_2'}\\
\end{array}\hspace*{1cm}\begin{array}{rcl}
v' &=& (v_1',v_2')\\
b' &= & \valid{d_1} \wedge \valid{d_2}\\
d' &=& (b',(d_1',d_2'))\\
\end{array}
\]
%
By the induction hypothesis applied to $s_1$ and $s_2$, we have 
\[
\begin{array}{l}
v_1' = v_1\\
v_2' = v_2\\
\end{array}\hspace*{1cm}\begin{array}{l}
\valid{d_1} = \valid{d_1'}\\
\valid{d_2} = \valid{d_2'}\\
\end{array}
\]
It follows that $(v_1,v_2) = (v_1',v_2')$ and $b = b'$, which
finishes the case.

%%%
%%% Comprehension
%%%
\item[Case:] $s = \SComp{s}{x}{e}$\\[1ex]
By the definition of the store function we have
\[
\begin{array}{l}
\forall i \in \{1,\tdots,k\}.\,\store{(\Env, x \mapsto w_i)}{F}{r}{v_i,d_i}{s}{F_i',\phi_i}\\
\eval{e}{\Env,r}{\List{tau}} = [w_1,\tdots,w_m ]\\
\end{array}\hspace*{.75cm}\begin{array}{rcl}
v &=& [v_1,\tdots,v_j]\\
d &=& [d_1,\tdots,d_l]\\
k &=& \min{(j,l,m)}\\
F' &=& F_1' \FAppend \tdots \FAppend F_k'\\
\phi &=& \lambda F'.~(j = k = l) \wedge (b = \bigwedge_i^k \valid{d_i}) \bigwedge_i^k \phi_i(F')\\
\end{array}
\]
By $\phi'(G_1 \FAppend F' \FAppend G_2)$ we have
\[
\begin{array}{l}
k = j = l = m\\
b = (\bigwedge_i^k \valid{d_i})\\
\end{array}\hspace*{1cm}\begin{array}{l}
\forall i \in \{1,\tdots,k\}.\,\phi_i'(G_1 \FAppend F' \FAppend G_2) \\
\end{array}
\]
%
Let
\[
H_i = ((G_1\FAppend F_1\FAppend \tdots \FAppend F_{i-1}) \FAppend F_i \FAppend (F_{i+1} \FAppend \tdots \FAppend F_k \FAppend G_2))
\]
for $i$ from $1$ to $k$. As $(\FAppend)$ is associative we have,
\[
(G_1\FAppend (F_1\FAppend \tdots \FAppend F_k)\FAppend G_2) = H_i \quad \text{for}~i \in \{1,\tdots,k\}
\]
and hence:
\[
\phi_i'(H_i) \quad \text{for}~i \in \{1,\tdots,k\}
\]
%
By the definition of the load function we also have 
\[ 
\begin{array}{l}
\forall i \in \{1,\tdots,k\}\,\load{(\Env, x \mapsto w_i)}{H_i}{r}{s_1}{v_i,d_i'}\\
\end{array}\hspace*{1cm}\begin{array}{rcl}
v' &=& [v_1',\tdots,v_k']\\
b' &=& \bigwedge_i^k \valid{d_i'}\\
d' &=& (b',[d_1',\tdots,d_k'])\\
\end{array}
\]
%
By the induction hypothesis applied to $s$ ($k$ times), we have $v_i'
= v_i$ and $\valid{d_i'} = \valid{d_i}$ for = $i$ from $1$ to
$k$. It follows that $[v_1,\tdots,v_k] = [v_1',\tdots,v_k']$ and $b =
b'$, which finishes the case.

%%%
%%% Predicate
%%%
\item[Case:] $s = \SPred{e}$\\[1ex]
%
By the definitions of the store and load functions we have
\[
\begin{array}{rcl}
v &=& ()\\
d &=& ((),b)\\
F' &=& F\\
\phi' &=& \lambda F'.~(b = \eval{e}{\Env,r}{\mathit{bool}})\\
\end{array}\hspace*{1cm}\begin{array}{rcl}
v' &=& ()\\
d' &=& (b',())\\
b' &=& \eval{e}{\Env,r}{\mathit{bool}}\\
\end{array}
\]
By $\phi'(G_1 \FAppend F' \FAppend G_2)$ we have $b =
\eval{e}{\Env,r}{\mathit{bool}}$. It follows that $v = v'$ and $b =
b'$, which finishes the case.

%%%
%%% Option
%%%
\item[Case:] $s = \SOption{s_1}$\\[1ex]
%
We analyze several subcases:
\begin{description}
\item[Subcase:] $v = \Just{v_1}$ and $d = (b,\Just{d_1})$\\[1ex]
%
By the definition of the store function we have
\[
\begin{array}{l}
\store{\Env}{F}{r}{ v_1,d_1 }{s_1}{F',\phi_1'}\\
\end{array}\hspace*{1cm}\begin{array}{rcl}
\phi' &=& \lambda F'.~(b = \valid{d_1}) \wedge (r \in \dom{F}) \wedge \phi_1'(F')\\
\end{array}
\]
%
By $\phi'(G_1 \FAppend F' \FAppend G_2)$ we have $b = \valid{d_1}$ and
$r \in \dom{G_1 \FAppend F' \FAppend G_2}$.  By the definition of the
load function we also have
\[ 
\begin{array}{rcll}
\load{\Env}{(G_1 \FAppend F' \FAppend G_2)}{r}{s_1}{v_1',d_1'}\\
\end{array}\hspace*{1cm}\begin{array}{rcl}
v' &=& \Just{v_1'}\\
b' &=& \valid{d_1'}\\
d' &=& (b',\Just{d_1'})\\
\end{array}
\]
By the induction hypothesis applied to $s_1$ we have $v_1' = v_1$ and
$b' = b$. It follows that $v' = v$.

\item[Subcase:] $v = \Nothing$\\[1ex]
%
By the definition of the store and load functions we have
\[
\begin{array}{rcl}
F' &=& \FDelete{F}{r}\\
\phi' &=& \lambda F'.~(d = \Nothing) \wedge b \wedge (r \not\in \dom{F'})\\
\end{array}\hspace*{1cm}\begin{array}{rcl}
v' &=& \Nothing\\
b' &=& \True\\
d' &=& (b',\Nothing)\\
\end{array}
\]
As $\phi'(G_1 \FAppend F' \FAppend G_2)$ we have $d
= \Nothing$ and $b$ and $r \not\in \dom{G_1 \FAppend F' \FAppend
  G_2}$. Thus, we immediately have $v' = v$ and $b' = b$. 
\item[Subcase:] $v = \Just{v_1}$ and $d = \Nothing$\\[1ex]
%
Vacuously holds: by the definition of the store function we have
$\phi' = \lambda F'.~\False$, which contradicts the assumption that
$\phi'(G_1 \FAppend F' \FAppend G_2)$.
\end{description}
Thus, in each subcase we have $v' = v$ and $\valid{d} = \valid{d'}$,
which finishes the subcase and the inductive proof. \hfill \qed
\end{description}}

\smallskip

\noindent The first theorem states that loading from a file system $F$
and immediately storing the resulting representation and metadata
yields the original file system and, moreover, it satisfies the
predicate produced by the store function. The second theorem states
that storing an arbitrary representation and metadata and then loading
the resulting file system yields the same representation and contains
errors only if the original metadata also contained errors. These
properties are based on the general correctness conditions that have
been proposed for bidirectional transformations in the context of
lenses~\cite{lenses}, but are generalized here to accommodate the
inconsistencies that can arise when working with imperfect, ad hoc
data. The proofs of these theorems can be found in
Appendix~\ref{sec:proof-appendix}. 

