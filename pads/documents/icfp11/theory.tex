\section{A Core Calculus for \forest{}}
\label{sec:theory}
\newcommand{\us}{\ensuremath{\_\!\_}}
\newcommand{\defeq}{\ensuremath{\triangleq}}
\renewcommand{\bnfdef}{\ensuremath{\mathord{::=}}}
\newcommand{\slsh}{\ensuremath{\mathord{\textsf{/}}}}
\newcommand{\File}[1]{\ensuremath{\mathsf{File}(#1)}}
\newcommand{\Dir}[1]{\ensuremath{\mathsf{Dir}(#1)}}
\newcommand{\Link}[1]{\ensuremath{\mathsf{Link}(#1)}}
\newcommand{\List}[1]{\ensuremath{[ #1 ]}}
\newcommand{\Set}[1]{\ensuremath{\{ #1 \}}}
\newcommand{\Map}[1]{\ensuremath{\{\!\mid #1 \mid\!\}}}
\newcommand{\FAppend}{\ensuremath{\text{++}}}
\newcommand{\FUpdate}[3]{\ensuremath{#1[#2 := #3]}}
\newcommand{\FDelete}[2]{\ensuremath{\FUpdate{F}{r}{\bot}}}
\newcommand{\PNil}{\ensuremath{\bullet}}
\newcommand{\PCons}[2]{\ensuremath{#1\,\textsf{/}\,#2}}
\newcommand{\Just}[1]{\ensuremath{\mathsf{Just(#1)}}}
\newcommand{\Nothing}{\ensuremath{\mathsf{Nothing}}}
\newcommand{\True}{\ensuremath{\mathsf{True}}}
\newcommand{\False}{\ensuremath{\mathsf{False}}}
\newcommand{\fn}[2]{\ensuremath{#1(#2)}}
\newcommand{\Sk}{k^{\tau_m}_{\tau_r}}
\newcommand{\SAdhoc}[1]{\ensuremath{\mathsf{Adhoc}({#1}^{\tau_m}_{\tau_r})}}
\newcommand{\SPred}[1]{\ensuremath{\mathsf{Pred}(#1)}}
\newcommand{\SPath}[2]{\ensuremath{#1\,{::}\,#2}}
\newcommand{\SPair}[3]{\ensuremath{\langle #1 {:} #2, #3 \rangle}}
\newcommand{\SOption}[1]{\ensuremath{(#1)?}}
\newcommand{\SComp}[3]{\ensuremath{[ #1 \mid #2 \in #3 ]}}
\newcommand{\Env}{\ensuremath{\mathcal{E}}}
\newcommand{\ENil}{\ensuremath{\bullet}}
\newcommand{\yields}{\ensuremath{\rightsquigarrow}}
\newcommand{\valid}[1]{\ensuremath{\mathit{valid}(#1)}}
\newcommand{\typ}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\meta}{\typ{att}}
\newcommand{\REP}{\ensuremath{\mathit{REP}}}
\newcommand{\MD}{\ensuremath{\mathit{MD}}}
\newcommand{\md}[1]{\ensuremath{(#1)~\mathit{md}}}
\newcommand{\eval}[3]{\ensuremath{[\![#1]\!]^{#2}_{#3}}}
\newcommand{\pfile}{\ensuremath{\mathsf{File}}}
\newcommand{\pdir}{\ensuremath{\mathsf{Dir}}}
\newcommand{\plink}{\ensuremath{\mathsf{Link}}}
\newcommand{\att}{\ensuremath{\mathsf{a}}}
\newcommand{\defaultatt}{\ensuremath{\att_{\mathsf{default}}}}
\newcommand{\repty}[1]{{\cal R}[\![ #1 ]\!]}
\newcommand{\mdty}[1]{{\cal M}[\![ #1 ]\!]}
\newcommand{\loadkname}[1]{\ensuremath{\mathit{load}_{#1}}}
\newcommand{\storekname}[1]{\ensuremath{\mathit{store}_{#1}}}
\newcommand{\storek}[5]{\fn{\storekname{#1}}{#2,#3,#4,#5}}
\newcommand{\loadk}[4]{\fn{\loadkname{#1}}{#2,#3,#4}}
\newcommand{\stringty}{{string}}
\newcommand{\metapdty}{\meta}
\newcommand{\load}[5]{#1;#3~\models~#4~~#2~\rhd~(#5) }
\newcommand{\store}[6]{#1;#3~\models~#5~~(#6)~\lhd~(#2,#4) }

\begin{figure}
\[
\begin{array}{rr@{\;}r@{\;}l}
\textit{Strings}        & n & \in & \Sigma^{\ast} \\[1ex]
\textit{Paths}          & r,s & \bnfdef & \PNil \mid \PCons{r}{n} \\[1ex]
\textit{Attributes}     & \att  & \bnfdef & \dots\\[1ex]
\textit{Filesystem}     & T  & \bnfdef & \File{n} \\
                        &    & \bnfalt & \Link{r}\\
\textit{Contents}       &    & \bnfalt & \Dir{ \Set{n_1,\dots,n_k} }\\[1ex]
\textit{Filesystems}    & F & \bnfdef & \Map{ r_1 \mapsto (\att_1,T_1), \dots, r_k \mapsto (\att_k,T_k) }\\[1ex]
\textit{Values}         & v & \bnfdef & \att \bnfalt n \bnfalt r \bnfalt \True \bnfalt \False \bnfalt () \bnfalt (v_1,v_2) \\
                        &   & \bnfalt & \Just{v} \bnfalt \Nothing \bnfalt \List{v_1,\dots,v_k}\\
\textit{Expressions}    & e & \bnfdef & x \bnfalt v \bnfalt \dots \\[1ex]
\textit{Environments}   & \Env & \bnfdef & \ENil \bnfalt E,x\mapsto v \\[1ex]
\textit{Specifications} & s & \bnfdef & \Sk 
                              \bnfalt \SPath{e}{s}
                              \bnfalt \SPair{x}{s_1}{s_2}\\[1ex]
                        &   & \bnfalt & \SComp{s}{x}{e}
                              \bnfalt \SPred{e}
                              \bnfalt \SOption{s}
\end{array}
\]
\label{fig:calculus-syntax}
\caption{\forest{} calculus syntax}
\end{figure}

This section describes a core calculus that formalizes the essential
features of \forest{} precisely in a simple setting. It is inspired by
classical (\ie{}, not separating, substructural or ambient) unordered
tree logics, customized for file systems. We used this calculus to
investigate various features and prove theorems (such as the
round-tripping properties presented at the end of this section) as we
developed \forest{}.

\paragraph*{File system model.}
%
Figure~\ref{fig:calculus-syntax} presents the formal file system
model. A path $r$ is a sequence of strings\footnote{For simplicity, we
  ignore the special path elements ``..'' and ``.''.  It would be easy
  to add these features, at the cost of complicating the semantics.}
and a file systems $F$ is finite map from paths to pairs of attributes
$\att$ and file system contents $T$.  We leave attributes abstract but
expect that they include the usual fields: owner, group, date
modified, {\it etc.}  The attribute $\defaultatt$ contains default
values for all fields. The contents $T$ of a node in the file system
is either a file $\File{n}$ (where $n$ is the string contents of the
fiel), a symbolic link $\Link{r}$ (where $r$ is the path pointed to by
the link), or a directory $\Dir{\Set{n_1,\dots,n_k}}$ (with paths
$n_1$ to $n_k$). We write $\dom{F}$ for the set of paths defined in
$F$, $F(r)$ for the contents at $r$, and $F(r) = \bot$ when $r$ is not
in $\dom{F}$.

A file system $F$ is {\em well-formed} if it encodes a tree with
directories at the internal nodes and files and symbolic links at the
leaves. More formally, we say that $F$ is well-formed if
%
\begin{itemize}
\item $\dom{F}$ is prefix-closed,
\item $F(r) = (\att,\Dir{ \Set{n_1,\dots,n_k} }) \implies$\\ \hspace*{3.3mm}$\forall i \in \{1,\dots,k\}.~\PCons{r}{n_i} \in \dom{F}$, and
\item $F(r) = (\att,\File{n_r}) \vee F(r) = (\att,\Link{r'}) \implies$\\ \hspace*{3.3mm}$\forall n.~\PCons{r}{n} \not\in \dom{F}$.
\end{itemize}
%
Note that although the structure of a well-formed file system is
tree-shaped, cycles can be also expressed using symbolic links that
point ``up'' in the file system.

\paragraph{File system specifications.}
%
Figure~\ref{fig:calculus-syntax} presents the syntax of file system
specifications $s$.  We leave the syntax of expression language
abstract but assume that it contains values $v$, variables $x$, and
other operators (in the full \forest{} language, expressions can be
arbitrary Haskell code).  An environment $\Env$ maps variables to
values.  The semantic function $\eval{e}{\Env,r}{\tau}$ evaluates an
expression $e$ in the environment $\Env$ at path $r$, yielding a value
$v$ of type $\tau$.

The simplest file system specifications are constants $\Sk$, which
range over specifications for files (\pfile), directories (\pdir),
links (\plink), and \padshaskell{}-described files (\SAdhoc{b}). The
type annotations $\tau_r$ and $\tau_m$ are described below. In
addition, we assume that each constant has associated functions
$\loadkname{k}$ and $\loadkname{k}$. For example, the $\loadkname{}$
function for the \pfile{} construct, which describes any file (but not
symbolic links or directories), is defined as follows:
%
\[
\loadkname{\pfile}~(\Env,F,r) =
\begin{cases}
  (n,(\True,\att)), \mathrm{if } F(r) = (\att,\File{n}) \\
  ("",(\False,\defaultatt)), \mathrm{otherwise}\\
\end{cases}
\]
%
It either returns the contents and attributes of the file at path $r$
if it exists, or $""$ and default attributes if $F$ does not contain a
file at $r$. The load functions for the \plink{} and \pdir{} constants
are similar. The load function for \SAdhoc{b}{} reads the file system
in the same way as \pfile{}, but invokes $b$ parser to produce the
final representation.  The $\storekname{}$ function for \pfile{} is
defined as follows:
%
\[
\begin{array}{l}
\storekname{\pfile}~(\Env,F,r,v,d) =\\[.5ex]
\quad 
\begin{cases}
  (\FUpdate{F}{r}{(\att,\File{v})},            & \text{if}~d = (\True,\att)\\
   \; \phi'(F') = (F'(r) = (\att,\File{v})))\\[1ex]
  \FDelete{F}{r},                              & \text{if}~d = (\False,\att)~\wedge\\
   \; \phi'(F') = F'(r) \neq (\us,\File{\us})) & \;\;\; F(r) = (\us,\File{\us})\\[1ex]
  F,              & \text{otherwise}\\
   \; \phi'(F') = F'(r) \neq (\us,\File{\us}))\\
\end{cases}
\end{array}
\]
It produces two results: an update file system $F'$ and a predicate
$\phi'$ that records the constraints needed to ensure
consistency. Given a representation $v$ and metadata $d$, it
overwrites the contents of the file system $F$ at path $r$ to
$(\att,File{v})$ if $d$ is valid (and contains $\att$), deletes the
contents of $F$ at $r$ if $d$ is not valid but $F(r)$ contains a file,
and otherwise returns $F$ unchanged. The predicate $\phi'$ requires
that $F'(r)$, the contents of the new file system $F'$ at $r$, be
$\File{v}$ in first case and that $F'(r)$ not be a file in the other
two cases. These constraints are needed to ensure properties such as
the round-tripping properties presented at the end of this section.

In the \forest{} surface syntax, records and paths are specified using
a single construct (and similarly for comprehensions) while the core
calculus models (dependent) records, paths, and comprehensions as
independent, orthogonal constructs.  Path specifications are written
$\SPath{e}{s}$, where $e$ is a path name (to be appended to the
current path) and $s$ specifies a fragment of the file system at that
path. Record specifications are written \SPair{x}{s_1}{s_2}, where $x$
may appear in $s_2$. Comprehension specifications are written
$\SComp{s}{x}{e}$, where $e$ is an expression that describes a set of
values, $x$ is a variable, and $s$, which may depend on $x$, specifies
a fragment of the file system for each value of $x$.  For example, the
specification
\begin{center}
\cd{\{c \kw{is} "c.txt" :: C, d \kw{is} "d.txt" :: D c\}} 
\end{center}
is encoded in the calculus as
%
\[
\SPair{x\,}{\,(\SPath{\texttt{"}\mathtt{c.txt}\texttt{"}}{C})}{(\SPath{\texttt{"}\mathtt{d.txt}\texttt{"}}{D\; x})}, 
\]
Similarly, the comprehension
\begin{center}
\cd{[c :: C | c <- \kw{matches} (GL "*")]} 
\end{center}
is encoded as: \(\SPair{x}{\pdir}{\SComp{\SPath{y}{C}}{y}{x}}
\). Predicate specifications $\SPred{e}$ succeed when $e$ evaluates to
\True{} and fail when $e$ evaluates to \False{} under the current
environment.  A \forest{} constraint of the form \cd{s \kw{where} e}
is encoded in the calculus using a dependent pair and a predicate:
$\SPair{x}{s}{\SPred{e[x/\mathtt{this}]}}$ Finally, maybe
specifications are written as $\SOption{s}$ in the calculus.

\begin{figure}
\[
\begin{array}{l|l|l}
s & \repty{s} = & \mdty{s} =  \\
\hline
\Sk & \tau_r &  \tau_m~\mathit{md} \\
\SPath{e}{s} & \repty{s} & \mdty{s} \\
\SPair{x}{s_1}{s_2} & \repty{s_1} \times \repty{s_2} & \md{\mdty{s_1} \times \mdty{s_2}} \\
\SComp{s}{x}{e} & \repty{s}~\typ{list} & \md{\mdty{s}~\typ{list}}    \\
\SPred{e} & \typ{unit} & \typ{unit}~\mathit{md}\\
\SOption{s} & \repty{s}~\typ{option} & \md{\mdty{s}~\typ{option}} %\\
\end{array}
\]
\caption{\forest{} calculus representation and metadata types}
\label{fig:calculus-types}
\end{figure}


\begin{figure*}
\begin{minipage}[t]{.45\textwidth}
\fbox{$\load{\Env}{F}{r}{s}{v,d}$}
\[
\begin{array}{c}
\infrule
{ }
{ \load{\Env}{F}{r}{\Sk}{ \loadk{k}{\Env}{F}{r} } }
{ }
\\[1.5em]
\infrule
{ \load{\Env}{F}{\eval{\PCons{r}{e}}{\Env,r}{\mathit{path}}}{s}{v,d} }
{ \load{\Env}{F}{r}{\SPath{e}{s}}{v,d} }
{ }
\\[1.5em]
\infrule
{ \begin{array}{c}
  \load{\Env}{F}{r}{s_1}{ v_1,d_1 } \\
  \load{\Env[x \mapsto v_1]}{F}{r}{s_2}{ v_2,d_2 }\\
  b = \valid{d_1} \wedge \valid{d_2}
  \end{array} }
{ \load{\Env}{F}{r}{\SPair{x}{s_1}{s_2}}{ (v_1,v_2),(b, (d_1,d_2)) } }
{ }
\\[1.5em]
\infrule
{ \begin{array}{c}
  \eval{e}{\Env,r}{(\tau\ \mathit{list})} = [w_1,\dots,w_k ]\\
  \forall i \in \{1,\dots,k\}.~\load{\Env[x \mapsto w_i]}{F}{r}{s}{v_i,d_i}\\
  b = \bigwedge_i^k \valid{d_i} \quad \mathit{vs} = [v_1,\dots,v_k] \quad \mathit{ds} = [d_1,\dots,d_k] 
  \end{array} }
{ \load{\Env}{F}{r}{ \SComp{s}{x}{e} }{ \mathit{vs},(b,\mathit{ds}) } }
{ }
\\[1.5em]
\infrule
{ b = \eval{e}{\Env,r}{\mathit{bool}} }
{ \load{\Env}{F}{r}{ \SPred{e} }{ (),(b,()) } }
{ }
\\[1.5em]
\infrule
{ r \not\in \dom{F} }
{ \load{\Env}{F}{r}{ \SOption{s_1} }{ \Nothing,(\False,\Nothing) } }
{ }
\\[1.5em]
\infrule
{ r \in \dom{F} \quad \load{\Env}{F}{r}{s_1}{v_1,d_1} }
{ \load{\Env}{F}{r}{ \SOption{s_1} }{ \Just{v_1},(\valid{d_1},\Just{d_1}) } }
{ }
\\[1.5em]
\end{array}
\]
\end{minipage}\hfill\vrule\hfill\begin{minipage}[t]{.5\textwidth}
\fbox{$\store{\Env}{F}{r}{v,d}{s}{F',\phi'}$}\\
\[
\begin{array}{c}
\infrule
{ }
{ \store{\Env}{F}{r}{v,d}{\Sk}{ \storek{k}{\Env}{F}{r}{v,d} } }
{ }
\\[1.5em]
\infrule
{ \store{\Env}{F}{\eval{\PCons{r}{e}}{\Env,r}{\mathit{path}}}{v,d}{s}{F',\phi'} }
{ \store{\Env}{F}{r}{v,d}{\SPath{e}{s}}{F',\phi' } }
{ }
\\[1.5em]
\infrule
{ \begin{array}{c}
  \store{\Env}{F}{r}{  v_1,d_1 }{s_1}{ F_1',\phi_1 } \\
  \store{\Env[x \mapsto v_1]}{F}{r}{ v_2,d_2 }{s_2}{ F_2',\phi_2 } \\
  \phi'(F') = (b = \valid{d_1} \wedge \valid{d_2}) \wedge \phi_1'(F') \wedge \phi_2'(F')
  \end{array} }
{ \store{\Env}{F}{r}{ (v_1,v_2),(b,(d_1,d_2)) }{\SPair{x}{s_1}{s_2}}{ F_1' \FAppend F_2',\phi' } }
{ }
\\[1.5em]
\infrule
{ \begin{array}{c}  
  \mathit{vs} = [v_1,\dots,v_j] \quad \mathit{ds} = [d_1,\dots,d_l]\\
  \eval{e}{\Env,r}{(\tau\ \mathit{list})} = [w_1,\dots,w_m ] \quad  k = \min{(j,l,m)} \\
  \forall i \in \{1,\dots,k\}.~\store{\Env[x \mapsto w_i]}{F}{r}{v_i,d_i}{s}{F_i',\phi_i'}\\
  \phi'(F') = (j = l = m) \wedge (b = \bigwedge_i^k \valid{d_i}) \wedge (\bigwedge_i^k \phi_i'(F'))\\
  \end{array} }
{ \store{\Env}{F}{r}{\mathit{vs},(b,\mathit{ds})}{ \SComp{s}{x}{e} }{ F_1' \FAppend \dots \FAppend F_k',\phi' } }
{ }
\\[1.5em]
\infrule
{ \phi'(F') = (b = \eval{e}{\Env,r}{\mathit{bool}}) }
{ \store{\Env}{F}{r}{(),(b,())}{ \SPred{e} }{ F,\phi' } }
{ }
\\[1.5em]
\infrule
{ \begin{array}{c}
  \store{\Env}{F}{r}{ v_1,d_1 }{ s_1 }{ F',\phi_1' }\\
  \phi'(F') = (b = \valid{d_1}) \wedge (r \in \dom{F'}) \wedge \phi_1'(F')
  \end{array} }
{ \store{\Env}{F}{r}{ \Just{v_1},(b,\Just{d_1}) }{ \SOption{s_1} }{ F',\phi' } }
{ }
\\[1.5em]
\infrule
{ \begin{array}{c}
  v = \Nothing \vee d = \Nothing\\
  \phi'(F') = (v = \Nothing) \wedge (d = \Nothing) \wedge \neg b \wedge r \not\in \dom{F'}
  \end{array} }
{ \store{\Env}{F}{r}{ v,(b,d) }{ \SOption{s_1} }{ \FDelete{F'}{r},\phi' } }
{ }
\\[1.5em]
\end{array}
\]
\vfill
\end{minipage}
\centerline{\hfill (a) \hfill\hfill \hspace*{.05\textwidth} (b) \hfill}
\caption{\forest{} calculus semantics for (a) loading and (b) storing}
\label{fig:calculus-semantics}
\end{figure*}



\paragraph*{Calculus Semantics.}
%
The semantics of the calculus is organized into three separate
definitions, one for each of the three artifacts generated by the
\forest{} compiler.

Figure~\ref{fig:calculus-types} defines types for the representations
($\repty{s}$) and metadata ($\mdty{s}$) generated by specifications
$s$. The types for constants $\Sk$ are read off from their annotations
while the types for other specifications are constructed from their
structure in the obvious way---\eg, the type of representations for
\SPair{x}{s_1}{s_2} is a product $(\repty{s_1} \times
\repty{s_2}$. The type constructor $\mathit{md}$ provides a uniform
representation for metadata and is defined as follows:
\[
\begin{array}{lcl}
\tau~\mathit{md} & = & \typ{header} \times \tau \\
\typ{header} & = & \typ{bool} 
\end{array}
\]
The function $\valid{d}$ extracts the boolean from the metadata
structure $d$, returning $\True$ if there are no errors in the
structure and $\False$ otherwise. \jnf{Should this come later---\ie,
  after defining the load judgment?} Our semantics obeys the following
basic coherence property, which says that the load function for
specifications $s$ generates representations and metadata belonging to
$\repty{s}$ and $\mdty{s}$ respectively:
%
\begin{proposition}
  If $\load{\Env}{F}{r}{s}{v,d}$ and $\repty{s} = \tau_{\mathcal{R}}$
  and $\mdty{s} = \tau_{\mathcal{M}}$ then $\turn v :
  \tau_{\mathcal{R}}$ and $\turn d : \tau_{\mathcal{M}}$,
\end{proposition}
%
The judgment $\turn v : \tau$ states that $v$ has type $\tau$.

The inference rules on the left side of
Figure~\ref{fig:calculus-semantics} define the semantics of the load
function. Intuitively, the judgment $\load{\Env}{F}{r}{s}{v,d}$ states
that in environment $\Env$ and file system $F$, the specification $s$
matches the file system fragment at path $r$ and produces the
representation $v$ and metadata $d$. This judgment may also be viewed
as a total function from $\Env$, $F$, $r$ and $s$ to $(v,d)$. The
judgment is total because when $F$ fails to match $s$, the load
function generates defaults in the representation $v$ and records
errors in the metadata $d$.  This design allows a programmer to
explore a file system fragment even if it contains errors.

Let us examine a few of the inference rules that define the store
function in detail. The rule for constants $\Sk$ just invokes the
associated $\loadkname{}$ function for $k$. The rule for
$\SComp{s}{x}{e}$ comprehensions is more interesting: it first
evaluates $e$ to a list $[w_1,\dots,w_k]$ and then invokes the store
function for $s$ $k$ times in environments where $x$ is bound to each
$w_i$. It then collects up the results into lists of reprsentations
$[v_1,\dots,v_k]$ and metadata $[d_1,\dots,d_k]$, which is uses as the
final result. The predicate $\SPred{e}$ construct tests whether an
expression $e$ is satisfied. It returns $()$ as the representation and
$(\eval{e}{\Env,r}{\mathit{bool}},())$ as the metadata. Finally,
$\SOption{s}$ invokes $s$'s load function if the current path $r$
exists in the file system, injecting the result into the maybe type
using $\mathsf{Just}$, and otherwise returns $\Nothing$.

The inference rules on the right side of
Figure~\ref{fig:calculus-semantics} define the store function. The
judgment $\store{\Env}{F}{r}{v,d}{s}{F',\phi'}$ states that in
environment $\Env$ storing $(v,d)$ into file system $F$ using
specification $s$ yields the file system $F'$ and predicate
$\phi'$. The predicate $\phi'$ tracks the conditions on the file
system needed to ensure that it accurately reflects the information in
the representation and metadata.

As a simple example to illustrate why predicates are needed, consider
the specification $s = \SPair{x}{\pfile}{\pfile}$ and suppose that the
load function is called in an environment $\Env$ with a file system
$F$ and path $r$ where $F(r) = (\att,\File{n})$. The representation
returned by load will be a pair $(n,n)$ containing two copies of the
file contents and the metadata will also contain a pair
$(\True,(\True,\att),(\True,\att)))$ with two copies of the metadata
associated to that file. Now suppose that we change the representation
to $(n,n')$, with $n \neq n'$, and we store the result back to the
file system. Unfortunately, because the representation is
inconsistent---it does not satisfy the dependency between the two
components of the pair implied by $s$---the store function cannot
produce a new file system containing the information in both $n$ and
$n'$. Thus, it must store one and discard the other. The predicate
$\phi'$ generated by the store function provides a way to track and
report inconsistencies. The predicate generated by the store function
for $s$ would express the constraint that the file at $r$ be equal to
$n$ and $n'$, 
%
\[
\phi'(F') = (F'(r) = (\att,\File{n})) \wedge (F'(r) = (\att,\File{n}))
\]
%
which is obviously not satisfiable when $n' = n$. \jnf{Say more to
  connect these to manifests?}

Let us examine a few of the inference rules in detail. The rule for
constants $\Sk$ simply invokes the $\storekname{}$ function for
$k$. The rule for path specifications $\SPath{e}{s}$ passes off
control to the store function for $s$ after replacing the current path
$r$ with $\eval{\PCons{r}{e}}{\Env,r}{\mathit{path}}$. The rule for
dependent pairs $\SPair{x}{s_1}{s_2}$ is more interesting. Given a
pair $(v_1,v_2)$ as the representation, it first invokes the store
function for $s_1$ with $v_1$, producing an updated file system $F_1'$
and predicate $\phi_1'$. Next, it invokes the store function for $s_2$
with $v_2$ in an extended environment where $x$ is bound to $v_1$,
yielding another updated file system $F_2'$ and $\phi_2$'. It combines
the updated file systems using the following right-biased
concatenation operator,
%
\[
\begin{array}{l}
(F_1 \FAppend F_2)(r) = \\
\qquad 
\begin{cases}
  (\att_2,\Dir{N_1 \cup N_2}) & \text{if}~F_1(r) = (\att_1,\Dir{N_1}) \; \wedge \\
                              & \;\;\; F_2(r) = (\att_2,\Dir{N_2})\\
  F_1(r) & \text{if}~F_2(r) = \bot\\
  F_2(r) & \text{otherwise}\\
\end{cases}
\end{array}
\]
%
Finally, it combines the predicates using conjunction. The result is a
file system that contains the consistent changes made to the file
system by the store functions for $s_1$ and $s_2$ as well as a
predicate that checks for the consistency of all of their changes. 

The correctness of our semantics is captured by two round-tripping
properties, expressed in the following theorems:
%

\deferproof{theorem}{loadstore}{LoadStore}{%
  For all environments $\Env$, file systems $F$, paths $r$,
  specifications $s$, representations $v$, and metadata $d$ with
  $\load{\Env}{F}{r}{s}{v,d}$ and
  $\store{\Env}{F}{r}{v,d}{s}{F',\phi}$ we have $F = F'$ and
  $\phi'(F')$.}{%
  The proof is by induction on $s$. We assume that $\loadkname{k}$ and
  $\storekname{k}$ obey the theorem for every constant $\Sk$.
\begin{description}
%%%
%%% CONST
%%%
\item[Case:] $s = \Sk$\\[1ex]
%
By the definitions of the load and store functions we have 
\[ 
\begin{array}{rcl}
v,d  &=& \loadk{k}{\Env}{F}{r}\\
F',\phi' &=& \storek{k}{\Env}{F}{r}{v,d}\\
\end{array}
\]
By assumptions about the behavior of $\loadkname{k}$ and
$\storekname{k}$, we have $F' = F$ and $\phi'(F')$, which finishes
the case.

%%%
%%% PATH
%%%
\item[Case:] $s=\SPath{e}{s_1}$\\[1ex]
%
By the definitions of the load and store functions we have 
\[ 
\begin{array}{l}
\load{\Env}{F}{r'}{s_1}{v,d}\\
\store{\Env}{F}{r'}{v,d}{s_1}{F',\phi'}\\
\end{array} \hspace*{2cm}
\begin{array}{rcl}
r' &=& \eval{\PCons{r}{e}}{\Env,r}{\mathit{path}}\\
\end{array}
\]
By the induction hypothesis applied to $s_1$ we have $F' = F$ and
$\phi'(F')$, which finishes the case.

%%%
%%% Pair
%%%
\item[Case:]$s = \SPair{x}{s_1}{s_2}$:]\\[1ex]
%
By the definitions of the load and store functions we have 
\[ 
\begin{array}{l}
\load{\Env}{F}{r}{s_1}{v_1,d_1}\\
\store{\Env}{F}{r}{v_1,d_1}{s_1}{F_1',\phi_1'}\\
\load{\Env[x \mapsto v_1]}{F}{r}{s_2}{v_2,d_2}\\
\store{\Env[x \mapsto v_1]}{F}{r}{v_2,d_2}{s_2}{F_2',\phi_2'}\\
\end{array} \hspace*{2cm}
\begin{array}{rcl}
b &= & \valid{d_1} \wedge \valid{d_2}\\
v &=& (v_1,v_2)\\
d &=& (b,(d_1,d_2))\\
F' &=& F_1' \FAppend F_2'\\
\phi'(F') &=& (b = \valid{d_1} \wedge \valid{d_2}) \wedge \phi_1'(F') \wedge \phi_2'(F')\\
\end{array}
\]
By the induction hypothesis applied to $s_1$, we have $F_1' = F$ and
$\phi_1'(F_1')$. Likewise, by the induction hypothesis applied to
$s_2$, we have $F_2' = F$ and $\phi_2'(F_2')$. We immediately have
$\phi'(F')$ and $F' = F$ as (\FAppend) is idempotent, which finishes
the case.

%%%
%%% Comprehension
%%%
\item[Case:] $s = \SComp{s_1}{x}{e}$\\[1ex]
%
By the definitions of the load and store functions we have 
\[ 
\begin{array}{l}
\eval{e}{\Env,r}{(\tau\ \mathit{list})} = [w_1,\dots,w_k ]\\
\forall i \in \{1,...,k\}.\,\load{\Env[ x \mapsto w_i]}{F}{r}{s_1}{v_i,d_i}\\
\forall i \in \{1,...,k\}.\,\store{\Env[x \mapsto w_i]}{F}{r}{v_i,d_i}{s}{F_i',\phi_i'}\\
\end{array}\hspace*{.75cm}\begin{array}{rcl}
v &=& [v_1,\dots,v_k]\\
b &= &\bigwedge_i^k \valid{d_i}\\
d &=& (b,[d_1,\dots,d_k])\\
F' &=& F_1' \FAppend \dots \FAppend F_k'\\
\phi'(F') &=& (k = k = k) \wedge (b = \bigwedge_i^k \valid{d_i}) \wedge (\bigwedge_i^k \phi_i'(F'))\\
\end{array}
\]
By the induction hypothesis applied to $s$ ($k$ times), we have $F_i'
= F$ and $\phi'_i(F_i')$ for $i$ from $1$ to $k$. We immediately have
$\phi'(F')$ and $F' = F$ as (\FAppend) is idempotent, which finishes
the case.

%%%
%%% Predicate
%%%
\item[Case:] $s = \SPred{e}$\\[1ex]
%
By the definition of the load and store functions we have
\[
\begin{array}{rcl}
v &=& ()\\
d &=& (b,())\\
b &=& \eval{e}{\Env,r}{\mathit{bool}}\\
\end{array}\hspace*{2cm}\begin{array}{rcl}
F' &=& F\\
\phi'(F') &=& (b = \eval{e}{\Env,r}{\mathit{bool}})\\
\end{array}
\]
Thus, we immediately have $F' = F$ and $\phi'(F')$.

%%%
%%% Option
%%%
\item[Case:] $s = \SOption{s_1}$\\[1ex]
%
We analyze two subcases:
\begin{description}
\item[Subcase:] $r \in \dom{F}$\\[1ex]
%
By the definition of the load and store functions we have
\[ 
\begin{array}{l}
\load{\Env}{F}{r}{s}{v_1,d_1}\\
\store{\Env}{F}{r}{v_1,d_1}{s}{ F',\phi_1' }\\
\end{array}\hspace*{2cm}\begin{array}{rcl}
v &=& \Just{v_1}\\
d &=& (b,\Just{d_1})\\
b &=& \valid{d_1}\\
\phi'(F') &=& (b = \valid{d_1}) \wedge (r \in \dom{F}) \wedge \phi_1'(F')\\
\end{array}
\]
%
By the induction hypothesis applied to $s_1$ we have $F' = F$ and
$\phi_1'(F')$. We immediately have $\phi'(F')$.

\item[Subcase:] $r \not\in \dom{F}$\\[1ex]
%
By the definition of the load and store functions we have 
\[ 
\begin{array}{rcl}
v &=& \Nothing\\
d &=& (b,d_1)\\
d_1 &=& \Nothing\\
b &=& \False\\
\end{array}\hspace*{2cm}\begin{array}{rcl}
F' &=& \FDelete{F}{r}\\
\phi'(F') &=& (v = \Nothing) \wedge (d_1 = \Nothing) \wedge (\neg b) \wedge  (r \not\in \dom{F'})
\end{array}
\]
We immediately have $F' = F$ and $\phi'(F')$, which finishes the case
and the inductive proof. \hfill \qed
\end{description}
\end{description}
}

\deferproof{theorem}{storeload}{StoreLoad}{ For all environments
  $\Env$, file systems $F$ and $F'$, paths $r$, specifications $s$,
  representations $v$ and $v'$, metadata $d$ and $d'$, and constraints
  $\phi'$ with $\store{\Env}{F}{r}{v,d}{s}{F',\phi'}$ and $\phi'(F')$
  and $\load{\Env}{F'}{r}{s}{v',d'}$ we have $v' = v$ and $\valid{d} =
  \valid{d'}$.}{%
  We will prove a slightly stronger result that implies the theorem:
  for all environments $\Env$, file systems $F$, $G_1$, $G_2$, and
  $F'$, paths $r$, specifications $s$, representations $v$ and $v'$,
  metadata $d$ and $d'$, and constraints $\phi'$ with
  $\store{\Env}{F}{r}{v,d}{s}{F',\phi'}$ and $\phi'(G_1 \FAppend F'
  \FAppend G_2)$ and $\load{\Env}{(G_1 \FAppend F' \FAppend
    G_2)}{r}{s}{v',d'}$ we have $v' = v$ and $\valid{d} =
  \valid{d'}$. The proof is by induction on $s$. We assume that
  $\loadkname{k}$ and $\storekname{k}$ obey the theorem for every
  constant $\Sk$.
\begin{description}
%%%
%%% Constant
%%%
\item[Case]: $s = \Sk$\\[1ex]
%
By the definitions of the load and store functions we have 
\[ 
\begin{array}{rcll}
F',\phi &=& \storek{k}{\Env}{F}{r}{v,d}\\
v',d'  &=& \loadk{k}{\Env}{(G_1 \FAppend F' \FAppend G_2)}{rs}\\
\end{array}
\]
By assumptions about the behavior of $\loadkname{k}$ and
$\storekname{k}$, we have $v' = v$ and $\valid{d} = \valid{d'}$,
which finishes the case. 

%%%
%%% Path
%%%
\item[Case:] $s=\SPath{e}{s_1}$\\[1ex]
%
By the definitions of the load and store functions we have
\[
\begin{array}{l}
\store{\Env}{F}{r'}{v,d}{s_1}{F',\phi'}\\
\load{\Env}{(G_1 \FAppend F' \FAppend G_2)}{r'}{s_1}{v',d'}\\
\end{array}\hspace*{2cm}\begin{array}{rcl}
r' &=& \eval{\PCons{r}{e}}{\Env,r}{\mathit{path}}\\
\end{array}
\]
%
By the induction hypothesis applied to $s_1$ we have $v' = v$ and
$\valid{d} = \valid{d'}$, which finishes the case.

%%%
%%% Pair
%%%
\item[Case:] $s = \SPair{x}{s_1}{s_2}$\\[1ex]
%
By the definition of the load function we have
\[
\begin{array}{l}
\store{\Env}{F}{r}{v_1,d_1}{s_1}{F_1',\phi_1'}\\
\store{\Env[x \mapsto v_1]}{F}{r}{v_2,d_2}{s_2}{F_2',\phi_2'}\\
\end{array}\hspace*{2cm}\begin{array}{rcl}
v &=& (v_1,v_2)\\
d &=& (b,(d_1,d_2))\\
F' &=& F_1' \FAppend F_2'\\
\phi'(F') &=& (b = \valid{d_1} \wedge \valid{d_2}) \wedge \phi_1'(F') \wedge \phi_2'(F')\\
\end{array}
\]
By $\phi'(G_1 \FAppend F' \FAppend G_2)$ we have
\[
\begin{array}{l}
b = \valid{d_1} \wedge \valid{d_2}\\
\phi_1'(G_1 \FAppend F' \FAppend G_2)\\
\phi_2'(G_1 \FAppend F' \FAppend G_2)\\
\end{array}
\]
%
As $(\FAppend)$ is associative we also have,
\[
\begin{array}{rcl}
(G_1\FAppend (F_1\FAppend F_2)\FAppend G_2) &=& (G_1\FAppend F_1\FAppend (F_2\FAppend G_2))\\
(G_1\FAppend (F_1\FAppend F_2)\FAppend G_2) &=& ((G_1\FAppend F_1)\FAppend F_2\FAppend G_2),\\
\end{array}
\]
and hence:
\[
\begin{array}{l}
\phi_1'(G_1\FAppend F_1\FAppend (F_2\FAppend G_2))\\
\phi_2'((G_1\FAppend F_1)\FAppend F_2\FAppend G_2)\\
\end{array}
\]
By the definition of the load function we have 
\[ 
\begin{array}{rcll}
\load{\Env}{(G_1 \FAppend F_1 \FAppend (F_2 \FAppend G_2))}{r}{s_1}{v_1',d_1'}\\
\load{\Env[x \mapsto v_1}{((G_1 \FAppend F_1) \FAppend F_2 \FAppend G_2)}{r}{s_2}{v_2',d_2'}\\
\end{array}\hspace*{2cm}\begin{array}{rcl}
v' &=& (v_1',v_2')\\
b' &= & \valid{d_1} \wedge \valid{d_2}\\
d' &=& (b',(d_1',d_2'))\\
\end{array}
\]
%
By the induction hypothesis applied to $s_1$ and $s_2$, we have 
\[
\begin{array}{l}
v_1' = v_1\\
v_2' = v_2\\
\end{array}\hspace*{2cm}\begin{array}{l}
\valid{d_1} = \valid{d_1'}\\
\valid{d_2} = \valid{d_2'}\\
\end{array}
\]
It follows that $(v_1,v_2) = (v_1',v_2')$ and $b = b'$, which
finishes the case.

%%%
%%% Comprehension
%%%
\item[Case:] $s = \SComp{s}{x}{e}$\\[1ex]
By the definition of the store function we have
\[
\begin{array}{l}
\forall i \in \{1,\dots,k\}.\,\store{\Env[x \mapsto w_i]}{F}{r}{v_i,d_i}{s}{F_i',\phi_i}\\
\eval{e}{\Env,r}{(\tau\ \mathit{list})} = [w_1,\dots,w_m ]\\
\end{array}\hspace*{.75cm}\begin{array}{rcl}
v &=& [v_1,\dots,v_j]\\
d &=& [d_1,\dots,d_l]\\
k &=& \min{(j,l,m)}\\
F' &=& F_1' \FAppend \dots \FAppend F_k'\\
\phi(F') &=& j = k = l \wedge b = (\bigwedge_i^k \valid{d_i}) \bigwedge_i^k \phi_i(F')\\
\end{array}
\]
By $\phi'(G_1 \FAppend F' \FAppend G_2)$ we have
\[
\begin{array}{l}
k = j = l = m\\
b = (\bigwedge_i^k \valid{d_i})\\
\end{array}\hspace*{2cm}\begin{array}{l}
\forall i \in \{1,\dots,k\}.\,\phi_i'(G_1 \FAppend F' \FAppend G_2) \\
\end{array}
\]
%
Let
\[
H_i = ((G_1\FAppend F_1\FAppend \dots \FAppend F_{i-1}) \FAppend F_i \FAppend (F_{i+1} \FAppend \dots \FAppend F_k \FAppend G_2))
\]
for $i$ from $1$ to $k$. As $(\FAppend)$ is associative we have,
\[
(G_1\FAppend (F_1\FAppend \dots \FAppend F_k)\FAppend G_2) = H_i \quad \text{for}~i \in \{1,\dots,k\}
\]
and hence:
\[
\phi_i'(H_i) \quad \text{for}~i \in \{1,\dots,k\}
\]
%
By the definition of the load function we also have 
\[ 
\begin{array}{l}
\forall i \in \{1,\dots,k\}\,\load{\Env[ x \mapsto w_i]}{H_i}{r}{s_1}{v_i,d_i'}\\
\end{array}\hspace*{2cm}\begin{array}{rcl}
v' &=& [v_1',\dots,v_k']\\
b' &=& \bigwedge_i^k \valid{d_i'}\\
d' &=& (b',[d_1',\dots,d_k'])\\
\end{array}
\]
%
By the induction hypothesis applied to $s$ ($k$ times), we have $v_i'
= v_i$ and $\valid{d_i'} = \valid{d_i}$ for = $i$ from $1$ to
$k$. It follows that $[v_1,\dots,v_k] = [v_1',\dots,v_k']$ and $b =
b'$, which finishes the case.

%%%
%%% Predicate
%%%
\item[Case:] $s = \SPred{e}$\\[1ex]
%
By the definitions of the store and load functions we have
\[
\begin{array}{rcl}
v &=& ()\\
d &=& ((),b)\\
F' &=& F\\
\phi'(F') &=& (b = \eval{e}{\Env,r}{\mathit{bool}})\\
\end{array}\hspace*{2cm}\begin{array}{rcl}
v' &=& ()\\
d' &=& (b',())\\
b' &=& \eval{e}{\Env,r}{\mathit{bool}}\\
\end{array}
\]
By $\phi'(G_1 \FAppend F' \FAppend G_2)$ we have $b =
\eval{e}{\Env,r}{\mathit{bool}}$. It follows that $v = v'$ and $b =
b'$, which finishes the case.

%%%
%%% Option
%%%
\item[Case:] $s = \SOption{s_1}$\\[1ex]
%
We analyze two subcases:
\begin{description}
\item[Subcase:] $v = \Just{v_1}$ and $d = (b,\Just{d_1})$\\[1ex]
%
By the definition of the store function we have
\[
\begin{array}{l}
\store{\Env}{F}{r}{ v_1,d_1 }{s}{F',\phi_1'}\\
\end{array}\hspace*{2cm}\begin{array}{rcl}
\phi'(F') &=& (b = \valid{d_1}) \wedge (r \in \dom{F}) \wedge \phi_1'(F')\\
\end{array}
\]
%
By $\phi'(G_1 \FAppend F' \FAppend G_2)$ we have $b = \valid{d_1}$ and
$r \in \dom{G_1 \FAppend F' \FAppend G_2}$.  By the definition of the
load function we also have
\[ 
\begin{array}{rcll}
\load{\Env}{(G_1 \FAppend F' \FAppend G_2)}{r}{s}{v_1',d_1'}\\
\end{array}\hspace*{2cm}\begin{array}{rcl}
v' &=& \Just{v_1'}\\
b' &=& \valid{d_1'}\\
d' &=& (b',\Just{d_1'})\\
\end{array}
\]
By the induction hypothesis applied to $s_1$ we have $v_1' = v_1$ and
$b' = b$. It follows that $v' = v$.

\item[Subcase:] $r \not\in \dom{F}$\\[1ex]
%
By the definition of the store and load functions we have
\[
\begin{array}{rcl}
F' &=& \FDelete{F}{r}\\
\phi'(F') &=& (v = \Nothing) \wedge (d = \Nothing) \wedge (\neg b) \wedge (r \not\in \dom{F'})\\
\end{array}\hspace*{2cm}\begin{array}{rcl}
v' &=& \Nothing\\
b' &=& \False\\
d' &=& (b',\Nothing)\\
\end{array}
\]
As $\phi'(G_1 \FAppend F' \FAppend G_2)$ we have $v = \Nothing$ and $d
= \Nothing$ and $\neg b$ and $r \not\in \dom{G_1 \FAppend F' \FAppend
  G_2}$. Thus, we immediately have $v' = v$ and $b' = b$, which finishes the case and
the inductive proof. \hfill \qed
\end{description}
\end{description}}

\smallskip

\noindent The first theorem states that loading from a file system $F$
and immediately storing the resulting representation and metadata
yields the original file system and, moreover, it satisfies the
predicate produce by the store function. The second theorem states
that storing an arbitrary representation and metadata and then loading
the resulting file system yields the same representation and contains
errors only if the original metadata also contained errors. These
properties are based on the general correctness conditions that have
been proposed for bidirectional transformations in the context of
lenses~\cite{lenses}, but are generalized here to accommodate the
inconsistencies that can arise when working with imperfect, ad hoc
data. The proofs of these theorems can be found in
Appendix~\ref{sec:proof-appendix}. 

