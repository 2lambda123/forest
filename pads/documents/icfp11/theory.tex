\section{A Core Calculus for \forest{}}
\label{sec:theory}
\renewcommand{\bnfdef}{\ensuremath{\mathord{::=}}}
\newcommand{\slsh}{\ensuremath{\mathord{\textsf{/}}}}
\newcommand{\File}[1]{\ensuremath{\mathsf{File}(#1)}}
\newcommand{\Dir}[1]{\ensuremath{\mathsf{Dir}(#1)}}
\newcommand{\Link}[1]{\ensuremath{\mathsf{Link}(#1)}}
\newcommand{\List}[1]{\ensuremath{[ #1 ]}}
\newcommand{\Map}[1]{\ensuremath{\{\!\mid #1 \mid\!\}}}
\newcommand{\FAppend}{\ensuremath{\mathord{++}}}
\newcommand{\FUpdate}[3]{\ensuremath{#1[#2 := #3]}}
\newcommand{\FDelete}[2]{\ensuremath{\mathsf{Del}~#1(#2)}}
\newcommand{\PNil}{\ensuremath{\bullet}}
\newcommand{\PCons}[2]{\ensuremath{#1\,\textsf{/}\,#2}}
\newcommand{\Just}[1]{\ensuremath{\mathsf{Just(#1)}}}
\newcommand{\Nothing}{\ensuremath{\mathsf{Nothing}}}
\newcommand{\True}{\ensuremath{\mathsf{True}}}
\newcommand{\False}{\ensuremath{\mathsf{False}}}
\newcommand{\fn}[2]{\ensuremath{#1(#2)}}
\newcommand{\Sk}{k^{\tau_m}_{\tau_r}}
\newcommand{\SAdhoc}[1]{\ensuremath{\mathsf{Adhoc}({#1}^{\tau_m}_{\tau_r})}}
\newcommand{\SPred}[1]{\ensuremath{\mathsf{Pred}(#1)}}
\newcommand{\SPath}[2]{\ensuremath{#1\,{::}\,#2}}
\newcommand{\SPair}[3]{\ensuremath{\langle #1 {:} #2, #3 \rangle}}
\newcommand{\SOption}[1]{\ensuremath{#1?}}
\newcommand{\SComp}[3]{\ensuremath{[ #1 \mid #2 \in #3 ]}}
\newcommand{\Env}{\ensuremath{\mathcal{E}}}
\newcommand{\ENil}{\ensuremath{\bullet}}
\newcommand{\yields}{\ensuremath{\rightsquigarrow}}
\newcommand{\valid}[1]{\ensuremath{\mathit{valid}(#1)}}
\newcommand{\typ}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\meta}{\typ{att}}
\newcommand{\REP}{\ensuremath{\mathit{REP}}}
\newcommand{\MD}{\ensuremath{\mathit{MD}}}
\newcommand{\md}[1]{\ensuremath{(#1)~\mathit{md}}}
\newcommand{\eval}[2]{\ensuremath{\mathsf{eval}_{#1}(#2)}}
\newcommand{\pfile}{\ensuremath{\mathsf{F}}}
\newcommand{\ptext}{\ensuremath{\mathsf{T}}}
\newcommand{\pbin}{\ensuremath{\mathsf{B}}}
\newcommand{\pany}{\ensuremath{\mathsf{A}}}
\newcommand{\att}{\ensuremath{\mathsf{a}}}
\newcommand{\defaultatt}{\ensuremath{\att_{\mathsf{default}}}}
\newcommand{\repty}[1]{{\cal R}[\![ #1 ]\!]}
\newcommand{\mdty}[1]{{\cal M}[\![ #1 ]\!]}
\newcommand{\loadk}[3]{\fn{\mathit{ld}}{#1,#2,#3}}
\newcommand{\storek}[4]{\fn{\mathit{st}}{#1,#2,#3,#4}}
\newcommand{\stringty}{{string}}
\newcommand{\metapdty}{\meta}
\newcommand{\load}[5]{#1;#2;#3 \models #4 \yields #5 }
\newcommand{\store}[6]{#1;#2;#3;#4 \models #5 \yields #6 }

\begin{figure}
\[
\begin{array}{rr@{\;}r@{\;}l}
\textit{Strings}        & n & \in & \Sigma^{\ast} \\[1ex]
\textit{Paths}          & r,s & \bnfdef & \PNil \mid \PCons{r}{n} \\[1ex]
\textit{Attributes}     & \att  & \bnfdef & \dots\\[1ex]
\textit{Filesystem}     & T  & \bnfdef & \File{n} \\
\textit{Contents}       &    & \bnfalt & \Dir{ \List{n_1,\dots,n_k} }\\
                        &    & \bnfalt & \Link{r}\\[1ex]
\textit{Filesystems}    & F & \bnfdef & \Map{ r_1 \mapsto (\att_1,T_1), \dots r_k \mapsto (\att_k,T_k) }\\[1ex]
\textit{Values}         & v & \bnfdef & \att \bnfalt n \bnfalt r \bnfalt \True \bnfalt \False \bnfalt () \bnfalt (v_1,v_2) \\
                        &   & \bnfalt & \Just{v} \bnfalt \Nothing \bnfalt \{ v_1,\dots,v_k \}\\
\textit{Expressions}    & e & \bnfdef & x \bnfalt v \bnfalt \dots \\[1ex]
\textit{Environments}   & \Env & \bnfdef & \ENil \bnfalt E,x\mapsto v \\[1ex]
\textit{Specifications} & s & \bnfdef & \Sk 
                              \bnfalt \SAdhoc{b}
                              \bnfalt \SPath{e}{s}
                              \bnfalt \SPair{x}{s_1}{s_2}\\[1ex]
                        &   & \bnfalt & \SComp{s}{x}{e}
                              \bnfalt \SPred{e}
                              \bnfalt \SOption{s}\\[1ex]
\end{array}
\]
\caption{File systems and their specifications}
\label{fig:calculus-syntax}
\end{figure}

We have defined an idealized core calculus that captures the
essence of \forest{}.  This calculus helped us to design various
aspects of the language and provides a compact way of describing the
central features of the language in a precise way.  It is inspired by
classical (\ie{}, not separating, substructural or ambient)
unordered tree logics, customized slightly to our application domain.

\paragraph*{File system model and specification syntax.}
%
Figure~\ref{fig:calculus-syntax} presents the formal file system
model.  File paths $r$ are sequences of string names\footnote{For
  simplicity, we ignore the special path elements ``..'' and ``.''.
  It is easy to add these features, although the semantics becomes
  more complicated because path expressions must be normalized.}  and
file systems $F$ are finite partial maps from paths to pairs of file
attributes $\att$ and file system contents $T$.  We leave the
attribute records abstract; they should include the usual fields:
owner, group, date modified, {\it etc.}  We write $\defaultatt$ for
a default attribute record where necessary.  The contents $T$ of a
node in the file system may be a file $\File{n}$ (with underlying
string contents $n$), a directory $\Dir{ \List{n_1,\dots,n_k} }$ (with
contents named $n_1, \ldots, n_k$) or a symbolic link $\Link{r}$
(where $r$ is the path pointed to by the link).

A file system model $F$ is {\em well-formed} if it is tree-shaped,
with directories forming internal nodes and files and symbolic links
at the leaves.  In addition, these conditions must hold:
\begin{itemize}
\item The domain of $F$ must be prefix-closed.
\item If $F(r) = (\att,\Dir{ \List{n_1,\dots,n_k} })$ then for $i=1,\ldots,k$,
$\PCons{r}{n_i} \in \dom{F}$.
\item  If $F(r) = (\att,\File{n_r})$ or $(\att,\Link{r'})$ then 
there does not exist $n$ such that $\PCons{r}{n} \in \dom{F}$.
\end{itemize}

Figure~\ref{fig:calculus-syntax} also presents the syntax of a simple
computation language $e$ and our file system specifications $s$.  The
computation language $e$ contains values $v$, variables $x$, and other
operators, which we leave unspecified.  An environment $\Env$ maps
variables to values.  The semantic function $\eval{\tau}{\Env,r,e}$
evaluates an expression $e$ in an environment $\Env$ with respect to a
current path $r$, yielding a value $v$ of type $\tau$.

The simplest file system specifications are constants $k$, which range
over basic specifications such as those for files (\pfile), text files
(\ptext), binary files (\pbin), or any file system contents at all
(\pany).

\padshaskell{} specifications are modeled as \SAdhoc{b} where
$b^{\tau_m}_{\tau_r}$ is a parser---i.e., a total function from pairs
of environments and strings to pairs of type $\tau_r \times \tau_m$,
where the first element is the representation for the parsed data and
the second element is its metadata.

\forest{}'s surface syntax combines specifications for records and
paths into a single construct (and similarly for comprehensions and
paths). The calculus models (dependent) records, paths, and
comprehensions as independent, orthogonal constructs.  Record
specifications are written \SPair{x}{s_1}{s_2}, where $x$ may appear
in $s_2$.  Path specifications are written $\SPath{e}{s}$, where $e$
is a path name (to be appended to the current path) and $s$ specifies
a fragment of the file system at that path. Comprehension
specifications are written $\SComp{s}{x}{e}$, where $e$ is a set of
values, $x$ is a variable, and $s$, which may depend on $x$, specifies
a fragment of the file system for each value of $x$.  \forest{}'s
combined record-and-path construct \cd{\{c \kw{is} "c.txt" :: C, d
  \kw{is} "d.txt" :: D c\}} is encoded in the calculus as
$\SPair{x}{(\SPath{\texttt{"}\mathtt{c.txt}\texttt{"}}{C})}{(\SPath{\texttt{"}\mathtt{d.txt}\texttt{"}}{D\;
    x})}$.  Similarly, \forest{}'s comprehension \cd{[x :: s | x <-
  e]} is encoded as the composition of the calculus constructors
$\SComp{s_1}{x}{e}$ and $s_1 = \SPath{x}{s}$.

Predicate specifications $\SPred{e}$ succeed when $e$ evaluates to
\True{} and fail when $e$ evaluates to \False{} under the current
environment.  A \forest{} constraint of the form \cd{s \kw{where} e} is
encoded in the calculus as a dependent pair with a predicate:
$\SPair{x}{s}{\SPred{e[x/\mathtt{this}]}}$

Finally, maybe specifications are written as $\SOption{s}$ in the
calculus.

\begin{figure}
\[
\infrule
{ }
{ \load{\Env}{F}{r}{\Sk}{ \loadk{\Sk}{F}{r} } }
{ }
\]

\[
\infrule
{ F(r) = (\att,\File{n}) \qquad 
  b^{\tau_m}_{\tau_r}(E,n) = v,d }
{ \load{\Env}{F}{r}{\SAdhoc{b}}{ v,(\valid{d},(d,\att)) } }
{ }
\]

\[
\infrule
{ F(r) = (\att,T) \qquad T \neq \File{n} \qquad
  b^{\tau_m}_{\tau_r}(E,\epsilon) = (v,d)
}
{ \load{\Env}{F}{r}{\SAdhoc{b}}{ v,(\valid{d},(d,\att)) } }
{ }
\]

\[
\infrule
{ 
  r \not\in \dom{F}  \qquad
  b(E,\epsilon) = (v,d)
}
{ \load{\Env}{F}{r}{\SAdhoc{b}}{ v,(\False,(d,\defaultatt)) } }
{ }
\]

\[
\infrule
{ \load{\Env}{F}{\eval{path}{E,r,\PCons{r}{e}}}{s}{v,d} }
{ \load{\Env}{F}{r}{\SPath{e}{s}}{v,d} }
{ }
\]

\[
\infrule
{ \begin{array}{c}
  \load{\Env}{F}{r}{s_1}{ v_1,d_1 } \\
  \load{\Env[x \mapsto v_1}{F}{r}{s_2}{ v_2,d_2 }
  \end{array} }
{ \load{\Env}{F}{r}{\SPair{x}{s_1}{s_2}}{ (v_1,v_2),(\valid{d_1} \wedge \valid{d_2}, (d_1,d_2)) } }
{ }
\]

\[
\infrule
{ \begin{array}{c}
  \eval{(\tau\ \mathit{list})}{\Env,r,e} = [w_1,\dots,w_k ]\\
  \load{\Env[x \mapsto w_1]}{F}{r}{s}{v_1,d_1}\\
  \vdots \\
  \load{\Env[x \mapsto w_k]}{F}{r}{s}{v_k,d_k}
  \end{array} }
{ \load{\Env}{F}{r}{ \SComp{s}{x}{e} }{ [v_1,\dots,v_k],(\bigwedge_i \valid{d_i},[d_1,\dots,d_k]) } }
{ }
\]


\[
\infrule
{ }
{ \load{\Env}{F}{r}{ \SPred{e} }{ (),(\eval{bool}{E,r,e},()) } }
{ }
\]


\[
\infrule
{ r \not\in \dom{F} }
{ \load{\Env}{F}{r}{ \SOption{s} }{ \Nothing,(\False,\Nothing) } }
{ }
\]

\[
\infrule
{ r \in \dom{F} \qquad \Env;F;r \models s \yields v,d }
{ \load{\Env}{F}{r}{ \SOption{s} }{ \Just{v},(\valid{d},\Just{d}) } }
{ }
\]
\caption{\forest{} calculus loading semantics}
\label{fig:calculus-load-semantics}
\end{figure}

\begin{figure}
\[
\infrule
{ }
{ \store{\Env}{F}{r}{v,d}{\Sk}{ \storek{\Sk}{F}{r}{v,d} } }
{ }
\]

\[
\infrule
{ \begin{array}{c}
  b^{\tau_m}_{\tau_r}(E,v,d) = n\\
  F' = \FUpdate{F}{r}{(\att,\File{n})}\\
  \phi = (\lambda F'.~F'(r) = (\_,\File{n}))
  \end{array} }
{ \store{\Env}{F}{r}{ v,(\True,(d,\att)) }{\SAdhoc{b}}{F',\phi } }
{ }
\]

\[
\infrule
{ \phi = (\lambda F'.~v = \epsilon \wedge \neg \exists \att',n'.~F'(r) = (\att',\File{n'})) }
{ \store{\Env}{F}{r}{ v,(\False,(d,\att)) }{\SAdhoc{b}}{ F, \phi } }
{ }
\]

\[
\infrule
{ \store{\Env}{F}{\eval{path}{E,r,\PCons{r}{e}}}{v,d}{s}{F',\phi} }
{ \store{\Env}{F}{r}{v,d}{\SPath{e}{s}}{F',\phi } }
{ }
\]

\[
\infrule
{ \begin{array}{c}
  \store{\Env}{F}{r}{  v_1,d_1 }{s_1}{ F_1',\phi_1 } \\
  \store{\Env[x \mapsto v_1}{F}{r}{ v_2,d_2 }{s_2}{ F_2',\phi_2 } \\
  F' = F_1' \FAppend F_2'\\
  \phi = \lambda F'.~\phi_1(F') \wedge \phi_2(F')
  \end{array} }
{ \store{\Env}{F}{r}{ (v_1,v_2),(d, (d_1,d_2)) }{\SPair{x}{s_1}{s_2}}{ F',\phi } }
{ }
\]

\[
\infrule
{ \begin{array}{c}  
  \eval{(\tau\ \mathit{list})}{\Env,r,e} = [w_1,\dots,w_m ]\\  
  k = \min{j,l,m} \\
  \store{\Env[x \mapsto w_1]}{F}{r}{v_1,d_1}{s}{F_1',\phi_1}\\
  \vdots \\
  \store{\Env[x \mapsto w_k]}{F}{r}{v_k,d_k}{s}{F_k',\phi_k}\\
  F' = F_1' \FAppend \dots \FAppend F_k'\\
  \phi = \lambda F'.~j = l = m \wedge \bigwedge_i phi_i(F')
  \end{array} }
{ \store{\Env}{F}{r}{[v_1,\dots,v_j],(d,[v_1,\dots,v_l])}{ \SComp{s}{x}{e} }{ F',\phi } }
{ }
\]

\[
\infrule
{ \phi = \lambda F'.~b }
{ \store{\Env}{F}{r}{(),(b,())}{ \SPred{e} }{ F,\phi } }
{ }
\]

\[
\infrule
{ \begin{array}{c}
  \store{\Env}{F}{r}{ v,d }{ s }{ F',\phi }\\
  \phi' = \lambda F'.~b \wedge r \in \dom{F'} \wedge \phi(F')
  \end{array} }
{ \store{\Env}{F}{r}{ \Just{v},(b,\Just{d}) }{ \SOption{s} }{ F',\phi } }
{ }
\]

\caption{\forest{} calculus storing semantics}
\label{fig:calculus-store-semantics}
\end{figure}

\paragraph*{Calculus Semantics.}
%
The semantics of the calculus is organized into three separate
definitions, one for each of the three artifacts generated by the
\forest{} compiler. These definitions are spelled out in
Figures~\ref{fig:calculus-semantics} and \ref{fig:calculus-types}.

The first semantic judgement has the form $\Env;F;r \models s \yields
v,d$.  This judgement captures the behavior of the load function.
Intuitively, it states that in environment $\Env$ and file system $F$,
specification $s$ matches the file system fragment at current path $r$
and produces the representation $v$ and metadata $d$.  This judgement
may also be viewed as a total function from $\Env$, $F$, $r$ and $s$
to the pair $v$ and $d$.  The judgement is total because when file
system fragments fail to match the given specification, defaults are
generated for the representation $v$ and errors are recorded in the
metadata $d$.  This design is preferable to failing as it allows a
programmer to explore a file system fragment even when it contains
errors, as is common in \filestores{}.

The rule for constants depends upon an auxiliary function 
{\it ck} (pronounced ``check'') that interprets the constants.  For
example, the {\it ck} function for the (\pfile) construct, which
describes any file (but not symbolic links or directories), is defined
as follows:
\[
\begin{array}{@{}l}
ck(\mbox{\sf F}^{\metapdty}_{\stringty},F,r) = (n,(\True,\att)), \mathrm{if } F(r) = (\att,\File{n}) \\
ck(\mbox{\sf F}^{\metapdty}_{\stringty},F,r) = (\texttt{""},(\False,\att)), \mathrm{if } F(r) = (\att,T), T \not=\File{n} \\
ck(\mbox{\sf F}^{\metapdty}_{\stringty},F,r) = (\texttt{""},(\False,\defaultatt)), \mathrm{otherwise}
\end{array}
\]

The rule for \padshaskell{} parsers, and several of the other rules,
use the function $valid(d)$.  This function extracts a boolean from
the metadata structure $d$, returning $\True$ if there are no errors
in the structure and $\False$ otherwise. 

The second and third semantic judgements specify the representation
and metadata types for a given specification.  They have the form
$\repty{s} = \tau$ and $\mdty{s} = \tau$, respectively.  Note here
that $\meta$ is the type for file attribute records and the 
$md$ type is defined as follows.
\[
\begin{array}{lcl}
\tau~\mathit{md} & = & \typ{header} \times \tau \\
\typ{header} & = & \typ{bool} 
\end{array}
\]

The three
sets of definitions obey the following basic coherence property, where
$\turn v : \tau$ states that the value $v$ has type $\tau$.

\begin{proposition}
  If $\Env;F;r \models s \yields v,d$ and $\repty{s} =
  \tau_{\mathcal{R}}$ and $\mdty{s} = \tau_{\mathcal{M}}$ then $\turn
  v : \tau_{\mathcal{R}}$ and $\turn d : \tau_{\mathcal{M}}$
\end{proposition}


\begin{figure}

\[
\begin{array}{l|l|l}
\hline
s & \repty{s} = & \mdty{s} =  \\
\hline
\Sk & \tau_r &  \tau_m~\mathit{md} \\
\SAdhoc{b} & \tau_r & (\tau_m \times \meta)~\mathit{md} \\
\SPath{e}{s} & \repty{s} & \mdty{s} \\
\SPair{x}{s_1}{s_2} & \repty{s_1} \times \repty{s_2} & \md{\mdty{s_1} \times \mdty{s_2}} \\
\SComp{s}{x}{e} & \repty{s}~\typ{list} & \md{\mdty{s}~\typ{list}}    \\
\SPred{e} & \typ{unit} & \typ{unit}~\mathit{md}\\
\SOption{s} & \repty{s}~\typ{option} & \md{\mdty{s}~\typ{option}} %\\
%\hline
\end{array}
\]

%where:
%
%\[
%\begin{array}{lcl}
%\tau~\mathit{md} & = & \typ{header} \times \tau \\
%\typ{header} & = & \typ{bool} 
%\end{array}
%\]
\caption{\forest{} calculus data and metadata types}
\label{fig:calculus-types}
\end{figure}


% \begin{figure}

% \[
% \begin{array}{lcl}
% \repty{\Sk} & = & \tau_r \\
% \repty{\SAdhoc{b}} & = & \tau_r \\
% \repty{\SPath{e}{s}} & = & \repty{s} \\
% \repty{\SPair{x}{s_1}{s_2}} & = & \repty{s_1} \times \repty{s_2} \\
% \repty{\SComp{s}{x}{e}} & = & \repty{s}~\typ{list}  \\
% \repty{\SPred{e}} & = & \typ{unit} \\
% \repty{\SOption{s}} & = & \repty{s}~\typ{option}  \\
% \\
% \mdty{\Sk} & = & \tau_m~\mathit{md}\\
% \mdty{\SAdhoc{b}} & = & (\tau_m \times \meta)~\mathit{md}\\
% \mdty{\SPath{e}{s}} & = & \mdty{s} \\
% \mdty{\SPair{x}{s_1}{s_2}} & = & \md{\mdty{s_1} \times \mdty{s_2}} \\
% \mdty{\SComp{s}{x}{e}} & = & \md{\mdty{s}~\typ{list}}  \\
% \mdty{\SPred{e}} & = & \typ{unit}~\mathit{md}\\
% \mdty{\SOption{s}} & = & \md{\mdty{s}~\typ{option}}  \\
% \\
% \tau~\mathit{md} & = & \typ{header} \times \tau \\
% \typ{header} & = & \typ{bool} 
% \end{array}
% \]
% \caption{\forest{} calculus data and metadata types}
% \label{fig:calculus-types}
% \end{figure}

\begin{theorem}
$\load{E}{F}{r}{s}{v,d} \wedge \store{E}{F}{r}{v,d}{s}{F',\phi} \Rightarrow F' = F \wedge \phi(F')$
\end{theorem}

\begin{theorem}
$\store{E}{F}{r}{v,d}{s}{F',\phi} \wedge \phi(G \FAppend F' \FAppend H) \wedge \load{E}{(G \FAppend F' \FAppend H)}{r}{s}{v',d'} \Rightarrow v' = v \wedge \valid{d} \Leftrightarrow \valid{d'}$
\end{theorem}
