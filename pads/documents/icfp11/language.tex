\section{\forest{} Design}
\label{sec:language}

\forest{} is a domain-specific language embedded within Haskell using
the Quasiquote mechanism~\cite{Mainland:quasi}.  In a typical
\forest{} description, \forest{} declarations are interleaved with ordinary
Haskell declarations.  To introduce new \forest{} declarations,
the programmer simply opens the \forest{} sublanguage scope:
\begin{code}
[forest| ... forest declarations ... |]
\end{code}

\forest{} uses a type-based metaphor to describe directory
structures, so once  within the \forest{} sublanguage, the programmer
writes declarations that look and feel very much like extended Haskell
type declarations. 
Each such type declaration serves three purposes: 
(1) it describes a fragment of the file system,
(2) it specifies the structure of the in-memory {\em representation}
    that will be constructed when the fragment is (lazily) loaded into a Haskell program, and 
(3) it specifies the structure of the in-memory {\em metadata}
    that will be generated when the fragment loaded.
Such metadata includes error information (missing file, insufficient
permissions, \etc{})  as well as file system attributes (owner, size, \etc{}).
As we explain the design of \forest{}, 
readers should keep these three different aspects in mind.  
The effectiveness of the \forest{} language comes in part from the fact that these three 
elements can all be specified in a single compact description.  

Every \forest{} description is defined relative to a
{\em current path} within the file system.  As 
\forest{} matches a description against the file system, it 
adjusts the current path to reflect its navigation.
\cut{
In general, descriptions
do not assume that the current path is a valid path in the file
system.  
When the current
path is invalid, a description will generally\footnote{The \cd{Maybe} constructor,
discussed later, is an example of an exception to the general rule.} 
register an attempt to load from that
path as an error in the associated metadata structure.}

At its core, \forest{} is a simple dependent type system in which base
types denote files of various flavors and record types describe
directories.  \forest{} also includes a list type to describe
collections of files that all share some type.  We use a variety of
other type constructors to build more refined structures from these
basic building blocks.  We discuss each of these constructs in turn in
the remainder of this section.  A note on terminology: we use the term
``file system object'' or more simply ``object'' to denote either a
file, or a directory, or a symbolic link. 

\subsection{Files}
\label{sec:basics}
\forest{} provides a small collection of base types for describing
files: \cd{Text} for ASCII files, \cd{Binary} for binary files, and
\cd{Any} for arbitrary files.  As with all \forest{} types, each of
these types specifies a representation type, a metadata type, and a
loading function.  The in-memory representation for an ASCII file is a
Haskell \cd{String}; for binary and arbitrary files, it is a
\cd{ByteString}.  For all three file types, the metadata type pairs
file-system metadata with metadata describing properties of the file
contents.  The file-system metadata has type \cd{Forest\_md}, shown in
\figref{fig:forest-md}.  This structure stores two kinds of
information: (1) the number and kind of any errors that occurred while
loading the file and (2) the attributes associated with the file.
%% File-content metadata typically describes errors within the file, but
%%can be used for other purposes.  
\jnf{The transition right here confusing and abrupt. I was reading the
  figure carefully, which steps the reader through file system
  metadata and missed the stack pop back up to the top-level
  discussion of metadata...}
%
File-content metadata describes errors within the file.
For these three file types, there is
no meaningful content metadata and so this type is the unit type.
Leveraging Haskell's laziness, the loading functions create the
in-memory representations and set the metadata on demand.

\begin{figure}
\begin{centercode}
\kw{data} Forest_md = Forest_md 
   \{ numErrors :: Int
   , errorMsg  :: Maybe ErrMsg
   , fileInfo  :: FileInfo \}
\mbox{}
\kw{data} FileInfo = FileInfo 
   \{ fullpath    :: FilePath
   , owner       :: String
   , group       :: String
   , size        :: COff
   , access_time :: EpochTime
   , mod_time    :: EpochTime
   , read_time   :: EpochTime
   , mode        :: FileMode
   , isSymLink   :: Bool
   , kind        :: FileType \}
\end{centercode}
\caption{\forest{} metadata types.}
\label{fig:forest-md}
\end{figure}

Of course, there are many kinds of files, and the appropriate
representation and content metadata type for each such file varies.
Possible examples include XML documents, Makefiles, source files in
various languages, shell scripts, \etc{}  To support such files,
\forest{} provides a plug-in architecture, allowing third party users
to define new file base types by specifying a representation type, a
metadata type, and a corresponding loading function.

A common class of files are \textit{ad hoc data files} containing
semi-structured information, an example of which is the Princeton
student record file format\ifanon{}~\cite{pldi-aux-materials}\fi. 
In such cases, \forest{} can leverage the \padshaskell{} data
description language to define format-specific in-memory
representations, content metadata, and loading functions. 
\padshaskell{} is a recently developed version of 
\pads{}~\cite{fisher+:pads,fisher+:toplas,mandelbaum+:pads-ml}.
Like \forest{}, \padshaskell{} is embedded in Haskell using
quasiquotation.  For example, the following code snippet 
begins the \pads{} specification of the Princeton student record
format: 
\noindent
\begin{code}
[pads| \kw{data} Student(name::String) = <pads decl> |]
\end{code}
This description is parameterized by the name of the student whose
data is in the file; the complete description appears in the appendix.
From this specification, the \pads{} compiler
generates an in-memory representation type \cd{Student}, a content metadata
type \cd{Student_md}, and a parsing function.  

\forest{} provides the \cd{File} type constructor to lift \pads{}
types to \forest{} file types.  For example, the declaration
\begin{code}
[forest| \kw{type} SFile(n::String) = File(Student n) |]
\end{code}
introduces a new file type named \cd{SFile} whose format is given by
the \pads{} type \cd{Student}.  As with the \pads{} type, \cd{SFile}
is parameterized by the name of the student.  

Using \padshaskell{} descriptions in \forest{} not only helps specify
the structure of ad hoc data files, but it also generates a structured
in-memory representation of the data, allowing Haskell programmers to
traverse, query and otherwise manipulate such data.  
\padshaskell{} and \forest{} were designed to work seamlessly
together.  From the perspective of the Haskell programmer traversing
a resulting in-memory data structure, there is effectively no difference
between iterating over files in a directory or structured sequences of
lines or tokens within a file.

While \padshaskell{} is independently interesting,
this paper focuses on \forest{}.  Henceforth, any
unadorned declarations occur within the \forest{} scope
\cd{[forest|...|]} unless otherwise noted.  Any declarations prefixed
by \cd{>} 
are ordinary Haskell declarations.

\subsection{Optional Files}
\label{sec:maybe}
Sometimes, a given file (or directory or symbolic link) may or may not
be present in the file system, and either situation is valid.
\forest{} provides the \cd{Maybe} type constructor for this
situation.  If \cd{T} is a \forest{} type, then \cd{Maybe T} is the
\forest{} type denoting an optional \cd{T}.  In particular, 
\cd{Maybe T} succeeds and returns representation \cd{None} when the
current path does not exist in the file system.  \cd{Maybe T} also
succeeds and returns \cd{Just v} for some \cd{v} of type \cd{T} 
when the current path exists and matches \cd{T}.  \cd{Maybe T}
registers an error in the metadata when the current path exists but
the corresponding object does not match \cd{T}. 

\subsection{Symbolic Links}
\label{sec:symlinks}
When symbolic links occur in a described file system fragment,
\forest{} follows the symbolic link to its target, mimicking 
standard shell behavior.    In addition, however, it is possible
for programmers to specify explicitly that a particular file is a
symbolic link using the base type \cd{SymLink}.  The in-memory
representation for an explicit symbolic link is the path that is the
target of the link.  It is possible to use constraints
(\secref{sec:constraints}) to specify desired properties of the link
target, such as requiring it to be to a specific file.

In \forest{}, any file system object may be described in multiple ways.
Hence, in the case of a symbolic link, it is possible to use one declaration to
specify that the object is a symbolic link and a second to specify
the type of the link target.  We will see an example of such a specification in the
next subsection. 

\subsection{Directories}
\label{sec:directories}
\forest{} directories are record-like datatype constructors that allow
users to specify directory structures. For example, to specify the root directory
of the student repository in \figref{fig:student-pic}, we might use
the following declaration.  This declaration assumes that we have already
defined \cd{Class y}, a parameterized description that specifies
the structure of a directory holding data for the class of year \cd{y},
and \cd{Grads}, a description that specifies the structure of the
directory holding all graduated classes.   
\begin{code}
\kw{type} PrincetonCS_1 = \kw{Directory}
  \{ notes   \kw{is} "README"    :: Text
  , seniors \kw{is} "classof11" :: Class 11
  , juniors \kw{is} "classof12" :: Class 12
  , grads   \kw{is} "graduates" :: Grads \}
\end{code}
Each field of the record describes a single file system object.  It has three components:  
(1) an internal name (\eg{}, \cd{notes} or \cd{seniors}) that
must be a valid Haskell record label, 
(2) an external name specified as a value of type \cd{String}
(\eg{}, \cd{"README"} or  \cd{"classof11"}) that gives the name of the
object on disk, and 
(3) a \forest{} description of the object (\eg{}, \cd{Text} or \cd{Class 11}).

When the external name is itself a valid Haskell label, users may omit
it, in which case \forest{} uses the label as the on-disk name:
\begin{code}
\kw{type} PrincetonCS_2 = \kw{Directory}
  \{ notes \kw{is} "README" :: Text
  , classof11 :: Class 11
  , classof12 :: Class 12
  , graduates :: Grads \}
\end{code}
We could not abbreviate the \cd{notes} field because labels must start
with a lowercase letter in Haskell. 

\paragraph*{Matching.}
For a file system object to match a directory description, the object must be a
directory and each field of the record must match.  A field \cd{f} matches
when the object whose path is the concatenation of the current path
and the external name of \cd{f} matches the type of \cd{f}.

It is possible for the same file system object to match multiple
fields in a directory description at the same time.  For example, if
\cd{"README"} were actually a symbolic link, it is possible to
document that fact by mentioning it twice in the directory
description, once as a text file and once as a symbolic link:
\begin{code}
\kw{type} PrincetonCS_3 = \kw{Directory}
  \{ link  \kw{is} "README" :: SymLink
  , notes \kw{is} "README" :: Text
  , ... \}
\end{code}

It is also possible for a directory to contain objects
that are unmatched by a description.  We allow extra items because it
is common for directories to contain objects that users do not care
about.  For example, a directory structure may contain extra files or
directories related to a version control system, and a
description writer may not want to clutter the \forest{} specification
with that information.  As we will see shortly, it is possible to
specify the absence of file system objects using constraints.

As suggested by the syntax, the in-memory representation of a
directory is a Haskell record with the corresponding labels.  The type
of each field is the representation type of the \forest{} type for the
field. The metadata has a similar structure. The metadata for
each field has two components: file-system attribute information of
type \cd{Forest_md} and field-specific metadata whose type is derived
from the \forest{} type for the field.  In addition, the directory
metadata contains an additional value of type \cd{Forest_md} that 
summarizes the errors occurring in directory components and stores the
\cd{FileInfo} structure for 
the directory itself.
When loading a directory, \forest{} constructs the appropriate in-memory
representation for each field that matches and puts the corresponding
metadata in the metadata structure. For fields that do not 
match, \forest{} constructs default values and marks the metadata with
suitable error information.


\paragraph*{Computed Paths}
\label{sec:computed-paths}

The above descriptions are a good start for our application, but they are
not ideal.  Every year, the directory for graduating seniors 
(\ie{}, \cd{classof11}) is moved into the graduates directory,
the juniors are promoted to seniors and a new junior class is created.
As it stands, we would have to edit the description every year.
An alternative is to parameterize the description with the current year and
to \textit{construct} the appropriate file names using Haskell functions:
\begin{code}
> toStrN i n = (replicate(n - length(show i)) '0') 
               ++ (show i)
> mkClass y = "classof" ++ (toStrN y 2)
\mbox{}
\kw{type} PrincetonCS (y::Integer) = \kw{Directory}
  \{ notes   \kw{is} "README" :: Text
  , seniors \kw{is} <|mkClass y    |> :: Class y
  , juniors \kw{is} <|mkclass (y+1)|> :: Class <|y+1|>
  , graduates :: Grads \}
\end{code}
The bracket syntax \cd{<|...|>} provides an escape so that we may use
Haskell within \forest{} code to specify arbitrary computations.  
When an expression is a constant or variable,
it may be supplied directly.  When an argument is more complex,
however, it must be written in brackets to escape to Haskell.
This example also
illustrates abstraction: any \forest{} declaration may be
parameterized by specifying a legal Haskell pattern and
its type.  The types of the fields for \cd{seniors} and \cd{juniors}
illustrate the use of parameterized descriptions.

\paragraph*{Approximate Paths}
As \filestores{} evolve, naming conventions may change.
Additionally, directory structures with multiple instances may have
minor variations in the names of individual files across instances.  
For example, in each Princeton class directory, there may
(or may not) be some number of students that have withdrawn from the
program, transferred to a different program, or gone on
leave.  Over the years, slightly different directory names
have been used to represent these situations.  

To accommodate this variation, \forest{} includes the matching
construct to approximate file names.  We can use this mechanism to
describe the class directory:
\begin{code}
> transRE = RE "TRANSFER|Transfer"
> leaveRE = RE "LEAVE|Leave"
> wdRE    = RE "WITHDRAWN|WITHDRAWAL|Withdrawn"
\mbox{}
\kw{type} Class (y::Integer) = \kw{Directory}
  \{ bse \kw{is} <|"BSE" ++ (toString y)|> :: Major
  , ab  \kw{is} <|"AB"  ++ (toString y)|> :: Major   
  , trans \kw{matches} transRE :: Maybe Major      
  , withd \kw{matches} wdRE    :: Maybe Major
  , leave \kw{matches} leaveRE :: Maybe Major \}
\end{code}
A field with the form \cd{<label> \kw{matches} <regexp> :: T}
finds the set of paths in the files system that match \cd{currentPath/} \cd{<regexp>}.
If there are zero or one such files, the \cd{matches} form acts just as the \cd{is} 
form.  If more than one file matches, one of the matches
is selected non-deterministically, a multiple match error is
registered in the metadata, and matching continues as it would with
the \cd{is} form.  In addition to regular expressions, the matching
construct also allows \textit{glob patterns}, (\ie{}, patterns such as 
\cd{*.txt}),  to specify the names of files on disk. 


\subsection{List Comprehensions}
\label{sec:comprehensions}

Record directories allow programmers to specify a fixed number of file
system objects, each with its own type.
List comprehensions, on the other hand, allow programmers to specify
an arbitrary number of file system objects, each with the same type.
As an example, we can use a list comprehension to specify the
\cd{Grads} directory from \figref{fig:student-pic}:

\begin{code}
> getYear s = 
>   toInteger $ reverse $ take 2 $ reverse s
> cRE = RE "classof[0-9][0-9]"
\mbox{}
\kw{type} Grads = 
  [c :: Class <|getYear c|> | c <- \kw{matches} cRE]
\end{code}
%% $
In this specification, \cd{Grads} is a directory fragment containing a number of
\cd{Class} subdirectories with names \cd{c} that match the regular expression
\cd{cRE}.  The Haskell function \cd{getYear} extracts the last two digits from the
name of the directory, converts the string digits to an integer year, and passes
the year to the underlying \cd{Class} specification.
More generally, comprehensions have the form \cd{[path :: T | id <- gen, pred]} where \cd{id} 
is bound in turn to each of the file names generated by \cd{gen}, which may be a \cd{matches} clause 
(used to match against the files at the current path as in the previous section) or a list
computed in Haskell.  These generated \cd{id}s are filtered by the
optional predicate \cd{pred}.  For each such legal \cd{id}, there is a
corresponding expression \cd{path}, which \forest{} interprets as extending
the current path.  The object at each such path should have the \forest{}
type \cd{T}.  The identifier \cd{id} is in scope in \cd{pred},
\cd{path}, and \cd{T}.  

The in-memory representation of a comprehension is a list containing
pairs of the name of a matching object and its representation.  The
metadata is a list of the metadata of the matching objects paired with
a summary metadata structure of type \cd{Forest_md}.


\paragraph*{Representation Transformations}
Although the list representation for comprehensions is useful, it can
be desirable to use a more sophisticated data structure to
represent such collections.  To support
this usage, \forest{} allows programmers to prefix a list
comprehension with any type constructor that belongs to a 
container type class that supports operations to convert between the
list representation and the desired container representation. 

As an example, consider the specification of the \cd{Major} directory.
Each such directory contains a list of student files and an additional
template file named either \cd{sss.txt} or \cd{sxx.txt}.  The
declaration below specifies the collection of student files by
matching with a glob pattern and filtering to exclude 
template files. It uses the \cd{Map} type constructor to specify that
the data and metadata should be collected in a
\cd{Map} rather than a list.
\begin{code}
> template s = s `elem` ["sss.txt", "sxx.txt"]
> txt = GL "*.txt"
\mbox{}
\kw{type} Major = Map
   [ s :: File (Student <|dropExtension s|>) 
   | s <- \kw{matches} txt, <|not (template s)|>]
\end{code}


\subsection{Attributes and Constraints}
\label{sec:constraints}

Every file system object has a number of attributes associated with
it, such as the file owner and size.  In general,
if a \forest{} identifier \cd{id} refers to a path, the attributes for the object at that
path are available through the identifier \cd{id_att}, which has
type \cd{Forest_md} (\figref{fig:forest-md}).  Forest defines
accessor functions such as \cd{get_modes} (get permissions), \cd{get_kind} (get
ASCII/binary/directory characteristics) and others to inspect
these attributes.
%Figure~\ref{fig:metadata-components} lists a set of helper functions that
%extract useful information from attribute structures.


\begin{figure}
\input{student-description}
\caption{\forest{} description of Princeton \filestore{}. (Associated Haskell and \pads{} code
  appears in\ifanon\auxmaterials\else{} the appendix\fi.)}
\label{fig:student-description}
\end{figure}


\textit{Constrained types} make use of attributes. For example, the
type \cd{PrivateText} specifies a text file accessible only by its owner.
\begin{code}
\kw{type} PrivateFile = 
 Text \kw{where} <|get_modes this_att == "-rw-------"|>
\end{code}
The keyword \kw{where} introduces a constraint on the underlying type.
If a constraint is false, an error 
is registered in the metadata.  Within the constraint, \cd{this} refers to the representation 
of the underlying object, \cd{this_att} refers to its attributes and \cd{this_md} 
to its complete metadata.

Using attributes, we can write a \textit{universal
  directory description}, which is sufficiently general to describe
any directory:
\begin{code}
\kw{type} Universal = \kw{Directory}
  \{ asc \kw{is} [ f :: Text 
           | f <- \kw{matches} (GL "*"), 
          <| get_kind f_att == AsciiK |> ]
  , bin \kw{is} [ b :: Binary 
           | b <- \kw{matches} (GL "*"), 
          <| get_kind b_att == BinaryK |> ]
  , dir \kw{is} [ d :: Universal  
           | d <- \kw{matches} (GL "*"),
          <| get_kind d_att == DirectoryK |> ]
  , sym \kw{is} [ s :: SymLink 
           | s <- \kw{matches} (GL "*"), 
          <| get_sym s_att == True |> ] \}
\end{code}
The description requires recursion to describe the directory case,
which \forest{} supports.
In the case that a symbolic link creates a cycle in the file system by
pointing to a parent directory, the Haskell in-memory representation
is a (lazy) infinite data structure.  

We can also use constraints to specify that certain files do not appear
in certain places.  As an example, we might want to require that no
binaries appear in a directory given to an untrusted user as scratch
space. The description below flags an error if a binary file exists
in the directory. 
\begin{code}
\kw{type} NoBin =
  [ b :: Binary | b <- \kw{matches} (GL "*"), 
                  <| get_kind b_att == BinaryK |> ]
  \kw{where} <|length this == 0|>
\end{code}

% \begin{figure}
% \begin{center}
% \begin{tabular}{l|l}
% function name &  information \\
% \hline
% \cd{get_group} & object group\\
% \cd{get_kind} & the sort of file or directory \\
% \cd{get_modes} & permission string\\
% \cd{get_owner} & object owner\\
% \cd{get_size} & object size \\
% \end{tabular}
% \end{center}
% \caption{Selected file attribute functions}
% \label{fig:metadata-components}
% \end{figure}


\subsection{Gzip and Tar Type Constructors}
\label{sec:file-modifiers}

Some files need to be processed before they can be used.  A typical
example is a compressed file such as the gzipped log files in 
\coral{}.  \forest{} provides processing-specific type
constructors to describe such files.   For example, if
\cd{CoralLog} is a \padshaskell{} 
description of a \coral{} log file then 
\begin{code}
\kw{type} Info = Gzip (File CoralLog)
\end{code}
describes a gzipped log file.
Likewise, suppose \cd{logs.tar.gz} is a gzipped tar file and that the type
\cd{ManyLogs} describes the directory of log files that \cd{logs.tar} expands
to when untarred.  Such a situation can be described using a
combination of the \cd{Tar} and \cd{Gzip} type constructors:
\begin{code}
\kw{type} MoreInfo = Gzip (Tar ManyLogs)
\end{code}


\subsection{Putting it all together}

The preceding subsections give an overview of \forest{}'s design.
Figures~\ref{fig:student-description} and~\ref{fig:coral-description}
give the specifications for the two running examples, minus the
associated \padshaskell{} and \haskell{} declarations.  The complete
descriptions of these \filestores{} and additional descriptions are
available in the \ifanon\auxmaterials\else appendix\fi, including
descriptions of the \pads{} website, a Gene Ontology \filestore{}, and
CVS repositories.

\begin{figure}
%CoralCDN Description:
\input{coral-description}
\caption{\forest{} CoralCDN description. Associated Haskell and
  \pads{} code appears in \ifanon\auxmaterials\else the appendix\fi.}
\label{fig:coral-description}
\end{figure}
