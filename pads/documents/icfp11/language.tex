\section{\forest{} Design}
\label{sec:language}
\cut{
\reviewer{Section 3 reads like a reference manual - as a long list of
  features.  I'd like to hear more about why this list of features was
  chosen - were these just useful in practice?  Or is there some kind
  of theoretical argument for why these features are "good"?}
}

Data stored in \filestore{}s shares many characteristics of
data stored in ordinary, in-memory data structures.
%Indeed, \filestore{}s are often merely a durable, readable representation of such
%data structures.  
Consequently, \forest{}
uses the same sort of language to describe \filestores{} as one uses to describe
ordinary data structures --- the language of types. 
Simple base
types describe individual file system objects\footnote{We use the term
\emph{file system object} or more simply \emph{object} to denote either a
file, a directory, or a symbolic link.} and more complex types 
describe organized collections of file system 
objects. 
This idea forms the basis for our design.

\paragraph*{Embedding \forest{} in \haskell{}.}
In order to write lightweight scripts, 
programmers must be able to manipulate and transform file system 
objects side-by-side with ordinary data structures.  Consequently,
a language like \forest{} must be embedded within a more general
host programming language.
%and  move seamlessly between on-disk and
%in-memory representations of \filestore{} data, so we implemented
%\forest{} as an embedded domain-specific language.  
%This choice allows
%programmers to manipulate \filestore{} data almost as if it were
%simply stored in data structures in the host language.  
We chose
Haskell as the host language primarily because of its rich support for 
type-directed programming, which facilitates the construction of generic 
tools that can operate over any \forest{}
description.  As a bonus, \haskell{}'s quasiquoting 
mechanism~\cite{Mainland:quasi} proved a
useful way to implement \forest{}.  It enabled tight integration of
the two languages while admitting fine-grained control 
over \forest{} syntax.
  
%% Given this host context, \forest{} declarations were designed to 
%% look like extensions of the corresponding Haskell
%% declarations.  This programmers would have an intuitive understanding
%% of the in-memory data structures generated for their \filestore{}s.
%% Within this framework, we
%% developed constructs that were sufficiently expressive to capture all
%% the \filestore{}s we had seen in practice.

%% Since \forest{} is a domain-specific language embedded in Haskell
%% using quasiquotes, \forest{}
%% declarations can appear in normal Haskell files in any context
%% expecting a declaration.
To introduce new \forest{} declarations within a \haskell{} program,
the programmer simply opens the \forest{} sublanguage using
quasiquoting notation:
\begin{code}
[forest| ... forest declarations ... |]
\end{code}
When processing such a quasiquote, the Haskell compiler invokes the
\forest{} compiler,  which converts the given \forest{} declarations
into a sequence of plain Haskell declarations that collectively
implement the \forest{} declarations.

\paragraph*{Forest Structure and Interpretations.}
Once within the \forest{} sublanguage, the programmer writes
declarations that resemble extended Haskell type declarations. 
Each such type declaration has three primary semantic interpretations: 
\begin{enumerate}
\item An interpretation as an {\em expected on-disk shape} of a file system 
    fragment.  
\item An interpretation as an ordinary \haskell{} type for the in-memory {\em representation}
    that will be constructed when the file system 
     fragment is loaded into 
     a Haskell program. 
\item An interpretation as an ordinary \haskell{} type for the in-memory 
   {\em metadata}
    that will be generated when the file system fragment is loaded.
\end{enumerate}
All three interpretations are used by the tool that loads data from
the filestore into memory as specified by a \forest{} description.  
When supplied with
a {\em current path}, the loader uses the first interpretation 
to validate that the filestore rooted at that
path has the correct shape.  
If the expected shape is complicated,
possibly involving several nested subshapes (and hence
traversal through several subdirectories), the semantics of \forest{}
dictates how the loader should adjust the current path 
as it goes.  When validation (also called {\em matching}) succeeds, we
say the filestore fragment {\em matches} the description.
The second interpretation is used when the loader
lazily pulls the on-disk data into memory. 
The in-memory data structure is guaranteed to have the 
\haskell{} type given by the second interpretation.
The third interpretation provides a
type for the metadata structure generated by the loader.
Such metadata includes error information (missing file, insufficient
permissions, \etc{})  as well as file system attributes (owner, size, \etc{}).
%Every \forest{} description is defined relative to a
%{\em current path} within the file system.  As 
%\forest{} matches a description against the file system, it 
%adjusts the current path to reflect its navigation.

The effectiveness of the \forest{} language comes in part from the fact 
that these three interpretations all arise from a single compact description.  
Moreover, to aid the programmer in navigating between interpretations, we
align the syntax of \forest{} with the syntax of \haskell{} where possible.
For example, if the \haskell{} types for the in-memory representation and
metadata are record types, then the \forest{} syntax is designed to look similar
to a \haskell{} record type.  Likewise,  if the \haskell{} types for the in-memory representation and
metadata are Maybe types then the \forest{} syntax is designed to look similar
to a \haskell{} Maybe type.  
%Section~\ref{sec:theory} makes these connections
%precise by defining a formal core calculus for \forest{}.
Many of these high-level design considerations were adopted
from earlier work on 
\pads{}~\cite{fisher+:pads,fisher+:toplas,mandelbaum+:pads-ml}, although 
the semantics of \forest{} (which operates over graph-based filestores)
is substantially different from the semantics
of \pads{} (which operates over sequence-based strings).

\paragraph{Errors.}
As with
\pads{}~\cite{fisher+:pads,fisher+:toplas,mandelbaum+:pads-ml}, we do
not assume that a given \filestore{} conforms perfectly to its associated
\forest{} description.  Instead, when loading data, we check that a 
\filestore{} conforms and mark discrepencies
in the metadata.  This design allows users to respond in
application-specific ways to errors.  It also allows \forest{} to check
the arbitrarily complex conditions that may be specified by 
\forest{}'s dependent types.\footnote{Validation that a filestore
  obeys a Forest specification is akin to type checking.  However, 
it is akin to type checking closed, zero-order values (trees and graphs)
as opposed to type checking parameterized, higher-order values (functions).
Consequently, even though Forest has dependent types, type checking 
is not algorithmically challenging.  For example, \forest{} does not
have to decide equivalence of expressions with free variables as one  
must do when type checking a dependent lambda calculus.}  
Because \forest{} loads data
lazily, this choice means errors will not be detected unless the user
program needs to touch the portion of the \filestore{} with the
error. The user can force a complete conformance check by accessing
the top-level error count.  It is possible for the
\filestore{} to change during or after this check.  For the
\filestores{} we have seen in practice, there are
extra-linguistic procedures in place to prevent such concurrent
modifications; we leave to future work the possibility of 
using operating system support to monitor and/or prevent
such changes automatically. 

\dpw{Yeah, I don't like the paragraph header ``Onward'' either but I
can't stomach this next paragraph being in the same subsection as the 
errors paragraph because it's not about errors.  Just putting it there
without a header violates my sense of proper nested scoping.  Feel
free to suggest a different paragraph header.}

\paragraph{Onward.}
In the remainder of this section, we discuss the specific type
constructors that constitute the \forest{} language and illustrate
their use in our running examples.  
%We also justify the presence of every \forest{} feature by
%showing it used in an example drawn from the authors experience.   


\subsection{Base Types: Files}
\label{sec:basics}
\forest{} provides a small collection of base types for describing
individual files: \cd{TextFile} for ASCII files, \cd{BinaryFile} for
binary files, and 
\cd{AnyFile} for arbitrary files.  As with all \forest{} types, each of
these types specifies a representation type, a metadata type, and 
loading and storing functions. 
For all three file types, the representation type is a
\cd{ByteString}.
Similarly all three share a metadata type, which
pairs file-system metadata
with metadata describing properties of the file contents.  The
file-system metadata has type \cd{Forest\_md}, shown in
\figref{fig:forest-md}.  
%
%\reviewer{Do you ever feel any pain as a result of representing list
%  data separately from a list of its metadata, such that types don't
%  guarantee the two lists match in length? -- I think this is too
%  specific to worry about}
%
This structure stores two kinds of
information: 
\begin{enumerate} 
\item the number and kind of any errors that occurred during loading 
\item the attributes associated with the file (\cd{fileInfo})
\end{enumerate} %
File-content metadata describes errors within the file.
For these three file types, there is
no meaningful content metadata and so this type is the unit type.
Leveraging Haskell's laziness, the loading functions create the
in-memory representations and set the metadata on demand.  The storing
functions, which are described in more detail in \secref{sec:exp},
do the inverse.

\begin{figure}
\begin{centercode}
\kw{data} Forest_md = Forest_md 
   \{ numErrors :: Int
   , errorMsg  :: Maybe ErrMsg
   , fileInfo  :: FileInfo \}
\mbox{}
\kw{data} FileInfo = FileInfo 
   \{ fullpath    :: FilePath
   , owner       :: String
   , group       :: String
   , size        :: COff
   , access_time :: EpochTime
   , mod_time    :: EpochTime
   , read_time   :: EpochTime
   , mode        :: FileMode
   , isSymLink   :: Bool
   , kind        :: FileType \}
\end{centercode}
\caption{\forest{} metadata types.}
\label{fig:forest-md}
\end{figure}

Although useful, these three base types are not sufficient for
describing the wide range of files used in practice, including XML
documents, Makefiles, source files in various languages, shell
scripts, \etc{} The appropriate representation and content metadata
types for each such file varies. To support such files,
\forest{} provides a plug-in architecture, allowing third-party users
to define new file types by specifying a representation type, a
metadata type, and corresponding loading and storing functions.

A common class of files are \textit{ad hoc data files} containing
semi-structured information, an example of which is the Princeton
student record file format. 
In such cases, \forest{} can leverage the \padshaskell{}~\cite{fisher-walker:icdt} data
description language to define format-specific in-memory
representations, content metadata, and loading and storing functions. 
\padshaskell{} is a recently developed version of 
\pads{}~\cite{fisher+:pads,fisher+:toplas,mandelbaum+:pads-ml}.
Like \forest{}, \padshaskell{} is embedded in Haskell using
quasiquotation.  For example, the following code snippet 
begins the \pads{} specification of the Princeton student record
format: 
\noindent
\begin{code}
[pads| \kw{data} Student(name::String) = Student
            \{ person  :: Line (Person name)
            , Header  
            , courses :: [Line Course]
            , Trailer
            \} 
       ...  |]
\end{code}
This description is parameterized by the name of the student whose
data is in the file; the complete description appears in the companion
technical report~\cite{forest-techreport}.
From this specification, the \pads{} compiler
generates an in-memory representation type \cd{Student}, a content metadata
type \cd{Student_md}, and parsing and printing functions.  

\forest{} provides the \cd{File} type constructor to lift \pads{}
types to \forest{} file types.  For example, the declaration
\begin{code}
[forest| \kw{type} SFile(n::String) = File(Student n) |]
\end{code}
introduces a new file type named \cd{SFile} whose format is given by
the \pads{} type \cd{Student}.  As with the \pads{} type, \cd{SFile}
is parameterized by the name of the student.  

Using \padshaskell{} descriptions in \forest{} not only helps specify
the structure of ad hoc data files, but it also generates a structured
in-memory representation of the data, allowing Haskell programmers to
traverse, query and otherwise manipulate such data.  
We designed \padshaskell{} and \forest{} to work seamlessly
together.  From the perspective of the Haskell programmer traversing
a resulting in-memory data structure, there is effectively no difference
between iterating over files in a directory or structured sequences of
lines or tokens within a file.

While \padshaskell{} is independently interesting,
this paper focuses on \forest{}.  Henceforth, any
unadorned declarations occur within the \forest{} scope
\cd{[forest|...|]} unless otherwise noted.  Any declarations prefixed
by \cd{>} 
are ordinary Haskell declarations.

\subsection{Base Type: Symbolic Links}
\label{sec:symlinks}
When symbolic links occur in a described filestore,
\forest{} follows the symbolic link to its target, mimicking 
standard shell behavior.    However, \forest{} allows
programmers to specify explicitly that a particular file is a
symbolic link using the base type \cd{SymLink}.  The in-memory
representation for an explicit symbolic link is the path that is the
target of the link.  It is possible to use constraints
(\secref{sec:constraints}) to specify desired properties of the link
target, such as requiring it to be to a specific file.

In \forest{}, any file system object may be described in multiple ways.
Hence, in the case of a symbolic link, it is possible to use one declaration to
specify that the object is a symbolic link and a second to specify
the type of the link target.  We will see an example of such a specification in \secref{sec:directories}


\subsection{Maybe: Optional File System Objects}
\label{sec:maybe}
Sometimes, a given file (or directory or symbolic link) may or may not
be present in the file system, and either case is valid.
To handle this situation, we leverage the idea of an option type by
providing a \forest{}-level \cd{Maybe} type constructor that maps the
optional file system object to a \cd{Maybe} type in Haskell. In particular,
if \cd{T} is a \forest{} type, then \cd{Maybe T} is the
\forest{} type denoting an optional \cd{T}.  The type
\cd{Maybe T} succeeds and returns representation \cd{None} when the
current path does not exist in the file system.  \cd{Maybe T} also
succeeds and returns \cd{Just v} for some \cd{v} of type \cd{T} 
when the current path exists and matches \cd{T}.  \cd{Maybe T}
registers an error in the metadata when the current path exists but
the corresponding object does not match \cd{T}. 


\subsection{Records: Directories}
\label{sec:directories}
\forest{} directories are record-like datatype constructors that allow
users to specify directory structures. For example, to specify the root directory
of the student repository in \figref{fig:student-pic}, we might use
the following declaration.  This declaration assumes that we have already
defined \cd{Class y}, a parameterized description that specifies
the structure of a directory holding data for the class of year \cd{y},
and \cd{Grads}, a description that specifies the structure of the
directory holding all graduated classes.   
\begin{code}
\kw{type} PrincetonCS_1 = \kw{Directory}
  \{ notes   \kw{is} "README"    :: TextFile
  , seniors \kw{is} "classof11" :: Class 11
  , juniors \kw{is} "classof12" :: Class 12
  , grads   \kw{is} "graduates" :: Grads \}
\end{code}
Each field of the record describes a single file system object.  It has three components:  
(1) an internal name (\eg{}, \cd{notes} or \cd{seniors}) that
must be a valid Haskell record label, 
(2) an external name specified as a value of type \cd{String}
(\eg{}, \cd{"README"} or  \cd{"classof11"}) that gives the name of the
object on disk, and 
(3) a \forest{} description of the object (\eg{}, \cd{TextFile} or \cd{Class 11}).

When the external name is itself a valid Haskell label, users may omit
it, in which case \forest{} uses the label as the on-disk name:
\begin{code}
\kw{type} PrincetonCS_2 = \kw{Directory}
  \{ notes \kw{is} "README" :: TextFile
  , classof11 :: Class 11
  , classof12 :: Class 12
  , graduates :: Grads \}
\end{code}
We could not abbreviate the \cd{notes} field because labels must start
with a lowercase letter in Haskell. 

\paragraph*{Matching.}
For a file system object to match a directory description, the object must be a
directory and each field of the record must match.  A field \cd{f} matches
when the object whose path is the concatenation of the current path
and the external name of \cd{f} matches the type of \cd{f}.

It is possible for the same file system object to match multiple
fields in a directory description at the same time.  For example, if
\cd{"README"} were actually a symbolic link, it is possible to
document that fact by mentioning it twice in the directory
description, once as a text file and once as a symbolic link:
\begin{code}
\kw{type} PrincetonCS_3 = \kw{Directory}
  \{ link  \kw{is} "README" :: SymLink
  , notes \kw{is} "README" :: TextFile
  , ... \}
\end{code}

It is also possible for a directory to contain objects
that are unmatched by a description.  We allow extra items because it
is common for directories to contain objects that users do not care
about.  For example, a directory structure may contain extra files or
directories related to a version control system, and a
description writer may not want to clutter the \forest{} specification
with that information.  We will see shortly that it is possible to
specify the absence of file system objects using constraints.

As suggested by the syntax, the in-memory representation of a
directory is a Haskell record with the corresponding labels.  The type
of each field is the representation type of the \forest{} type for the
field. The metadata has a similar structure. The metadata for
each field has two components: file-system attribute information of
type \cd{Forest_md} and field-specific metadata whose type is derived
from the \forest{} type for the field.  In addition, the directory
metadata contains an additional value of type \cd{Forest_md} that 
summarizes the errors occurring in directory components and stores the
\cd{FileInfo} structure for 
the directory itself.
When loading a directory, \forest{} constructs the appropriate in-memory
representation for each field that matches and puts the corresponding
metadata in the metadata structure. For fields that do not 
match, \forest{} constructs default values and marks the metadata with
suitable error information.

\paragraph*{Computed Paths}
\label{sec:computed-paths}

The above descriptions are a good start for our application, but they are
not ideal.  Every year, the directory for graduating seniors 
(\ie{}, \cd{classof11}) is moved into the graduates directory,
the juniors are promoted to seniors and a new junior class is created.
As it stands, we would have to edit the description every year.
An alternative is to parameterize the description with the current year and
to \textit{construct} the appropriate file names using Haskell functions:
\begin{code}
> toStrN i n = (replicate(n - length(show i)) '0') 
>              ++ (show i)
> mkClass y = "classof" ++ (toStrN y 2)
\mbox{}
\kw{type} PrincetonCS (y::Integer) = \kw{Directory}
  \{ notes   \kw{is} "README" :: TextFile
  , seniors \kw{is} <|mkClass y    |> :: Class y
  , juniors \kw{is} <|mkclass (y+1)|> :: Class <|y+1|>
  , graduates :: Grads \}
\end{code}
The bracket syntax \cd{<|...|>} provides an escape so that we may use
Haskell within \forest{} code to specify arbitrary computations.  
When an expression is a constant or variable,
it may be supplied directly.  When an argument is more complex,
however, it must be written in brackets to escape to Haskell.
This example also
illustrates abstraction: any \forest{} declaration may be
parameterized by specifying a legal Haskell pattern and
its type.  The types of the fields for \cd{seniors} and \cd{juniors}
illustrate the use of parameterized descriptions.

\paragraph*{Approximate Paths}
As \filestores{} evolve, naming conventions may change.
Additionally, directory structures with multiple instances may have
minor variations in the names of individual files across instances.  
For example, in each Princeton class directory, there may
(or may not) be some number of students that have withdrawn from the
program, transferred to a different program, or gone on
leave.  Over the years, slightly different directory names
have been used to represent these situations.  

To accommodate this variation, \forest{} includes the matching
construct to approximate file names.  We can use this mechanism to
describe the class directory:
\begin{code}
> transRE = RE "TRANSFER|Transfer"
> leaveRE = RE "LEAVE|Leave"
> wdRE    = RE "WITHDRAWN|WITHDRAWAL|Withdrawn"
\mbox{}
\kw{type} Class (y::Integer) = \kw{Directory}
  \{ bse \kw{is} <|"BSE" ++ (toString y)|> :: Major
  , ab  \kw{is} <|"AB"  ++ (toString y)|> :: Major   
  , trans \kw{matches} transRE :: Maybe Major      
  , withd \kw{matches} wdRE    :: Maybe Major
  , leave \kw{matches} leaveRE :: Maybe Major \}
\end{code}
A field with the form \cd{<label> \kw{matches} <regexp> :: T}
finds the set of paths in the files system that match \cd{currentPath/} \cd{<regexp>}.
If there are zero or one such files, the \cd{matches} form acts just as the \cd{is} 
form.  If more than one file matches, one of the matches
is selected non-deterministically, a multiple match error is
registered in the metadata, and matching continues as it would with
the \cd{is} form.  In addition to regular expressions, the matching
construct also allows \textit{glob patterns}, (\ie{}, patterns such as 
\cd{*.txt}),  to specify the names of files on disk. An example appears
in the next subsection. 


\subsection{Lists}
\label{sec:comprehensions}

%% I don't think so...
%%\reviewer{Section 3.2 spends half a page describing comprehensions
%%  over various collections.  It's cool that you can put these into
%%  types (although maybe this means Forest isn't really a "simple"
%%  dependent type system anymore), but surely this can be described
%%  more succinctly.}
%
Just as Haskell has both records and lists, so too does \forest{}.
Records allow programmers to specify a fixed number of file
system objects, each with its own type.  Lists, on the
other hand, allow programmers to specify an arbitrary number of file
system objects, each with the same type.  As an example, we can use a
list to specify the \cd{Grads} directory from
\figref{fig:student-pic}.  We borrow Haskell's notation for list
comprehensions to specify the names of the file system objects:

\begin{code}
> getYear s = 
>   toInteger $ reverse $ take 2 $ reverse s
> cRE = RE "classof[0-9][0-9]"
\mbox{}
\kw{type} Grads = 
  [c :: Class <|getYear c|> | c <- \kw{matches} cRE]
\end{code}
%% $
In this specification, \cd{Grads} is a directory fragment containing a number of
\cd{Class} subdirectories with names \cd{c} that match the regular expression
\cd{cRE}.  The Haskell function \cd{getYear} extracts the last two digits from the
name of the directory, converts the string digits to an integer year, and passes
the year to the underlying \cd{Class} specification.
More generally, \forest{} lists have the form \cd{[path :: T | id <- gen, pred]} where \cd{id} 
is bound in turn to each of the file names generated by \cd{gen}, which may be a \cd{matches} clause 
(used to match against the files at the current path as in the previous section) or a list
computed in Haskell.  These generated \cd{id}s are filtered by the
optional predicate \cd{pred}.  For each such legal \cd{id}, there is a
corresponding expression \cd{path}, which \forest{} interprets as extending
the current path.  The object at each such path should have the \forest{}
type \cd{T}.  The identifier \cd{id} is in scope in \cd{pred},
\cd{path}, and \cd{T}.  

The in-memory representation of a \forest{} list is a Haskell list containing
pairs of the name of a matching object and its representation.  The
metadata is a list of the metadata of the matching objects paired with
a summary metadata structure of type \cd{Forest_md}.


\paragraph*{Representation Transformations.}
Although the list representation for comprehensions is useful, it can
be desirable to use a more sophisticated data structure to
represent such collections.  To support
this usage, \forest{} allows programmers to prefix a list
comprehension with any type constructor that belongs to a
\forest{}-defined 
container type class.  This type class contains functions that
specify how to convert between the list representation and the
desired container representation.  We have provided such instance
declarations for Haskell's \cd{Map} and \cd{Set} type constructors.

As an example, consider the specification of the \cd{Major} directory.
Each such directory contains a list of student files and an additional
template file named either \cd{sss.txt} or \cd{sxx.txt}.  The
declaration below specifies the collection of student files by
matching with a glob pattern and filtering to exclude 
template files. It uses the \cd{Map} type constructor to specify that
the data and metadata should be collected in a
\cd{Map} rather than a list.  

\begin{code}
> template s = s `elem` ["sss.txt", "sxx.txt"]
> txt = GL "*.txt"
\mbox{}
\kw{type} Major = Map
   [ s :: File (Student <|dropExtension s|>) 
   | s <- \kw{matches} txt, <|not (template s)|>]
\end{code}


\subsection{Dependent Types: Attributes and Constraints}
\label{sec:constraints}

Every file system object has a number of \textit{attributes} associated with
it, such as its owner, group, permissions, and size.  In general,
if a \forest{} identifier \cd{id} refers to a path, 
then the identifier \cd{id_att} refers to the
corresponding attributes.  This attribute identifier has type
\cd{Forest_md}, shown in \figref{fig:forest-md}. 
Forest defines
helper functions to access these attributes, some of which are listed
in \figref{fig:metadata-components}.

\textit{Constrained types} are a simple form of dependent types that
allow users to specify required attributes. 
For example, the 
type \cd{PrivateFile} specifies a text file accessible only by its owner.
\begin{code}
\kw{type} PrivateFile = TextFile 
      \kw{where} <|get_modes this_att == "-rw-------"|>
\end{code}
The keyword \kw{where} introduces a constraint on the underlying type.
The load function for the type \cd{PrivateFile} checks this
constraint during loading.  
If the constraint is false, it records that fact in the metadata.
Within constraints, the special identifier \cd{this} refers to the representation 
of the underlying object, \cd{this_att} refers to its attributes and \cd{this_md} 
to its complete metadata.


Using attributes, we can write a \textit{universal
  directory description}, which is sufficiently general to describe
any directory:
\begin{code}
\kw{type} Universal = \kw{Directory}
  \{ asc \kw{is} [ f :: TextFile 
           | f <- \kw{matches} <| GL "*" |>, 
          <| get_kind f_att == AsciiK |> ]
  , bin \kw{is} [ b :: BinaryFile 
           | b <- \kw{matches} <| GL "*" |>, 
          <| get_kind b_att == BinaryK |> ]
  , dir \kw{is} [ d :: Universal  
           | d <- \kw{matches} <| GL "*" |>,
          <| get_kind d_att == DirectoryK |> ]
  , sym \kw{is} [ s :: SymLink 
           | s <- \kw{matches} <| GL "*" |>, 
          <| isJust (get_symLink s_att) |> ] \}
\end{code}
When a directory is loaded using the \cd{Universal} description, all
the ASCII files will end up the in \cd{asc} field, all the binary
files in \cd{bin}, all the directories in \cd{dir}, and all the symbolic
links in \cd{sym}.  Note that the description uses recursion to
describe nested directories. In the case that a symbolic link creates
a cycle in the file system by pointing to a parent directory, the
Haskell in-memory representation is a (lazy) infinite data structure.  
We view the fact that it is possible to write such a universal
description in \forest{} as evidence that the language is
appropriately expressive.  This description also serves as an example
of how to describe a filestore by its \textit{structure} rather than
its \textit{names}.   

We can also use constraints to specify that certain files \textit{do not} appear
in certain places.  As an example, we might want to require that no
binaries appear in a directory given to an untrusted user as scratch
space. The description below flags an error during loading if a binary
file exists in the directory. 
\begin{code}
\kw{type} NoBin =
 [ b :: BinaryFile | b <- \kw{matches} <| GL "*" |>, 
                 <| get_kind b_att == BinaryK |> ]
  \kw{where} <|length this == 0|>
\end{code}

\begin{figure}
\begin{center}
\begin{tabular}{l|l}
function name &  information \\
\hline
\cd{get_group} & object group\\
\cd{get_kind} & the sort of file or directory \\
\cd{get_modes} & permission string\\
\cd{get_owner} & object owner\\
\cd{get_size} & object size \\
\end{tabular}
\end{center}
\caption{Selected file attribute functions}
\label{fig:metadata-components}
\end{figure}


\subsection{Specialized Constructors: Gzip and Tar}
\label{sec:file-modifiers}

Some files need to be processed before they can be used.  A typical
example is a compressed file such as the gzipped log files in 
\coral{}.  \forest{} provides processing-specific type
constructors to describe such files.   For example, if
\cd{CoralLog} is a \padshaskell{} 
description of a \coral{} log file then 
\begin{code}
\kw{type} Info = Gzip (File CoralLog)
\end{code}
describes a gzipped log file.
Likewise, suppose \cd{logs.tar.gz} is a gzipped tar file and that the type
\cd{ManyLogs} describes the directory of log files that \cd{logs.tar} expands
to when untarred.  Such a situation can be described using a
combination of the \cd{Tar} and \cd{Gzip} type constructors:
\begin{code}
\kw{type} MoreInfo = Gzip (Tar ManyLogs)
\end{code}

\cut{
\reviewer{Forest uses staged compilation, but descriptions of when
  each type of error (e.g, Forest-type error, filestore constraint
  violation, ...)  can occur are scattered throughout the text.  I'd
  like to see a list of the kinds of things that can go wrong and when
  (and how) those errors are dealt with.}

\reviewer{Forest defines a dependent type system, but there's no
  mention of any practical issues (e.g., type equality) that arise
  from programming with it - do these just not show up in practice?
  Or are they hidden somewhere?  Is there any particular feature that
  you wish Haskell's type system had?}

\reviewer{One claim that I am not entirely convinced is how the type
  system can help to prevent errors. Is the claim that Forest type
  system is able to statically detect some 'impossible' defintions? Or
  just that it can detect non-conformance to the defined format at
  runtime? Detecting non-conformance would not be very interesting,
  but if Forest does more than that an example might help to
  illustrate the point.}

\reviewer{Also, the authors claim that Forest has a "dependent type
  system". I am not sure how this can be true unless the declared
  interface somehow changes when the physical file system is
  explored.}
}


\begin{figure}
\input{student-description}
\caption{\forest{} description of Princeton \filestore{}. 
%(Associated Haskell and \pads{} code
% appears in a technical report~\cite{forest-techreport}.)
}
\label{fig:student-description}
\end{figure}


\begin{figure}
%CoralCDN Description:
\input{coral-description}
\caption{\forest{} CoralCDN description. 
% Associated Haskell and
% \pads{} code appears a technical report~\cite{forest-techreport}.
}
\label{fig:coral-description}
\end{figure}


\subsection{Putting it all together}

The preceding subsections give an overview of \forest{}'s design.
Figures~\ref{fig:student-description} and~\ref{fig:coral-description}
give the specifications for the two running examples, minus the
associated \padshaskell{} and \haskell{} declarations.  The complete
descriptions of these \filestores{} and additional descriptions are
available in a technical report~\cite{forest-techreport}, including
descriptions of the \pads{} website, a Gene Ontology \filestore{}, and
CVS repositories.

