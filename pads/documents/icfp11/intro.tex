\reviewer{"quasiquotation" vs "quasi-quotation" --- different
  spellings used in various places.}
\dpw{we will use quasiquotation uniformly.}

\section {Introduction}
\label{sec:intro}

Databases are an effective, time-tested technology for storing
structured and semi-structured data.  Nevertheless, many computer
users eschew the benefits of structured databases and store important
semi-structured information in collections of files
and directories in a conventional file system instead.  For example, the
Princeton Computer Science Department
stores records of undergraduate student grades in a structured set of
directories and uses scripts to compute averages and
study grading trends.  Similarly, Michael Freedman collects
sets of log files from \coral, a distributed content distribution
network~\cite{freedman+:coral,freedman:coral-experience}.  
The logs are organized in hierarchical
directory structures based on machine name, time and date.  Freedman
mines the logs for information on system security and performance.  At
Harvard, physics professor Vinothan Manoharan stores 
his experimental data in sets of files and
extracts information using python scripts.  At AT\&T, vast structured
repositories contain network monitoring information,
phone call records, and billing data.  
Many software code bases, including Haskell and its associated Cabal libraries,
require that specific files exist in particular formats at precise
locations described in other files. 
Similarly, version control systems like \texttt{cvs} utilize the file
system to store revision information. Web sites require various types
of files to exist in particular directories according to content type,
and security considerations often require particular permissions on
these files.
Many other examples exist across the computational sciences and social
sciences, in computer systems research, in computer
systems administration and in industry.

Users choose to implement ad hoc databases in this manner for a number
of reasons. A key factor is  that using
databases often requires paying substantial up-front costs such as:
(1) finding and evaluating the appropriate database software (and
possibly paying for it); (2) learning how to load data into the
database; (3) writing programs to transform the raw data for loading into the database; (4) learning how
to access the data once it is in the database; and (5) interfacing the
database with a conventional programming language to support
applications that use the data.  Finally, it may be the case that the
database optimizes for a pattern of use not suited to the actual
application, which makes the overhead of the database system even
less desirable. 

\reviewer{"programmers often store data in the file system" -> "
  "programmers often prefer to store data in file systems"}\jnf{Not
  sure what the problem with our wording was...}

Rather than paying these costs, programmers often store data in
the file system, using a combination of directory structure, file
names, file contents, and symbolic links to organize the data.  We call such a
representation of a coherent set of data a \textit{\filestore{}}.
The ``query language'' for a \filestore{}
is often a shell script or conventional programming language.

Unfortunately, the informality of \filestores{} can have
negative consequences.  First, there is generally no documentation,
which means it can be hard to understand the data and its
organization.  New users struggle to learn the structure, and if
the system administrator leaves, knowledge of the data
organization may be lost.  Second, the structure of the \filestore{} tends
to evolve: new elements are added and old formats are changed, sometimes
accidentally.  Such evolution can cause hacked-up data processing
tools to break or return erroneous results; it also further complicates
understanding the data.  Third, there is often no
systematic means for detecting errors even though data errors can
be immensely
important.  For example, for \filestores{} containing monitoring information,
errors can signal that some portion of the monitored system is broken.
Fourth, analyses tend to be built from scratch.
There is no auxiliary query or tool support and no help with debugging.
Tools tend to be ``one-off'' efforts that are not
reuseable.  Fifth, dealing with
large data sets, which are common in this setting, imposes extra
difficulties.  For example,  standard shell tools
such as \cd{ls} fail when more than 256 files appear on the
command line.  Hence, programmers must  break up their data
and process it in smaller sets, a tedious task.

We propose a better way: A type-based
specification language, programming environment and toolkit for
managing \filestores{}.  
This language, called \forest{}, is implemented as an embedded domain-specific
language in \haskell{}.
\forest{} allows programmers to describe the expected shape of a
\filestore{} and to materialize it as typed,
format-specific \haskell{} data structures.  Conversely,
given data structures with the appropriate type, \forest{}
makes it straightforward to dematerialize these structures
and write them out to disk.  The
goal is to make programming with \filestores{} as
easy as programming with regular \haskell{} data
structures.  
%Furthermore, \forest{} leverages
%\haskell{}'s support for generic programming to make it easy to define
%tools that work for any \filestore{} with a \forest{} description.  


\cut{
As well as serving as documentation, generating tools to check for
consistency, and providing basic programming support by lazily
materializing \filestores{} in memory, \forest{} 
provides substantial additional support for
programmers.  

The goal is for programmers to obtain a whole range
benefits by writing one simple, compact file system specification.
The automatically generated auxiliary support includes:}

In exchange for writing a \forest{} specification,  programmers obtain
a number of benefits:
(1) a set of type declarations to represent the \filestore{} in memory,
(2) a set of type declarations that capture errors and file system attributes for the \filestore{},
(3) a loading function to populate these in-memory structures, 
(4) a storing function to push possibly updated structures back out to disk, and
(5) type class instance declarations that make it possible for
   programmers to query, analyze, and transform \filestore{} data
   using generic functions.

To illustrate the power of the generic programming infrastructure, and
to increase the value of writing a \forest{} specification, we have built a
number of tools that work for any \filestore{} with a
\forest{} specification.  These tools include a \filestore{}
visualizer, a permission checker, and \filestore{}-specific versions
of standard command-line tools such as \cd{grep} and \cd{tar}.
Using this same infrastructure, we built a tool to infer
a \forest{} specification for the directory structure starting at a
given path, which means programmers do
not have to start from scratch when writing a specification for their
\filestores{}. 

In addition to serving as a programming tool,
\forest{} descriptions provide {\em executable documentation} that can
be used to check whether a given \filestore{} conforms to its
specification.  For example, Unix file systems should be laid out
according to the informal standard set forth by the Filesystem
Hierarchy Standard Group~\cite{fsh}, which requires, among other
things, that certain directories \textit{only} contain certain files,
presumably for security reasons. \forest{} provides a language for
expressing standards precisely and for checking that given file
systems conform to them.  As another example, the
\pads{} website~\cite{padsweb} contains a complex set of scripts and
data files to implement an online demo.  Unless all of the required
data files, directories, and symbolic links are configured correctly,
the web demo fails with an inscrutable error message.  \forest{}
allows the \pads{} webmaster to precisely document all of these
requirements and to detect specification violations, making it easy to
find and repair errors.


In summary, this paper makes the following contributions.
%
\reviewer{the five (!) contributions range from overly broad ("we
  propose the *idea* of extending a modern programming language with
  *tightly integrated linguistic features for describing filestores*")
  to completely specific ("a case study in implementing
  domain-specific languages").}
%
\begin{itemize}
\item {\bf Conceptual}:  We propose the {\em idea} 
of extending a modern programming language with
{\em tightly integrated linguistic features for describing \filestores{}}
and for automatically generating programming infrastructure from such 
descriptions.

\item {\bf Language Design}: We present the design of \forest{}
  and illustrate its use on real-world examples.
  The design is expressive, concise and smoothly integrated into
  Haskell.  

\item {\bf Theoretical}: We present a core calculus of \forest{}
descriptions and analyze its semantics.  We use the semantics
to prove several results including round-tripping theorems that
establish a correspondence between loads and stores of \filestore{} data.

\item {\bf Tool Generation}: We describe how third-party developers
  can use \haskell{}'s generic programming infrastructure to generate
  \filestore{}-specific tools generically.

\item {\bf Case Study in Domain-Specific Language Design}: \forest{}
  is fully implemented and serves
  as a case study in implementing domain-specific
  languages. Its implementation combines a number of
  experimental features of \haskell{} such as quasi-quoting and \template{}.
  It has practical impact on the \haskell{} implementation itself:  
  the \haskell{} team modified and extended \template{} and the
  quasiquoting mechanism in response to our needs. 
%  and made these modifications
%   available in the most recent release of \haskell{}.
\end{itemize}

\paragraph*{Related Work.}
There has been much past work on domain-specific languages for
describing, parsing and printing individual data files. 
Examples include 
Lex, Yacc,
Antlr~\cite{antlr}, Parsec~\cite{LeijenMeijer:parsec} and 
Pads~\cite{fisher+:toplas}, to name just a few.  
However, \forest{} differs
substantially from any of these systems because it focuses on technology
for describing {\em entire file systems}.  
A key difference is that
simple file systems are {\em trees} and complex ones with symbolic links are 
{\em graphs}, whereas files are {\em sequences} (of characters
or tokens). Consequently,
the language design, formal systems,
semantic issues, and underlying implementation 
technology are all entirely different.  Section~\ref{sec:related}
contains a further discussion of related work.

%Overall, \forest{} substantially lowers pragmatic barriers to programming 
%with data on disk.

%% Tool Notes:

%% \begin{itemize}
%% \item Core tools implemented within the compiler. (loader)
%% \item Generic tools, useable with all descriptions, and implemented as
%%   third-party libraries.
%% \begin{itemize}
%% \item Unix-like shell tools: grep, ls, tar, cp, rm
%% \item description-generation tool using universal description
%% \item simple directory visualization by generating dot files and highlighting errors
%% \item pretty printing tools
%% \end{itemize}
%% \item Custom programming against typed interface and querying using Haskell generic programming libraries
%% \end{itemize}

\reviewer{Since the authors mentioned several practical uses of Forest
  in the introduction, it might be a bonus to include some of those as
  mini-case studies.}
