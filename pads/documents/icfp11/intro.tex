\section {Introduction}
\label{sec:intro}

Databases are an effective, time-tested technology for storing
structured and semi-structured data.  Nevertheless, many computer
users eschew the benefits of structured databases and store important
semi-structured information in collections of conventional files
scattered across a conventional file system instead.  For example, the
Princeton Computer Science Department
stores records of undergraduate student grades in a structured set of
directories and uses scripts to compute averages and
study grading trends.  Similarly, Michael Freedman collects
sets of log files from \coral, a distributed content distribution
network~\cite{freedman+:coral,freedman:coral-experience}.  
The logs are organized in hierarchical
directory structures based on machine name, time and date.  Freedman
mines the logs for information on system security, health and performance.  At
Harvard, Vinothan Manoharan, a physics professor, stores 
his experimental data in sets of files and
extracts information using python scripts.  At AT\&T, vast structured
repositories contain networking information,
phone call detail and billing data.  And there are
many other examples across the computational sciences and social
sciences, in computer systems research, in computer
systems administration, and in industry.

Users choose to implement ad hoc databases in this manner for a number
of reasons. A key factor is  that using
databases often requires paying substantial up-front costs such as:
(1) finding and evaluating the appropriate database software (and
possibly paying for it); (2) learning how to load data into the
database; (3) possibly writing programs that transform raw data 
so it may be loaded; (4) learning how
to access the data once it is in the database; and (5) interfacing the
database with a conventional programming language to support
applications that use the data.  Finally, it may be the case that the
database optimizes for a pattern of use not suited to the actual
application, which makes paying the overhead of the database system even
less desirable. 

Rather than paying these costs, programmers often store data in
the file system, using a combination of directory structure, file
names and file contents to organize the data.  We will call such a
representation of a coherent set of data a \textit{\filestore{}}.
The ``query language'' for a \filestore{}
is often a shell script or conventional programming language.

Unfortunately, the informality of \filestores{} can have
negative consequences.  First, there is generally no documentation,
which means it can be hard to understand the data and its
organization.  New users struggle to learn the structure, and if
the system administrator leaves, knowledge of the data
organization may be lost.  Second, the structure of the \filestore{} tends
to evolve: new elements are added and old formats are changed, sometimes
accidentally.  Such evolution can cause hacked-up data processing
tools to break or return erroneous results; it also further complicates
understanding the data.  Third, there is often no
systematic means for detecting data errors even though data errors can
be immensely
important.  For example, for \filestores{} containing monitoring information,
errors can signal that some portion of the monitored system is broken.
Fourth, analyses tend to be built from scratch.
There is no auxiliary query or tool support and no help with debugging.
Tools tend to be ``one-off'' efforts that are not
reuseable.  Fifth, dealing with
large data sets, which are common in this setting, imposes extra
difficulties.  For example,  standard tools
such as \cd{ls} fail when more than 256 files appear on the
command line.  Hence, programmers must  break up their data
and process it in smaller sets, a tedious task.

In this paper, we propose a better way: A novel type-based
specification language, programming environment and toolkit for
managing \filestores{}.  
This language, called \forest{}, is an embedded domain-specific
language in \haskell{}.
\forest{} allows programmers to describe the expected shape of a
\filestore{} and to materialize it as typed,
format-specific \haskell{} data structures.  Conversely,
given data structures with the appropriate type, \forest{}
makes it straightforward to dematerialize these structures
and write them out to disk.  In either case, the
goal is to making programming with \filestores{} as
easy and robust as programming with any other \haskell{} data
structure.  Furthermore, \forest{} leverages
\haskell{}'s support for generic programming to make it easy to define
tools that work for any \filestore{} with a \forest{} description.  


\forest{} descriptions provide {\em executable documentation} that can
be used to check whether a given \filestore{} conforms to its
specification.  For example, Unix file systems should be laid out as
described by the Filesystem Hierarchy Standard Group in an informal
standards document~\cite{fsh}.  In addition, the standard requires that certain
directories contain \textit{only} the specified files, presumably for
security reasons. \forest{} provides a language for writing such
standards precisely and a checker that allows users to verify that
their installation conforms to the standard.  As another example, the
\pads{} website~\cite{padsweb} contains a complex set of scripts and
data files to implement an online demo.  Unless all of the required
data files, directories, and symbolic links are configured correctly,
the web demo fails with an inscrutable error message.  \forest{}
allows the \pads{} webmaster to precisely document all of these
requirements and to detect specification violations, making it easy to
find and repair errors.

\cut{
As well as serving as documentation, generating tools to check for
consistency, and providing basic programming support by lazily
materializing \filestores{} in memory, \forest{} 
provides substantial additional support for
programmers.  

The goal is for programmers to obtain a whole range
benefits by writing one simple, compact file system specification.
The automatically generated auxiliary support includes:}

In exchange for writing a \forest{} specification,  programmers obtain
a number of benefits.  These benefits include 
(1) a set of type declarations to represent the \filestore{} in memory,
(2) a set of type declarations that capture errors and file system attributes for the \filestore{},
(3) a loading function to populate these in-memory structures, 
(4) a storing function to push updates back out to disk, and
(5) type class instance declarations that make it possible for
   programmers to query, analyze, and transform \filestore{} data
   using generic functions.

To illustrate the power of the generic programming infrastructure and
to increase the value of writing a \forest{} specification, we built a
number of tools that work for any \filestore{} with a
\forest{} specification.  These tools include a \filestore{}
visualizer, a permission checker, and \filestore{}-specific versions
of standard command-line tools such as \cd{grep} and \cd{tar}.
Using this same infrastructure, we built a tool to infer
a \forest{} specification for the directory structure starting at a
given path, which means programmers do
not have to start from scratch when writing a specification for their
\filestores{}. 

In summary, this paper makes the following contributions.
\begin{itemize}
\item {\bf Conceptual}:  We propose the {\em idea} 
of extending a modern programming language with
{\em tightly integrated linguistic features for describing \filestores{}}
and for automatically generating programming infrastructure from such 
descriptions.

\item {\bf Language Design}: We present the design of \forest{}
  and illustrate its use on real-world examples.
  The design is expressive, concise and smoothly integrated into
  Haskell.  

\item {\bf Theoretical}: We present a core calculus of \forest{}
descriptions and analyze its semantics.  We use the semantics
to prove several results including round-tripping theorems that
establish a correspondence between loads and stores of \filestore{} data.

\item {\bf Tool Generation}: We describe how third-party developers
  can use \haskell{}'s generic programming infrastructure to generate
  \filestore{}-specific tools generically.

\item {\bf Case Study in Domain-Specific Language Design}: \forest{}
  is fully implemented and its design serves
  as a case study in extensive, practical, domain-specific
  language design in modern languages by combining a number of
  experimental features of \haskell{} such as quasi-quoting and \template{}.
  Moreover, our \forest{} design and implementation experience 
  has had practical impact on the \haskell{} implementation itself:  
  the \haskell{} team modified and extended \template{} and the
  quasi-quoting mechanism in response
  to our needs.  These modifications
  are available in the most recent release of \haskell{}.
\end{itemize}

\paragraph*{Related Work.}
There has been much past work on domain-specific languages for
describing, parsing and printing individual data files. 
Examples include 
systems such as Lex, Yacc,
Antlr~\cite{antlr}, Parsec~\cite{LeijenMeijer:parsec} and 
PADS~\cite{fisher+:toplas}, to name just a few.  
However, \forest{} differs
substantially from any of these systems because it focuses on technology
for describing {\em entire file systems}.  More since 
simple file systems are {\em trees} and complex ones with symbolic links are 
{\em graphs}, whereas files are {\em sequences} (of characters or tokens), 
the language design, formal systems,
semantic issues, and underlying implementation 
technology are all entirely different.  Section~\ref{sec:related}
contains a further discussion of related work in this area.

%Overall, \forest{} substantially lowers pragmatic barriers to programming 
%with data on disk.

%% Tool Notes:

%% \begin{itemize}
%% \item Core tools implemented within the compiler. (loader)
%% \item Generic tools, useable with all descriptions, and implemented as
%%   third-party libraries.
%% \begin{itemize}
%% \item Unix-like shell tools: grep, ls, tar, cp, rm
%% \item description-generation tool using universal description
%% \item simple directory visualization by generating dot files and highlighting errors
%% \item pretty printing tools
%% \end{itemize}
%% \item Custom programming against typed interface and querying using Haskell generic programming libraries
%% \end{itemize}
