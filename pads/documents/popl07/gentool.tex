\section{The Generic Tool Framework}
\label{sec:gen-tool}

An essential benefit of \padsml{} is that it can provide users with a
high return-on-investment for describing their data. While the
generated parser and printer alone are enough to justify the user's
effort, we aim to increase the return by enabling users to easily
construct data analysis tools. However, there is a limit, both in
resources and expertise, to the range of tool generators that we can
develop.  Indeed, new and interesting data analysis tools are
constantly being developed, and we have no hope of integrating even a
fraction of them into the \padsml{} system ourselves. Therefore, it is
essential that we provide a simple framework for others to develop
tool generators.

The techniques of type-directed programming, known variously as
\textit{generic}~\cite{hinze+:generic-programming} or
\textit{polytypic}~\cite{jeuring+:polytypic-programming} programming,
provide a convenient conceptual starting point in designing a tool
framework.  In essence, any tool generator is a function from a description
to the corresponding tool. As \padsml{} descriptions are types, a tool generator is a type-directed program.

Support for some form of generic programming over data representations
and parse descriptors is an essential first step in supporting the
development of tool generators. While a full-blown generic programming
system like Generic Haskell~\cite{hinze+:generic-haskell} would be useful in this context, \ocaml{} lacks a generic programming facility. 
All is not lost, however, as a number of useful data processing tools share a common computational paradigm, and we can support that paradigm without full generic programming support.

In particular, many of the tools we have encountered 
perform their computations in a single pass over the representation
and corresponding parse descriptor, visiting each value in the data
with a pre-, post-, or in-order traversal.  This paradigm arises naturally
as it scales to very large data sets. It can be
abstracted in a manner similar to the generic functions of Lammel and
Peyton-Jones~\cite{lammel+:syb}. For each format description, we generate a
format-dependent traversal mechanism that implements a generalized
fold over the representation and parse descriptor corresponding to
that format. Then, tool developers can write a format-independent,
\emph{generic tool} by specifying the behaviour of the tool for each
\padsml{} type constructor. The traversal mechanism interacts with
generic tools through a signature that every generic tool must match.

The generic tool architecture of \padsml{} delivers a number of
benefits over the fixed architecture of \padsc{}. In \padsc{}, all
tools are generated from within the compiler. Therefore, developing a
new tool generator requires understanding and modifying the compiler.
Furthermore, the user selects the set of tools to generate when compiling the description.  In \padsml{}, tool generators can be
developed independent of the compiler and they can be developed more
rapidly because the ``boilerplate'' code to traverse data need not be
replicated for each tool generator. In addition, the user controls
which tools to ``generate'' for a given data format, and the choice
can differ on a program-by-program basis.

\subsection{The Generic-Tool Interface}
\label{sec:gentool-interface}

\begin{figure}
\begin{code}\scriptsize
\kw{module} \kw{type} S = \kw{sig}
 \kw{type} state
 ...
 \kw{module} Record : \kw{sig}
   \kw{type} partial_state
   \kw{val}  init          : (string * state) list -> state
   \kw{val}  start         : state -> Pads.pd_header 
                        -> partial_state
   \kw{val}  project       : state -> string -> state
   \kw{val}  process_field : partial_state -> string
                        -> state -> partial_state
   \kw{val}  finish        : partial_state -> state
 \kw{end}

 \kw{module} Datatype : \kw{sig}
   \kw{type} partial_state
   \kw{val}  init            : unit -> state
   \kw{val}  start           : state -> Pads.pd_header 
                          -> partial_state
   \kw{val}  project         : state -> string -> state option
   \kw{val}  process_variant : partial_state -> string 
                          -> state -> partial_state
   \kw{val}  finish          : partial_state -> state
 \kw{end}
  ...
\kw{end}
\end{code}
\vskip -2ex
\caption{Excerpt of generic-tool interface \texttt{Generic\_tool.S}.}
\label{fig:gentool-interface}
\end{figure}

The interface between format-specific traversals and generic tools is
specified as an \ocaml{} signature.  For every type constructor in
\padsml{}, the signature describes a sub-module that implements the
generic tool for that type constructor.  In addition, it specifies an
(abstract) type for auxiliary state that is threaded through the
traversal. \figref{fig:gentool-interface} contains an
excerpt of the signature that includes the signatures of the
\cd{Record} and \cd{Datatype} modules.  The signatures of other
modules are quite similar.

The \cd{Record} module includes a type \cd{partial_state} that allows
tools to represent intermediate state in a different form than the
general state. The \cd{init} function forms the state of the record
from the state of its fields. The \cd{start} function receives the PD
header for the data element being traversed and begins processing the
element. Function \cd{project} takes a record's state and the name of
a field and returns that field's state. Function \cd{process_field}
updates the intermediate state of the record based on the name and
state of a field, and \cd{finish} converts the finished intermediate
state into general tool state.  Note that any of these functions could
have side effects.

Although the \cd{Datatype} module is similar to the \cd{Record} module,
there are some important differences. The \cd{Datatype}\cd{init} function 
does not
start with the state of all the variants. Instead, a variant's state is
added during processing so that only variants that have been
encountered will have corresponding state. For this reason,
\cd{project} returns a \cd{state option}, rather than a \cd{state}.
This design is essential for supporting recursive datatypes as trying
to initialize the state for all possible variants of the datatype
would cause the \cd{init} function to loop infinitely.
\cut{
\begin{figure}
\begin{code}\scriptsize
\kw{module} Traverse (Tool : Generic_tool.S) :
\kw{sig}
  \kw{val} init : unit -> Tool.state
  \kw{val} traverse : rep -> pd -> Tool.state -> Tool.state
\kw{end}
\end{code}
\caption{The signature of the Traversal functor within the signature \texttt{Type.S}.}
\label{fig:traversal-interface}
\end{figure}
}

The following code snippet gives the signature of the
traversal functor as it would appear in the signature \cd{S} from
\secref{sec:padsml-impl}. 
\begin{code}\scriptsize
\kw{module} Traverse (Tool : Generic_tool.S) :
\kw{sig}
  \kw{val} init : unit -> Tool.state
  \kw{val} traverse : rep -> pd -> Tool.state -> Tool.state
\kw{end}
\end{code}%
\vskip -2ex
\noindent
The functor takes a generic tool generator and produces
a format-specific tool with two functions: \cd{init}, to create the initial
state for the tool, and \cd{traverse}, which traverses the
representation and parse descriptor for the type and updates the given
tool state.

\subsection{Example Tools}
\label{sec:gentool-motivation-ex}

\cut{
\begin{figure}
  \centering
  \scriptsize
\begin{verbatim}
<Order>
   <summary>
      <errors>1</errors> <total>2</total>        
   </summary>
   <Order_header>
      <summary>
         <errors>1</errors> <total>2</total>        
      </summary>
      <order_num>
         <errors>0</errors> <total>2</total>        
      </order_num>
      <att_order_num>
         <summary>
            <errors>1</errors> <total>2</total>        
         </summary>
         <val>
            <errors>0</errors> <total>2</total>                
         </val>
      </att_order_num>
      <ord_version>
         <errors>0</errors> <total>2</total>                
      </ord_version>
      ...
   </Order_header>
</Order>
\end{verbatim}  
  \caption{A fragment of the accumulator output for \dibbler{}. The
    output is encoded in \xml{}.}
  \label{fig:gentool-acc-output}
\end{figure}
}
\begin{figure}
  \centering
  \scriptsize
\begin{verbatim}
<Order_header size="13" status="GOOD">
 <order_num><val>9153</val></order_num>
 <att_order_num><val>9153</val></att_order_num>
 <ord_version><val>1</val></ord_version>
 <service_tn>
    <Something><val>0</val></Something>
 </service_tn>
 <billing_tn>
    <Something><val>0</val></Something>
 </billing_tn>
 <nlp_service_tn>
    <Something><val>0</val></Something>
 </nlp_service_tn>
 <nlp_billing_tn>
    <Something><val>0</val></Something>
 </nlp_billing_tn>
 <zip_code><Nothing><val></val></Nothing></zip_code>
 <ramp><Ramp><val>152268</val></Ramp></ramp>
 <order_sort><val>LOC_6</val></order_sort>
 <order_details><val>0</val></order_details>
 <unused><val>FRDW1</val></unused>
 <stream><val>DUO</val></stream>
</Order_header>
\end{verbatim}  
  \caption{A fragment of the \xml{} output for \dibbler{}. }
  \label{fig:gentool-xml-output}
\end{figure}

We have used this framework to implement a variety of tools useful for processing ad hoc data, including an \xml{} formatter, an accumulator tool for generating statistical overviews of the data, and a data printer for debugging.  We briefly describe these tools to illustrate the flexibility of the framework.

The \xml{} formatter converts any data with a \padsml{} description into a canonical \xml{} format.  This conversion is useful because it allows analysts to exploit the many useful tools that exist for manipulating data in \xml{}.  \figref{fig:gentool-xml-output} shows a sample portion of the output of this tool when run on the \dibbler{} data in \figref{fig:sample-data}(b).  

The accumulator tool provides a statistical summary of data.
Such summaries are useful for developing a quick understanding of data quality.  In particular, after receiving a new batch of data, analysts might want to know the frequency of errors, or which fields are the most corrupted. 
The accumulator tool tracks the distribution of the top $n$
distinct legal values and the percentage of errors. 
It operates over data sources
whose basic structure is a series of records of the same type, 
providing a summary based on viewing many records
in the data source.    More complex accumulator programs and a number of other statistical algorithms can easily be implemented using the tool generation infrastructure..

\cut{
\figref{fig:gentool-acc-output} shows a sample portion of
accumulator output for the \dibbler{} data
from~\figref{fig:sample-data}(b). The output indicates that one out of
the two \cd{Order}s has an error. Investigating further, we notice
that the problem lies in the \cd{Order_header}, in particular within
the \cd{att_order_num} field.  This field has a constraint on it, and
one of the values violates the constraint. A quick glance at the data
fragment reveals that the second order contains the offending field.
In general, particular invalid data can be located using the parse
descriptor.
}
% \begin{figure}
% \begin{code}\scriptsize
% \kw{type} baseAcc = int * int
% \kw{type} acc = ...
% | RecordData of baseAcc * acc Table.t

% \kw{type} compoundAcc = baseAcc * acc Table.t

% \kw{type} state = acc

% \kw{module} Record = \kw{struct}
%   \kw{type} partial_state = compoundAcc

%   \kw{let} init accs = RecordData ((0,0), Table.from_list accs)

%   \kw{let} start state header =
%     \kw{match} state \kw{with}
%       RecordData ((errs, total), accs) ->
% 	\kw{let} errs' = if header.nerr > 0
%                     then errs + 1 else errs
% 	\kw{in} (((errs', total + 1), accs) : partial_state)
%     | _ -> \kw{raise} ...
	  
%   \kw{let} project state label = 
%      \kw{match} state \kw{with}
%       RecordData (_, accs) -> (\kw{try} Table.find accs label
%                                  \kw{with} _ -> \kw{raise} ...)
%     | _ -> \kw{raise} ...

%   \kw{let} process_field (ba, accs) label acc =
%     (ba, Table.update accs label acc)
      
%   \kw{let} finish (ba, accs) = RecordData (ba, accs)
% \kw{end}
% ...
% \end{code}
% \caption{Excerpts from the implementation of the accumulator.}
% \label{fig:gentool-accum-code}
% \end{figure}

\cut{
In~\figref{fig:gentool-accum-code}, we show a portion of the
accumulator implementation, including the \cd{Record} module. We first
define a basic accumulator, which is simply a pair of integers
counting the number of errors seen and the total number of elements
seen. The type \cd{acc} is essentially a universal datatype with
accumulator summaries for every element of the representation type. We
show the \cd{RecordData} variant for illustration.  The \cd{init}
function starts both counts at zero and converts the provided list of
subcomponent accumulators into a \cd{Table.t}.  The \cd{start}
function updates the summary based on the error count \cd{nerr} in the
PD header provided, and increments that total count by one. It returns
a \cd{partial_state}, as indicated by the type annotation. Projection
and processing of fields are simply lookups and insertions in a table
of subcomponent accumulators.
}

Finally, as an aid in debugging \padsml{} descriptions, we have implemented a simple printing tool.  In contrast to the printer generated by the \padsml{} compiler, the output of this tool corresponds to the in-memory
representation of the data rather than its original format, which may have delimiters \etc{} that are not present in the representation.  This format is often more readable than the raw data.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../thesis.tex"
%%% End: 
