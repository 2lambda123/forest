\section{Conclusions}
\label{sec:future}

\cut{
\padsml{} is already an effective, working system for data description
and processing.  However, there are a number of ways we plan to make it 
even better.

First, there are a number of properties of data descriptions
a programmer might want to infer or verify.  For example, it is not hard to
write a non-terminating data description by accident.  It
is also possible to write a description with completely redundant
subparts (dead parser code).  While these problems might be caught 
through testing,
we would prefer to catch them at compile time.  
% It is also often useful
% for programmers to know the ``size'' of any data that matches 
% a description.  For instance, programmers describing network packets can use
% such properties to check
% their work. 
Consequently,
we plan to explore development a \padsml{} ``type checker'' 
to infer description properties and catch obvious errors.

A second long-term goal is to build a collection of
higher-level, format-independent data analysis tools.  By
``higher-level'' tools, we mean tools that perform semantic data
analysis as opposed to simpler, low-level syntactic transformation
(such as \xml\ conversion) and analysis.  
Tools in this category include tools for
content-based search, clustering, statistical data modeling, data 
generation and machine learning.  We believe that if we can automatically
generate stand-alone,
end-to-end tools that perform these functions over arbitrary data, 
we can have a substantial impact on the
productivity of many researchers in fields ranging from computational
in biology and networking.  We hope to provide access to these tools
through LaunchPADS, our data visualization 
environment~\cite{launchpads:planx,launchpads:sigmod}, which currently
only interfaces with \padsc{}.

Third, as mentioned in Section~\ref{sec:intro}, ad hoc data sources are often
very large scale.  Large data volumes often require that the data be
processed without loading it into main memory all at once.  The
\padsc{} language accommodates efficient processing of very
large-scale data~\cite{fisher+:pads} by supporting multiple-entry
point parsing, which permits a user to write tools that have fixed
memory requirements and that can yield a result in one scan of the
data source.  We plan to explore similar techniques in \padsml{}. 
}
% \section{Conclusions}
% \label{sec:conc}

Vast quantities of important information exist only in ad hoc formats.  
Data analysts desperately need reliable, high-level tools to 
help them document, parse, analyze, transform, query, and visualize such data.  
\padsml{} is a high-level domain-specific language and system
designed for this purpose.  
Inspired by the type structure of functional
programming languages, \padsml{} uses dependent
polymorphic recursive data types to describe the syntax and the semantic properties of ad hoc data sources.  The language is compact and expressive, capable of describing data from diverse domains including networking, computational biology, finance, and cosmology. 
The \padsml{} compiler uses a ``types as modules'' compilation strategy
in which every \padsml{} type definition is compiled into
an \ocaml{} module containing types for data representations
and functions for data processing.  Functional programmers
can use the generated modules to write clear and concise {\em format-dependent}
data processing programs.  Furthermore, our system design
allows external tool developers to write new {\em format-independent} tools
simply by supplying a module that matches the appropriate generic
signature.  
To give \padsml{} a precise semantics, we have simplified and extended the Data Description Calculus (\ddc)~\cite{fisher+:next700ddl} to account for parametric polymorphism.


We hope the \padsml{} system can serve as a 
challenge problem for researchers studying functional programming language
design and implementation.  In particular, our ``types as modules'' 
compilation strategy pushes against
the limits of modern module system design --- \ocaml{}'s experimental
recursive modules do not allow us to implement recursive types as
recursive modules in the natural way we envision.  
In addition, future \padsml{} programs
might be phrased extremely elegantly
as (dependently) type-directed programs, but mainstream
languages lack either dependent types or type-directed programming
features, or  both.  Lastly, rather than erasing
dependent typing information upon translation of \padsml{} into \ocaml{},
it would be ideal to preserve the dependency and to verify
that data processors preserve necessary data invariants.
Unfortunately,
sufficiently practical and powerful dependent type systems 
do not currently exist.  So while functional languages are clearly the
``programming tools of choice for discriminating hackers,''
many challenges remain in the domain of ad hoc data processing.

% Unfortunately again, while there are 
% ``generics for the masses,''~\cite{ it seems the ``the masses'' must
% program in Haskell 98.

% We challenge 

% The poses
% the number of challenges

% The \padsml{} compilation strategy also provides a stimulating and
% practical test case for researchers studying functional language
% design.  Since recursive types are compiled into recursive modules and
% parameterized types are compiled into functors, \padsml{} pushes the
% limits of the most expressive modern module systems.  It also suggests
% a collection of problems for researchers studying type-directed
% programming.  We encountered these limits in our work implementing
% \padsml{} in
% \ocaml, but rather than changing
% our basic compilation strategy, which we feel is very natural and elegant,
% we have left certain combinations of features (recursion and polymorphism)
% unimplemented.
% We challenge functional language designers to extend their favourite
% language to meet the demands of our application.


