%\newpage
\appendix
\section{Regulus Data Description in PADS/C}
\label{app:regulus-padsc}
\input{regulus.tex}

\section{Complete Syntax and Semantics of \ddc{}}
\label{app:ddc-semantics}
We first define the syntax of \ddc{} terms:

%\begin{figure}
{\small
\begin{bnf}
  \name{Kinds} \meta{\gk} \::= \kty \| \ity \-> \gk 
                               \| \kty \-> \gk \\
  \name{Types} \meta{\ty} \::= 
    \ptrue\| \pfalse \| \pbase{e} \| 
    \plam{\var}{\ity}{\ty} \| \papp{\ty}{e} \nlalt
    \psig x \ty \ty \| \psum \ty e \ty \| \pand \ty \ty \|
    \pset x \ty e \| \pseq \ty \ty {\pterm e \ty} \nlalt
    \ptyvar       \| \pmu{\ptyvar}{\gk}{\ty} \| \ptylam{\ptyvar}{\kty}{\ty} \| \ptyapp{\ty}{\ty}
    \nlalt \pcompute e \ity \| \pabsorb \ty \| \pscan{\ty}  
\end{bnf}
}
%\caption{\ddc{} Syntax}
%\label{fig:complete-ddc-syntax}
%\end{figure}

\noindent
\figref{fig:ddc-kinding} gives the complete kinding rules for the
system.

\cut{
\emph{Explain next sentence better.}
Finally, with the introduction of potentially open \implang types, we
now check that $\ity$ in rule Compute is closed with respect to any
types but the representation type variables corresponding to $\pctxt$.
}
\begin{figure*}[t]
\small
\fbox{$\ddck[\ty,\pctxt;\ctxt,\kind,\mcon]$}\\[-2ex]
\[
\infer[\text{Unit}]{
    \ddck[\ptrue,\pctxt;\ctxt,\kty,\con]
  }{\wfd {} {\fotyc \pctxt,\ctxt}}
\quad 
\infer[\text{Bottom}]{
    \ddck[\pfalse,\pctxt;\ctxt,\kty,\con]
  }{\wfd {} {\fotyc \pctxt, \ctxt}}
\quad 
\infer[\text{Const}]{
    \ddck[\pbase{e},\pctxt;\ctxt,\kty,\con]
  }{
    \begin{semcond}
      \wfd {} {\fotyc \pctxt,\ctxt} &
      \stsem[e,{\fotyc \pctxt,\ctxt},\ity] \\
      \vlet {\ity \iarrowi \kty} {\Ikind(C)}
    \end{semcond}
  }
\]

\[
\infer[\text{Abs}]{
    \ddck[\plam{\var}{\ity}{\ty},
         \pctxt;\ctxt,\ity \iarrowi \kind,\mcon]
  }{
    \ddck[\ty,\pctxt;\ectxt{\var{:}\ity},\kind,\mcon]
  }
\quad
\infer[\text{App}]{
  \ddck[\papp{\ty}{e},\pctxt;\ctxt,\gk,\mcon]
}{
  \ddck[\ty,\pctxt;\ctxt,\ity \iarrowi \gk,\mcon] &
  \stsem[e,{\fotyc \pctxt,\ctxt},\ity]
}
\]

\[
\infer[\text{Prod}]{
    \ddck[\psig{x}{\ty}{\ty'},\pctxt;\ctxt,\kty,\con]
  }{       
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] &
    \ddck[\ty',\pctxt;
          \ectxt {x{:}\iprod {\itsem[\ty]} 
              {\itpdsem[\ty]}},
          \kty,\mcon']
  }
\]

\[
\infer[\text{Sum}]{
    \ddck[\psum{\ty}{e}{\ty'},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] & \ddck[\ty',\pctxt;\ctxt,\kty,\mcon'] 
  }
\quad
  \infer[\text{Intersection}]{
    \ddck[\pand \ty {\ty'},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] & \ddck[\ty',\pctxt;\ctxt,\kty,\mcon'] 
  }
\]

\[
  \infer[\text{Con}]{
    \ddck[\pset x \ty e,\pctxt;\ctxt,\kty,\con]
  }{ 
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] & 
    \stsem[e,
     {\fotyc \pctxt,
    \ectxt{x{:}\iprod{\itsem[\ty]} 
      {\itpdsem[\ty]}}},\iboolty]
  }
\]

\[\infer[\text{Seq}]{
    \ddck[\pseq \ty {\ty_s} {\pterm e {\ty_t}},\pctxt;\ctxt,\kty,\con]
  }{
    \begin{array}{c}
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] \qquad
    \ddck[{\ty_s},\pctxt;\ctxt,\kty,\mcon_s] \qquad
    \ddck[{\ty_t},\pctxt;\ctxt,\kty,\mcon_t] \\
    \stsem[e,{\fotyc \pctxt,\ctxt},
    \iprod {\itsem[{\ty_m}]}      
    {\itpdsem[{\ty_m}]}
    \iarrowi \iboolty]
    \quad (\ty_m = \pseq \ty {\ty_s} {\pterm e {\ty_t}})
    \end{array}
  }
\]

\[
  \infer[\text{TyVar}]{
    \ddck[\ptyvar,{\pctxt;\ctxt},\kty,\ncon]
  }{\wfd {}{\fotyc \pctxt, \ctxt} \quad \tyvar{:}\kty \in \pctxt}
\quad
  \infer[\text{Rec}]{
    \ddck[\pmu \ptyvar \kty \ty,\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,{\pctxt,\ptyvar{:}\kty;\ctxt},\kty,\con]
  }
\quad
\infer[\text{TyAbs}]{
    \ddck[\ptylam{\tyvar}{\kty}{\ty},
         \pctxt;\ctxt,\kty \iarrowi \kind,\mcon]
  }{
    \ddck[\ty,{\pctxt,\tyvar{:}\kty;\ctxt},\kind,\mcon]
  }
\quad
\infer[\text{TyApp}]{
  \ddck[\ptyapp{\ty_1}{\ty_2},\pctxt;\ctxt,\gk,\mcon]
}{
  \ddck[\ty_1,\pctxt;\ctxt,\kty \iarrowi \gk,\mcon] &
  \ddck[\ty_2,\pctxt;\ctxt,\kty,\mcon]
}
\]



\[
  \infer[\text{Compute}]{       
    \ddck[\pcompute{e}{\ity},\pctxt;\ctxt,\kty,\con]
  }{
    \wfd {}{\fotyc \pctxt, \ctxt} &
    \stsem[e,{\fotyc \pctxt,\ctxt},\ity] & 
    \fomegak{\fortyc \pctxt}{\ity}{\kty}
  }      
\quad
\infer[\text{Absorb}]{
    \ddck[\pabsorb{\ty},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon]
  }
\quad
  \infer[\text{Scan}]{
    \ddck[\pscan{\ty},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon]
  }
\]
\caption{\ddc{} Kinding Rules}
\label{fig:ddc-kinding}
\end{figure*}

\noindent
The representation for each \ddc{} type $\tau$ are defined as follows:
\vskip 1ex

%\begin{figure}
\fbox{$\itsem[\ty] = \ity$}
\[
\begin{array}{lcl} 
\itsem[\ptrue] & = & \iunitty \\
\itsem[\pfalse] & = & \invty \\
\itsem[\pbase{e}] & = & \isum {\Irty(C)} \invty   \\
\itsem[\plam{\var}{\ity}{\ty}] & = & \itsem[\ty] \\
\itsem[\papp \ty e] & = & \itsem[\ty] \\
\itsem[\psig \var {\ty_1} {\ty_2}]  & = & \iprod {\itsem[\ty_1]} {\itsem[\ty_2]}    \\
\itsem[\psum {\ty_1} e {\ty_2}]     & = & \isum {\itsem[\ty_1]} {\itsem[\ty_2]} \\
\itsem[\pand {\ty_1} {\ty_2}]  & = & \iprod {\itsem[\ty_1]}{\itsem[\ty_2]}\\
\itsem[\pset x \ty e] & = & \isum {\itsem[\ty]}{\itsem[\ty]}\\
% field names: length, elts
\itsem[\pseq \ty {\ty_{\text{sep}}} {\pterm e {\ty_{\text{term}}}}] & = & 
    \iprod \iintty {(\iseq{\itsem[\ty]})}             \\
%% \itsem[\pcase e c {\ty_1} {\ty_2}]       & = & \isum {\itsem[\ty_1]} {\itsem[\ty_2]}\\
\itsem[\ptyvar] & = & \ptyvar_\repname \\
\itsem[\pmu{\ptyvar}{\gk}{\ty}] & = & \imu{\ptyvar_\repname}{\itsem[\ty]} \\
\itsem[\lambda \ptyvar.\ty]       & = & \lambda \ptyvar_\repname.\itsem[\ty] \\
\itsem[\ty_1 \ty_2]              & = & \itsem[\ty_1] \itsem[\ty_2] \\
\itsem[\pcompute e \ity]                 & = & \ity \\
\itsem[\pabsorb \ty]                     & = & \isum \iunitty \invty \\
\itsem[\pscan \ty] & = & \isum {\itsem[\ty]} \invty
%% \pext{
%% \itsem[\ptransform e e \ty]              & = & \itsem[\ty]\\
%% }
\end{array}
\]
%\caption{Representation Types}
%\label{fig:complete-rep-tys}
%\end{figure}

\noindent
The parse descriptor for each \ddc{} type $\tau$ are defined as follows:
\vskip 1ex

%\begin{figure}
\fbox{$\itpdsem[\ty] = \ity$}
\[ 
\begin{array}{lcl} 
%% %% example: \ua.(int * a) + None
%% %%          pd = \ua.pd_hdr  * ((pd_hdr * ([int]_pd * [a]_pd)) + [None]_pd)
%% %%             = \ua.pd_hdr  * ((pd_hdr * ([int]_pd * a)) + [None]_pd)
\itpdsem[\ptrue] & = & \ipty \iunitty \\                                                  
\itpdsem[\pfalse] & = & \ipty \iunitty \\                                                  
\itpdsem[\pbase{e}] & = & \ipty \iunitty\\
\itpdsem[\plam \var \ity \ty] & = & \itpdsem[\ty] \\
\itpdsem[\papp \ty e] & = & \itpdsem[\ty] \\
\itpdsem[\psig \var {\ty_1} {\ty_2}] & = & 
               \ipty {\iprod {\itpdsem[\ty_1]} {\itpdsem[\ty_2]}} \\
\itpdsem[\psum {\ty_1} e {\ty_2}] & = & 
               \ipty {(\isum {\itpdsem[\ty_1]} {\itpdsem[\ty_2]})} \\
\itpdsem[\pand {\ty_1} {\ty_2}] & = & \ipty {\iprod {\itpdsem[\ty_1]} {\itpdsem[\ty_2]}}    \\
\itpdsem[\pset x \ty e] & = & \ipty {\itpdsem[\ty]} \\
\itpdsem[\pseq \ty {\ty_{\text{sep}}} {\pterm e {\ty_{\text{term}}}}] & = & 
  \iapty {\itpdsem[\ty]} \\
\itpdsem[\ptyvar] & = & \ipty{\ptyvar_\pdbname} \\
\itpdsem[\pmu \ptyvar \kty \ty] & = & 
  \ipty{\imu{\ptyvar_\pdbname}{\itpdsem[\ty]}} \\
\itpdsem[\lambda \ptyvar.\ty]      
     & = & \lambda \ptyvar_\pdbname.\itpdsem[\ty] \\
\itpdsem[\ty_1 \ty_2]            & = & \itpdsem[\ty_1] \itpdsemstrip[\ty_2] \\
\itpdsem[\pcompute e \ity]            & = & \ipty \iunitty \\
\itpdsem[\pabsorb \ty]                & = & \ipty \iunitty \\
\itpdsem[\pscan{\ty}] & = & \ipty {(\isum {(\iprod \iintty
    {\itpdsem[\ty]})} \iunitty)}
\end{array}
\]

\fbox{$\itpdsemstrip[\ty] = \ity$}

\[
\begin{array}{lcl} 
\itpdsemstrip[\ty] & = & \ity \ \ \mbox{where}\ \itpdsem[\ty] \equiv \ipty{\ity}
\end{array}
\]
%\caption{Parse-Descriptor Types}
%\label{fig:complete-pd-tys}
%\end{figure}

\vskip 1ex
\noindent
\figref{fig:ddc-sem} gives the parsing semantics for \ddc{} type $\tau$.
\vskip 1ex
\begin{figure*}
\small
\fbox{$\trans[\ty,\ctxt,\gk] = e$} 

\[
\begin{array}{l}
  %% None 
\trans[\ptrue,\ctxt,\kty] =
  \lampair{\spair<\off,\newrep{unit}{},\newpd{unit}{\off}>}
\\[3pt] %\\
%% False 
\trans[\pfalse,,] =
  \lampair{\spair<\off,\newrep {bottom}{},\newpd {bottom}{\off}>}
\\[3pt] %\\ 
%% Const 
\trans[\pbase{e},\ctxt,\kty] =
  \lampair{\iapp {\iapp {\Iimp(C)} (e)} {\itup {\idata,\off}}}
\\[3pt] %\\
%% Abs 
\trans[\plam{\var}{\ity}{\ty},,] =
   \sfn{\nrm\var}{\ity}{\trans[\ty,\ectxt{\var{:}\ity},\kind]}
\\[3pt] %\\
%% App 
\trans[\papp{\ty}{e},\ctxt,\gk] =
  \trans[\ty,,] \sapp e  
\\[3pt]
%% Prod 
%\begin{array}{l}
\trans[\psig{x}{\ty}{\ty'},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampair{} \\
    \quad  \ilet {\spair<\off',r,p>} 
    {{\trans[\ty,,]} \sapp \spair<\idata,\off>} \\
    \quad  \ilet x {\ictup{r,p}}\\
    \quad  \ilet {\spair<\off'',r',p'>} 
    {{\trans[\ty',,]} \sapp \spair<\idata,\off'>} \\
    \quad \spair<\off'',\newrep {\gS}{r,r'},\newpd {\gS}{p,p'}>
  \end{array}  
%\end{array}
\\
%% Sum 
%\begin{array}{l}
  \trans[\psum{\ty}{e}{\ty'},,] = \\
  \begin{array}{l}  
  \lampair{} \\
  \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
  \quad \iif {\pdok p} \; \ithen {
    \def \r {\newrep {+left}{r}}
    \def \p {\newpd {+left}{p}}
    \spair<\off',\r,\p>} \\
  \quad \ielse {\ilet {\itup{\off',r,p}}{\trans[\ty',,] \sapp \spair<\idata,\off>}} \\
  \quad 
  {  % begin scope
    \def \r {\newrep {+right}{r}}
    \def \p {\newpd {+right}{p}}
    %% 
    \spair<\off',\r,\p>
  }\\ % end scope
  \end{array}
\\
%% Intersection 
  \trans[\pand{\ty}{\ty'},,] = \\
  \begin{array}{l}  
     \lampair{} \\
     \quad \ilet {\itup{\off',r,p}} {\trans[\ty,,] \sapp \spair<\idata,\off>} \\
     \quad \ilet {\itup{\off'',r',p'}} {\trans[\ty',,] \sapp \spair<\idata,\off>} \\
     \quad {\spair<\codefont{max}(\off',\off''),\newrep {\&}{r,r'},\newpd {\&}{p,p'}>}
   \end{array}
\\
%\quad
%% Set 
  \trans[\pset{x}{\ty}{e},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampair{} \\
    \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
    \quad \ilet x {\ictup{r,p}}\\
    \quad \ilet c e \\
    \quad \spair<\off',\newrep {con} {c,r},\newpd {con} {c,p}>
  \end{array}
\\
\end{array}
\begin{array}{l}
%% Array 
\trans[\pseq{\ty}{\ty_s}{\pterm e {\ty_t}},,] = \\
  \begin{array}{l}  
    \lampair{}\\
      \quad \iletfun {isDone}{\itup{\off,r,p}}{\\
        \qquad \ior {\eofpred {\idata,\off}} {e\codefont {\sapp
          \spair<r,p>}} \iori \\
        \qquad \ilet {\itup{\off',r',p'}}{\trans[\ty_t,,] \spair<\idata,\off>}\\
        \qquad \pdok{p'}
      }\\
      \quad \iin \\
      \quad \iletfun {continue} {\itup{\off,\off',r,p}} {\\
        \qquad \iif  {\off = \off' \iori \isdone {\off',r,p}} \; \ithen {\itup{\off',\codefont{r,p}}} \\
        \qquad \ielse {
          \ilet {\itup{\off_s,r_s,p_s}}{\trans[\ty_s,,] \sapp \spair<\idata,\off'>}}\\
        \qquad \ilet {\itup{\off_e,r_e,p_e}}{\trans[\ty,,] \sapp \ictup{\idata,\off_s}}\\
        \qquad \mathtt{continue} \sapp \ictup{
            \off,\off_e,\newrep {seq} {r,r_e}, \newpd {seq} {p, p_s, p_e}
        }}\\
      \quad \iin
   \end{array}\\
  \begin{array}{l}  
      \quad \ilet {\mathtt{r}} {\newrep {seq\_init}{}}\\
      \quad \ilet {\mathtt{p}} {\newpd {seq\_init}{\off}}\\
      \quad \iif {\isdone{\off,r,p}} \; \ithen {\itup{\off,\codefont{r,p}}}\\
      \quad \ielse {\ilet {\itup{\off_e,r_e,p_e}}{\trans[\ty,,] \sapp
          \spair<\idata,\off>}} \\
      \quad \mathtt{continue} \sapp \ictup{\off',\off_e,
        \newrep {seq} {r,r_e}, \newpd {seq} {p, \newpd {unit} \off, p_e}}      
  \end{array}  
\\
%\end{array}
%\quad
%\begin{array}{l}
%% Var
\trans[\ptyvar,,] = \codefont{f_\ptyvar}
\\[3pt]
%% Mu
\trans[\pmu \ptyvar \gk \ty,,] = \\
  \begin{array}{l}
  \ifun {f_\ptyvar} {\itup{\data{:}\ibitsty,\off{:}\ioffty}  
           : \ioffty * \pmu \ptyvar \gk \itsem[\ty] 
                    * (\ipty{\pmu \ptyvar \kty \itpdsem[\ty]}) } {}\\
  \quad \ilet {\itup{\off',r,p}} 
   {\trans[\ty,,] \iappi \ictup{\data,\off}} \\ 
  \qquad \ictup{\off',\iroll{r}{\pmu \ptyvar \gk \itsem[\ty]},
     (p.h,\iroll{p}{\pmu \ptyvar \kty \itpdsem[\ty]})}
%}}
  \end{array}  
\\[3pt]
%% lambda \alpha
\trans[\lambda\tyvar . \ty,,] = %\\
%  \begin{array}{l}
    \Lambda \tyvar_\repname. 
    \Lambda \tyvar_\pdbname. \lambda \codefont{f_\ptyvar}. \trans[\ty,,]
%  \end{array}  
\\
%% t1 t2
\trans[\ty_1 \ty_2,,] = 
    \trans[\ty_1,,]\; [\itsem[\ty_2]]\; [\itpdsemstrip[\ty_2]]\; \trans[\ty_2,,]
\\
%% Compute
\trans[\pcompute e \ity,,] = \\
  \quad \lampair{\itup{\off,\newrep {compute} {\nrm e},\newpd {compute} \off}}
\\[3pt]
%% Absorb
\trans[\pabsorb \ty,,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \ilet {\itup {\off',r,p}} {\trans[\ty,,] \sapp \spair<\idata,\off>}\\
    \quad \itup{\off',\newrep {absorb} p,\newpd {absorb} p}   
  \end{array}  
\\
%% Scan
\trans[\pscan \ty,,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \iletfun {try} {i} {\\
      \qquad \ilet {\itup{\off',r,p}} {\trans[\ty,,] \sapp
        \codefont{\spair<\data,\off + i>}} \\
      \qquad \iif {\pdok p}\; \ithen \\
      \qquad {\ictup{\off',\newrep {scan} r,
        \newpd {scan} {i,p}}}\; \ielse {}\\
      \qquad \iif {\codefont{i = scanMax}}\; \ithen \\
      \qquad {\ictup{\off,\newrep {scan\_err} {},
        \newpd {scan\_err} {\off}}}\; \ielse {}\\
      \qquad \codefont {try \sapp (i+1)}
   }\\
   \quad \iin \sapp \codefont{try \sapp 0} \\
  \end{array}  
\\
\end{array}
\]
%\caption{\ddc{} Semantics (cont.)}
\caption{\ddc{} Semantics}
\label{fig:ddc-sem}
\end{figure*}

The type correctness theorem relies on base type parsers behaving
properly.  The following conditions make explicit the properties that
base type semantic functions must satisfy.
\begin{condition}[Conditions on Base-type Interfaces]
  \begin{enumerate}
  \item $\dom {\Ikind} = \dom {\Iimp}$.
  \item If $\Ikind(C) = {\ity \iarrowi \kty}$ then $\Iopty(C) =
    \ioparrow \ity {\kTrans[\kty,\pbase e]}$ (for any $e$).
  \item $\fomegak{}{\Irty(C)}{\kty}$.
    \label{cond:closed-op}
  \end{enumerate}
\end{condition}

\section{Host Language}
\label{app:host-lang}

%\begin{figure}[tp]
\small
\begin{bnf}
%   \name{Variables} \meta{f,x,y} \\
%   \name{Bit}   \meta{b}   \::= 0 \| 1 \\ 
  \name{Bits}  \meta{B}   \::= \cdot \| 0\,B \| 1\,B \\ 
  \name{Constants} \meta{c} \::=
      () \| \itrue \| \ifalse \| 0 \| 1 \| -1 \| \dots \nlalt
      \ierr \| \data \| \off \| \iok \| \iecerr \| \iecpc \| \ldots \\

  \name{Values} \meta{v} \::= 
      \const \| % \ilam{\nrm \var}{\ity}{e} \| 
      \ifun {\nrm f} {\nrm x} e \| \ipair v v \nlalt
      \iinld{\ity}{v} \| \iinrd{\ity}{v} \|
      \iarr{\vec{v}} \\

  \name{Operators} \meta{op} \::= 
      = \; \| \; < \; \| \inotop % \| \isizeofop
      \| \ldots \\

  \name{Expressions} \meta{e} \::= 
      \const \| \var \| \iop{e} \|
%      \ilam {\nrm \var} \ity e \| 
      \ifun {\nrm f} {\nrm x} e \| 
      \iapp e e \nlalt
    \Lambda \alpha.e \| e \; [\ty] \nlalt
%      \iletfun {\nrm f} {\nrm x} e \; \iin \; e' \| 
      \ilet {\nrm x} e \; e \|
      \iif e \; \ithen e \; \ielse e \nlalt
      \ipair{e}{e} \| \ipi {\nrm i}{e} \|
      \iinld{\ity}{e} \| \iinrd{\ity}{e} \nlalt
      \icaseg{e}{\nrm x}{e}{\nrm x}{e} \nlalt
      \iarr{\vec e} \| \iappend e e \| \isub e {\nrm e} \nlalt
      \iroll{e}{\mu\alpha.\tau} \| \iunroll{e}{\mu\alpha.\tau}
      \\
      
  \name{Base Types} \meta{a} \::= 
      \iunitty \| \iboolty \| \iintty  \| 
      \invty \nlalt  \ibitsty \| \ioffty \| \iecty
  \\
  \name{Types} \meta{\ity} \::= 
      \ibasety \| \ityvar \| \iarrow \ity \ity \| \iprod \ity \ity \|
      \isum \ity \ity \nlalt
      \iseq \ity \| \forall \ityvar.\ity  \|
      \imu \ityvar \ity   
      \| \lambda \alpha.\ity 
      \| \ity \; \ity
  \\
  \name{Kinds} \meta{\kappa} \::= \kty \| \kappa \rightarrow \kappa
  
\end{bnf}
%\caption{\Implang{} Language: F$^\omega$}
%\label{fig:implang-syntax}
%\end{figure}

\section{Helper Functions}
\label{app:asst-functions}

\trversion{
%% Maps pads base types to implementation language base types
\begin{description}
\item $\Ikind : {Const} \rightarrow {Kind}$.
\item $\Irty : {Const} \rightarrow {Type}$.
% \item $\Ipdty : {Const} \rightarrow {Type}$.
\item $\Iimp : {Const} \rightarrow {Expression}$.
\end{description}
}

% In defining the parsing functions, we use the following helper functions:

Generic Helpers:

{\small
\begin{itemize}
\renewcommand{\labelitemi}{}
%\begin{description}
\item $\codefont {Eof} : \ibitsty \iprodi \ioffty \iarrowi \iboolty$

\item $\codefont{scanMax} : \iintty$

\item $\ifun {max} {\ictup{m,n}} {\codefont{\iif {m>n}\; \ithen m\; \ielse n}}$
\item $\ifun {pos} n {\codefont{\iif {n=0}\; \ithen 0\; \ielse 1}}$
\item $\ifun {isOk} p {\codefont{pos(p.h.nerr) = 0}}$
\item $\ifun {isErr} p {\codefont{pos(p.h.nerr) = 1}}$

\item $\ifun {max\_ec} {\ictup{ec_1, ec_2}} {}$ \\
  $\begin{array}{l}
    \iif {\codefont{ec_1} = \iecpc \iori \codefont{ec_2} = \iecpc}\; \ithen \iecpc \\
    \ielse{} \iif {\codefont{ec_1} = \iecerr \iori \codefont{ec_2} = \iecerr}\; \ithen \iecerr \\
    \ielse \iok
   \end{array}$
\end{itemize}
%\end{description}
}

% We define for each \ddc{} type a pair of constructor functions, one to build a representation and another to build a parse descriptor.
% The type of PD headers is $\iintty
%   \iprodi \iecty \iprodi \ispty$. We refer to the projections using
%   dot notation as $\codefont{nerr}$, $\codefont{ec}$ and
%   $\codefont{sp}$, respectively. A span is a pair of offsets, referred
%   to as $\codefont{begin}$ and $\codefont{end}$, respectively. Array
%   bodies have type $\iintty \iprodi \iintty \iprodi (\iseq \ity)$ (for
%   element type $\ity$). We refer to the projections as
%   $\codefont{neerr}$, $\codefont{length}$ and $\codefont{elts}$,
%   respectively.  

\noindent
Type-Specific Helpers:

{\small
\begin{itemize}
\renewcommand{\labelitemi}{}

\item %[Unit:]
\item $\ifun {R_{unit}} \iuval \iuval$
\item $\ifun {P_{unit}} \off {\itup{\itup{0,\iok,\ipair \off \off},\iuval}}$

\item %[Bottom:]
\item $\ifun {R_{bottom}} \iuval \ierr$
\item $\ifun {P_{bottom}} \off ((1,\iecpc,\ipair \off \off),())$

\item %[Pair:]
\item $\ifun {R_{\gS}} {\ipair {r_1} {r_2}} {\itup {\codefont{r_1,r_2}}}$
\item $\ifun{H_{\gS}} {\ictup{h_1,h_2}}{}$ \\
  $\begin{array}{l}
    \ilet {nerr} {\codefont{pos \itup{{h_1}.{nerr}} + pos \itup{{h_2}.{nerr}}}}\\
    \ilet {ec} {\iif {\codefont{h_2.ec} = \iecpc}\; \ithen {\iecpc}\\
    \quad \ielse {\codefont{max\_ec} \iappi \codefont{h_1.ec} \iappi \codefont{h_2.ec}}} \\
    \ilet {sp} {\ictup{h_1.sp.begin, h_2.sp.end}} \\
    \quad \ictup {nerr,ec,sp}
  \end{array}$

\item $\ifun {P_{\gS}} {\ictup{p_1, p_2}} {\ictup {H_{\gS} \itup{p_1.h,p_2.h},\itup{p_1,p_2}}}$

\item %[Sum:]
\item $\ifun {R_{+left}} r {\iinl {\codefont r}}$
\item $\ifun {R_{+right}} r {\iinr {\codefont r}}$

\item $\ifun {H_+} h {\ictup{pos(h.nerr),h.ec,h.sp}}$
\item $\ifun {P_{+left}} p {\ictup{\codefont{H_+} \iappi p.h, \iinl p}}$
\item $\ifun {P_{+right}} p {\ictup{\codefont{H_+} \iappi p.h, 
      \iinr  p}}$

\item %[Intersection:]
\item $\ifun {R_{\&}} {\ictup {r,r'}} {\ictup {r,r'}}$
\item $\ifun {H_{\&}} {\ictup {h_1, h_2}} {}$ \\
    $\begin{array}{l}
      \ilet {nerr} {\codefont{pos \itup{{h_1}.{nerr}} + pos \itup{{h_2}.{nerr}}}}\\
      \ilet {ec} {\iif {\codefont{h_1.ec} = \iecpc \iandi \codefont{h_2.ec} = \iecpc}\; \ithen {\iecpc}\\
      \quad \ielse{\codefont{max\_ec} \iappi \codefont{h_1.ec} \iappi \codefont{h_2.ec}}} \\
      \ilet {sp} {\ictup{h_1.sp.begin, max \itup{h_1.sp.end, h_2.sp.end}}} \\
      \quad \ictup {nerr,ec,sp}
    \end{array}$

\item $\ifun {P_{\&}} {\ictup {p_1,p_2}} {\ictup{H_{\&} \iappi 
      \itup{p_1.h, p_2.h},\itup{p_1,p_2}}}$

\item %[Set:]
\item $\ifun {R_{con}} {\ictup{c,r}} {
    \iif {\codefont c} \; \ithen {\iinl {\codefont r}} \; \ielse {\iinr {\codefont r}}
  }$ 
\item $\ifun {P_{con}} {\ictup {c, p}} {}$ \\
    $\begin{array}{l}
      \iif {\codefont c} \; \ithen {\ictup{(pos(p.h.nerr),p.h.ec,p.h.sp),p}} \\
      \ielse {\ictup {(1 + pos(p.h.nerr),\maxec \iecerr {p.h.ec},p.h.sp),p}}
    \end{array}$
 \end{itemize}

 \begin{itemize}
 \renewcommand{\labelitemi}{}

\item %[Array:] 
\item $\ifun {R_{seq\_init}} {\iuval} {\ictup{0,\ieseq}}$   
\item $\ifun {P_{seq\_init}} \off {\ictup{(0,\iok,\ipair \off
      \off),(0,0,\ieseq)}}$

\item $\ifun {R_{seq}} {\ictup{r, r_e}} 
  {\ictup{r.len+1,\iappend{r.elts} {\iarr{r_e}}}}$
\item $\ifun {H_{seq}} {\ictup{h, h_s, h_e}} {}$ \\
  $\begin{array}{l}
      \ilet {eerr} {
        \codefont{\iif {h.neerr = 0 \mathrel{and} h_e.nerr > 0}}\\
        \codefont{\quad \ithen 1 \;  \ielse 0}
      }\\
      \ilet {nerr} {\codefont{h.nerr + pos(h_s.nerr) + eerr}}\\
      \ilet {ec} {\iif{\codefont{h_e.ec} = \iecpc}\; \ithen {\iecpc}\\
      \quad \ielse{\maxec {\codefont{h.ec}} {\codefont{h_e.ec}}
          }} \\
      \ilet {sp} {\ictup{h.sp.begin,h_e.sp.end}} \\
      \quad \ictup {nerr,ec,sp}
    \end{array}$

\item $\ifun{P_{seq}} {\ictup{p, p_s, p_e}}{}$ \\ 
  $\begin{array}{l}
    \codefont{(H_{seq} \iappi \itup{p.h,p_s.h,p_e.h},}\\ 
    \codefont{\itup{p.neerr + pos(p_e.h.nerr), p.len + 1,\iappend {p.elts}
        {\iarr{p_e}}})}
  \end{array}$

\item %[Compute:]
\item $\ifun{R_{compute}} r {\codefont r}$
\item $\ifun{P_{compute}} \off {\ictup{\itup{0,\iok,\ipair \off \off},\iuval}}$

\item %[Absorb:]
\item $\ifun {R_{absorb}} p {\iif {\pdok p}\; 
    \ithen {\iinl \iuval}\; \ielse {\iinr \ierr}}$
\item $\ifun {P_{absorb}} p {\ictup{p.h,\iuval}}$

\item %[Scan:]
\item $\ifun{R_{scan}} r  {\codefont{\iinl r}}$
\item $\ifun{P_{scan}} {\itup{i,p}} {}$ \\
$\begin{array}{l}
\ilet {nerr} {\codefont{pos(i) + pos(p'.h.nerr)}}\\
\ilet {ec} {\iif {\codefont{nerr = 0}}\; \ithen \iok\; \ielse \iecerr} \\
\ilet {hdr} {\ictup{nerr,ec,(p.sp.begin - i,p.sp.end)}} \\
\quad \ictup{hdr,\iinl {\ictup{i,p}}}
\end{array}$

\item $\ifun {R_{scan\_err}} {()} {\iinr \ierr}$
\item $\ifun {P_{scan\_err}} \off {\ilet {hdr} {\ictup{1,\iecpc,(\off,\off)}}}$\\
  \verb+ +$\ictup{hdr,\iinr \iuval}$
%% \item[Transform:]
%% \item \fnm{P_T} (h,b) = (h,(???,b))
\end{itemize}
}
\trversion{
\begin{lemma}[Function Types]
  $\stsem[\codefont{isOk},
  \codefont{pos}{:}\iintty \iarrowi \iintty,
  \forall \ga.\ipty \ga \iarrowi \iboolty]$.
\end{lemma}
}


\begin{figure*}
\small
\fbox{$\transpp[\ty,\ctxt,\gk] = e$} 

\[
\begin{array}{l}
  %% None 
\transpp[\ptrue,\ctxt,\kty] =
  \lampppair{\epsilon}
\\[3pt] %\\
%% False 
\transpp[\pfalse,,] =
  \lampppair{\epsilon}
\\[3pt] %\\ 
%% Const 
\transpp[\pbase{e},\ctxt,\kty] =
  \lampppair{\iapp {\iapp {\Igen{pp}(C)} (e)} {\ictup {r,pd}}}
\\[3pt] %\\
%% Abs 
\transpp[\plam{\var}{\ity}{\ty},,] =
   \sfn{\nrm\var}{\ity}{\transpp[\ty,\ectxt{\var{:}\ity},\kind]}
\\[3pt] %\\
%% App 
\transpp[\papp{\ty}{e},\ctxt,\gk] =
  \transpp[\ty,,] \sapp e  
\\[3pt]
%% Prod 
%\begin{array}{l}
\transpp[\psig{x}{\ty_1}{\ty_2},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampppair{} \\
      \quad  \ilet x {\ictup{\ipid{1}{r},\ipid{1}{\ipid{2}{pd}}}}\\
      \quad  \ilet {bs_1} 
%%    \def \rf {foo} %% {\ipid{1}{r}}
%%   \def \pf {bar} %% {\ipid{1}{\ipid{2}{pd}}}
%%  \def \rs {baz} %% {\ipid{2}{r}}
%% \def \ps {foo} %% {\ipid{2}{\ipid{2}{pd}}}
      {{\transpp[\ty_1,,]} \sapp \codefont{x}} \\
      \quad  \ilet {bs_2} 
      {{\transpp[\ty_2,,]} \sapp \spair<\ipid{2}{r},\ipid{2}{\ipid{2}{pd}}>} \\
      \quad \iappend{bs_1}{bs_2}
  \end{array}  
%\end{array}
\\
%% Sum 
%\begin{array}{l}
  \transpp[\psum{\ty_1}{e}{\ty_2},,] = \\
  \begin{array}{l}  
  \lampppair{} \\
  \quad \icasess {\ictup{r,\ipid{2}{pd}}} \\
  \quad \ipattss{\ictup{\iinl{r_1}, \iinl{p_1}}} 
	{ {\transpp[\ty_1,,]} \sapp \codefont{\ictup{r_1,p_1}}}\\
  \quad \ipattss{\ictup{\iinr{r_2}, \iinr{p_2}}} 
	{ {\transpp[\ty_2,,]} \sapp \codefont{\ictup{r_2,p_2}}}\\
  \quad \ipattss{\_}  {\epsilon}\\
  \end{array}
\\
%% Intersection 
  \transpp[\pand{\ty_1}{\ty_2},,] = \\
  \begin{array}{l}  
    \lampppair{} \\
    \quad \ilet {p_1}{\ipid {1} {\ipid {2}{pd}}} \\
    \quad \ilet {p_2}{\ipid {2} {\ipid {2}{pd}}} \\
    \quad \iif {\ipid {end} {\ipid {sp} {\ipid h {p_1}}} > \ipid {end} {\ipid {sp}
          {\ipid h {p_2}}}} \\
    \qquad \ithen {{\transpp[\ty_1,,]} \sapp \spair<\ipid{1}{r},p_1>} \\
    \qquad  \ielse{{\transpp[\ty_2,,]} \sapp \spair<\ipid{2}{r},p_2>}
   \end{array}
\\
%\quad
%% Set 
  \transpp[\pset{x}{\ty}{e},\ctxt,\kty] = \\
  \begin{array}{l}  
  \lampppair{} \\
  \quad \icasess {\ictup{r,\ipid{2}{pd}}} \\
  \quad \ipattss{\ictup{\iinl{r_1}, p_1}} 
	{ {\transpp[\ty,,]} \sapp \codefont{\ictup{r_1,p_1}}}\\
  \quad \ipattss{\ictup{\iinr{r_2}, p_2}} 
	{ {\transpp[\ty,,]} \sapp \codefont{\ictup{r_2,p_2}}}\\
  \end{array}
\\
\end{array}
\begin{array}{l}
%% Array 
\transpp[\pseq{\ty}{\ilit}{\pterm e {\ty_t}},,] = \\
  \begin{array}{l}  
    \lampppair{}\\
      \quad \iletfun {print}{\itup{rs,ps}}{\\
         \qquad \icasess {\ictup{rs,ps}} \\
         \qquad \ipattss{\ictup{[], []}} \epsilon \\
         \qquad \ipattss{\ictup{[r], [p]}} 
	         { {\transpp[\ty,,]} \sapp \ictup{r,p} }\\
         \qquad \ipattssp{\ictup{r::rs, p::ps}} \\
	    \qqquad  {\transpp[\ty,,]} \sapp  \ictup{r,p}
                     \; \codefont{@}\\
	    \qqquad  \printlit \ilit
                     \; \codefont{@} \\
            \qqquad  \codefont{print} \ictup{rs,ps}  
      }\\
      \quad \iin \\      
      \quad \codefont{print} \ictup{\ipid {elts} r,\ipid{elts} {pd}}
  \end{array}  
\\
%\end{array}
%\quad
%\begin{array}{l}
%% Var
\transpp[\ptyvar,,] = \codefont{pp_\ptyvar}
\\[3pt]
%% Mu
\transpp[\pmu \ptyvar \gk \ty,,] = \\
  \begin{array}{l}
  \ifun {pp_\ptyvar} {\itup{r:\pmu \ptyvar \gk \itsem[\ty], pd:\ipty{\pmu \ptyvar \kty \itpdsem[\ty]}}
                     : \data{:}\ibitsty} {}\\
  \quad \trans[\ty,,] \ictup{\iunroll{r}{\pmu \ptyvar \gk \itsem[\ty]},
     \iunroll{p.2}{\pmu \ptyvar \kty \itpdsem[\ty]}}
%}}
  \end{array}  
\\[3pt]
%% lambda \alpha
\transpp[\lambda\tyvar . \ty,,] = %\\
%  \begin{array}{l}
    \Lambda \tyvar_\repname. 
    \Lambda \tyvar_\pdbname. \lambda \codefont{pp_\ptyvar}. \transpp[\ty,,]
%  \end{array}  
\\
%% t1 t2
\transpp[\ty_1 \ty_2,,] = 
    \transpp[\ty_1,,]\; [\itsem[\ty_2]]\; [\itpdsemstrip[\ty_2]]\; \transpp[\ty_2,,]
\\
%% Compute
\transpp[\pcompute e \ity,,] = \lampppair{} \epsilon \\
%% Absorb
\transpp[\pabsorblit \ilit,,] =
    \gl \spair<\ictup{},\codefont{pd}>.\printlit \ilit
%  \begin{array}{l}  
%     {\transpp[\ty,,]} \sapp \codefont{\ictup{\ipid{1}{\ipid{2}{p}},
% 		                                   \ipid{2}{\ipid{2}{p}}}} \\
% \end{array}  
\\
%% Scan
\transpp[\pscan \ty,,] = \\
  \begin{array}{l}  
    \lampppair{}\\
    \quad \icasess {\ictup{r,\ipid{2}{pd}}} \\
    \quad \ipattss{\ictup{\iinl{r_1}, \iinl{p_1}}} 
	{ {\transpp[\ty,,]} \sapp \codefont{\ictup{r_1,\ipid 2 {p_1}}}}\\
    \quad \ipattss{\ictup{\iinr{r_2}, \iinr {p_2}}} \epsilon\\
  \end{array}  
\\
\end{array}
\]
%\caption{\ddc{} Printing semantics (cont.)}
\caption{\ddc{} Printing semantics}
\label{fig:ddc-print-sem}
\end{figure*}

% function pp_a (r, pd) = 
%  [[t]]_pp (unfold r,unfold (pd.2))
%


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper.tex"
%%% End: 
