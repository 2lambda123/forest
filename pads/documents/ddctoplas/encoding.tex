\section{Encoding \ddl{}s in \ddc{}}
\label{sec:ddc-encodings}

\edcom{S: merge ipads extensions into one syntax figure. same for
  elab. Then, explain separately.}

We can better understand data description languages by elaborating
their constructs into the types of \ddc{}. We start by specifying the
complete elaboration of \ipads{}
into \ddc. We then discuss other features of \padsc{}, \padsml{},
\datascript{}, and \packettypes{} that are not found in \ipads{}.
Finally, we briefly discuss some limitations of \ddc{}.

% \subsection{\ipads{}:  An Idealized DDL}
% \label{sec:ddc-ipads}

% \ipads{} is an idealized version of the \padsc\ language that captures
% many of the common features of \ddl{}s. % \ipads{} captures the essence
% % of \padsc{}, on which it is based, in a fashion similar to the way
% % that MinML~\cite{harper:plbook} captures the essence of ML or
% % Featherweight Java~\cite{igarasi+:featherweight} captures the essence
% % of Java.
% The two essential differences between \padsc\ and \ipads\ are
% that many of the compound constructs have been replaced by simpler,
% orthogonal contstructs, and some of the subtler syntactic features of
% \padsc\ have been eliminated. Though the syntax differs, the structure
% of \padsc{}'s relatives \padsml{}, \packettypes{} and \datascript{}
% are similar. Hence, \ipads\ serves as an effective idealization of
% these languages as well. Some features, however, are particular to a
% given language, and are therefore introduced as separate \ipads\
% extensions, later in this section.

% \ipads{} data descriptions are types.  Complex \ipads{} descriptions
% are built by using type constructors to glue together a collection of
% simpler types, with the simplest being base types like those of
% \padsml{}. A complete \ipads{} description
% is a sequence of type definitions terminated by a single type.  This
% terminal type describes the entirety of a data source, making use of
% the previous type definitions to do so.  \ipads{} type definitions can
% have one of two forms.  The form ($\alpha = \itmv$) introduces the
% type identifier $\alpha$ and binds it to \ipads{} type $\itmv$.  The
% type identifier may be used in subsequent types.  The second form
% ($\Prec{}\; \alpha = \itmv$) introduces a recursive type definition.
% In this case, $\alpha$ may appear in $\itmv$.

% \figref{fig:ipads-syntax} summarizes the formal syntax of \ipads.  As
% with \ddc, expressions $e$ and types $\sigma$ are taken from the host
% language, described in \secref{sec:host-lang}.  Notice that we use $x$
% for host language variables and $\alpha$ for \ipads{} type variables.
% $\pbase{e}$ denotes a base type parameterized by a value. $\Pfun{}$
% introduces value-parameterized types and $\Plit{\const}$ describes a
% literal in the data source. $\Pstruct{}$s describe sequences, much
% like \padsml{} records.  $\Punion{}$ is a simplified version of
% \padsml{} datatypes, supporting only description of variance in the
% data source.  $\Parray{}$ describes homogenous sequences like the
% \padsml{} built-in type \cd{Plist}. However, the separator and
% terminator of $\Parray{}$ are specified as types rather than literals.
% $\Pwhere$ specifies constraints, $\Popt$ allows for an optional
% element, and $\Prec$ introduces recursive types. $\Pcompute$ is
% identical to $\pcomputen$ of \ddc.  $\Palt{}$ is an intersection type;
% it describes data that is described by all the branches simultaneously
% and produces a set of values - one from each type.

% \begin{figure}
% \begin{bnf}
% %   \mname{Type Definitions}{2} \meta{d} \::= \alpha = \itmv
% %   \|  \Prec{} \; \alpha = \itmv \\ \\
%   \name{Types} \meta{\itmv} \::= 
%     \pbase{e} \| \Plit{\const} \nlalt
%     \Pfun{} (\var:\ity) = \itmv \| \itmv\; e \nlalt
%     \Pstruct{} \{\overrightarrow {\var{:}\itmv}\} \| 
%     \Punion{} \{\overrightarrow {\var{:}\itmv}\} \|
%     \Palt{} \{\overrightarrow {\var{:}\itmv}\} \nlalt
%     \itmv \; \Pwhere{} \, x.e \| 
%     \Popt{}\; \itmv \|
%     \iParray{\itmv}{\itmv}{\itmv}{} \nlalt 
%     \Pcompute{} \; e{:}\ity \|
%      \alpha \| \Prec{} \; \alpha . \itmv
%      \\
% %   \mname{Host Lang. Expressions}{2} \meta{e}  \::= ... \\ \\
% %   \mname{Host Lang. Types}{2} \meta{\sigma}  \::= ...
%   \name{Programs} \meta{p} \::= \itmv \| \alpha = \itmv;\,\nont{p} \|
%   \Prec{} \; \alpha = \itmv;\,\nont {p}
% \end{bnf}
% \caption{The syntax of the \ipads{} data description langauge.}
% \label{fig:ipads-syntax}
% \end{figure}

\subsection{\ipads{} Elaboration}
\label{sec:trans-sl}

\begin{figure}
\fbox{$ \mathit{prog} \cipads \ty \; \text{prog}$}

\[
 \infer[\textsc{Prog-One}]{ 
     \itmv \cipads \ty \; \text{prog}
  }{
     \itmv \cipads \ty
  }
\qquad
  \infer[\textsc{Prog-Def}]{ 
     \ga = \itmv; \; \mathit{p} \cipads \ty \; \text{prog}
  }{
     \mathit{p}[\itmv/\ga] \cipads \ty \; \text{prog}
  }
\qquad
  \infer[\textsc{Prog-RecDef}]{ 
      \Prec{}\; \ga = \itmv; \; \mathit{p} \cipads \ty \; \text{prog}
  }{
     \mathit{p}[\Prec{}\; \ga.\itmv/\ga] \cipads \ty \; \text{prog}
  }
\]

\fbox{$ \itmv  \cipads \ty$}

\[
  \infer[\textsc{Base}]{ 
     \pbase e \cipads \pbase e
  }{}
\qquad
  \infer[\textsc{Pfun}]{ 
     \Pfun (x:\ity) = \itmv \cipads \plam x
    \ity \ty
  }{
    \itmv \cipads \ty
  }
\qquad
  \infer[\textsc{App}]{ 
     \itmv \; e \cipads \ty \; e
  }{
     \itmv \cipads \ty
  }
\]

\[
  \infer[\textsc{Pstruct}]{
    \begin{array}{l}
     \Pstruct \{x_1{:}\itmv_1 \dots x_n{:}\itmv_n\}
    \cipads \\
    \qquad \gS \; x_1{:}\ty_1. \cdots \gS \; x_{n-1}{:}\ty_{n-1}.\ty_n
   \end{array}
  }{ 
    \itmv_i \cipads \ty_i
  }
\qquad
  \infer[\textsc{Punion}]{
    \begin{array}{l}
       \Punion \{x_1{:}\itmv_1 \dots x_n{:}\itmv_n\}
      \cipads \\
      \qquad \ty_1 + \dots + \ty_n + \pfalse
    \end{array}
  }{ 
     \itmv_i \cipads \ty_i
  }
\]

\[
\qquad
  \infer[\textsc{Palt}]{
     \Palt \{x_1{:}\itmv_1 \dots x_n{:}\itmv_n\} \cipads
    \ty_1 \& \dots \& \ty_n
  }{ 
     \itmv_i \cipads \ty_i
  }
\qquad
  \infer[\textsc{Popt}]{
     \Popt \; \itmv \cipads
     \psum \ty {} \ptrue
  }{
     \itmv \cipads \ty
  }
\]

\[
  \infer[\textsc{Pwhere}]{
    \begin{array}{l}
       \itmv \; \Pwhere \, x.e \cipads \pset x \ty {\iif {\pdok {\nrm x.\codefont{pd}}} \; \ithen e \; \ielse
        \itrue}
    \end{array}
  }{ 
    \itmv \cipads \ty
  }
\]

\[
  \infer[\textsc{Parray}]{
     \iParray{\itmv}{{\itmv_{sep}}}{{\itmv_{term}}}{} \cipads 
    \pseq \ty {\pscan {\ty_s}} {\pterm f {\ty_t}}
  }{ 
    \itmv \cipads \ty & 
    \itmv_{sep} \cipads \ty_s &
    \itmv_{term} \cipads \ty_t &
    (f = \ilam x{}\ifalse)
  }
\quad
  \infer[\textsc{Pcompute}]{ 
     \Pcompute{} \; e{:}\ity \cipads \pcompute e \ity
  }{}
\]

\[
  \infer[\textsc{Plit}]{ 
     \Plit \const \cipads 
    \pscan {\pabsorb {\pset \var \ty {\var = \const}}}
  }{
    \defty \const \ty
  }
\qquad
  \infer[\textsc{Var}]{ 
     \ga \cipads \ga
  }{}    
\qquad
  \infer[\textsc{Prec}]{ 
     \Prec{}\; \ga.\itmv \cipads \pmu \ga {} \ty
  }{
     \itmv \cipads \ty
  }
\]
  \caption{Encoding \ipads{} in \ddca{}}
  \label{fig:encode-ipads}
\end{figure}

We specify the elaboration from \ipads{} to \ddc{} with two judgments:
 $p \cipads \ty\; \text{prog}$ indicates that the \ipads{} program
$p$ is encoded as \ddc{} type $\ty$, while $\itmv \cipads \ty$
does the same for \ipads{} types $\itmv$. These judgments are defined
in \figref{fig:encode-ipads}.

As much of the elaboration is straightforward, we mention only a few
important points. Notice we add $\pbot$ as the
last branch of the \ddc{} sum when elaborating \Punion{} so that the
parse will fail if none of the branches match rather than returning
the result of the last branch. We base this behavior
  directly on the actual \padsc{} language. In the elaboration of
\Pwhere{}, we only check the constraint if the underlying value parses
with no errors. For \Parray{}s, we add simple error recovery by
scanning for the separator type.  This behavior allows us to easily
skip erroneous elements. We use the $\pscann$ type in the same way for
\padskw{Plit}, as literals often appear as field separators in
\Pstruct{}s.  We also absorb the literal, as its value is known
statically.  We use the function ${\rm Ty}(c)$ to determine the
correct type for the particular literal. For example, a string
literal would require a \Pstring{} type.

\subsection{Beyond \ipads{}}

We now give semantics to four features not found in \ipads{}: \padsc{}
switched unions, \padsml{} polymorphic, recursive datatypes,
\datascript{} arrays, and \packettypes{} overlays.

\paragraph*{\padsc{} switched unions}
A switched union, like a \Punion, indicates variability in the data
format with a set of alternative formats (branches). However, instead
of trying each branch in turn, the switched union takes an expression that
determines which branch to use. Typically, this expression depends upon data read earlier in the parse. Each branch is preceded by a tag,
and the first branch whose tag matches the expression is selected.
If none match then the default branch $\itmv_{\text{def}}$ is chosen.
The syntax of a switched union is $\Pswitch{}\;e\;\{\overrightarrow{e
  \Rightarrow x{:}\itmv}\; \itmv_{\text{def}}\}$.

To aid in our elaboration of \Pswitch{}, we define a type $\iif e\;
\ithen {\itmv_1}\; \ielse {\itmv_2}$ that allows us to choose
between two types conditionally: 
% Our first attempt to
% elaborate the conditional relies on \ddc{} sums:
% \[
% \infer{
%   \iif e\; \ithen {\itmv_1}\; \ielse {\itmv_2} 
%   \cipads \psum
%   {\pset y {\psum {\pset x \ptrue {\inotop\;e}} {} {\ty_1}} e}
%   {} {\ty_2}
% }{
%   \itmv_1 \cipads \ty_1 &
%   \itmv_2 \cipads \ty_2
% }
% \]
% If $e$ is true, then the nested constraint will fail causing the left
% branch of the nested sum to fail and $\ty_1$ will be used to parse
% the data. As $e$ is true, the second constraint will succeed, leaving
% us with the left branch of the root sum. Conversely, if $e$ is false,
% the first constraint will be satisfied, but the second will not,
% causing us to parse the data with $\ty_2$. 

% Unfortunately. while this seems to work, it will fail if there is an
% error in $\ty_1$ when $e$ is true. The error will cause errors in the
% constrained type despite the satisfaction of its constraint, thereby causing
% the parser to use $\ty_2$. To address this problem, we use 
% intersections:
{\small
\[
\infer{
    \begin{array}{l}
    \iif e\; \ithen {\itmv_1}\; \ielse {\itmv_2} 
    \cipads
%    \qquad \qquad \quad
 c \iprodi \pand {({\psum {\pset x \ptrue {\inotop\;e}} {} {\ty_1}})}
    {({\psum {\pset x \ptrue {e}} {} {\ty_2}})}
    \end{array}
}{
  \itmv_1 \cipads \ty_1 &
  \itmv_2 \cipads \ty_2 &
  (c  = \pcompute {\codefont{if}
          \;e\;\codefont{then\;1\;else\;2\;}}{\codefont{Pint}})
}
\]}%
\noindent
The computed value $c$ records which branch of the conditional is
selected.  If the condition $e$ is true, $c$ will be 1, the left-hand
side of the intesection will parse $\ty_1$ and the right will parse nothing.
Otherwise, $c$ will be 2, the left-hand side will parse nothing and the
right $\ty_2$.
% The computed value $c$ indicates which branch is to be taken and the
% intersection parses exactly that branch of the conditional-type.  We
% use a combination of constrained and sum type to guard each branch with a
% condition such that the branch is only parsed if the condition is
% false. We guarantee that exactly one branch is parsed by guarding the
% two branches with mutually exclusive conditions. 

Now, we can encode \Pswitch{} as syntactic sugar for a series of cascading
conditional types.
{\small
\[
\begin{array}{l}
\Pswitch{}\;e\;\{\\
\quad e_1 \Rightarrow x_1{:}\itmv_1\\ 
\quad \dots \\
\quad e_n \Rightarrow x_n{:}\itmv_n\\
\quad \itmv_{\text{def}} \}
\end{array}
\quad
 \mathbf{=}
\quad
\begin{array}{l} 
    \iif {e = e_1}\; \ithen {\itmv_1}\; \ielse{}\\
%    \iif {e = e_2}\; \ithen {\itmv_2}\; \ielse{}\\
    \dots\\
    \iif {e = e_n}\; \ithen {\itmv_1}\; \ielse{}\\
    \itmv_{\text{def}}
\end{array}
\]}%
\noindent
Note that we can safely replicate $e$ as the
host language is pure.

\paragraph*{\padsml\ polymorphic, recursive datatypes}
We have also developed an encoding of \padsml{}'s polymorphic,
recursive datatypes. We present this encoding in two steps. First, we
extend \ipads{} with type abstraction and application, and specify
their elobaration into \ddc{}. Notice that \ipads{} type abstractions
can have multiple parameters.
\begin{bnf}
  \name{Types} \meta{\itmv} \::= ... \| 
\PFun{}\; (\overrightarrow \alpha) = \itmv
  \|   \itmv \; (\overrightarrow \itmv)

\end{bnf}
\[
  \infer{ 
     \PFun (\overrightarrow \ga) = \itmv \cipads \overrightarrow{\gl\,\ptyvar.}\ty
  }{
    \itmv \cipads \ty
  }
\qquad
  \infer{ 
     \itmv \; (\overrightarrow {\itmv}) \; \cipads \papp \ty
     {\overrightarrow {\ty}}
  }{
     \itmv \cipads \ty \qquad \overrightarrow {\itmv \cipads \ty}
  }
\]

Next, we extend \ipads{} programs to include datatype bindings.
Datatype bindings include the name of the type, $\ga$, a list of type
parameters ($\overrightarrow \ga$), a single value parameter $\var$, and a body
that consists of a list of named variants. As with $\Prec$ bindings,
we do not specify the meaning of datatype bindings in \ddc{} directly.
Rather, we decompose a given datatype into a compound \ipads{} type,
which is then substituted into the remainder of the program.

\begin{bnf}
  \name{Programs} \meta{p} \::= ... \|   
  \Pdatatype{}\; \alpha\;  \; (\overrightarrow{\alpha}) (\var:\ity) = 
  \{\overrightarrow {\var{:}\itmv}\};\,\nont {p}
\end{bnf}
\[
  \infer{ 
  \Pdatatype{} \; \ga \;  (\overrightarrow{\ga})\;(\var:\ity) =
  \{\overrightarrow {\var{:}\itmv}\}; \;\mathit{p} \cipads \ty \; \text{prog}
  }{
     \mathit{p}[\itmv'/\ga] \cipads \ty \; \text{prog} \qquad 
     (\itmv' = \PFun{}\;(\overrightarrow \ga) = \;\Pfun{}(\var:\ity) = \Prec{}\; \ga.\,\Punion{}\{\overrightarrow {\var{:}\itmv}\})
  }
\]

There are two important points to notice about the decomposition.
First, a datatype is decomposed into no less than four \ipads\ (and,
by extension, \ddc{}) types. Second, and more subtly, the recursive
type is nested inside of the abstractions, thereby preventing the
definition of nonuniform datatypes. Indeed, the name of the bound
datatype, $\ga$, plays two distinct roles -- within the recursive
type, it is a monomorphic type referring only to the recursive type
itself, while within the rest of the program it is a polymorphic type
referring to the entire type abstraction.

% Our choice to limit \padsml{} uniform datatypes was based on three
% factors: first, and foremost, we lacked any compelling examples that
% demanded nonuniform datatypes; second, recursion over higher-order
% types significantly complicates both the theory of \ddc{} and the
% implementation of \padsml{}; lastly, there is no support in \ocaml{}
% for polymorphic recursion~\footnote{The absence might be due to the
%   fact that type inference for polymorphicly-recursive functions
%   (without type annotations) is
%   undecidable~\cite{henglein:poly-recursion}.}.

\paragraph*{\datascript\ arrays}
Next, we introduce \datascript{}-style arrays for binary data,
$\itmv\;[\mathit{length}]$. They are parameterized by an optional
length field, instead of a separator and terminator. If the user
supplies the length of the sequence, the array parser reads exactly
that number of elements. Arrays with the length field specfied can be
encoded in a straightforward manner with \ddc{} sequences: 
\[
  \infer{
    \itmv \; [\mathit{length}] \cipads 
    \pseq \ty {\ptrue{}} {\pterm {f} {\pfalse{}}}
  }{ 
    \itmv \cipads \ty & 
    (f = \ilam {((len,elts),p)} {} {\codefont{len} = \mathit{length}})
  }
\]
As these arrays have neither separators nor terminators, we use
$\ptrue$ (always succeeds, parsing nothing)
and $\pfalse$ (always fails, parsing nothing), 
respectively, for separator and terminator. The
function $f$ takes a pair of array representation and PD and compares
the sequence length recorded in the representation to
$\mathit{length}$.

Arrays of unspecified length are more difficult to encode as they must
check the next element for parse errors without consuming it from the
data stream. A termination predicate cannot encode this check as they
cannot perform lookahead. Therefore, we must use the terminator type
to look ahead for an element parse error. For this purpose, we
construct a type which succeeds where $\ty$ fails and fails where
$\ty$ succeeds:
\[
\pset x {\psum \ty {} \ptrue} {\icaseg {x.rep} {\_}
  {\ifalse} {\_} {\itrue}}
\]
\noindent
Abbreviated $\pnot \ty$, this type attempts to parse a $\ty$. On
success, the representation will be a left injection. The constraint
in the constrained type will therefore fail. If a $\ty$ cannot be
parsed, the sum will default to $\ptrue$, the rep will be a right
injection, and the constraint will succeed. The use of the sum in the
underlying type is critical as it allows the constrained type to be
error free even when parsing $\ty$ fails.

With $\pnotn$, we can encode the unbounded \datascript{} array as
follows:
\[
  \infer{
    \itmv \; [{length}] \cipads 
    \pseq \ty {\ptrue{}} {\pterm {\ilam x {} \ifalse} {\pnot \ty}}
  }{ 
    \itmv \cipads \ty
  }
\]
Note that the termination predicate is trivially false, as we use the
lookahead-terminator exclusively to terminate the array. 

\paragraph*{\em \packettypes\ overlays}
Finally, we consider the {\it overlay} construct found in
\packettypes{}.  An overlay allows description authors ``to merge two
type specifications by embedding one within the other, as is done when
one protocol is {\it encapsulated} within another. Overlay[s]
introduce additional substructure to an already existing
field.''~\cite{sigcomm00}.  For example, consider a network packet
from a fictional protocol FP, where the packet body is represented as
a simple byte-array.
\begin{code}
FPPacket = \Pstruct \{
  header : FPHeader;
  body   : \Pbyte \Parray{}(\Pnosep,\Peof);
\}

IPinFP = \Poverlay FPPacket.body \Pwith IPPacket
\end{code}
Type \Pnosep{} indicates that there are no separators between elements
of the byte array. It can be encoded as \cd{\Pcompute{}(():unit)}, as
this type consumes no data and produces a unit value without errors.
The overlay creates a new type \cd{IPinFP} where the body field is an
\cd{IPPacket} rather than a simple byte array.

\edcom{TP: show encoding. Mention that technical, but uninteresting.}
We have developed a elaboration of the overlay syntax into \ddc{}. In
essence, overlays are syntactic sugar: overlaying a subfield of a
given type replaces the type of that subfield with a new type.
However, despite the essentially syntactic nature of overlays, we
discovered a critical subtlety of semantic significance, not mentioned
by the \packettypes\ authors. Any expressions in the original type that refer to the
overlayed field may no longer be well typed after applying the
overlay. For example, consider extending \cd{FPPacket} with a field
that is constrained to be equal to the checksum of the body:
\begin{code}
FPPacket = \Pstruct \{
  header   : FPHeader;
  body     : \Pbyte \Parray{}(\Pnosep,\Peof);
  checksum : Pint \Pwhere{} cs.cs = checksum(body);
\}
\end{code}
\noindent
The \cd{checksum} function requires that \cd{body} be a \cd{byte}
array. Therefore, if we overlay \cd{body} with a structured type like
\cd{IPPacket}, then \cd{body} will no longer be a byte array and, so,
the application of \cd{checksum} to \cd{body} will be
ill-formed.  We thought to disallow such expressions in the overlayed
type. However, we found this to be a difficult, if not impossible
task.  More importantly, such a restriction is unnecessary.  Instead,
the new type can be checked for well formedness after the overlay
process, an easy task in the \ddc{} framework.

At this point, we have described the elaborations of some of the more
interesting features of the languages that we have studied. However,
to give a fuller sense of what is possible, we briefly list additional
features of \datascript{} and \packettypes{} for which we have found
encodings in \ddc{}:
\begin{itemize}
\item \packettypes{}: arrays, where clauses, structures, overlays,
  and alternation.
\item \datascript{}: constrained types (enumerations and bitmask
  sets), value-parameterized types (which they refer to as ``type
  parameters''), arrays, constraints, and (monotonically increasing)
  labels. 
  \edcom{S: Explain these labels for readers not familiar with \datascript.}
\end{itemize}

%\edcom{M: what's the second one?}
We know of a couple of features from data description languages that
we cannot implement in \ddc{} as it stands.  First, we cannot support
a label construct that permits the user to rewind the input. Second,
\datascript{} allows the element type of an array to reference the
representation of the array itself~\cite{gpce02} (see, in particular,
the example in Figure 5). This feature can be useful, for example, if
the element type needs the index of the array element that is
currently being processed.  \ddc{} does not support this kind of
element-type parameterization. However, we do not view such
limitations as particularly troublesome. Like the $\lambda$-calculus
or $\pi$-calculus, \ddc{} is intended to capture many common language
features, while providing a convenient and effective basis for
extension with new features.

% Indeed, the two main features of \datascript{} that cannot currently
% be encoded in \ddc{}, require only straightforward modifications or
% additions.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../thesis.tex"
%%% End: 
