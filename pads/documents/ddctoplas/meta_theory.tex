\section{Metatheory}
\label{sec:ddc-meta-theory}

One of the most difficult, and perhaps most interesting, challenges of our
work on \ddc{} was determining what
properties we wanted to hold. What are the ``correct''
invariants of data description languages? While there are many
well-known desirable invariants for programming languages, the
metatheory of data description languages has been
uncharted.

We present the following two properties as critical invariants of
our theory.  Just like the classic Progress and Preservation theorems
should hold for any conventional typed programming language,
we feel that the following properties should hold, in some form, for any data
description language.
\begin{itemize}
\item {\bf Parser Type Correctness}: For a \ddc{} type $\ty$, the
  representation and PD output by the parsing function of $\ty$ will
  have the types specified by $\itsem[\ty]$ and
  $\itpdsem[\ty]$, respectively.
  
\item {\bf Canonical Forms of Parsed Data}: We give a precise
  characterization of the results of parsers by defining the {\em
    canonical forms} of representation-parse descriptor pairs
  associated with a dependent \ddc{} type. Of particular relevance to
  data description, we show that the errors reported in the parse
  descriptor will accurately reflect the errors present in the
  representation.
\end{itemize}

The aim of this section is to formally state and prove that these
critical properties hold for our \ddc\ theory. However, before we can
do so, we must establish some basic properties of our semantics. We
begin with a number of properties that we expect to hold for variable
names. First, all variable names introduced by the parsing semantics
function should be considered taken from a separate syntactic domain
than variables that may appear in ordinary expressions.  Therefore,
they are by definition ``fresh'' with respect to any expressions that
can be written by the user.  Second, for those types with bound
variables, the potential alpha-conversion when performing a
substitution on the type exactly parallels any alpha-conversion of the
same variable where it appears in the translation of the type. Last,
all constructors, support functions and base-type parsers are closed
with respect to user-defined variable names.

Next, we require that \ddc{} base types satisfy the properties that we
desire to hold of the rest of the calculus.  Below is a formal
statement of these requirements. Note that by
condition~\ref{cond:closed-op}, base type parsers must be closed.
\begin{condition}[Conditions on Base-types]
\label{cond:base-types}
  \begin{enumerate}
  \item $\dom {\Ikind} = \dom {\Iimp}$.
  \item If $\Ikind(C) = {\ity \iarrowi \kty}$ then $\Iopty(C) =
    \iarrow \ity {\kTrans[\kty,\pbase e]}$ (for any $e$ of type $\ity$).
  \item $\stsem[\Iimp(C),,\Iopty(C)]$.
    \label{cond:closed-op}
  \end{enumerate}
\end{condition}
%\edcom{M: canon is not defined yet. Either define it informally now or move it to
%  later where it is needed.}

\begin{figure}[t]
\[ 
\begin{array}{ll}
  \infer{\ty \stepstok 0 \ty}{} \qquad
  &
  \infer{\ty \stepstok {k+1} \ty''}
  {\ty \stepsto \ty' \quad \ty' \stepstok k \ty''}
\\[2ex]
  \infer{\iexpn \stepstok 0 \iexpn}{} 
&
 \infer{\iexpn \stepstok {k+1} \iexpn''}
  {\iexpn \stepsto \iexpn' \quad \iexpn' \stepstok k \iexpn''}
\end{array}
\]
\caption{K-steps normalization and evaluation judgments}
\label{fig:k-steps-norm-eval}
\end{figure}

The evaluation of \fomega{} terms and the normalization of \ddc{}
types are both defined with a small-step semantics. However, it is
useful to be able to reason about terms and types that are related by
arbitrary many ($k$) steps in these semantics, rather than just one.
To this end, in \figref{fig:k-steps-norm-eval}, we define two
judgments that respectively generalize evaluation and normalization to
$k$ steps. Next, we state some properties of these judgments.

\begin{lemma}[Properties of K-step Evaluation]
  \begin{enumerate}
  \item If $\,\iexpn_1 \stepstok k \iexpn_1'$ then $\iexpn_1 \, \iexpn_2
    \stepstok k \iexpn_1' \, \iexpn_2$.
  \item If $\,\iexpn_2 \stepstok k \iexpn_2'$ then $\ivaln \, \iexpn_2
    \stepstok k \ivaln \, \iexpn_2'$.
  \item If $\,\iexpn \stepstok k \iexpn'$ then $\iexpn \, [\ity]
    \stepstok k \iexpn' \, [\ity]$.
  \item If $\, e_1 \stepstok i e_2$ and $e_2 \stepstok j e_3$
    then $e_1 \stepstok {(i+j)} e_3$.
  \end{enumerate}
\label{lemma:kleene-eval}
\end{lemma}

\begin{proof}
  By induction on the number of steps in evaluation relation.
\end{proof}

\begin{lemma}[Properties of K-step Normalization]
  \begin{enumerate}
  \item If $\,\ty_1 \stepstok k \ty_1'$ then $\ty_1 \, \ty_2
    \stepstok k \ty_1' \, \ty_2$.
  \item If $\,\ty_2 \stepstok k \ty_2'$ then $\tyval \, \ty_2
    \stepstok k \tyval \, \ty_2'$.
  \item If $\,\ty_1 \stepstok k \ty_1'$ then $\ty_1 \, \iexpn
    \stepstok k \ty_1' \, \iexpn$.
  \item If $\,\iexpn \stepstok k \iexpn'$ then $\tyval \, \iexpn
    \stepstok k \tyval \, \iexpn'$.
  \item If $\,\ty_1 \stepstok i \ty_2$ and $\ty_2 \stepstok j \ty_3$
    then $\ty_1 \stepstok {(i+j)} \ty_3$.
  \end{enumerate}
\label{lemma:kleene-norm}
\end{lemma}

\begin{proof}
  By induction on the number of steps in evaluation relation.
\end{proof}

\begin{lemma}[K-step Evaluation Inversion]
  \begin{enumerate}
  \item If $\, \iexpn_1 \, \iexpn_2 \stepstok k \ivaln$ then $k > 0$ and
    $\exists\;i,j,\ivaln_1,\ivaln_2$ \suchthat{} $\iexpn_1 \stepstok i \ivaln_1$ and $\iexpn_2 \stepstok j
      \ivaln_2$, with $i+j < k$.
  \item If $\, \iexpn\,[\ity] \stepstok k \ivaln$ then
    $\exists\;i,\ivaln'$ \suchthat{} $\iexpn \stepstok i
    \ivaln'$, with $i < k$.
  \item If $\, (\ifun {\nrm f} {\nrm x} \iexpn) \iappi \ivaln \stepstok k \ivaln'$ then
    $\iexpn[(\ifun {\nrm f} {\nrm x} \iexpn)/f][\ivaln/\ivarn] \stepstok {k-1} \ivaln'$.
  \item If $\, \ilet {\nrm \ivarn} \iexpn \, \iexpn' \stepstok k
    \ivaln$ then $\exists\;i,\ivaln'$ \suchthat{} $\iexpn
    \stepstok i \ivaln'$ with $i < k$. 
  \item If $\, \iif{\iexpn}\;\ithen {\iexpn_1}\; \ielse{\iexpn_2} \stepstok
    k \ivaln$ and $\iexpn \kstepsto \itrue$ then $\exists\;i$ \suchthat{} $\iexpn_1 \stepstok i
    \ivaln$ with $i < k$.
  \item If $\, \iif{\iexpn}\;\ithen {\iexpn_1}\; \ielse{\iexpn_2} \stepstok
    k \ivaln$ and $\iexpn \kstepsto \ifalse$ then $\exists\;i$ \suchthat{} $\iexpn_2 \stepstok i
    \ivaln$ with $i < k$.
  \end{enumerate}
\label{lemma:kleene-eval-inv}
\end{lemma}

\begin{proof}
  By induction on the number of steps in the evaluation relation.
\end{proof}

\begin{lemma}[Confluence of Evaluation]
  If $\iexpn \stepstok k \ivaln$ and $\iexpn \stepstok i \iexpn'$ then
  $\iexpn' \stepstok {k-i} \ivaln$.
  \label{lemma:eval-unique}
\end{lemma}

\begin{proof}
  By induction on the height of the first derivation, using
  determinacy of single-step evaluation as needed.
\end{proof}

A number of \ddc\ properties
involve reasoning about terms that are equivalent up-to equivalent
typing annotations. Therefore, we now define this equivalence and state
some of its properties.

\begin{definition}[Expression Equivalence]
  $\iexpn \iexpreq \iexpn'$ iff $\iexpn$ is syntactically equal to
  $\iexpn'$ modulo alpha-conversion of bound variables and equivalence
  of typing annotations.
\label{def:op-eq}  
\end{definition}

\begin{lemma}[Properties of Expression Equivalence]
  \begin{enumerate}
  \item If $\iexpn \iexpreq \iexpn'$ and $\iexpn \stepstok k \iexpn_1$ then
    $\exists\;\iexpn_1'$ \suchthat{}
    $\iexpn' \stepstok k \iexpn_1'$ and $\iexpn_1 \iexpreq \iexpn_1'$.
  \item If $\iexpn \iexpreq \iexpn'$ then 
    $\iexpn_1[\iexpn/\ivarn] \iexpreq \iexpn_1[\iexpn'/\ivarn]$.
  \item If $\ity \equiv \ity'$ then 
    $\iexpn[\ity/\tyvar] \iexpreq \iexpn[\ity'/\tyvar]$.
  \item $\iexpn \iexpreq \iexpn$.
  \item If $\iexpn \iexpreq \iexpn'$ then $\iexpn' \iexpreq \iexpn$. 
  \item If $\iexpn \iexpreq \iexpn'$ and $\iexpn' \iexpreq \iexpn''$  then
    $\iexpn \iexpreq \iexpn''$ .
  \end{enumerate}
\label{lemma:misc-synt-eq}
\end{lemma}

\begin{proof}
  Part 1. By induction on the number of steps in the evaluation relation.
  Note that evaluation in \fomega{} is not influenced by typing
  annotations. Part 2: By induction on size of $\iexpn_1$. Part 3: By
  induction on size of $\iexpn$ and definition of expression
  equivalence. Parts 4, 5, 6: By reflexivity, symmetry and transitivity
  of expression equality and type equivalence.
\end{proof}

Next, we state two properties of \fomega\ type equivalence that are
needed later.
\begin{lemma}[Properties of \fomega\ Type Equivalence]
  \begin{enumerate}
  \item If $\;\wfty{\ctxt} {\ity} {\kind}$ and $\ity \equiv \ity'$ then
    $\wfty{\ctxt} {\ity'} {\kind}$. \label{lemma:fomega-eq-ty-kinding}
  \item If $\;\stsem[e,{\ctxt,x{:}\ity,\ctxt'},\ity_1]$ and $\ity \equiv
    \ity'$ then $\stsem[e,{\ctxt,x{:}\ity',\ctxt'},\ity_1]$. \label{lemma:fomega-eq-hyp-typing}
  \end{enumerate}
\label{lemma:fomega-ty-eq-props}
\end{lemma}

Next, we show that substitution commutes with all of the
semantic interpretations of \ddc{}. For clarity, we first introduce
two substitution-related abbreviations:
\[
\begin{array}{lll}
\xsubabbrev \ty \ptyvar & = & \xsub \ty \ptyvar\\
\zsubabbrev \ty \ptyvar & = & \zsub \ty \ptyvar
\end{array}
\]  

\begin{lemma}[Commutativity of Substitution and Semantic Interpretation]
  \begin{enumerate}
  \item $\itsem[{\ty[\ty'/\ptyvar]}] = \itsem[\ty]\xsubabbrev {\ty'} \ptyvar$.
  \item If $\ddck[\ty,\pctxt;\ctxt,\gk,]$ then $\itsem[{\ty[\ty'/\ptyvar]}] = 
    \itsem[\ty][\itsem[\pmu \ptyvar \gk \ty]/\ptyvar_\repname]$.
  \item If $\ \exists\,\ity$ \suchthat\ $\itpdsem[\ty] = \ity$ and
    $\ \exists\,\ity$ \suchthat\ $\itpdsem[\ty'] \equiv {\ipty \ity}$
then $\itpdsem[{\ty[\ty'/\ptyvar]}] \equiv
    \itpdsem[\ty]\xsubabbrev {\ty'} \ptyvar = 
    \itpdsem[\ty][\itpdsemstrip[\ty]/\ptyvar_\pdbname]$.
  \item If $\ \exists\,\ity$ \suchthat\ $\itpdsem[\ty] = \ity$ and
    $\ \exists\,\ity$ \suchthat\ $\itpdsem[\ty'] \equiv {\ipty \ity}$
then $\trans[{\ty[\ty'/\ptyvar]},,] \iexpreq
    \trans[\ty,,]\zsubabbrev {\ty'} \ptyvar$.
  \item $\itsem[{\ty[\ivaln/\ivarn]}] = \itsem[\ty]$.
  \item $\itpdsem[{\ty[\ivaln/\ivarn]}] = \itpdsem[\ty]$.
  \item $\trans[{\ty[\ivaln/\ivarn]},,] = \trans[\ty,,][\ivaln/\ivarn]$.
  \end{enumerate}
\label{lemma:subst-comm}
\end{lemma}

\begin{proof}
  Parts 1,3-7: By induction on structure of types. For part 3, the
  most interesting case is for the type $\ptyvar$, which is shown in
  detail in \appref{app:extended-proofs}.
  Part 2 is proven by induction
  on the height of the kinding derivation.  The most interesting case
  is $\pcomputen$, as it is the only construct in which a variable of
  the form $\ptyvar_\pdbname$ might appear. However, as the type is
  well-formed, we know from the kinding rules that the only type
  variables allowed in $\ity$ are of the form $\tyvar_\repname$.
  For part 4, note that variables of the form $\parsenamecd_\repname$
  cannot appear in any $\ty$ -- they can only be introduced by the
  parsing semantics function. A number of the more challenging cases
  are shown in detail in \appref{app:extended-proofs}. 
  For part 6, note that the open variables in $\trans[\ty,,]$ are
  exactly those that are open in $\ty$ itself, as none are introduced
  in the translation.
\end{proof}

Next, we prove a similar commutativity result for the $\kTrans[\cdot,\cdot]$ function.
%\edcom{M: Use new subst. abbreviation.}
\begin{lemma}
 If $\ \exists\,\ity$ \suchthat\ $\itpdsem[\ty] = \ity$ and
    $\ \exists\,\ity$ \suchthat\ $\itpdsem[\ty'] \equiv {\ipty \ity}$
then  $\kTrans[{\kind\xsubabbrev {\ty'} \ptyvar},{\ty[\ty'/\ptyvar]}] = 
  \kTrans[\kind,\ty]\xsubabbrev {\ty'} \ptyvar$.
\label{lemma:pt-subst-comm}
\end{lemma}

\begin{proof}
  By induction on the size of the kind, using
  \lemref{lemma:subst-comm} for $\kty$ case.
\end{proof}

\begin{lemma}
  The function $\itsem[\cdot]$ is total.
\end{lemma}
\begin{proof}
  By induction on the structure of types.
\end{proof}

Next we present some standard type-theoretic results for \ddc{}
kinding and normalization.

\begin{lemma}[\ddc{} Preservation]
  If $\; \ddck[\ty,,\kind,]$ and $\ty \kstepsto \tyval$ then $\ddck[\tyval,,\kind,]$.
\label{lemma:ddc-preservation}
\end{lemma}
\begin{proof}
  By induction on the kinding derivation.
\end{proof}

\begin{lemma}[\ddc{} Inversion]
  All kinding rules are invertable.
  \label{lemma:inversion}
\end{lemma}
\begin{proof}
  By inspection of the kinding rules.
\end{proof}

\begin{lemma}[\ddc{} Canonical Forms]
  If $\; \ddck[\tyval,,\kind,]$ then either
  \begin{itemize}
  \item $\kind = \kty$, or
  \item $\kind = \ity \iarrowi \gk$ and $\ty = \plam \ivarn {} {\ty'}$, or
  \item $\kind = \kty \iarrowi \gk$ and $\ty = \plam \ptyvar {} {\ty'}$.
  \end{itemize}
\label{lemma:norm-canon-form}
\end{lemma}
\begin{proof}
  By kinding rules and grammar of normalized types $\tyval$.
\end{proof}

Finally, we state the substitution lemmas that we assume to hold of
the various underlying \fomega\ judgments followed by a substitution
lemma for \ddc{}.

\begin{lemma}[\fomega{} Substitution]
  \begin{enumerate}
  \item If $\;\wfd{}{\ctxt,\tyvar{::}\kty,\ctxt'}$ and $\wfty \ctxt \ity
    \kty$ then $\wfd{}{\ctxt,\ctxt'[\ity/\tyvar]}$.
  \item If $\;\wfty {\ctxt,\tyvar{::}\kty} \ity \kind$ and $\wfty \ctxt {\ity_1} \kty$ then
    $\wfty \ctxt {\ity[\ity_1/\tyvar]} \kty$.
  \item If $\;\stsem[\iexpn,{\ctxt,\tyvar{::}\kty,\ctxt'},\ity]$ and $\wfty \ctxt {\ity_1}
    \kty$ then
    $\stsem[{\iexpn[\ity_1/\tyvar]},{\ctxt,\ctxt'[\ity_1/\tyvar]}, {\ity[\ity_1/\tyvar]}]$.
  \item If $\;\stsem[\iexpn,{\ctxt,\ivarn{:}\ity'},\ity]$ and 
    $\stsem[\ivaln,\ctxt,\ity']$ then 
    $\stsem[{\iexpn[\ivaln/\ivarn]},\ctxt,\ity]$
  \end{enumerate}
  \label{lemma:fomega-subst}
\end{lemma}

\begin{proof}
  These are standard properties of \fomega. They are all proven by
  induction on the height of the first derivation.
\end{proof}

\begin{lemma}[\ddc{} Substitution]
  \begin{enumerate}
  \item If $\ddck[\ty,{\pctxt;\ctxt,\ivarn{:}\ity},\kind,]$ and 
    $\stsem[\ivaln,{\fotyc \pctxt;\ctxt},\ity]$
    then $\ddck[\ty[\ivaln/\ivarn],\pctxt;\ctxt,\kind,]$.
  \item If $\ddck[\ty,{\pctxt,\ptyvar{:}\kty;\ctxt,\ctxt'},\kind,]$ and 
    $\ddck[\ty',\pctxt;\ctxt,\kty,]$
    then $\ddck[\ty[\ty'/\ptyvar],{\pctxt;\ctxt,\ctxt'[\ty'/\ptyvar]},{\kind[\ty'/\ptyvar]},]$.
  \end{enumerate}
  \label{lemma:ty-val-subst} % deprecated
  \label{lemma:ty-ty-subst}  % deprecated
  \label{lemma:ddc-subst}
\end{lemma}
\begin{proof}
  For both parts, by induction on the first derivation, using
  Lemma~\ref{lemma:fomega-subst} as needed.
\end{proof}

% \edcom{State and prove progress?}

Finally, we state another commutativity property for the semantic
functions. In essence, it says that evaluation (aka. normalization,
type equivalence) commutes with semantic interpretation. This result
has inherent value for reasoning about \ddc{}, as it allows one to
reason about the semantics of \ddc{} functions directly in terms of
the stated normalization rules, rather than indirectly through
semantic interpretation and the evaluation/equivalence rules of the
semantic domain. Note that the premise of the lemma involves parser
evaluation because that is what is needed for later use. We posit without
proof that this lemma would be equally true if the second
premise were switched with the first conclusion.
\edcom{TP: say more: how would it be useful.}

\begin{lemma}[Commutativity of Evaluation and Semantic Interpretation]
  If $\; \ddck[\ty,,\kind,]$ and $\trans[\ty,,] \kstepsto \ivaln$ then
  \begin{enumerate}
  \item $\ty \kstepsto \tyval$,
  \item $\ivaln \iexpreq \trans[\tyval,,]$,
  \item $\itsem[\ty] \equiv \itsem[\tyval]$, and
  \item $\itpdsem[\ty] \equiv \itpdsem[\tyval]$.
  \end{enumerate}
\label{lemma:eval-corr}
\end{lemma}
\begin{proof}
  By induction on the number of steps in the evaluation.  Within the
  induction, we proceed using a case-by-case analysis of the possible
  structures of type $\ty$. The complete proof is shown in
  \appref{app:extended-proofs}.
\end{proof}


\subsection{Type Correctness}
Our first key theoretical result is that the various semantic
functions we have defined are coherent.  In particular, we show that
for any well-kinded \ddca{} type $\tau$, the corresponding parser is
well typed, returning a pair of the corresponding representation and
parse descriptor.

Demonstrating that generated parsers are well formed
and have the expected types is nontrivial primarily because
the generated code expects parse descriptors to have a particular shape,
and it is not completely obvious they do in the presence of polymorphism.
Hence, to prove type correctness, we first need to characterize the shape of
parse descriptors for arbitrary \ddc{} types.   

The particular shape required is that every parse descriptor be a pair
of a header and an (arbitrary) body. The most straightforward
characterization of this property is too weak to prove directly, so we
instead characterize it as a logical relation in
Definition~\ref{def:pd-props}.  Lemma~\ref{lemma:pd-log-rel}
establishes that the logical relation holds of all well-formed \ddca{}
types by induction on kinding derivations, and the desired
characterization follows as a corollary.

\begin{definition}
\label{def:pd-props}
\begin{itemize}
\item $\hhpred \ty \kty$ iff $\ \exists\,\ity$ s.t. $\itpdsem[\ty] \equiv
  {\ipty \ity}$.
\item $\hhpred \ty {\kty \iarrowi \kind}$ iff $\ \exists\,\ity$
  s.t. $\itpdsem[\ty] \equiv \ity$ and whenever $\hhpred
  {\ty'}{\kty}$, we have $\hhpred {\papp \ty {\ty'}}{\kind}$.
\item $\hhpred \ty {\ity \iarrowi \kind}$ iff $\ \exists\,\ity'$
  s.t. $\itpdsem[\ty] \equiv \ity'$ and $\hhpred{\papp \ty e}{\kind}$
  for any expression $e$.
\end{itemize}
\end{definition}

\begin{lemma}
  If $\hhpred \ty \kty$ then $\exists \, \ity \, s.t. \itpdsem[\ty] =
  \ity$.
\label{lemma:H-prop}
\end{lemma}
\begin{proof}
  Follows immediately from definition of $\hhpred \ty \kty$.
\end{proof}

Note that we implicitly demand that $\itpdsem[\ty]$ is well defined in
the hypothesis of the lemma. We cannot assume that it is well-defined,
even for well-formed $\ty$, as that is part of what we are trying to
prove.

\begin{lemma}
  If $\itpdsem[\ty] \equiv \itpdsem[\ty']$ then $\hhpred \ty \kty$ iff $\hhpred {\ty'} \kty$.
\label{lemma:eq-preserve-H}
\end{lemma}
\begin{proof}
  By induction on the structure of the kind.
\end{proof}

\begin{lemma}
  If $\hhpred {\ty} \kind$ and $\hhpred {\ty'} \kty$ then $\hhpred {\ty[\ty'/\ptyvar]} \kind$.
\label{lemma:hh-subst}
\label{lemma:sub-preserve-H}
\end{lemma}
\begin{proof}
  By induction on the structure of the kind.  The proof is detailed in
  \appref{app:extended-proofs}.
\end{proof}

\begin{lemma}
\label{lemma:pd-log-rel}
If $\ddck[\ty,{\pctxt;\ctxt},\kind,{}]$ then $\hhpred \ty \kind$.
\end{lemma}

\begin{proof}
  By induction on the height of the kinding derivation. A number of
  the more challenging cases are shown in \appref{app:extended-proofs}.
\end{proof}

\begin{corollary}
\label{cor:pd-props}
  \begin{itemize}
  \item If $\ddck[\ty,\pctxt;\ctxt,\kind,{}]$ then $\exists
     \ity.\itpdsem[\ty] = \ity$.
   \item If $\ddck[\ty,\pctxt;\ctxt,\kty,{}]$ then $\exists
     \ity.\itpdsem[\ty] \equiv \ipty \ity$.
  \end{itemize}
\end{corollary}

\begin{proof}
  Immediate from definition of $\hhpred \ty \kind$ and
  Lemma~\ref{lemma:pd-log-rel}.
\end{proof}

We can now prove a general result stating that if a type is well
formed, then its type interpretations will be well formed, and that
the kind of the type will correspond to the kinds of its
interpretations. We first state this correspondence formally and then
state and prove the lemma.

\begin{definition}[\ddc{} Kind Interpretation in \fomega{}]
\begin{itemize}
\item $K(\kty)        = \kty$
\item $K(\ity \iarrowi {\kind}) = K(\kind)$
\item $K(\kty \iarrowi {\kind}) = \kty \iarrowi K(\kind)$
\end{itemize}
\end{definition}

\begin{lemma}[Representation-Type Well Formedness]
If $\ddck[\ty,\pctxt;\ctxt,\kind,]$ then 
\begin{itemize}
\item $\wfty{\fortyc \pctxt}{\itsem[\ty]}{K(\kind)}$
\item $\wfty{\fopdtyc \pctxt}{\itpdsem[\ty]}{K(\kind)}$
\item If $\kind = \kty$ then $\wfty {\fopdtyc \pctxt}{\itpdsemstrip[\ty]}{\kty}$.
\end{itemize}
\label{lemma:rep-ty-well-form}
\end{lemma}

\begin{proof}
  By induction using Lemma~\ref{lemma:pd-log-rel} and
  \lemref{lemma:fomega-ty-eq-props}, part~\ref{lemma:fomega-eq-ty-kinding}.
\end{proof}

We continue by stating and proving that parsers are type correct.
However, to do so, we must first establish some typing properties of
the representation and parse-descriptor constructors, as at least one of them appears in most
parsing functions. In particular, we prove that each constructor
produces a value whose type corresponds to its namesake \ddc{}
type. For clarity, we abbreviate $\ipty \ity$ as $\pda \ity$.

\begin{lemma}[Types of Constructors]
\label{lem:types-of-constructors}
\begin{itemize}
\item $\newrepf {unit} : \iarrow \iunitty \iunitty$
\item $\newpdf  {unit} : \iarrow \ioffty {\ipty \iunitty}$
\item $\newrepf {bottom} : \iarrow \iunitty \invty$
\item $\newpdf  {bottom} : \iarrow \ioffty {\ipty \iunitty}$
\item $\newrepf {\gS} : \forall \ga,\gb.\iarrow {\iprod \ga \gb} {\iprod \ga \gb}$
\item $\newpdf {\gS} : \forall \ga,\gb. 
  \iarrow {\iprod {\pda \ga} {\pda \gb}}
  {\pda {(\pda \ga \iprodi \pda \gb)}}
$
\item $\newrepf {+left} : \forall \ga, \gb.\iarrow \ga 
                            {\isum \ga \gb}$
\item $\newrepf {+right} : \forall \ga, \gb.\iarrow \gb {\isum \ga \gb}$
\item $\newpdf {+left} : \forall \ga, \gb.\iarrow {\pda \ga} 
  {\ipty {(\isum {\pda \ga}{\pda \gb})}}$
\item $\newpdf {+right} :\forall  \ga, \gb. \iarrow {\pda \gb} 
                            {\ipty {(\isum {\pda \ga} {\pda \gb})}}$
\item $\newrepf {\&} : \forall \ga,\gb.\iarrow {\iprod \ga \gb} {\iprod \ga \gb}$
\item $\newpdf {\&} : 
\forall \ga,\gb.
  \pda \ga \iprodi
  \pda \gb \iarrowi 
         {\ipty {(\pda \ga \iprodi \pda \gb)}}
$.
\item $\newrepf {con} : \forall \ga.\iprod \iboolty \ga 
  \iarrowi {\isum \ga \ga}$
\item $\newpdf {con} :\forall  \ga. \iprod \iboolty \iarrow {\pda \ga} {\ipty {\pda \ga}}$
\item $\newrepf {seq\_init} : \forall \ga.\iarrow \iunitty {\iintty \iprodi \iseq \ga}$
\item $\newpdf {seq\_init} : \forall \ga. \iarrow \ioffty {\iapty {\pda\ga}}$
\item $\newrepf {seq} : \forall \ga.\iarrow
  {(\iintty \iprodi \iseq \ga) \iprodi \ga}
  {\iintty \iprodi \iseq \ga}$
\item $\newpdf {seq} :\forall  {\ga_{elt}},{\ga_{sep}}. 
  (\iapty {\pda {\ga_{elt}}}) \iprodi
  \pda {\ga_{sep}} \iprodi 
  \pda {\ga_{elt}} \iarrowi \\
  \iapty {\pda {\ga_{elt}}}$
\item $\newrepf {compute} : \forall \ga.\iarrow \ga \ga$
\item $\newpdf {compute} : \iarrow \ioffty {\ipty \iunitty}$
\item $\newrepf {absorb} : \forall \ga.\iarrow {\pda \ga} {\isum
    \iunitty \invty}$
\item $\newpdf {absorb} :\forall  \ga. \iarrow {\pda \ga} {\ipty
    \iunitty}$
\item $\newrepf {scan} : \forall \ga.\iarrow \ga {\isum \ga \invty}$
\item $\newpdf {scan} :\forall  \ga. \iarrow {\iprod \iintty {\pda \ga}}
  {\ipty {(\isum {(\iprod \iintty {\pda \ga})} \iunitty)}}$
\item $\newrepf {scan\_err} : \forall \ga.\iarrow \iunitty {\isum \ga \invty}$
\item $\newpdf {scan\_err} :\forall  \ga. \iarrow \ioffty
  {\ipty {(\isum {(\iprod \iintty \ga)} \iunitty)}}$
\end{itemize}  
\end{lemma}

\begin{proof}
  By typing rules of \fomega.
\end{proof}

With our next lemma, we establish the type correctness of the
generated parsers. We prove the lemma using a general induction
hypothesis that applies to open types.
This hypothesis must account for the fact
that any free type variables in a \ddc{} 
type $\ty$ will become free
function variables in $\trans[\ty,,]$. To that end, 
we define the function $\ptyc \pctxt$ which maps type-variable contexts $\pctxt$ in the \ddc{}
to value-variable contexts $\ctxt$ in \fomega.  
% In addition, the function
% $\fotyc{\pctxt}$ generates the appropriate \fomega\ type-variable context from
% the \ddc{} context $\pctxt$.
\vskip -1.5ex
\[
  \ptyc{\cdot} = \cdot \qquad 
  \ptyc{\pctxt,\ptyvar{:}\kty} = \ptyc \pctxt,\codefont{\parsename_\ptyvar}{:}\kTrans[\kty,\ptyvar]
\]

\begin{lemma}[Type Correctness Lemma]
\label{lem:type-correctness}
If $\ddck[\ty,{\pctxt;\ctxt},\gk,{}]$ then
$\stsem[{\trans[\ty,,]},{\fotyc \pctxt, \ctxt,\ptyc \pctxt},
{\kTrans[\kind,\ty]}]$
\end{lemma}

\begin{proof}
  By induction on the height of the kinding derivation. A number of
  the more challenging cases are shown in \appref{app:extended-proofs}.
\end{proof}

\begin{theorem}[Type Correctness of Closed Types]
\label{thm:type-correctness}
  If $\ddck[\ty,,\gk,\con]$ then
  $\stsem[{\trans[\ty,,]},,\kTrans[\kind,\ty]]$.
\end{theorem}

A practical implication of this theorem is that it is sufficient to
check data descriptions (\ie{}, \ddca{} types) for well-formedness to
ensure that the generated types and functions are well formed. This
property is sorely lacking in many common implementations of Lex and
YACC, for which users must examine generated code to debug
compile-time errors in specifications.

\subsection{Canonical Forms}

\ddc{} parsers generate pairs of representations and parse descriptors
designed to satisfy a number of invariants.  Of greatest importance is
the fact that when the parse descriptor reports that there are no errors in a
particular substructure, the programmer can count on the
representation satisfying all of the syntactic and semantic
constraints expressed by the dependent \ddc{} type description.  When
a parse descriptor and representation satisfy these invariants and
correspond properly, we say the pair of data structures is {\em
  canonical} or in {\em canonical form}.

For each \ddc{} type, its canonical forms are defined via two
(mutually recursive) relations.  The first, $\corr \tyval r p$,
defines the canonical form of a representation $r$ and a parse
descriptor $p$ at normal type $\tyval$.  It is defined for all closed
normal types $\tyval$ with base kind $\kty$.  Types with higher kind
such as abstractions are excluded from this definition as they cannot
directly produce representations and PDs.

A second definition, $\corrkl \ty r p$ normalizes $\ty$ to a $\tyval$,
thereby eliminating outermost type and value applications. Then, the
requirements on $\tyval$ are given by $\corr \tyval r p$.  For
brevity, we write $p.h.{nerr}$ as $p.{nerr}$ and use $\mathtt{pos}$ to
denote the function that returns zero when passed zero and one when
passed another natural number.

\begin{definition}[Canonical Forms I]
$\corr \tyval r p$ iff exactly one of the following is true:
  \begin{itemize}
  \item $\tyval = \ptrue$ and $r = \iuval$ and $p.{nerr} = 0$.
  \item $\tyval = \pfalse$ and $r = \ierr$ and $p.{nerr} = 1$.
  \item $\tyval = \pbase{e}$ and $r = \iinld \ity \const$ and $p.{nerr} = 0$.
  \item $\tyval = \pbase{e}$ and $r = \iinrd \ity \ierr$ and $p.{nerr} = 1$.
  \item $\tyval = \psig x {\ty_1} {\ty_2}$ and $r =\ipair {r_1} {r_2}$ and $p =
    \ipair h {\ipair {p_1} {p_2}}$ 
    and $h.{nerr} = \mathtt{pos}(p_1.{nerr}) + \mathtt{pos}(p_2.{nerr})$, $\corrkl
    {\ty_1} {r_1} {p_1}$ and $\corrkl {\ty_2[(r,p)/x]} {r_2} {p_2}$.
  \item $\tyval = \psum {\ty_1} e {\ty_2}$ and $r =\iinld {\ity}{r'}$
    and $p = \ipair h {\iinld {\ity}{p'}}$
    and $h.{nerr} = \mathtt{pos}(p'.{nerr})$ and $\corrkl
    {\ty_1} {r'} {p'}$.
  \item $\tyval = \psum {\ty_1} e {\ty_2}$ and $r =\iinr {r'}$
    and $p = \ipair h {\iinr {p'}}$
    and $h.{nerr} = \mathtt{pos}(p'.{nerr})$ and $\corrkl
    {\ty_2} {r'} {p'}$.
  \item $\tyval = \pand {\ty_1} {\ty_2}$, $r = \ipair {r_1} {r_2}$ and $p =
    \ipair h {\ipair {p_1}{p_2}}$, 
    and $h.{nerr} = \mathtt{pos}(p_1.{nerr}) + \mathtt{pos}(p_2.{nerr})$, 
    $\corrkl {\ty_1} {r_1} {p_1}$ and $\corrkl {\ty_2} {r_2} {p_2}$.
  \item $\tyval = \pset x {\ty'} e$, $r = \iinld \ity {r'}$ and $p =
    \ipair h {p'}$, 
    and $h.{nerr} = \mathtt{pos}(p'.{nerr})$, $\corrkl {\ty'}{r'}{p'}$
    and $e[(r',p')/x] \kstepsto\itrue$.
  \item $\tyval = \pset x {\ty'} e$, $r = \iinrd \ity {r'}$
    and $p = \ipair h {p'}$,
    and $h.{nerr} = 1 + \mathtt{pos}(p'.{nerr})$,
    $\corrkl {\ty'}{r'}{p'}$ and $e[(r',p')/x] \kstepsto \ifalse$.
  \item $\tyval = \pseq {\ty_e}{\ty_s}{\pterm {e,\ty_t}}$, 
    $r = \ipair {len} {\iarr{\vec {r_i}}}$, $p = \itup{h,\itup{{neerr},{len}',\iarr {\vec {p_i}}}}$,
    ${neerr} = \sum_{i=1}^{len} \mathtt{pos}(p_i.{nerr})$, \\
    ${len} = {len}'$, $\corrkl {\ty_e}
    {r_i} {p_i}$ (for $i=1 \ldots {len}$), and
    $h.{nerr} \geq \mathtt{pos}({neerr})$.
  \item $\tyval = \pmu \ptyvar {} {\ty'}$, 
    $r = \iroll{r'}{\itsem[\pmu \ptyvar {} {\ty'}]}$, $p =
    \ipair h {\iroll{p'}{
                \itpdsem[\pmu \ptyvar {} {\ty'}]}}$, 
        $p.{nerr} = p'.{nerr}$ 
    and \linebreak
    $\corrkl {\ty'[\pmu \ptyvar {} {\ty'}/\ptyvar]} {r'} {p'}$.
  \item $\tyval = \pcompute e \ity$ and $p.{nerr} = 0$.
  \item $\tyval = \pabsorb {\ty'}$, $r = \iinl \iuval$, and $p.nerr = 0$.
  \item $\tyval = \pabsorb {\ty'}$, $r = \iinr \ierr$, and $p.nerr > 0$.
  \item $\tyval = \pscan {\ty'}$, $r =\iinl {r'}$,
      $p = \ipair h {\iinl {\ipair i {p'}}}$,
      $h.nerr = \mathtt{pos}(i) + \mathtt{pos}(p'.nerr)$, and \linebreak
      $\, \corrkl {\ty'}{r'}{p'}$.
  \item $\tyval = \pscan {\ty'}$,
      $r =\iinr \ierr$,
      $p = \ipair h {\iinr \iuval}$, and
      $h.{nerr} = 1$.
  \end{itemize}
\end{definition}

\begin{definition}[Canonical Forms II]
$\corrkl \ty r p$ iff $\ty \kstepsto \tyval$ and $\corr \tyval r p$.
\label{def:canon-forms-II}
\end{definition}

We first prove that the representation and parse-descriptor constructors, under the appropriate
conditions, produce values in canonical form.

\begin{lemma}[Constructors Produce Values in Canonical Form]
  \label{lem:cons-props}
  \begin{itemize}
  \item $\corr \ptrue {\newrep {true} {}} {\newpd {true} \off}$.
  \item $\corr \pfalse {\newrep {false} {}} {\newpd {false} \off}$.
  \item If $\corrkl {\ty_1} {r_1} {p_1}$ and $\corrkl {\ty_2[(r,p)/x]} {r_2} {p_2}$
    then\\ $\corr {\psig x {\ty_1} {\ty_2}}
    {\newrep {\gS} {r_1,r_2}}{\newpd {\gS} {p_1,p_2}}$.
  \item If $\corrkl \ty r p$ then $\corr {\psum \ty e {\ty'}} 
      {\newrep {+left} r} {\newpd {+left} p}$.
  \item If $\corrkl \ty r p$ then $\corr {\psum {\ty'} e \ty} 
      {\newrep {+right} r} {\newpd {+right} p}$.
  \item If $\corrkl {\ty_1} {r_1} {p_1}$ and $\corrkl {\ty_2} {r_2} {p_2}$
    then\\ $\corr {\pand {\ty_1} {\ty_2}}
    {\newrep {\&} {r_1,r_2}}{\newpd {\&} {p_1,p_2}}$.
  \item If $\corrkl \ty r p$ and $e[(r,p)/x] \kstepsto c$ then\\ $\corr {\pset x \ty e} 
    {\newrep {set} {c,r}} {\newpd {set} {c,p}}$
  \item $\corr {\pseq \ty {\ty_s}{\pterm e {\ty_t}}} 
    {\newrep {seq\_init} {}} {\newpd {seq\_init} \off}$.
  \item If $\corr {\pseq \ty {\ty_s} {\pterm e {\ty_t}}} r p$ and
    $\corrkl \ty {r'} {p'}$ then, for any $p''$,\\
    $\corr {\pseq \ty {\ty_s}{\pterm e {\ty_t}}}
    {\newrep {seq} {r,r'}} {\newpd {seq} {p,p'',p'}}$.    
  \item $\corr {\pcompute e \ity} {\newrep {compute} {e}} {\newpd {compute} \off}$.
  \item $\corr {\pabsorb \ty} {\newrep {absorb} p} {\newpd {absorb} p}$.
  \item If $\corrkl {\ty} r p$ then $\corr {\pscan \ty} 
      {\newrep {scan} r} {\newpd {scan} {i,p}}$.
  \item $\corr {\pscan \ty} 
      {\newrep {scan\_err} {}} {\newpd {scan\_err} \off}$.
  \end{itemize}
\end{lemma}

\begin{proof}
  By inspection of the constructor functions. 
% \trversion{
%   Array case is most complicated, in particular proving the clause
%   $h.{nerr} \geq \mathtt{pos}({neerr})$. To do so, you must prove that
%   $H_{seq}$ maintains this invariant. The first case of the match is the
%   hard one, as ${nerr}$ is 0 (if its $1$, then it must be greater than
%   or equal to $\mathtt{pos}(n)$, for any $n$).  First, as $h.{nerr} =
%   0$, so too must $neerr$. Next, note that in this first case,
%   $h1.{nerr} = 0$. Now, the new value of ${neerr}$ is just the sum of
%   the original ${neerr}$ and $\mathtt{pos}(h1.{nerr})$, that is, $0 +
%   0$.}
\end{proof}

In addition, we require that base type parsers produce values in canonical form:
\begin{condition}[Base Type Parsers Produce Values in Canonical Form]
  \label{cond:base-types-cf}
  If $\;\stsem[v,,\ity]$, $\Ikind(C) = \iarrow \ity \kty$ and $\Iimp(C)
  \sapp v \sapp \spair<\data,\off> \kstepsto \spair<\off',r,p>$ then
  $\corr {\pbase v} r p $.
\end{condition}

Lemma~\ref{lem:err-corr-at-T} states that the parsers for
well-formed types (of base kind) will produce a canonical pair of
representation and parse descriptor, if they produce anything at all.

\begin{lemma}[Parsing to Canonical Forms]
\label{lem:err-corr-at-T}
If $\; \ddck[\ty,,\kty,]$ and $\trans[\ty,,] \sapp \spair<B,\off> \kstepsto
  \spair<\off',r,p>$ then $\corrkl \ty r p$.
\end{lemma}

\begin{proof}
  By induction on the height of the second derivation -- that is, the
  number of steps taken to evaluate. Within the induction, we proceed
  using a case-by-case analysis of the possible structures of type
  $\ty$.  A number of the more challenging cases are shown in
  \appref{app:extended-proofs}.
\end{proof}

% We conclude this section with a useful property of canonical
% representations and PDs. If the PD reports no errors, then there are
% no syntactic errors in the representation data structure {\it at any
%   level}.  We formally define {\it valid} (error-free) values next,
% followed by the statement of the property itself.

% \begin{definition}[Valid Value]
% $\noerr v$ iff exactly one of the following is true:
% \begin{itemize}
% \item $v = c$ and $c \neq \ierr$.
% \item $v = \ifun f x e$.
% \item $v = \ipair {v_1} {v_2}$ and $\noerr {v_1}$ and $\noerr {v_2}$.
% \item $v = \iinl {v'}$ and $\noerr {v'}$.
% \item $v = \iinr {v'}$ and $\noerr {v'}$.
% \item $v = \iarr{v_1 \cdots v_n}$ and $\noerr {v_i}$ for $i=1\ldots n$.
% \item $v = \iroll{v'}{\ity}$ and $\noerr {v'}$.
% \end{itemize}
% \end{definition}

% \begin{lemma}
%   If $\corrkl \ty r p$ and $p.h.nerr = 0$ then $\noerr r$.
% \end{lemma}

% \begin{proof}
%   By induction on the structure of r.
% \end{proof}

\begin{corollary}
  If $\corrkl \ty r p$ and $p.h.nerr = 0$ then there are no syntactic
  or semantic errors in the representation data structure $r$.
\end{corollary}

This corollary is important as it ensures that a single check is
sufficient to verify the validity of a data structure. Only if the
data structure is not valid will further checking of substructures be
required.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../thesis.tex"
%%% End: 
