%\documentclass[fleqn]{article}
%\documentclass[twocolumn,10pt]{article}
\documentclass[nocopyrightspace,10pt]{sigplanconf}

\usepackage{xspace,amsmath,math-cmds,
            math-envs,inference-rules,times,
            verbatim,alltt,multicol,proof,url}
\usepackage{epsfig}
\usepackage{code} 
%\setlength{\oddsidemargin}{0in}
%\setlength{\evensidemargin}{0in}
%\setlength{\textwidth}{6.5in}
%\setlength{\textheight}{8.5in}

\setlength{\hoffset}{-1in}
\setlength{\voffset}{-1in}

\setlength{\topmargin}{.5in}
\setlength{\headheight}{0pt}
\setlength{\headsep}{0pt}

\setlength{\evensidemargin}{.75in}
\setlength{\oddsidemargin}{.75in}

% Text area:

\newdimen{\standardtextwidth}
\setlength{\standardtextwidth}{42pc}

\setlength{\textwidth}{\standardtextwidth}

\setlength{\topskip}{0pt}
\setlength{\columnsep}{1.5pc}
\setlength{\textheight}{58.5pc}
\input{definitions}

\begin{document}

\title{Typing Directories\thanks{There no student authors.  If
    accepted, Kathleen will make the presentation.}}

\authorinfo{Kathleen Fisher}
	   {AT\&T Labs Research}
           {\small \tt kfisher@research.att.com}
\authorinfo{David Walker}
	   {Princeton University}
           {\small \tt dpw@cs.princeton.edu}
\authorinfo{Kenny Q. Zhu}
	   {Princeton University}
           {\small \tt kzhu@cs.princeton.edu}
\maketitle{}
\date{}


Many applications, be they single programs or collections of programs,
rely on a set of files, directories, and symbolic links to
store and organize information.  Examples include monitoring
systems, such as those developed for PlanetLab or internally at AT\&T;
version control systems such as CVS or SVN; repositories of scientific
data; test regression systems; mail and web page caches; software
package management systems; source code management systems, \etc{}

These applications assume that the constituent files, directories, and
symbolic links satisfy various properties, \eg{}, files and
directories must exist with appropriate owners, groups, and
permissions; symbolic links must have the correct targets; create
and/or modify times must be consistent, \etc.  Privacy or hygiene
considerations might require that only a specified set of files exist.
Finally, index or configuration files may specify the directory and
file structured required by the application.  For example, CVS uses 
Entries files to list the files and directories under source code
control.  

\includegraphics[width=\columnwidth]{CVSStructure.pdf}

If these properties fail to hold, applications can fail in
unpredictable ways with poor error messages.  Yet, general-purpose
tools to determine whether the portions of a file system specific to a
particular application are in a good state do not exist.  Instead, each
application writer must craft one-off tools or simply hope that errors
do not arise. 

To address this deficiency, we are designing \dirpads{}, a language
for specifying the files, directories, and symbolic links that
constitute the data for an application, the relationships between
them, and any required properties.  Individual files can be described
using base types such as \cd{p_xml} or \cd{p_html} (such types can be
defined as plug-ins by users), or with \pads{}
types, in which case values in the file can be used to describe other
portions of the file structure.  Directory declarations describe
collections of files, either by giving the on-disk names or by
specifying patterns.   The language
includes the ability to express constraints on meta-data, such as
owners, groups, permissions, and timestamps.  

To give a flavor of the language, we show a fragment of the
description of the CVS version control system because it is concise
and familiar.  Of necessity, it illustrates only a portion of our
language.  The \pads{} type \cd{entries_f} describes the
contents of the \cd{Entries} file, which are then used to define the
list of \cd{dirs} and \cd{files} in the directory under CVS control,
which has \dirpads{} type \cd{cvs_rep_d}:


\begin{code}
\kw{ptype} repository_f = ...
\kw{ptype} root_f = ...
\kw{ptype} dir_t = \kw{precord} \{
  "D/" ;
  dname :: pstring "/";
  "////"; \} 
\kw{ptype} file_t = \kw{precord} \{
  "/";
  fname :: pstring "/";        "/";
  version  :: pint * "." * pint;  "/";
  ... \}

\kw{ptype} entry_t = Dir of dir_t | File of file_t
\kw{ptype} entries_f = \kw{psource} (entry_t plist)

\kw{ptype} cvs_d = \kw{pdirectory} \{
  repository \kw{is} "Repository" :: repository_f;
  root       \kw{is} "Root"       :: root_f;
  entries    \kw{is} "Entries"    :: entries_f; \}

\kw{ptype}  cvs_rep_d = \kw{pdirectory} \{
  cvs   \kw{is} "CVS" :: cvs_d;
  dirs  \kw{is} [ dname d  :: cvs_rep_d | 
                  Dir  d <- cvs.entries ];
  files \kw{is} [ fname f :: p_any      | 
                  File f <- cvs.entries ];
\}

\end{code}

Given such a description, we can test whether the file system conforms
to the description.  If it does not, we can give clear error messages
highlighting the problems precisely.  We can also find whether there
are additional files not mentioned in the description, allowing users
to find junk easily.  We can also define description-specific versions
of common shell tools.  Finally, we can provide a programmatic
interface to the directory structure.

\bibliographystyle{plain}
%\bibliographystyle{abbrv}

\bibliography{pads}

\end{document}

%%% Local Variables:
%%% mode: outline-minor
%%% End:

