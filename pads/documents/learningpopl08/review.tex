Our format inference algorithm is implemented as a series of phases that
generate and transform an internal format description language we
refer to simply as the \ir.  The \ir{} is very similar to
the \ipads{} language we developed and formalized in previous 
work~\cite{fisher+:popl06}.  Apart from syntax, the main differences 
are that the \ir{} omits recursion and function declarations; the former
being beyond the scope of our current inference techniques and the 
latter being unnecessary during the course of the inference algorithm.
%Without recursion and function declarations, %from a parsing perspective,
%this core \ir{} is also quite closely related to a standard language
%of regular expressions, albeit with interesting basic symbols and
%a limited form of dependency.
%In addition, for convenience during inference, the scope of dependent 
%variable binding is slightly different, as will be explained below.

\begin {figure}
{\small
\begin {tabular}{llll}
%\multicolumn{4}{l}{
%\begin {tabular}{llll}
$c$ & ::= & $a$ \myalt $i$ \myalt $s$ & (constants)\\
$x$ & & & (variables) \\
$p$ & :: = & $c$ \myalt $x$ & (parameters) \\
\\
\end{tabular}

\begin {tabular}{ll}
\multicolumn{2}{l}{Base types $b$  ::=} \\
\hspace{5pt} \cd{Pint} &                  (generic, unrefined integer) \\
\myalt \cd{PintRanged} &             (integer with min/max values) \\
\myalt \cd{Pint32} &                 (32-bit integer) \\
\myalt \cd{Pint64} &                (64-bit integer) \\
\myalt \cd{PintConst} &              (constant integer) \\
\myalt \cd{Pfloat} &                (floating point number) \\
\myalt \cd{Palpha} &                (alpha-numeric string) \\
\myalt \cd{Pstring} &               (string; terminating character) \\
\myalt \cd{PstringFW} &             (string; fixed width) \\
\myalt \cd{PstringConst} &          (constant string) \\
\myalt \cd{Pother} &                (punctuation character) \\
\myalt \cd{ComplexB} &              (complex base type defined by regexp; \\
                                     & \hspace{5pt} \eg{} date, time, \etc{}) \\
\myalt \cd{Pvoid} &                 (parses no characters; fails immediately) \\
\myalt \cd{Pempty} &                (parses no characters; succeeds immediately) \\
\\
\end {tabular}

\begin {tabular}{ll}
\multicolumn{2}{l}{Types $T$ ::= } \\ 
\hspace{5pt} $b$($p_1$,...,$p_k$)&          (parameterized base type) \\
\myalt  $x$:$b$($p_1$,...,$p_k$) &         (parameterized base type; \\
                                & \hspace{5pt} underlying value named x)    \\  
\myalt  \cd{struct} \{$T_1$; ... $T_k$;\}&   (fixed sequence of items) \\
\myalt  \cd{array} \{$T$;\} &            (array with unbounded repetitions) \\
\myalt  \cd{arrayFW} \{$T$;\}[$p$]&        (array; fixed length)  \\
\myalt  \cd{arrayST} \{$T$;\}[sep,term]& (array; separator and terminator) \\
\myalt  \cd{union} \{$T_1$; ... $T_k$;\} &   (alternatives) \\
\myalt  \cd{enum} \{$c_1$; ... $c_k$;\} &    (enumeration of constants) \\
\myalt  $x$:\cd{enum} \{$c_1$; ... $c_k$;\} &         (enumeration of constants; \\
                                & \hspace{5pt} underlying value named x)    \\  
\myalt  \cd{option} \{$T$;\} &           (type T or nothing) \\
\myalt  \cd{switch} $x$ \cd{of} \\
\hspace{6pt} \{$c_1$ \cd{=>} $T_1$; $\ldots$ $c_k$ \cd{=>} $T_k$;\} & (dependent choice) \\
\\
\end {tabular}

\begin {tabular}{ll}
\multicolumn{2}{l}{Representations of parsed data $d$  ::= } \\
\hspace{5pt} $c$ &        (constant) \\
\myalt  in$_i$($d$) &    (injection into the $i^{th}$ alternative of a union) \\
\myalt  ($d_1$,$\ldots$,$d_k$) &  (sequence of data items) \\
\end{tabular}
}
\caption {Selected elements of the \ir{}.} \shrink
\label{fig:ir}
\end{figure}


\begin{figure*}
Crashreporter.log:
{\small \begin{verbatim}
Sat Jun 24 06:38:46 2006 crashdump[2164]: Started writing crash report to: /Logs/Crash/Exit/ pro.crash.log
- crashreporterd[120]: mach_msg() reply failed: (ipc/send) invalid destination port
\end{verbatim}
}

Sirius AT\&T Phone Provisioning Data:
{\small \begin{verbatim}
8152272|8152272|1|6505551212|6505551212|0|0||no_ii152272|EKRS_6|0|FRED1|DUO|10|1000295291
8152261|8152261|1|0|0|0|0||no_ii752261|EKRS_1|0|kfeosf2|DUO|EKRS_6|1001390400|EKRS_OS_10|1001476801
\end{verbatim}
}

% ASL.log:
% {\small  \begin{verbatim}
% [Time 2006.11.25 16:47:18 UTC] [Facility user] [Sender E_e,] [PID 131] \
%   [Message sleep canceled time is: Sat Nov 25 08:47:18 2006;;] [Level 1] [UID -2] [GID -2] [Host Babylon]
% [Time 2006.11.25 16:51:23 UTC] [Facility install] [Sender Software Update] [PID 1879] \
%   [Message System requesting sleep.] [Level 5] [UID -2] [GID -2] [Host Babylon]
% \end{verbatim}
% }

% Apache Web Server Logs:
% {\small \begin{verbatim}
% 68.142.249.179 - - [13/Dec/2005:19:41:48 -0800] "GET /bridge-loan.html HTTP/1.0" 404 298 "-" \
%   "Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp)"
% 69.227.61.241 - - [13/Dec/2005:19:44:42 -0800] "GET / HTTP/1.1" 403 4251 "-" \
%   "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8) Gecko/20051111 Firefox/1.5"
% \end{verbatim}
% }

\caption {Example ad hoc data sources.} \shrink
\label{fig:example}
\end{figure*}



% The end goal of this project depends
% crucially on having both interpretations of these types.  The first
% interpretation is necessary to generate a
% parser and printer for the format.  The second interpretation 
% is necessary in order to define and
% implement useful generic algorithms, such as the xml translator, that
% walk over parsed data in memory.  

\subsection{The Language}

Like all languages in the \pads{} family, the \ir{} is a collection of
type definitions.  These ``types'' define both the external syntax of
data formatted on disk and the shape of the internal representations
that result from parsing.  We rely upon both of these aspects of type
definitions to generate stand-alone tools automatically.
%-- the first is necessary for generating parsers and printers; the
%second is necessary for implementing generic algorithms such as the 
%\xml{} translator.  In the following discussion, we focus on
%explaining the first interpretation, counting on the reader's intuition 
%for the second. 
Figure~\ref{fig:ir} summarizes the syntax of the \ir{} and of the
generated internal representations. 

The building blocks of any \ir{} data description are the base types $b$,
which may be parameterized by some number of arguments $p$.  Arguments
may either be constants $c$, which include characters $a$, integers
$i$ and strings $s$, or variables $x$ bound earlier in the description.
These base types include a wide range of different sorts of
integers and strings.  In its initial phases, the inference algorithm
uses general integer \cd{Pint}, alphanumeric string \cd{Palpha}
and punctuation character \cd{Pother(}$a$\cd{)} types.  In later phases,
these coarse-grained base types are analyzed, merged and refined, producing
integers with ranges \cd{PintRanged(min,max)},
integers with known size \cd{Pint32} or \cd{Pint64}, constant integers
(\cd{PintConst(}$i$\cd{)} for some integer $i$), or floating-point
numbers \cd{Pfloat}.  Likewise, later stages of our algorithm transform
alphanumeric strings into arbitrary strings with terminating characters
(\cd{Pstring(}$a$\cd{)} where $a$ terminates the string), fixed width
strings (\cd{PstringFW(}$i$\cd{)} where $i$ is the length of the string) 
or string constants \cd{PstringConst(}$s$\cd{)}.  For brevity in
our descriptions, we normally just write the constant string $s$
inline in a description instead of \cd{PstringConst(}$s$\cd{)}.

In addition to these simple base types, the \ir{} includes a
collection of higher-level base types commonly found in ad hoc data,
specified generally in Figure~\ref{fig:ir} as \cd{ComplexB}.  For
example, we have implemented base types for IP addresses, email
addresses, URLs, XML tags, dates, times and a variety of
others. Finally, the types \cd{Pvoid} and \cd{Pempty} are two special
base types that are introduced at various points in the inference
process.  The first fails immediately; the second succeeds
immediately.  Neither consumes any characters while parsing.

Complex descriptions are built from simpler ones using a variety of
type constructors.  Type constructors include
basic struct types \cd{struct}\{$T_1$; ... $T_k$;\}, which indicate a
data source
should contain a sequence of items matching $T_1$, ..., $T_k$,
basic array types \cd{array} $T$, which indicate a data source should contain
a sequence of items of arbitrary length, each matching $T$,
and union types \cd{union} \{$T_1$; ... $T_k$;\}, which indicate a
data source
should match one of $T_1$, ..., $T_k$.  Once again, initial phases
of the inference algorithm restrict themselves to one of these three
sorts of type constructors.  However, later phases of the algorithm
refine, merge and process these simple types in a variety of ways.
For example, unions may be transformed into 
enumerations of constants
\cd{enum} \{$c_1$; ... $c_k$;\}
or options \cd{option} \{$T$;\}.  In
addition, later phases of the algorithm 
bind variables to the results of parsing 
base types and enums.  For example, $x$:$b$($p_1$,...,$p_k$) expresses the fact that
variable $x$ is bound to the value parsed by base type
$b$($p_1$,...,$p_k$).  These variables express dependencies between 
different parts
of a description.\footnote{For the purposes of inference, 
every bound variable is assumed to be distinct
from every other that appears in a description.  Roughly speaking,
the scope of such variables
extends as far as possible to the right through the description.
Understanding the fine details of the semantics is not important
for understanding the central material in this paper.}  
For example, the length of a string \cd{PstringFW}($p$)
or an array \cd{ParrayFW}($p$) may depend upon either a constant or
a variable and likewise for any other parameterized base type.  In
addition, unions may be refined into dependent switch statements
\cd{switch} $x$ \cd{of} \{$c_1$ \cd{=>} $T_1$; $\ldots$ $c_k$ \cd{=>} $T_k$;\}, where the
data is described by $T_1$, ..., or $T_k$ depending on the value
associated with $x$, be it $c_1$, ..., or $c_k$.

One can observe that from a parsing perspective,
the subset of \pads{} that we consider in this paper is closely connected
to regular expressions: struct types serve the same purpose as
concatenation; array types serve the same purpose as Kleene star;
and union types serve the same purpose as unions.  Some of the dependencies
may also be translated into regular expressions.  For example, the type
$T = $
\cd{struct} \{$x$:\cd{enum} \{$c_1$; $c_2$\}; $T_0$; \cd{switch} $x$ \cd{of} \{$c_1$ \cd{=>} $T_1$; $c_2$ \cd{=>} $T_2$;\};\} may be translated into the
regular expression 
$R = (c_1 \cdot T_0 \cdot T_1) + (c_2 \cdot T_0 \cdot T_2)$.  However,
human \pads{} programmers tend to prefer $T$ over $R$ since $T$
clearly identifies the
tag that determines the branch of the union and it avoids
repetition of $T_0$ (which becomes more and more problematic as 
the number of alternatives grows).

In additional to parsing, there is a more interesting
interpretation of \pads types in which they are translated
into a set of data structures. 
We let metavariable $d$ range over such 
data structures.  For the purposes of this paper, $d$
may be a constant $c$, an injection into the $i^{th}$
variant of a union \cd{in}$_i(d)$, or a sequence of data items
$(d_1,\ldots,d_k)$.  The injections are used as the representations of
any sort of union type, be it a union, an enumeration, an option or a switch.
The sequences are used as the representations of any sort of sequence
type, whether it be a struct or one of the array variants.  Our earlier
work~\cite{fisher+:popl06} contains a precise treatment of this 
secondary semantics.

\subsection{Running Examples}

Figure~\ref{fig:example} presents tiny fragments of two
different ad hoc data files on which we have trained our inference algorithm.
The first, Crashreporter.log, is a Macintosh
system file that records information concerning process crashes.\footnote{For
expository purposes we have made a minor alteration to the Crashreporter.log
format to allow us to explain more concepts with a single example.
The evaluation section reports results on both the  
completely unmodified Crashreporter.log and the modified version.} 
The second, which we call Sirius, is an internal AT\&T format used to
record phone call provisioning information. 
%The third format is
%a generic system logging file called ASL.log, again taken from a
%Macintosh.
We use the Crashreporter.log data source as our main example throughout the
paper; periodically we refer to the Sirius data source to illustrate 
particular aspects of the inference algorithm.  
%We report on our experience
%with many more examples in the evaluation section of the paper.

\input{crashreporter-ir}

Figure \ref{fig:crashreporter:ir} presents a hand-written description
of the Crashreporter.log file in the \ir{} syntax.  This
description is most easily read from the bottom, starting
with the definition of the \cd{source} type.  This definition specifies that
the data source is an
array of structs separated by newline characters and
terminated by the end of file marker.  In other words,
the data source is a sequence of lines, with the struct
in question appearing on each line.  
The struct itself indicates each line is a sequence of
\cd{dateoption}, \cd{kind}, \cd{dumpid} and \cd{report} fields.  
The description also specifies that the delimiter \cd{"["} 
appears between the \cd{kind} and \cd{dumpid} fields, and the
delimiter \cd{"]: "} appears between the \cd{dumpid} and 
\cd{report} fields.

%% The reader can
%% \cd{dateoption} type (appearing above the definition of \cd{source})
%% is defined as either a dash or a structure containing a \cd{PDate}
%% (one of the complex base types our system uses), a \cd{PTime} (another
%% complex base type) and an integer year.  In between each of the three
%% fields in the \cd{dateoption} struct is a space character (written
%% \cd{" "}).

Most of the variable names associated with fields (\eg{}
\cd{date}, \cd{dumpid}, \etc{}) merely serve as documentation for the reader.
However, the \cd{kind} field is different -- it is used later in the 
description and hence illustrates a {\em dependency}.  
To be specific, the form of the
\cd{report} field depends upon the contents of the \cd{kind}
field.  If its value is \cd{"crashdump"}, then the \cd{report} is
a \cd{dumpReport} type, while if the \cd{kind} field is \cd{"crashreporterd"},
the \cd{report} is a \cd{reporterReport} type.  

Figure~\ref{fig:crashreporter:ir} contains three other definitions
aside from \cd{source}.  These definitions specify the
structure of the  \cd{dumpReport}, \cd{reporterReport} and \cd{dateOption}
types.

%% specify the component parts
%% The definition of \cd{reporterreport} is relatively simple -- it is
%% a structure containing a file path 
%% (\cd{Ppath} is one of the complex base types our system uses) and 
%% a message following 
%% \cd{" reply failed: "}.  A \cd{crashdump} message is more complicated --
%% it is a union of several different possible message formats. Finally, a
%% \cd{dateoption} type 
%% is defined as either a dash or a structure containing a \cd{PDate}, 
%% a \cd{PTime} and an integer year. 




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
