Our format inference algorithm is implemented as a series of phases that
generate and transform an internal format description language we
refer to simply as the \ir.  The \ir{} is very similar to
the \ipads{} language we developed and formalized in our previous 
work~\cite{fisher+:popl06}.  Apart from syntax, the main differences 
are that the \ir{} omits recursion and function declaration; the former
being beyond the scope of our current inference techniques, and the 
latter being unnecessary during the course of the inference algorithm.  
%In addition, for convenience during inference, the scope of dependent 
%variable binding is slightly different, as will be explained below.

\subsection{Preliminary Concepts}

Like all languages in the \pads{} family, the \ir{} is a collection of
type definitions.  These ``types'' define both the external syntax of
data formatted on disk and the shape of the internal representations
that result from parsing.  In order to generate fully functional tools
directly from data, we rely upon both aspects of these type definitions.
%-- the first is necessary for generating parsers and printers; the
%second is necessary for implementing generic algorithms such as the 
%\xml{} translator.  In the following discussion, we focus on
%explaining the first interpretation, counting on the reader's intuition 
%for the second. 
Figure~\ref{fig:ir} summarizes the syntax of selected core features of 
the \ir{} and the syntax we use for the generated internal representations.

\begin {figure}
\begin {tabular}{llll}
%\multicolumn{4}{l}{
%\begin {tabular}{llll}
$c$ & ::= & $a$ \myalt $i$ \myalt $s$ & (constants)\\
$x$ & & & (variables) \\
$p$ & :: = & $x$ \myalt $c$ & (parameters) \\
\\
\end{tabular}

\begin {tabular}{ll}
\multicolumn{2}{l}{base types $b$  ::=} \\
\hspace{5pt} \cd{Pint} &                  (generic, unrefined integer) \\
\myalt \cd{PintRanged} &             (integer with min/max values) \\
\myalt \cd{Pint32} &                 (32-bit integer) \\
\myalt \cd{Pint64} &                (64-bit integer) \\
\myalt \cd{PintConst} &              (constant integer) \\
\myalt \cd{Pfloat} &                (floating point number) \\
\myalt \cd{Palpha} &                (alpha-numeric string) \\
\myalt \cd{Pstring} &               (string; terminating character) \\
\myalt \cd{PstringFW} &             (string; fixed width) \\
\myalt \cd{PstringConst} &          (constant string) \\
\myalt \cd{Pother} &                (punctuation character) \\
\myalt \cd{ComplexB} &              (complex base type defined by regexp; \\
                                     & \hspace{5pt} eg: date, time, etc.) \\
\myalt \cd{Pvoid} &                 (parses no characters; fails immediately) \\
\myalt \cd{Pempty} &                (parses no characters; succeeds immediately) \\
\\
\end {tabular}{ll}

\begin {tabular}{ll}
\multicolumn{2}{l}{types $T$ ::= } \\ 
\hspace{5pt} $b$($p_1$,...,$p_k$)&          (parameterized base type) \\
\myalt  x:$b$($p_1$,...,$p_k$) &         (parameterized base type; \\
                                & \hspace{5pt} underlying value named x)    \\  
\myalt  \cd{struct} \{$T_1$; ... $T_k$;\}&   (fixed sequence of items) \\
\myalt  \cd{array} \{$T$;\} &            (array with unbounded repetitions) \\
\myalt  \cd{arrayFW} \{$T$;\}[$p$]&        (array; fixed length)  \\
\myalt  \cd{arrayST} \{$T$;\}[sep,term]& (array; separator and terminator) \\
\myalt  \cd{union} \{$T_1$; ... $T_k$;\} &   (alternatives) \\
\myalt  \cd{enum} \{$c_1$; ... $c_k$;\} &    (enumeration of constants) \\
\myalt  \cd{option} \{$T$;\} &           (type T or nothing) \\
\myalt  \cd{switch} $x$ \cd{of} \\
\hspace{6pt} \{$c_1$ \cd{=>} $T_1$; $\ldots$ $c_k$ \cd{=>} $T_k$;\} & (dependent choice) \\
\\
\end {tabular}{ll}

\begin {tabular}{ll}
\multicolumn{2}{l}{representations of parsed data $d$  ::= } \\
\hspace{5pt} $c$ &        (constant) \\
\myalt  in$_i$($d$) &    (injection into the ith alternative of a union) \\
\myalt  ($d_1$,$\ldots$,$d_k$) &  (sequence of data items) \\
\end{tabular}

\caption {Selected elements of the \ir{}.}
\label{fig:ir}
\end{figure}


% The end goal of this project depends
% crucially on having both interpretations of these types.  The first
% interpretation is necessary to generate a
% parser and printer for the format.  The second interpretation 
% is necessary in order to define and
% implement useful generic algorithms, such as the xml translator, that
% walk over parsed data in memory.  

The building blocks of any \ir{} data description are the base types $b$,
which may be parameterized by some number of arguments $p$.  Arguments
may either be constants $c$, which include integers $i$, strings
$s$ and characters $a$, or variables $x$, bound earlier in the description.
These base types include a wide range of different sorts of
integers and strings.  In its initial phases, the inference algorithm
uses general integer (\cd{Pint}), alphanumeric string (\cd{Palpha})
and punctuation character (\cd{Pother(}$a$\cd{)}) types.  In later phases,
these coarse-grained base types are analyzed, merged and refined, producing
integers with ranges (\cd{PintRanged(min,max)}),
integers with known size (\cd{Pint32} or \cd{Pint64}), constant integers
(\cd{PintConst(}$i$\cd{)}) for some integer $i$), or floating-point
numbers (\cd{Pfloat}).  Likewise, later stages of our algorithm transform
alphanumeric strings into arbitrary strings with terminating characters
(\cd{Pstring(}$a$\cd{)} where $a$ terminates the string), fixed width
strings (\cd{PstringFW(}$i$\cd{)} is a string with a length $i$) 
or string constants  (\cd{PstringConst(}$s$\cd{)}).  For brevity in
our descriptions, we normally just write the constant string $s$
inline in a description instead of \cd{PstringConst(}$s$\cd{)}.

In addition to these simple base types, the \ir{} includes a
collection of somewhat higher-level abstractions commonly found in ad
hoc data, specified generally in Figure~\ref{fig:ir} as \cd{ComplexB}.
For example, we have implemented base types for ip address, email
adresses, urls, XML tags, dates, times and a variety of
others. Finally, the types \cd{Pvoid} and \cd{Pempty} are two special
base types that are introduced at various points in inference process.
The first fails immediately; the second succeeds immediately.  Neither
consumes any characters while parsing.

Complex descriptions are built from simpler ones using a variety of
type constructors.  Type constructors include
basic struct types (\cd{struct \{T_1 ... T_k\}}), which indicate a file 
should contain a sequence of items matching \cd{T_1}, ..., \cd{T_k},
basic array types (\cd{array T}), which indicate a file should contain
a sequence of items of arbitrary length, each matching \cd{T},
and union types (\cd{union  \{T_1 ... T_k\}}), which indicate a file
should match one of \cd{T_1}, ..., \cd{T_k}.  Once again, initial phases
of the inference algorithm restrict themselves to one of these three
sorts of type constructors.  However, later phases of the algorithm
refine, merge and process these simple types in a variety of ways.
For example, unions may be transformed into 
enumerations of constants
(\cd{enum \{c_1,...,c_k\}}) or options (\cd{option T}).  In
addition, later phases of the algorithm 
bind variables to the results of parsing 
base types.  For example, \cd{x:b(p_1,...,p_k)} expresses the fact that
variable \cd{x} is bound to the value parsed by base type
\cd{b(p_1,...,p_k)}.  These variables express dependencies between 
different parts
of a description.\footnote{For the purposes of inference, 
every bound variable is assumed to be distinct
from every other that appears in a description.  Roughly speaking,
the scope of such variables
extends as far as possible to the right through the description.
Understandng the fine details of the semantics is not important
for understanding the central material in this paper.}  
For example, the length of a string (\cd{PstringFW(p)})
or an array (\cd{ParrayFW(p)}) may depend upon either a constant or
a variable and likewise for any other parameterized base type.  In
addition, unions may be refined into dependent switch statements
(\cd{switch x of \{c_1 => T_1 ... c_k => T_k\}}), where the
data is described by \cd{T_1}, ..., or \cd{T_k} depending on the value
associated with \cd{x}, be it \cd{c_1}, ..., or \cd{c_k}.

The result of parsing according to a description is an internal
representation of the data. We let metavariable $d$ range over such 
data representations.  For the purposes of this paper, data 
representation may be a constant $c$, an injection into the $i^{th}$
variant of a union \cd{in}$_i(d)$, or a sequence of data representations
$(d_1,\ldots,d_k)$.  The injections are used as the representations of
any sort of union type, be it a union, an enum, an option or a switch.
The sequences are used as the representations of any sort of sequence
type, whether it be a struct or one of the array variants.


\subsection{Running Examples}

Figure~\ref{fig:example} presents tiny fragments of two
different ad hoc data files we have trained our inference algorithm
on.  The first, Crashreporter.log, is a Macintosh
system file that records information concerning process crashes.\footnote{For
expository purposes we have made a minor alteration to the Crashreporter.log
format.  The evaluation section reports results on both the 
completely unmodified Crashreporter.log and the modified version
used to explain concepts in the paper.} The
second, we call Sirius, is an internal AT\&T format used to
record phone call provisioning information. 
%The third format is
%a generic system logging file called ASL.log, again taken from a
%Macintosh.
Crashreporter.log will be used as our main running example throughout the
paper; Sirius will be called upon periodically to illustrate
particular aspects of the inference algorithm.  We report on our experience
with many more examples in the evaluation section of the paper.

\begin{figure*}
Crashreporter.log:
{\small \begin{verbatim}
Sat Jun 24 06:38:46 2006 crashdump[2164]: Started writing crash report to: /Logs/Crash/Exit/ pro.crash.log
- crashreporterd[120]: mach_msg() reply failed: (ipc/send) invalid destination port
\end{verbatim}
}

Sirius AT\&T Phone Provisioning Data:
{\small \begin{verbatim}
9152272|9152272|1|2813640092|2813640092|0|0||no_ii152272|EDTF_6|0|MARVINS1|UNO|10|1000295291
9152261|9152261|1|0|0|0|0||no_ii152261|EDTF_1|0|jlaird1|UNO|EDTF_6|1001390400|EDTF_OS_10|1001476801
\end{verbatim}
}

% ASL.log:
% {\small  \begin{verbatim}
% [Time 2006.11.25 16:47:18 UTC] [Facility user] [Sender E_e,] [PID 131] \
%   [Message sleep cancelled time is: Sat Nov 25 08:47:18 2006;;] [Level 1] [UID -2] [GID -2] [Host Babylon]
% [Time 2006.11.25 16:51:23 UTC] [Facility install] [Sender Software Update] [PID 1879] \
%   [Message System requesting sleep.] [Level 5] [UID -2] [GID -2] [Host Babylon]
% \end{verbatim}
% }

% Apache Web Server Logs:
% {\small \begin{verbatim}
% 68.142.249.179 - - [13/Dec/2005:19:41:48 -0800] "GET /bridge-loan.html HTTP/1.0" 404 298 "-" \
%   "Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp)"
% 69.227.61.241 - - [13/Dec/2005:19:44:42 -0800] "GET / HTTP/1.1" 403 4251 "-" \
%   "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8) Gecko/20051111 Firefox/1.5"
% \end{verbatim}
% }

\caption {Example ad hoc data sources.}
\label{fig:example}
\end{figure*}

Figure \ref{fig:crashreporter:ir} presents a hand-writtern description
of the crashreporter file in the \ir{} syntax.  This
description is most easily read beginning at the bottom
with the definition of the \cd{source} type.  This definition specifies that
the data source is an
array of structs, each separated by a newline character. The array
is terminated by the end of file marker.  In other words,
the data source is a sequence of lines, with the struct
in question appearing on each line.  
The struct itself indicates each line is a sequence of
\cd{dateoption}, \cd{kind}, \cd{dumpid} and \cd{report} fields.  
The description also specifies that the constant string \cd{"["} 
will be found in between the \cd{kind} and the \cd{dumpid}, and the
constant string \cd{"]: "} will be found in between the \cd{dumpid} and 
the \cd{report}.

%% The reader can
%% \cd{dateoption} type (appearing above the definition of \cd{source})
%% is defined as either a dash or a structure containing a \cd{PDate}
%% (one of the complex base types our system uses), a \cd{PTime} (another
%% complex base type) and an integer year.  In between each of the three
%% fields in the \cd{dateoption} struct is a space character (written
%% \cd{" "}).

Most of the variable names associated with fields ({\em e.g.}
\cd{date}, \cd{dumpid}, etc.) merely serve as documentation for the reader.
However, the \cd{kind} field is different -- it is used later in the 
description and hence illustrates an element of {\em dependency}.  
To be specific, the form of the
\cd{report} field depends directly upon the contents of the \cd{kind}
field.  If the value associated with the
\cd{kind} field is \cd{"crashdump"}, then the \cd{report} is
a \cd{dumpreport} type, while if the \cd{kind} field is \cd{"crashreporterd"},
the \cd{report} is a \cd{reporterreport} type.  

Figure~\ref{fig:crashreporter:ir} contains three other definitions
aside from \cd{source}.  These definitions specify the
structure of the  \cd{dumpreport}, \cd{reporterreport} and \cd{dateoption}
types used by \cd{source}.

%% specify the component parts
%% The definition of \cd{reporterreport} is relatively simple -- it is
%% a structure containing a file path 
%% (\cd{Ppath} is one of the complex base types our system uses) and 
%% a message following 
%% \cd{" reply failed: "}.  A \cd{crashdump} message is more complicated --
%% it is a union of several different possible message formats. Finally, a
%% \cd{dateoption} type 
%% is defined as either a dash or a structure containing a \cd{PDate}, 
%% a \cd{PTime} and an integer year. 

\input{crashreporter-ir}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 