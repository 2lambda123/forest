The purpose of the structure refinement phase is to improve
the candidate structure produced by the structure discovery phase. We
formulate the structure refinement problem as an optimization problem. The
objective of the problem is, given an initial structure (treated as
an initial solution in some solution space), find the best possible structure
in its neighborhood for which the informational-theoretic scoring function
is optimized.

\paragraph*{Rewriting rules}
In order to move around in the solution space, we define a number of structure
transitions in the form of rewriting rules. The general form of the rule is
\[T \goto T', ~~ {\rm if~ some~ constraint~} c(T)~ {\rm is~ satisfied,}\]
where $T$ is a type, or sub-structure, and $T'$ is the type after the
transition.  Some rules are unconditional and thus free of constraints.
There are two kinds of rewriting rules: data-independent rules which
transform a type based on the syntax structure itself; and data-dependent
rules which transform a type based on some condition of the data values
parsed by this type. Currently, we only consider unary constraints on a base
type in $T$ (such as a base type having unique value or an enumeration of constant
values) or binary constraints on two base types in $T$ (e.g. in the switched
union case). The data independent rules mainly aim at reducing the complexity
of the structure while the data dependent rules seek to indentify data
dependency and establish relationships between different parts 
of the structure.

In Figure \ref{fig:rules}, we present a selection of
data independent and data dependent rules used in the refinement phase.
Some of the rules have been omitted or simplified for succinctness.
In these rules,
let $T_{punc}$ be any type that describes punctuation or white space characters.
Where $T\setof{X}$ appears in a pattern or the left-hand side of a rewriting
rule, $X$ is bound to the set of data representations resulting
from using $T$ to parse the appropriate part of each chunk from the training
set. Furthermore, let $card(X)$ be the cardinality of the set $X$, 
and let $X(i)$ be the data representation resulting
from parsing the $i^{th}$ chunk in the training set. Finally, given a union
value $in_j(v)$, we define function $tag(in_j(v))$ to be $j$.

\begin{figure*}
\begin{center}
\framebox{
\noindent
\begin{minipage}[t]{\columnwidth}
\paragraph*{Data independent rules}
\begin{enumerate}
\item Singleton structs and unions \\
$
\irstruct{T} \goto T
$\\ \\
$
\irstruct{} \goto \Pempty
$\\ \\
$
\irunion{T} \goto T
$\\ \\
$
\irunion{} \goto \Pvoid 
$ 

\item Struct and union clean-up\\
$
\irstruct{pre\_types; \Pvoid; post\_types} \goto \Pvoid
$\\ \\ 
$
\irstruct{pre\_types; \Pempty; post\_types} \goto \\
\sskip \irstruct{pre\_types; post\_types}
$\\ \\ 
$
\irunion{pre\_types; \Pvoid; post\_types} \goto \\
\sskip \irunion{pre\_types; post\_types} 
$\\ \\
$
\irunion{pre\_types; \Pempty; post\_types} \goto \\
\sskip \irunion{pre\_types; post\_types; \Pempty} 
$

\item Union to option\\
$
\irunion{T; \Pempty} \goto \iroption{T}
$\\ \\
$
\irunion{\Pempty; T} \goto \iroption{T}
$

\item Unnest structs and unions\\
$
\irstruct{pre\_types; \irstruct{mid\_types}; post\_types} \goto \\
\sskip \irstruct{pre\_types; mid\_types; post\_types}
$\\ \\
$
\irunion{pre\_types; \irunion{mid\_types}; post\_types} \goto \\
\sskip \irunion{pre\_types; mid\_types; post\_types}
$

\item Uniform struct to fixed-length array\\
$
\irstruct{T_1; \ldots; T_n} \goto \irarrayFW{T_1}{n}
$\\ 
\noindent if $n \ge 3$ and $\forall i \in [1,~ n],~ j \in [1,~ n]:~ T_i = T_j$.

\item Common prefix or postfix in union branches \\
$
\irunion{\irstruct{T; post\_types_1}; \\
\sskip \irstruct{T, post\_types_2}} \goto \\
\sskip \irstruct{T; \irunion{\irstruct{post\_types_1}; \\
\sskip \irstruct{post\_types_2}}}
$\\ \\
$
\irunion{\irstruct{T; post\_types}; T} \goto\\
\sskip \irstruct{T; \iroption{\irstruct{post\_types}}}
$\\ \\
$
\irunion{\irstruct{pre\_types_1; T}; \\
\sskip \irstruct{pre\_types_2; T}} \goto \\
\sskip \irstruct{\irunion{\irstruct{pre\_types_1}; \\
\sskip \irstruct{pre\_types_2}}; T}
$\\ \\
$
\irunion{\irstruct{pre\_types; T}; T} \goto \\
\sskip \irstruct{\iroption{\irstruct{pre\_types}}; T}
$

\item Combine adjacent constant strings \\
$
\irstruct{pre\_types; {\tt PstringConst (c_1)}; \\
\sskip {\tt PstringConst(c_2)}; post\_types} \goto \\
\sskip \irstruct{pre\_types; {\tt PstringConst (c_1 \wedge c_2)}; post\_types} 
$

\item {Get floating number number}\\
$
\irunion{{\tt Pint}; {\tt Pfloat}} \goto {\tt Pfloat}
$ 
\end{enumerate}
\end{minipage}
\hfill
\begin{minipage}[t]{\columnwidth}
\paragraph*{Data dependent rules}
\begin{enumerate}
\item Get floating point number \\
$
\irstruct{pre\_types; {\tt Pint}\setof{X}; {\tt PstringConst ('.')};  \\
\sskip {\tt Pint}\setof{Y}; post\_types} \goto \\
\sskip \irstruct{pre\_types; {\tt Pfloat}; post\_types}
$\\ 
\noindent if $\forall y \in Y:~ y \ge 0$. \\
\\
$
\irstruct{pre\_types; {\tt Pint}\setof{X}; \\
\sskip \iroption{\irstruct{{\tt PstringConst ('.')};  \\
\sskip {\tt Pint}\setof{Y}}}; post\_types} \goto \\
\sskip \irstruct{pre\_types; {\tt Pfloat}; post\_types}
$ \\
\noindent if $\forall y \in Y:~ y \ge 0$. 

\item Discover negative numbers\\
$
\irstruct{pre\_types; T_{punc}; {\tt PstringConst}('-');\\
\sskip {\tt Pint} \setof{X}; post\_types} \goto \\
\sskip \irstruct{pre\_types; T_{punc}; {\tt Pint}; post\_types}
$\\ 
\noindent if $\forall x \in X:~ x \ge 0$. \\
\\
$
 \irstruct{pre\_types; T_{punc}; {\tt PstringConst}('-'); \\
\sskip {\tt Pfloat}\setof{X}; post\_types} \goto \\
\sskip \irstruct{pre\_types; T_{punc}; {\tt Pfloat}; post\_types}
$\\ 
\noindent if $\forall x \in X:~ x \ge 0$.\\
\\
$
 \irstruct{pre\_types; T_{punc}; \iroption{{\tt PstringConst}('-')}; \\
\sskip {\tt Pint}(x); post\_types} \goto \\
\sskip \irstruct{pre\_types; T_{punc}; {\tt Pnat}; post\_types}
$\\
\noindent if $\forall x \in X:~ x \ge 0$.\\
\\
$
\irstruct{pre\_types; T_{punc}; {\tt \iroption{PstringConst}('-')}; \\
\sskip {\tt Pfloat}(x); post\_types} \goto \\
\sskip  \irstruct{pre\_types; T_{punc}; {\tt Preal}; post\_types}
$\\
\noindent if $\forall x \in X:~ x \ge 0$.

\item Base type with unique values to constant \\
$
{\tt Pint}\setof{X} \goto {\tt PintConst(c)} \\
$
{\rm if} $\forall x \in X:~ x = c$. 
\\ \\
$
{\tt Palpha}\setof{X} \goto {\tt PstringConst(c)} \\
$
{\rm if} $\forall x \in X:~ x = c$.
\\ \\
$
{\tt Pstring}\setof{X} \goto {\tt PstringConst(c)} \\
$
{\rm if} $\forall x \in X:~ x = c$.
\\ \\
$
{\tt Pother}\setof{X} \goto {\tt PstringConst(c)} \\ 
$
{\rm if} $\forall x \in X:~ x = c$.

\item Refine enums and ranges \\
$
{\tt Pstring}\setof{X} \goto \irenum{s_1; \ldots; s_k} \\
$
{\rm if}~ $\forall x \in X:~ x~ \in \{s_1, \ldots, s_k\}$.
\\ \\
$
{\tt Pint}\setof{X} \goto {\tt Pint32} \\
$
{\rm if} $\forall x \in X:~ 0 \le x~ < 2^{32}$.
\\ \\
$
{\tt Pint}\setof{X} \goto {\tt Pint64} \\
$
{\rm if} $\forall x \in X:~ 2^{32} \le x~ < 2^{64}$.
\\ \\
$
{\tt Pint}\setof{X} \goto {\tt PintRanged}(min,~ max) \\
$
{\rm if}~ $\forall x \in X:~ min \le x~ \le max$.

\item Union to switch \\
$
\irstruct{pre\_types; \irenum{c_1; \ldots; c_n}\setof{X}; mid\_types; \\
\sskip \irunion{T_1; \ldots; T_n}\setof{Y}; post\_types}\\
\goto \\
\irstruct{pre\_types, z:\irenum{c_1; \ldots; c_n}; mid\_types; \\
\sskip \irswitch{z}{c_1 \goto T_{\Pi(1)}; \ldots; c_n \goto T_{\Pi(n)}}; post\_types}
$\\ 
\noindent where $z$ is a fresh variable, and there exists a permutation $\Pi$, s.t.  $\forall i \in [1,~ card(X)]$, $\Pi(tag(X(i)))=tag(Y(i))$.
\end{enumerate}
\end{minipage}
}
\end{center}
\caption{List of rewriting rules} \label{fig:rules}
\end{figure*}

\paragraph*{Local search optimization}
The core of the rewriting system is 
a recursive, depth-first, greedy local search procedure. The output 
structure of one phase is used as input to the next phase.
This procedure begins by refining the children of any structured type before
the structure itself. When refining a type, it selects a rule that 
would {\em minimize} the information-theoretic score of the resulting
structure and applies it to the structure, and iterates.
Iterations stop when no reduction in the score is possible, and at
that time, structure $T$ is said to be {\em stable}.

\begin{figure}
\begin{code}
Refine(T, Rules)
\{
  foreach c in children(T)
    Refine(c, Rules)
  minScore := score(T)
  do \{
    minRule := \{\}
    foreach r in Rules 
    \{
      if score(r(T)) < minScore
      \{
        minScore := score(r(T))
        minRule := r
      \}
    \}
    if minRule != \{\} then T := minRule(T)
  \} while minRule != \{\}
\}
\end{code}
\caption{The generic greedy local optimization procedure}
\label{fig:refinement}
\end{figure}

The overall algorithm in Figure \ref{fig:refinement} is applied three
times in succession. We write $r(T)$ to mean the result of applying
rule $r$ to $T$, and $score(T)$ to represent the information-thereotic
score of structure $T$.
At the first time, the algorithm quickly reduces the initial structure to 
a much simpler, manageable sized new structure by using
the data independent rules {\em only}. The second time, data dependent
rules are used refine the base types to constant values and enumerations, etc,
and establish structural dependencies such as switched unions. This phase
requires a value-space analysis described below.
At the third time, a set of the data independent rules
(such as combining adjacent constant strings) are applied again. 
The third time is necessary because certain changes
to the base types in phase two such as the creation of constants may 
enable some of data independent rules which will further optimize the structure. 

\paragraph*{Value-space analysis}
A value-space analysis is performed as a prerequisite of the second phase.
Here, a number of data dependency tables are generated from the 
input structure, where each
column of the tables represent the data values associated with a particular base type 
in the structure, with some extra columns representing auxilliary information such as
array sizes and union branching decisions. Then we applied the TANE algorithm \cite{TANE-HKPT99}
which can be used to identify functional dependencies in relational databases.
Because TANE is expensive (exponential on the number of nodes in the structure) 
in general and the sample data we have is often not big enough hence 
result in many false positives, we modified TANE to produce only a minimum set 
of binary dependencies. The result of this dependency analysis is used to 
identify switched unions and fixed size arrays.
In addition, we also discover all the unary constraints on the base types by
analysizing every single column in the data tables. We store these unary and
binary constraint in a constraint map.  A rule can be applied 
only if the conditions are validated successfully
against the constraint map. 

\paragraph*{Running example}
To illustrate the refinement process a bit more concretely, let us walk through
a few steps as the system refines the initial structure of the crashreporter.log example.
Let us zoom into the beginning portion of the IR and omit some of the details as follows. 
We annotate each type with two pieces of auxiliary information: id of the node which
can be used as the variable name and the complexity score at this node, 
enclosed in a pair of parenthese. In addition, for Pother base types,
we append the character it binds to in parenthese after the type name.

\begin{verbatim}
struct(BTy_109, 435598.632b) {
  Pdate (BTy_0, 118482.098b);
  Pwhite (BTy_1, 887.044b);
  Ptime (BTy_2, 97416.824b);
  Pwhite (BTy_3, 887.044b);
  Pint (BTy_4, 5865.926b);
  Pwhite (BTy_5, 887.044b);
  Palpha (BTy_6, 23879.044b);
  Pother([) (BTy_8, 3336.618b);
  Pint (BTy_9, 6899.045b);
  Pother(]) (BTy_10, 3336.618b);
  union(BTy_58, 173712.822b) {
    struct(BTy_57, 156487.759b) {
     ...
    };
    struct(BTy_108, 17218.019b) {
     ...
    };
  };
};
\end{verbatim}

In Phase One, some common types, namely Pother, Pwhite and Palpha, from union branches
BTy\_57 and BTy\_108 are extracted out under the "common prefix in union" rule.
As a result of, the new structure with a better score 435504.687b is:

\begin{verbatim}
struct(BTy_109, 435504.687b) {
  Pdate (BTy_0, 118482.098b);
  Pwhite (BTy_1, 887.044b);
  Ptime (BTy_2, 97416.824b);
  Pwhite (BTy_3, 887.044b);
  Pint (BTy_4, 5865.926b);
  Pwhite (BTy_5, 887.044b);
  Palpha (BTy_6, 23879.044b);
  Pother([) (BTy_8, 3336.618b);
  Pint (BTy_9, 6899.045b);
  Pother(]) (BTy_10, 3336.618b);
  Pother(:) (BTy_12, 3336.618b);
  Pwhite (BTy_13, 887.044b);
  Palpha (BTy_14, 21125.044b);
  union(BTy_58, 148269.822b) {
    struct(BTy_57, 140512.323b) {
     ...
    };
    struct(BTy_108, 7750.455b) {
     ...
    };
  };
};

\end{verbatim}

In Phase Two, data dependent rules 3 and 4 are applied to all the base types to 
create a number of constants and enums, and therefore the structure is
transformed to: 

\begin{verbatim}
struct(BTy_109, 323626.593b) {
  Pdate (BTy_0, 118482.098b);
  " " (BTy_1, 11.044b);
  Ptime (BTy_2, 97416.824b);
  " " (BTy_3, 11.044b);
  2006 (BTy_4, 17.015b);
  " " (BTy_5, 11.044b);
  enum {"crashreporterd", "crashdump"} 
       (BTy_6, 156.133b);
  "[" (BTy_8, 11.044b);
  PintRanged(120, 29874) (BTy_9, 6580.450b);
  "]" (BTy_10, 11.044b);
  ":" (BTy_12, 11.044b);
  " " (BTy_13, 11.044b);
  enum {"crashdump", "mach_msg", "Finished", "Started", 
        "Unable", "Failed", } (BTy_14, 317.405b);
  union(BTy_58, 100570.505b) {
    struct(BTy_57, 99696.280b) {
     ...
    };
    struct(BTy_108, 867.181b) {
     ...
    };
  };
};
\end{verbatim}

Further, data dependency is discovered between type BTy\_8
and the union BTy\_58, and thus the latter is converted to
a switched union as follows.

\begin{verbatim}
struct(BTy_109, 323625.593b) {
  Pdate (BTy_0, 118482.098b);
  " " (BTy_1, 11.044b);
  Ptime (BTy_2, 97416.824b);
  " " (BTy_3, 11.044b);
  2006 (BTy_4, 17.015b);
  " " (BTy_5, 11.044b);
  enum {"crashreporterd", "crashdump"} 
       (BTy_6, 156.133b);
  "[" (BTy_8, 11.044b);
  PintRanged(120, 29874) (BTy_9, 6580.450b);
  "]" (BTy_10, 11.044b);
  ":" (BTy_12, 11.044b);
  " " (BTy_13, 11.044b);
  enum {"crashdump", "mach_msg", "Finished", "Started", 
        "Unable", "Failed", } (BTy_14, 317.405b);
  switch BTy_14 of (BTy_58, 100569.505b) {
    enum {"Failed", "Finished", "Started"}   => 
      struct(BTy_57, 99696.280b) {
       ...
      };
    enum {"Unable", "crashdump", "mach_msg"} =>
      struct(BTy_108, 867.181b) {
       ...
      };
  };
};
\end{verbatim}

Finally in Phase Three, rule 7 is applied to combine the constants in BTy\_10,
BTy\_12 and BTy\_13 of struct BTy\_109, which gives 

\begin{verbatim}
struct(BTy_109, 323615.282b) {
  Pdate (BTy_0, 118482.098b);
  " " (BTy_1, 11.044b);
  Ptime (BTy_2, 97416.824b);
  " " (BTy_3, 11.044b);
  2006 (BTy_4, 17.015b);
  " " (BTy_5, 11.044b);
  enum {"crashreporterd", "crashdump"} 
       (BTy_6, 156.133b);
  "[" (BTy_8, 11.044b);
  PintRanged(120, 29874) (BTy_9, 6580.450b);
  "]: " (BTy_10, 23.044b);
  enum {"crashdump", "mach_msg", "Finished", "Started", 
        "Unable", "Failed", } (BTy_14, 317.405b);
  switch BTy_14 of (BTy_58, 100569.505b) {
    enum {"Failed", "Finished", "Started"}   => 
      struct(BTy_57, 99696.280b) {
       ...
      };
    enum {"Unable", "crashdump", "mach_msg"} =>
      struct(BTy_108, 867.181b) {
       ...
      };
  };
};
\end{verbatim}

Comparing this final result with the initial description, one can see that
the structure refinement significately simplified the IR and lower the
complexity score; and with
the explicit constants and enums, the description is a lot more
informative than before.
