The purpose of the structure refinement is to improve
the candidate structure produced by the structure discovery phase. We
formulate the structure refinement problem as an optimization problem. The
objective of the problem is, given an initial structure (treated as
an initial solution in some solution space), find best possible structure
in its neighborhood for which the informational theoretic scoring function
is optimized.

In order to move around in the solution space, we define a number of structure
transitions in the form of rewriting rules. The general form of the rule is
\[T \goto T', ~~ {\rm if~ some~ constraint~} c(T)~ {\rm is~ satisfied,}\]
where $T$ is a type, or sub-structure, and $T'$ is the type after the
transition.  Some rules are unconditional and thus free of constraints.
There are two kinds of rewriting rules: data-independent rules which
transform a type based on the syntax structure itself; and data-dependent
rules which transform a type based on some condition of the data values
parsed by this type. Currently, we only consider unary constraints on a base
type in $T$ (such as a base type having unique value or an enumeration of constant
values) or binary constraints on two base types in $T$ (e.g. in the switched
union case). The data independent rules mainly aim at reducing the complexity
of the structure while the data dependent rules seek to indentify data
dependency and establish relationships between different parts 
of the structure.

In what follows, we present a selection of
data independent and data dependent rules used in the refinement stage.
Some of the rules have been omitted or simplified for succinctness.
We begin with a few definitions and present the rules in various groups.

Let $T_{punc}$ be any type that describes a punctuation or white space.
Let $T\setof{X}$ be a type $T$ where $X$ is a {\em bag} of data representations
parsed by $T$.

\subsubsection*{Data independent rules}
\begin{enumerate}
\item Singleton structs and unions \\
$
\irstruct{T} \goto T
$\\ \\
$
\irstruct{} \goto \Pempty
$\\ \\
$
\irunion{T} \goto T
$\\ \\
$
\irunion{} \goto \Pvoid 
$ 

\item Struct and union clean-up\\
$
\irstruct{pre\_types; \Pvoid; post\_types} \goto \Pvoid
$\\ \\ 
$
\irstruct{pre\_types; \Pempty; post\_types} \goto \\
\sskip \irstruct{pre\_types; post\_types}
$\\ \\ 
$
\irunion{pre\_types; \Pvoid; post\_types} \goto \\
\sskip \irunion{pre\_types; post\_types} 
$\\ \\
$
\irunion{pre\_types; \Pempty; post\_types} \goto \\
\sskip \irunion{pre\_types; post\_types; \Pempty} 
$

\item Union to option\\
$
\irunion{T; \Pempty} \goto \iroption{T}
$\\ \\
$
\irunion{\Pempty; T} \goto \iroption{T}
$

\item Unnest structs and unions\\
$
\irstruct{pre\_types; \irstruct{mid\_types}; post\_types} \goto \\
\sskip \irstruct{pre\_types; mid\_types; post\_types}
$\\ \\
$
\irunion{pre\_types; \irunion{mid\_types}; post\_types} \goto \\
\sskip \irunion{pre\_types; mid\_types; post\_types}
$

\item Uniform struct to fixed-length array\\
$
\irstruct{T_1; \ldots; T_n} \goto \irarrayFW{T_1}{n}
$\\ 
\noindent if $n \ge 3$ and $\forall i \in [1,~ n],~ j \in [1,~ n]:~ T_i = T_j$.

\item Common prefix or postfix in union branches \\
$
\irunion{\irstruct{T; post\_types_1}; \\
\sskip \irstruct{T, post\_types_2}} \goto \\
\sskip \irstruct{T; \irunion{\irstruct{post\_types_1}; \\
\sskip \irstruct{post\_types_2}}}
$\\ \\
$
\irunion{\irstruct{T; post\_types}; T} \goto\\
\sskip \irstruct{T; \iroption{\irstruct{post\_types}}}
$\\ \\
$
\irunion{\irstruct{pre\_types_1; T}; \\
\sskip \irstruct{pre\_types_2; T}} \goto \\
\sskip \irstruct{\irunion{\irstruct{pre\_types_1}; \\
\sskip \irstruct{pre\_types_2}}; T}
$\\ \\
$
\irunion{\irstruct{pre\_types; T}; T} \goto \\
\sskip \irstruct{\iroption{\irstruct{pre\_types}}; T}
$

\item Combine adjacent constant strings \\
$
\irstruct{pre\_types; {\tt PstringConst (c_1)}; \\
\sskip {\tt PstringConst(c_2)}; post\_types} \goto \\
\sskip \irstruct{pre\_types; {\tt PstringConst (c_1 \wedge c_2)}; post\_types} 
$

\item {Get floating number number}\\
$
\irunion{{\tt Pint}; {\tt Pfloat}} \goto {\tt Pfloat}
$ 
\end{enumerate}

\subsubsection*{Data dependent rules}
\begin{enumerate}
\item Get floating point number \\
$
\irstruct{pre\_types; {\tt Pint}\setof{X}; {\tt PstringConst ('.')};  \\
\sskip {\tt Pint}\setof{Y}; post\_types} \goto \\
\sskip \irstruct{pre\_types; {\tt Pfloat}; post\_types}
$\\ 
\noindent if $\forall y \in Y:~ y \ge 0$. \\
\\
$
\irstruct{pre\_types; {\tt Pint}\setof{X}; \\
\sskip \iroption{\irstruct{{\tt PstringConst ('.')};  \\
\sskip {\tt Pint}\setof{Y}}}; post\_types} \goto \\
\sskip \irstruct{pre\_types; {\tt Pfloat}; post\_types}
$ \\
\noindent if $\forall y \in Y:~ y \ge 0$. 

\item Discover negative numbers\\
$
\irstruct{pre\_types; T_{punc}; {\tt PstringConst}('-');\\
\sskip {\tt Pint} \setof{X}; post\_types} \goto \\
\sskip \irstruct{pre\_types; T_{punc}; {\tt Pint}; post\_types}
$\\ 
\noindent if $\forall x \in X:~ x \ge 0$. \\
\\
$
 \irstruct{pre\_types; T_{punc}; {\tt PstringConst}('-'); \\
\sskip {\tt Pfloat}\setof{X}; post\_types} \goto \\
\sskip \irstruct{pre\_types; T_{punc}; {\tt Pfloat}; post\_types}
$\\ 
\noindent if $\forall x \in X:~ x \ge 0$.\\
\\
$
 \irstruct{pre\_types; T_{punc}; \iroption{{\tt PstringConst}('-')}; \\
\sskip {\tt Pint}(x); post\_types} \goto \\
\sskip \irstruct{pre\_types; T_{punc}; {\tt Pnat}; post\_types}
$\\
\noindent if $\forall x \in X:~ x \ge 0$.\\
\\
$
\irstruct{pre\_types; T_{punc}; {\tt \iroption{PstringConst}('-')}; \\
\sskip {\tt Pfloat}(x); post\_types} \goto \\
\sskip  \irstruct{pre\_types; T_{punc}; {\tt Preal}; post\_types}
$\\
\noindent if $\forall x \in X:~ x \ge 0$.

\item Base type with unique values to constant \\
$
{\tt Pint}\setof{X} \goto {\tt PintConst(c)} \\
$
{\rm if} $\forall x \in X:~ x = c$. 
\\ \\
$
{\tt Palpha}\setof{X} \goto {\tt PstringConst(c)} \\
$
{\rm if} $\forall x \in X:~ x = c$.
\\ \\
$
{\tt Pstring}\setof{X} \goto {\tt PstringConst(c)} \\
$
{\rm if} $\forall x \in X:~ x = c$.
\\ \\
$
{\tt Pother}\setof{X} \goto {\tt PstringConst(c)} \\ 
$
{\rm if} $\forall x \in X:~ x = c$.

\item Refine enums and ranges \\
$
{\tt Pstring}\setof{X} \goto \irenum{s_1; \ldots; s_k} \\
$
{\rm if}~ $\forall x \in X:~ x~ \in \{s_1, \ldots, s_k\}$.
\\ \\
$
{\tt Pint}\setof{X} \goto {\tt Pint32} \\
$
{\rm if} $\forall x \in X:~ 0 \le x~ < 2^{32}$.
\\ \\
$
{\tt Pint}\setof{X} \goto {\tt Pint64} \\
$
{\rm if} $\forall x \in X:~ 2^{32} \le x~ < 2^{64}$.
\\ \\
$
{\tt Pint}\setof{X} \goto {\tt PintRanged}(min,~ max) \\
$
{\rm if}~ $\forall x \in X:~ min \le x~ \le max$.

\item Union to switch \\
$
\irstruct{pre\_types; \irenum{c_1; \ldots; c_n}\setof{X}; mid\_types; \\
\sskip \irunion{T_1; \ldots; T_n}\setof{Y}; post\_types}\\
\goto \\
\irstruct{pre\_types, z:\irenum{c_1; \ldots; c_n}; mid\_types; \\
\sskip \irswitch{z}{c_1 \goto T_{\Pi(1)}; \ldots; c_n \goto T_{\Pi(n)}}; post\_types}
$\\ 
\noindent where $z$ is a fresh variable, and there exists a permutation $\Pi$, s.t.
$\forall i \in [1,~ card(X)]$, $\Pi(tag(X(i)))=tag(Y(i))$, and 
$tag(in_j(d)) = j$.
\end{enumerate}

The refinement process consists of three sequential phases. Each phase takes
an input structure and transforms it to a new structure using 
a recursive, depth-first, greedy local search descent procedure. The output 
structure of one phase is used as input to the the next phase. 
At each node $T$ in the structure, it is refined after all its
children nodes have been refined. $T$ is refined through a number of
iteration. In every iteration, an applicable rule which
gives the biggest reduction in score is used to transform $T$ into
an updated $T'$.  Iterations stop when no reduction is possible, and at
this time, structure $T$ is said to be {\em stable}.

Fig. \ref{fig:refinement} gives 
a generic abstract algorithm of this recursive greedy search procedure. 
We write $r(T)$ to mean the result of applying
rule $r$ to $T$.

\begin{figure}
\begin{code}
Refine(T, Rules)
\{
  if T is not base type 
  \{
    foreach c in children(T)
      Refine(c, Rules)
  \}
  let minScore = MAX_INT
  do \{
    let minRule = \{\}
    foreach r in Rules 
    \{
      let score(T, r) be the score of r(T) 
      if score(T, r) < minScore
      \{
        minScore = score(T, r)
        minRule = r
      \}
    \}
    if minRule != \{\} then T = minRule(T)
  \} while minRule != \{\}
\}
\end{code}
\caption{The generic local descent procedure}
\label{fig:refinement}
\end{figure}

Phase One aims at quickly reducing the initial structure to 
a much simpler, manageable sized new structure, and this phase uses only
data independent rules. 

Before starting Phase Two, 
a number of data dependency tables are generated from the input structure, where each
column of the tables represent the data values associated with a particular base type 
in the structure, with some extra columns representing auxilliary information such as
array sizes and union branching decisions. Then we applied the TANE algorithm \cite{TANE-HKPT99}
which can be used to identify functional dependencies in relational databases.
Because TANE is expensive (exponential on the number of nodes in the structure) in general
and the sample data we have is often big enough hence result in many false positives,
we modified TANE to work only a minimum set of binary dependencies. The result of
this dependency analysis is used to identify switched unions and fixed size arrays.
In addition, we also discover all the unary constraints on the base types by
analysizing every single column in the data tables. We store these unary and
binary constraint in a constraint map, which is a pre-requisite for Phase Two.
Only data dependent rules are used in Phase Two. 
A rule can be applied if the conditions are validated successfully
against the constraint map. 

In Phase Three, a set of the data independent rules
(such as combining adjacent constant strings) are applied again. 
This phase is necessary because certain changes
to the base types in Phase Two such as the creation of constants may 
enable some of data independent rules which will further optimize the structure. 

To illustrate the refinement process a bit more concretely, let us look at how
the system refines a part of the initial structure from crashreporter.log example.
Let us zoom into a portion of the IR as follows. The information inside the
parenthese after each node represents the id of the node, number of
chunks parsed by this node, and the score for this node.

\begin{code}
Pstruct(Id = BTy_57 292, 156487.759b)
  Punion(Id = BTy_26 292, 56076.537b)
    Pstruct(Id = BTy_25 290, 55785.983b)
      [Other](:) (Id = BTy_12 290, 2195.875b);
      [White] (Id = BTy_13 290, 585.044b);
      [String] (Id = BTy_14 290, 13055.044b);
      [White] (Id = BTy_15 290, 585.044b);
      [String] (Id = BTy_16 290, 12185.044b);
      [White] (Id = BTy_17 290, 585.044b);
      [String] (Id = BTy_18 290, 8705.044b);
      [White] (Id = BTy_19 290, 585.044b);
      [String] (Id = BTy_20 290, 10445.044b);
      [White] (Id = BTy_21 290, 585.044b);
      [String] (Id = BTy_22 290, 3485.044b);
      [Other](:) (Id = BTy_23 290, 2195.875b);
      [White] (Id = BTy_24 290, 585.044b);
    End Pstruct;
    Pstruct(Id = BTy_35 2, 283.509b)
    [Other](:) (Id = BTy_27 2, 20.154b);
      [White] (Id = BTy_28 2, 9.044b);
      [String] (Id = BTy_29 2, 77.044b);
      [White] (Id = BTy_30 2, 9.044b);
      [String] (Id = BTy_31 2, 29.044b);
      [White] (Id = BTy_32 2, 9.044b);
      [String] (Id = BTy_33 2, 113.044b);
      [White] (Id = BTy_34 2, 9.044b);
    End Pstruct;
  End Punion;
  ...
End Pstruct
\end{code}

In Phase One, the first node that can be processed is node {\tt BTy\_26}
where only rule 6 "common prefix in union" can be applied. As a result of that
rewriting, the new structure with a better score is:

\begin{code}
Pstruct(Id = BTy_57 292, 156446.2b)
  Pstruct(Id = BTy_110 292, 56034.973b)
    [Other](:) (Id = BTy_12 292, 2210.984b);
    [White] (Id = BTy_13 292, 589.044b);
    [String] (Id = BTy_14 292, 13127.044b);
    [White] (Id = BTy_15 292, 589.044b);
    [String] (Id = BTy_16 292, 12209.044b);
    [White] (Id = BTy_17 292, 589.044b);
    [String] (Id = BTy_18 292, 8813.044b);
    [White] (Id = BTy_19 292, 589.044b);
    Poption(Id = BTy_26 292, 17310.463b)
      Pstruct(Id = BTy_25 290, 17303.419b)
    	[String] (Id = BTy_20 290, 10445.044b);
    	[White] (Id = BTy_21 290, 585.044b);
    	[String] (Id = BTy_22 290, 3485.044b);
    	[Other](:) (Id = BTy_23 290, 2195.875b);
    	[White] (Id = BTy_24 290, 585.044b);
      End Pstruct;
    End Poption;
  End Pstruct
  ...
End Pstruct
\end{code}

Next, with node {\tt BTy\_110} stable in phase 1, we proceed to
refine node {\tt BTy\_57}. Here rule 4 "unnest struct" can be applied.
And the resulting structure is:

\begin{code}
Pstruct(Id = BTy_57 292, 156439.855b)
  [Other](:) (Id = BTy_12 292, 2210.984b);
  [White] (Id = BTy_13 292, 589.044b);
  [String] (Id = BTy_14 292, 13127.044b);
  [White] (Id = BTy_15 292, 589.044b);
  [String] (Id = BTy_16 292, 12209.044b);
  [White] (Id = BTy_17 292, 589.044b);
  [String] (Id = BTy_18 292, 8813.044b);
  [White] (Id = BTy_19 292, 589.044b);
  Poption(Id = BTy_26 292, 17310.463b)
    Pstruct(Id = BTy_25 290, 17303.419b)
      [String] (Id = BTy_20 290, 10445.044b);
      [White] (Id = BTy_21 290, 585.044b);
      [String] (Id = BTy_22 290, 3485.044b);
      [Other](:) (Id = BTy_23 290, 2195.875b);
      [White] (Id = BTy_24 290, 585.044b);
    End Pstruct;
  End Poption;
  ...
End Pstruct
\end{code}

Later, rule 6 is applied to the parent of {\tt BTy\_57} and the first few
base types, {\tt BTy\_12} through {\tt BTy\_14}, were extracted out. 

In Phase Two, data dependent rules 3 and 4 are applied to all the base types to 
create a number of constants and enums, and as a result, 
we have:

\begin{code}
Pstruct(Id = BTy_57 292, 99716.44b)
  [StringConst] " " (Id = BTy_15 292, 11.044b);
  [Enum] {[StringConst] "to", [StringConst] "writing", } 
		(Id = BTy_16 292, 72.133b);
  [StringConst] " " (Id = BTy_17 292, 11.044b);
  [Enum] {[StringConst] "crash", [StringConst] "re-launch", } 
		(Id = BTy_18 292, 102.133b);
  [StringConst] " " (Id = BTy_19 292, 11.044b);
  Poption(Id = BTy_26 292, 103.293b)
    Pstruct(Id = BTy_25 290, 96.249b)
      [StringConst] "report" (Id = BTy_20 290, 41.044b)
      [StringConst] " " (Id = BTy_21 290, 11.044b)
      [StringConst] "to" (Id = BTy_22 290, 17.044b)
      [StringConst] ":" (Id = BTy_23 290, 11.044b)
      [StringConst] " " (Id = BTy_24 290, 11.044b)
    End Pstruct;
  End Poption;
...
End Pstruct
\end{code}

Finally in Phase Three, rule 7 is applied to node {\tt BTy\_25} to arrive at the 
final structure:
\begin{code}
Pstruct(Id = BTy_57 292, 99691.235b)
  [StringConst] " " (Id = BTy_15 292, 11.044b);
  [Enum] {[StringConst] "to", [StringConst] "writing", } 
		(Id = BTy_16 292, 72.133b);
  [StringConst] " " (Id = BTy_17 292, 11.044b);
  [Enum] {[StringConst] "crash", [StringConst] "re-launch", } 
		(Id = BTy_18 292, 102.133b);
  [StringConst] " " (Id = BTy_19 292, 11.044b);
  Poption(Id = BTy_26 292, 78.089b)
  	[StringConst] "report to: " (Id = BTy_20 290, 71.044b);
  End Poption;
  ...
End Pstruct
\end{code}

Comparing this final result with the initial description, one can see that
the structure refinement significately simplified the IR; and with
the explicit constants and enums, the description is a lot more
informative than before.
