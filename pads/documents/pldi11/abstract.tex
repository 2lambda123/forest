Many applications use the file system as a simple persistent data
store.  This approach is expedient, but it is not robust.  In general,
the overall correctness of such an application dependso on the
collection of files, directories, and symbolic links having some
precise hierarchical organization. Furthermore file system properties
such as file ownership, permissions, and timestamps must have
acceptable values. Unfortunately, current programming languages do not
provide support for documenting assumptions about the file system. In
addition, actually loading data from disk requires writing tedious
boilerplate code.

This paper describes \forest{}, a new domain-specific language for
describing directory structures embedded in \haskell{}. \forest{}
descriptions use a type-based metaphor to specify portions of the file
system in a simple, declarative manner.  \forest{} makes it easy to
connect data on disk to an isomorphic representation in memory
that can be manipulated by programmers as if it were any other
data structure in their program.  \forest{} generates
metadata that describes to what degree the files on disk conform to
the specification, making error detection easy. The system greatly
lowers the divide between on-disk and in-memory representations of
data. \forest{} leverages \haskell{}'s powerful generic programming
infrastructure to make it easy for third-party developers to build
tools that work for any \forest{} description.  We illustrate the use
of this infrastructure to build a number of useful tools, including a
visualizer, permission checker, and description-specific tools for a
number of standard shell tools.

\cut{
We present the design for \forest{} and describe the implementation of
a full working prototype. From a single compact description, the
\forest{} compiler generates a collection of \haskell{} types and
functions for validating and analyzing file system data.  In addition,
\forest{} generates type class instance declarations that make it
possible to exploit powerful generic programming paradigms that allow
third-party developers to build tools for querying, visualizing, and
debugging on-disk data in a generic way. We present examples
illustrating the use of \forest{} on a number of real-world directory
structures and programming tasks, including description-specific
replacements for a number of standard shell tools. Finally, we
formalize the core elements of the language as a simple calculus based
on classical tree logics.}