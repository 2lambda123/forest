One of the most pressing, modern programming language problems
involves designing mechanisms that provide programmers with immediate,
low-cost, easy-to-understand data access and data management tools.
This paper tackles one crucial aspect of this problem: access to
structured file systems.  It does so through the conception, design and
implementation of a new programming language called \forest.
\forest{} is a seemless extension of \haskell{} that allows programmers
to specify the structure of file systems or file system fragments
using a form of extended type declaration.  These specifications
include complete information about hierarchical and data-dependent directory
structure, directory unfolding (untarring), file attributes, file
compression, and file contents.  Once a programmer has defined a file
system specification, they may apply it to a file system fragment and
read or analyze the file system contents as if it were any other
strongly-typed data structure within their program.  In addition to
providing ordinary programming support, the
\forest{} system also generates a range of useful end-to-end
tools for managing file
system fragments including tools for error-detection, 
for visualization and debugging, for permission verification and for scripting.
For the latter application, \forest{} generates 
a suite of specification-directed
analogues of conventional Unix-style commands such as
{\tt ls}, {\tt grep}, {\tt tar}, {\tt cp} and others.
\forest{} is also tightly connected to generic programming support available
in \haskell{} and automatically generates all type classes necessary
to perform generic traversals, maps, folds or queries.  Consequently,
users may design new, domain-specific generic tools quickly and easily.
We demonstrate that the language design is both general and useful by
applying it to a number of real data sets and programming tasks.  We
also formalize the core elements of the language as a simple calculus
inspired by classical tree logics.

