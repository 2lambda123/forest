\section {Introduction}
\label{sec:intro}


One of the most pressing, modern programming language design problems is how
to provide programmers with immediate, low-cost, easy-to-understand
data access and data management tools.  
There are many aspects to this problem: database access (Links), 
program-to-program
communication infrastructure (Protobufs), language-integrated query (Linq), etc.
In this paper, we propose a new
kind of language design, geared towards solving one corner of this
crucial problem --- the corner.  Our proposal, \forest{}

Databases are an effective, time-tested technology for storing structured
and semi-structured data.  Nevertheless, many
computer users eschew the benefits of structured databases
and store their information in collections of files, scattered across
a conventional file system.  Programming with such data repositories is
complicated and error-prone, because there is generally no documentation
of file system structure, no systematic means for detecting errors, no
support for large sets of files and no
useful generic tool or query support.  Typically, in such settings,
programmers fall back on using inflexible, unreuseable, hard-to-understand, 
hard-to-modify collections of scripts.

This paper proposes a more general and robust solution to the 
  
The goal of \forest{} project is to make programming with such collections
of files as easy and robust as programming with structured, in-memory data 
structures.  We



Define the problem:

\begin{itemize}
\item Data accumulates over time in sets of files organized in
hierarchically structured file systems.  Show table of examples.
\item Problem: no documentation
\item Problem: errors. No tools for consistency checking/error dection
\item Problem: data encoded in combination of file and directory names as
well as internally in files
\item Problem: data is large: complicates infrastructure for getting
  data in to and out of programs. Can't even use standard unix tools
  like ls due to overexpansion on command line.
\end{itemize}

Goal: to make programming with data on disk as easy as programming
with a data structure in a program

Contributions:

\begin{itemize}
\item Concept:  the idea to extend a modern programming language with
fully integrated linguistic features for describing file system fragments
and for automatically generating programming infrastructure from such 
descriptions.

\item Description Language Design: we have carefully chosen \forest{}
  programming features based on our analysis of a number of examples.
  The design is expressive, concise and tastefully integrated into
  Haskell.  It lowers the barrier to programming with data on disk.
  We give examples...

\item Tool Generation: tools are automatically generated so that
  programmers may begin working with their described data immediately
  and easily.  List tools generated.  We illustrate the use of these
  tools on examples.

\item Implementation: a fully functional extension of Haskell.  We
  evaluate its performance briefly?  Side-comment: the implementation
  acts as a case study in *extensive,* practical, domain-specific
  language design in modern languages by combining a number of
  experimental features of Haskell such as quasi-quoting, template
  haskell, etc.

\item Semantics: we have a semantics for a core calculus.  This guides
  our implementation decisions.  Unlike parser generators, which are
  based on grammars over sequences, this is based on a classical logic
  over trees.
\end{itemize}

Tool Notes:

\begin{itemize}
\item Core tools implemented within the compiler. (loader)
\item Generic tools, useable with all descriptions, and implemented as
  third-party libraries.
\begin{itemize}
\item Unix-like shell tools: grep, ls, tar, cp, rm
\item description-generation tool using universal description
\item simple directory visualization by generating dot files and highlighting errors
\item pretty printing tools
\end{itemize}
\item Custom programming against typed interface and querying using Haskell generic programming libraries
\end{itemize}
