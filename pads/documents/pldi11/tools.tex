\section{Tools}
\label{sec:tools}
Third-party developers can use generic programming~\cite{Lammel+:syb} to
generate tools that will work for any file system structure that has a
\forest{} description.  As a proof of concept, we have written a
number of such tools, which we describe in this section.  
%We simulated
%being third-party users by not changing the code of the \forest{}
%compiler to build any of these tools.  The generic programming
%infrastructure provided by Haskell makes writing such tools very easy.

\subsection{Generic Querying }
One simple application of generic programming is querying 
meta-data to find files with a particular collection of attributes. 
The \cd{findFiles} function 
\begin{code}
findFiles :: (ForestMD md) => 
     md -> (FileInfo -> Bool) -> [FilePath]
\end{code}
takes as input any \forest{} meta-data value (\ie{}, any
value of type \cd{md} where \cd{md} belongs to the \forest{}
meta-data class \cd{ForestMD}) and a predicate on \cd{FileInfo}
structures, and returns the list of all \cd{FilePath}s anywhere in the
input meta-data whose associated \cd{FileInfo} satisfies the
predicate.  For example, if \cd{cs_md} is the meta-data associated
with the Princeton Computer Science Department data, then the code 
\begin{code}
dirs  = findFiles cs_md (\textbackslash(r::FileInfo) -> 
                           (kind r) == DirectoryK)
other = findFiles cs_md (\textbackslash(r::FileInfo) -> 
                           (owner r) /= "bwk")
\end{code}
binds \cd{dirs} to the list of all directories in the data set and
\cd{other} to all the directories and files not owned by 
user \cd{"bwk"}.

To implement the \cd{findFiles} function, we use the generic Haskell
function \cd{listify}: 
\begin{code}
findFiles md pred = map fullpath (listify pred md)
\end{code}
The return type of the polymorphic \cd{listify} function is
instantiated to match the argument type of its predicate argument. 
We map the \cd{fullpath} function over the resulting list of
\cd{FileInfo} structures to return only the \cd{FilePaths}.

\subsection{File System Visualization}
\fg{} generates a graphical representation of any directory structure
that matches a \forest{} specification.  We generated the graph in~\figref{fig:student-pic} using  
this tool.  In the default configuration, \fg{} uses boxes to denote
directories and ovals to denote files. Borders of varying
thickness distinguish between ASCII and binary files.  
Dashed node boundaries indicate symbolic links and red nodes flag errors.

The core functionality of \fg{} lies in the Haskell function \cd{mdToPDF}:
\begin{code}
mdToPDF :: ForestMD md => 
     md -> FilePath -> IO (Maybe String)
\end{code}
The function takes as input any meta-data value and a
filepath that specifies where to 
put the generated PDF file.  It optionally returns a string (\cd{Maybe
String}); if the option is present, the string contains an error
message.  The \cd{IO} type constructor indicates that there can be
side effects during the execution of the function.  A use of
this function to generate the graph for the Princeton Computer Science
Department looks like:
\begin{code}
 do \{ (cs_rep,cs_md) <- CS_load  "facadm"
    ; mdToPDF cs_md "Output/CS.pdf"       \}
\end{code}
Note that this code needs only the meta-data to generate the graph;
laziness means \forest{} will not load the representation in this
case. 

The related function \cd{mdToPDFWithParams} takes an additional
argument that allows the user to specify how to draw the nodes and
edges in the output graph.  Among other things, this parameter
specifies how to map a value of type \cd{Forest\_md} into
\graphviz{}~\cite{haskell-graphviz,Gansner+:graphviz} attributes.  By appropriately setting the
parameter, a user can customize the formatting of each node according
to its owner, group, or permissions, \etc{}, as well as specify global
properties of the graph such as its orientation and size.  \fg{} uses
the Haskell binding of the \graphviz{} library to layout and render
the graphs, so all customization provided by \graphviz{} are
available.

The \cd{listify} function is at the heart of the implementation of
this tool; we use it to convert the input meta-data to the list of
\cd{FileInfo}s in the meta-data.  We then convert this list into a
graph data structure suitable for use with the \graphviz{} library.

\subsection{Permission Checker}
The permission tool is designed to check the permissions on the files
and directories in a \forest{} description on a multi-user machine.
In particular, it enables one user to determine which files a second
user can read, write, or execute.  If the second user cannot access a
file in a particular way, the tool also reports the names of the files
and directories whose permissions have to change to allow the access.
The tool is useful when trying to share files with a colleague.  It
helps the first user ensure that all the necessary permissions
have been set properly to allow the second user access.  The key to
the implementation of this tool is again applying the \cd{listify}
function to the meta-data for the \forest{} description.

\subsection{Shell Tools}
We have implemented analogs of many shell tools that work
over a file system fragment defined by a
\forest{} description:
\begin{code}
ls    :: (ForestMD md) => md -> String -> IO String
grep  :: (ForestMD md) => md -> String -> IO String
tar   :: (ForestMD md) => md -> FilePath -> IO ()
cp    :: (ForestMD md) => md -> FilePath -> IO ()
\end{code}
%rm    :: (ForestMD md) => md -> String -> IO String
%rmdir :: (ForestMD md) => md -> String -> IO String
All of these functions work by extracting the relevant file names from
the argument meta-data structure using \cd{listify} and then calling
out to a shell tool to do the work.  For \cd{ls}, the second argument
gives the command-line arguments to pass to the shell version of
\cd{ls}, and the result is the resulting output. The implementation
uses \cd{xarg} to lift the restriction on the number of files that can
be passed to \cd{ls}. For \cd{grep}, the second argument is the 
search string and result is the output of the shell version of \cd{grep}. For
\cd{tar}, the second argument specifies the location for the resulting
tarball.  The implementation uses a file manifest to allow \cd{tar} to
work regardless of the number of files involved.  The \cd{cp} tool
uses the \cd{tar} tool to move the files mentioned in the meta-data to
the location specified by the second argument \textit{while retaining
the same directory structure}.   
%The module that implements these tools is~80 lines of Haskell code.

\subsection{Description Inference Tool}
This tool allows the user to generate a \forest{} description from the
contents of the file system.   The function
\begin{code}
getDesc :: FilePath -> IO String
\end{code}
takes as an argument the path to the root of the directory structure
to infer.  It returns a string containing the generated
representation.  For example, below we show a fragment of the
results when
\cd{getDesc} is invoked on the \texttt{classof11} directory:
\begin{code}
\kw{data} classof11 = \kw{Directory} \{
    aB11 \kw{is} "AB11" :: aB11,
    bSE11 \kw{is} "BSE11" :: bSE11,
    tRANSFER \kw{is} "TRANSFER" :: tRANSFER,
    wITHDREW \kw{is} "WITHDREW" :: wITHDREW
\}
\kw{data} tRANSFER = \kw{Directory} \{
    bEAUCHEMINtxt \kw{is} "BEAUCHEMIN.txt" :: File Ptext,
    vERSTEEGtxt \kw{is} "VERSTEEG.txt" :: File Ptext
\}
...
\end{code}
The description is not perfect: the label names are generated 
from the file name, for example.  Nevertheless, the tool improves
programmer productivity as it is
easier for a programmer to edit a generated description than to
start from scratch.   Our first tool in this vein is simple;
a more sophisticated variant would collapse records of files
into comprehensions when a width limit was exceeded or
other criteria were met.  Another variant might
collapse deeply nested directories into a universal directory
description when a depth limit was exceeded.
%When the number of files in a directory
%exceeds the width parameter, files with the same type are collected into
%comprehensions.  When the depth of the description exceeds the depth
%parameter, directories are given the universal directory type.

The \cd{getDesc} function works by using the universal description to
load the contents of the file system starting from the supplied path.
It then walks over the resulting meta-data to generate a \forest{}
parse tree, which it then pretty prints.


% \begin{figure}
% \begin{code}
% \kw{data} transfer = \kw{Directory} \{
% \}

% \kw{data} wITHDREW = \kw{Directory} \{
%     fingertxt \kw{is} "finger.txt" :: File Ptext
% \}

% \kw{data} tRANSFER = \kw{Directory} \{
%     bEAUCHEMINtxt \kw{is} "BEAUCHEMIN.txt" :: File Ptext,
%     vERSTEEGtxt \kw{is} "VERSTEEG.txt" :: File Ptext
% \}

% \kw{data} bSE11 = \kw{Directory} \{
%     transfer \kw{is} "transfer" :: transfer,
%     bOZAKtxt \kw{is} "BOZAK.txt" :: File Ptext,
%     kESSELtxt \kw{is} "KESSEL.txt" :: File Ptext,
%     ssstxt \kw{is} "sss.txt" :: File Ptext
% \}

% \kw{data} aB11 = \kw{Directory} \{
%     kADRItxt \kw{is} "KADRI.txt" :: File Ptext,
%     mACARTHERtxt \kw{is} "MACARTHER.txt" :: File Ptext,
%     oRRtxt \kw{is} "ORR.txt" :: File Ptext,
%     sSSStxt \kw{is} "SSSS.txt" :: File Ptext
% \}

% \kw{data} classof11 = Directory \{
%     aB11 \kw{is} "AB11" :: aB11,
%     bSE11 \kw{is} "BSE11" :: bSE11,
%     tRANSFER \kw{is} "TRANSFER" :: tRANSFER,
%     wITHDREW \kw{is} "WITHDREW" :: wITHDREW
% \}
% \end{code}
% \caption{Generated description. Type \texttt{File Ptext} is synonymous
%   with \texttt{Text}.}
% \label{fig:generated-description}
% \end{figure}

