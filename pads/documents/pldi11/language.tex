\section{\forest{} Design}
\label{sec:language}

\forest{} is a domain-specific language embedded within Haskell using the
Template Haskell extension mechanism~\cite{metahaskell}.  In a typical
\forest{} description, \forest{} declarations will be interleaved with ordinary
Haskell declarations.  To introduce new \forest{} declarations in amongst
Haskell declarations,
the programmer simply opens the \forest{} sublanguage scope:
\begin{code}
[forest| 
  ... forest declarations ...
|]
\end{code}

Once within the forest sublanguage, the programmer will write declarations
that look and feel very much like extended Haskell type declarations.
Each such type declaration serves three purposes: (1) it specifies how the user
expects some fragment of the file system to appear, (2) it describes
the structure of the in-memory {\em representation} of that 
file system fragment when it is read into a Haskell program, and (3) it describes 
the structure of the {\em metadata} that is associated with reading the file system
fragment into the Haskell program.  As we explain the different features of \forest{}, 
readers should keep these three different aspects of \forest{} descriptions in mind.  
The effectiveness of our design comes in part due to the fact that these three 
elements may all be specified using a single compact description.  

Readers should also be aware
that the validity of every description is defined relative to a 
{\em current path} or {\em current position} within the file system.  As 
the system interprets a description against the file system, the current path
will change from one directory or file path to the next.  In general, descriptions
do not assume that the current path is a valid path in the file system.  When the current
path is invalid, a description will generally\footnote{The \cd{Maybe} constructor,
discussed later, is an example of an exception to the general rule.} 
register an attempt to load from that
path as an error in the associated metadata structure.

\subsection{Simple Files}
\label{sec:basics}

The basic building blocks of any file system are the files themselves.  To get started,
\forest{} provides several different ways to describe a file at the current position.  The simplest
way is to choose from a collection of standard, built-in file descriptions:\footnote{Recall that
any text following \cd{--} is a comment in Haskell.} 
\noindent
\begin{code}
[forest| 
  type MyText = File Ptext   -- a text file
  type MyBin = File Pbin     -- a binary file
  type Whatever = File Pany  -- any file at all
|]
\end{code}
Each such declaration creates an identifier ({\it e.g.,} \cd{MyText}) that can be used in other
more complex descriptions later.  It also generates several utility functions that may
be used in the surrounding Haskell code, including functions 
for loading files that match the given description.  

Descriptions such as \cd{MyText} are useful when the user neither knows or cares much about
the internal structure of the given file.  On the other hand, when the user does know and does
care about the internal structure of a file, he or she will want to describe that structure,
and will be able to do so using \padshaskell{}.  \padshaskell{} is another sublanguage,
based on the PADS family of parser 
generators~\cite{fisher+:pads,fisher+:popl06,mandelbaum+:pads-ml}, but 
designed for use with Haskell and \forest{}.  \padshaskell{} declarations are introduced
within the pads scope:
\noindent
\begin{code}
[pads| 
  ... pads declarations ...
|]
\end{code}
These declarations are capable of generating parsers that may be referred
to later within \forest{}.  For example, it is straightforward to use \padshaskell{} to generate
a parser for student files such as the one shown in Figure~\ref{fig:student-file-example}
(see the appendix for its definition).
Assuming that the parser for the file is named \cd{Student} and that it takes a single string parameter
(\cd{n}, the student name), we can use it within \forest{} as follows.
\begin{code}
[forest| 
  type SFile (n::String) = File (Student n) 
|]
\end{code}
Using \padshaskell{} parsers in \forest{} not only helps specify the intended grammatical structure
of a file, but it also generates a structured in-memory representation for Haskell programmers
to traverse, query or otherwise manipulate.  Indeed, \padshaskell{} and \forest{}
were designed to work seemlessly together.  From the perspective of the Haskell
programmer traversing an in-memory data structure, there is effectively
no difference between iterating over files in a directory or
structured sequences of lines or tokens within a file.

While the design of \padshaskell{} is interesting in its own right, the rest of this
paper focuses on \forest{}.  Henceforth, the reader should assume
any unadorned declarations 
occur within the \forest{} scope \cd{[forest| ... |]} unless otherwise noted.
The reader should also assume any declarations prefixed by \cd{>} are ordinary
Haskell declarations.

\subsection{File Modifiers}
\label{sec:file-modifiers}

Some files need processing by a utility before they can be used.  A typical
example is a compressed file such as the gzipped log files in the Coral
example shown in Figure~\ref{fig:coral-pic}.  \forest{} allows users to describe such 
files using various modifiers.  For example, if \cd{CoralInfo} is a \padshaskell{}
description of a Coral log file then the following describes a gzipped log file.
\begin{code}
type CoralLog = Gzip (File CoralInfo)
\end{code}
Likewise, suppose \cd{logs.tar.gz} is a gzipped tar file and suppose also that 
\cd{AllLogs} describes the directory of log files that \cd{logs.tar} expands
to.  In this case, the following description will describe the contents of
\cd{logs.tar.gz} properly.
\begin{code}
type CoralLogs = Gzip (Tar AllLogs)
\end{code}

\subsection{Symbolic Links}
\label{sec:symlinks}

When symbolic links are present in the file system described,
the default behavior is to read through the symbolic links to their
targets.  Hence, the behavior of \forest{} will be intuitive to programmers who
are used to working in a standard UNIX-like environment.  In addition, however, it is possible
for a programmer to explicitly specify that she expects a symbolic link in a particular
position.  To do so, the programmer will use the \cd{SymLink} base type.  For
example:
\begin{code}
type MyFile = SymLink
\end{code}
In \forest{}, any file system object may be described in multiple different ways.
Hence, in the case of symbolic links, it is possible to use one declaration to
specify the fact that an object is a symbolic link, and a second declaration to specify
the nature of the target that link ({\em e.g.,} the target is a text file).  We will see such 
a specification in later subsections.

\subsection{Simple Directories}
\label{sec:simple-directories}

The simplest way to specify the contents of a directory is to use
a record-like declaration.  For example, to specify the root directory
of the student repository in Figure~\ref{fig:student-pic}, we might use
the following declaration.  This declaration assumes that we have already
defined \cd{Class n}, a parameterized description that specifies
the structure of a directory holding data on the class of year \cd{n},
and \cd{Grads}, a description that specifies the structure of the directory holding
all graduated classes.   
\begin{code}
type All = Directory
  \{ seniors is "classof11" :: Class 11
  , juniors is "classof12" :: Class 12
  , grads is "graduates" :: Grads
  , notes is "README" :: File Ptext
  \}
\end{code}
Above, each field of the record has three components:  (1) a label
name ({\it e.g.,} seniors or juniors), (2) a file or directory name
({\it e.g.,} "classof11" or "classof12"), and (3) a \forest{} subdescription
for the contents of the named object ({\it e.g.,} \cd{Class 11} or \cd{Grads}
or \cd{File Ptext}).

With simple descriptions like this one, it is common for users to want
the label to be the same as the name of the file.  In such a case, users
may write the following abbreviated description:
\begin{code}
type All = Directory
  \{ classof11 :: Class 11
  , classof12 :: Class 12
  , graduates :: Grads
  , notes is "README" :: File Ptext
  \}
\end{code}
Above, the name of the label is used as the expected file name.  We did not
shorten \cd{notes is "README"} to \cd{README} because labels must start
with a lowercase letter in Haskell.

\paragraph*{Matching.}
In order for a file system object to match a description like the one above, it must be a
directory and each field of the record must match.  A field matches when the given
file name ({\em e.g.,} \cd{"README"}) is concatenated to the current path and the 
object at that new path matches the field's subdescription.

It is possible for the same file system object to to match multiple different fields of a description at
the same time.  For example, if "README" were a symbolic link that pointed to a text file, one 
might want to specify that using a pair of declarations:
\begin{code}
type All = Directory
  \{ ...
  , link is "README" :: SymLink
  , notes is "README" :: File Ptext
  \}
\end{code}

It is also possible for a directory to contain a number of objects that go unmatched by
a description.  We made the design choice to allow extra items in
a directory because we found it common for directories to contain files that users
simply do not care much about.  For example,
if programmers do not need to extract information out of the README file and
users do not really care whether it exists or not, one might well choose
to omit it from the description.  One might be concerned that this design choice makes it difficult to specify
the absence of files (as opposed to their presence), which can be important
for security purposes in some cases.  However, we will see shortly that in the
uncommon case that programmers want to specify absence information, they can
do so using constraints.

When a directory does match a record declaration like this one, 
\forest{} provides utilities to read the directory in
to memory and generate a convenient programmatic representation for it.  
In this case, the type of the in-memory representation is a record type
with labels \cd{seniors}, \cd{juniors}, {\em etc.} and with field types
generated from the associated \forest{} subdescriptions \cd{Class}, \cd{Grads},
{\em etc.}  When the same object is described in two different ways, one may
get two different in-memory representations of it.  For instance, in the example above,
the \cd{link} field will hold a representation of the filepath that describes the target of the
symbol link whereas the \cd{notes} field will hold a representation of the \cd{README}
file itself ({\em i.e.,} a string of characters).

When a directory does not match a record declaration, \forest{} will
construct representations for the subparts that do match and will insert dummy values
into the parts that do not match.  \forest{} will also record all errors encountered in the
matching process in the object metadata.

\subsection{Computed and Approximate Paths}
\label{sec:computed-pathes}

Both of the above descriptions are a good start for our application, but neither
are ideal.  Every year, the directory for the graduating seniors 
({\em i.e.,} \cd{classof11}) gets moved into the graduates directory,
the juniors get promoted to seniors and a new junior class gets created.
As it stands, this means we would also have to edit our description every year.
An alternative is to parameterize our description with the current year and
to construct the appropriate file names.  If we follow this strategy,
we might arrive at the following specification for the top-level student directory:
\begin{code}
> mkclass y = "classof" ++ (toString y)
\mbox{}
type All (y::Integer) = Directory
  \{ seniors is <|mkclass y|> :: Class y
  , juniors is <|mkclass (y+1)|> :: Class <|y+1|>
  , graduates :: Grads
  , notes is "README" :: File Ptext
  \}
\end{code}
%\begin{code}
%type All (sy::String, jy::String) = Directory
%  \{ seniors is <|"classof" ++ sy|> :: Class
%  , juniors is <|"classof" ++ jy|> :: Class
%  , graduates :: Grads
%  , notes is "README" :: File Ptext
%  \}
%\end{code}
In general, \cd{<|...|>} can be used to escape back in to
Haskell to perform arbitrary computations.  Note also that any description
may be parameterized by specifying a legal Haskell identifier and its type.
Parameterized specifications may be used by supplying their arguments
in the usual way.  When arguments are simple constants or variables,
they may be supplied directly.  When arguments are more complex
computed expressions, it is necessary to use explicit escapes back 
in to Haskell.

As repositories evolve over time, naming conventions may change.
Alternatively, programmers simply may not care to specify certain names
exactly.  To accomodate these possibilities, \forest{} includes mechanisms
for approximate naming of files.  For example, in each class, there may
(or may not) be some number of students that have withdrawn from the
program, transferred to a different Princeton program on gone on
temporary leave.  Over the years, slightly different directory names
have been used to represent these situations.  Given this circumstance,
we can use the following declarations to describe the class directory.
\reminder{dpw: I edited out some of the withdrawn RE options to make it
fit on a line.}\reminder{jnf:how about making all of them two characters long (``tr'', ``wd'', ``lv'')?}
\begin{code}
> transRE = RE "TRANSFER|Transfer"
> leaveRE = RE "LEAVE|Leave"
> wdRE    = RE "WITHDRAWN|WITHDRAWAL|Withdrawn"
\mbox{}
type Class (y::Integer) = Directory
  \{ bse is <|"BSE" ++ (toString y)|> :: Major
  , ab  is <|"AB"  ++ (toString y)|> :: Major   
  , trans matches transRE :: Maybe Major      
  , wd matches wdRE :: Maybe Major
  , leave matches leaveRE :: Maybe Major 
  \}
\end{code}
A field with the form \cd{<label> matches <regexp> :: T}
finds the set of paths in the files system that match \cd{currentPath/} \cd{<regexp>}.
If there are zero or one matches, the \cd{matches} form acts like the \cd{is} 
form.\footnote{Recall that when 
there are zero matches, the \cd{is} form attempts to match the type \cd{T} 
against a non-existant file system object at a non-existant path.  This may or may not be
an error, depending on \cd{T}.  The matches form constructs a non-existant path
and behaves the same way.}  If there is more than one match, one of the many matches
is selected non-deterministically, a multiple match error is registered in the metadata,
and matching once again continues as in the \cd{is} form.

In this example, the \cd{matches} form is combined with the \cd{Maybe T} constructor.
\cd{Maybe T} succeeds and returns \cd{None} when the current path is not a path in the
file system.  \cd{Maybe T} also succeeds, returning \cd{Just v} for some \cd{v},
when applied to an object that matches \cd{T} at the current path.  \cd{Maybe T} 
registers an error in the metadata when the current path exists but 
the object at the current path does not properly match \cd{T}.

\subsection{Comprehensions}
\label{sec:comprehensions}

Record directories allow programmers to specify a fixed number of file system objects.
Comprehensions, on the other hand, allow programmers to specify arbitrary numbers
of file system objects.  As an example, we might specify the contents of the
\cd{Grads} directory from Figure~\ref{fig:student-file-example} as follows.
\reminder{dpw: changed Prelude.take into take below for space reasons.}
\reminder{dpw: perhaps the definition of getYear should use Haskell composition "." instead
of all the parens? Also, I changed the type of the Class parameter to an integer. Hence, I needed the toInteger conversion -- it wasn't obvious to me from the Haskell docs if in fact toInteger will
convert from a string to an integer. In the current Students2.hs (Oct. 23), all comprehensions
are nested within records.  I unnested here. I can imagine syntax is a possible issue with doing
that but not semantics.  The record wrapper does seem unnecessary overhead for the programmer.
(But really, it just helps me with the explanation here, because it makes comprehensions orthogonal.}
\begin{code}
> cYear s = 
>   toInteger (reverse (take 2 (reverse s)))
> cRE = RE "classof[0-9][0-9]"
\mbox{}
type Grads = 
  [c :: Class <|cYear c|> | c <- matches cRE]
\end{code}
In the specification above, \cd{Grads} is a directory that contains a number of
\cd{Class} subdirectories with names \cd{c} that match the regular expression
\cd{cRE}.  The Haskell function \cd{cYear} extracts the last two digits from the
name of the directory, converts the string digits to an integer year, and passes
the year to the underlying \cd{Class} specification.
More generally, comprehensions have the following form.
\begin{code}
[path :: T | id <- gen, pred]
\end{code}
Here, \cd{id} is bound to each of the strings generated by the \cd{gen},
which may be a \cd{matches} function (used to match against the files
at the current path) or may be some other list computed in Haskell. The allowed
\cd{id}s may be filtered by \cd{pred} and they may be used in the computation
\cd{path}.  Each such computed path is concatentated to the current path and
used to match a file system object with type \cd{T}.  The predicate and path
computation may also use the path metadata by referring to the variable
\cd{id_md}, which will be in scope.  The in-memory representation of a comprehension
is a list.

Another example of a comprehension occurs in specification the \cd{Major} 
directory.  These directories contain a list of student files, and one additional
template file named \cd{sss.txt} or \cd{sxx.txt}.  The declaration below
specifies all the student files except the template files.  Note that it uses
a glob pattern as opposed to a regular expression
to describe a set of text files.\footnote{A glob pattern
is a pattern used to describe file paths in UNIX-based systems.  Such patterns include
constant strings and wildcards \cd{*} and \cd{?}.} 
\begin{code}
> tpl s = (s == "sss.txt") || (s == "sxx.txt")
> txt = GL "*.txt"
\mbox{}
type Major =   
  [ s :: File (Student <|getName s|>) 
  | s <- matches txt, <|not (tpl s)|>]
\end{code}

\subsection{Attributes and Constraints}
\label{sec:constraints}

Every file system object has a number of attributes associated with it.  In general,
if a \forest{} identifier \cd{id} refers to a path, the attributes for the object at that
path are available through the identifier named \cd{id_att}. Figure~\ref{fig:metadata-components}
lists a set of functions that extract useful information from metadata structures.
Below, metadata functions used to write a universal description.
Notice that the description also happens to be recursive, another useful feature of
\forest{}.  In the case that a symbolic link creates a cycle in the file system, the Haskell
in-memory representation will be a (lazy) infinite data structure. 
\reminder{jnf: the preceding remark is only true if the symbolic link points to a directory, right?}
\begin{code}
type Universal = Directory 
  \{ asc is [ f :: File Ptext   
           | f <- matches (GL "*"), 
            <|get_kind f_att == AsciiK|>]
  , bin is [ b :: File Pbinary
           | b <- matches (GL "*") 
           where <|get_kind b_att == BinaryK|>]
  , dir is [ d :: Universal  
           | d <- matches (GL "*") 
           where <|get_kind d_att == DirectoryK|>]
  , sym is [s :: SymLink      
           | s <- matches (GL "*") 
           where <|get_sym s_att == True|>]
  \}
\end{code}

Attributes are also commonly used in {\em constraints}.  For example, if a user
wants to ensure that all her text files are private,
she might replace the use of \cd{File Ptext} in a description with the following
\cd{PrivateFile} definition.  
\reminder{dpw: The following two examples need to be tested to ensure correctness.}
\begin{code}
type PrivateFile = 
  File Ptext 
    where <|get_modes this_att == "-rw-------"|>
\end{code}
Here, the keyword \cd{where} introduces a constraint
on the underlying type.  If a constraint evaluates to false, an error
is registered in the metadata.  Within the constraint, \cd{this} refers to the representation 
of the underlying object, \cd{this_att} refers to its attributes and \cd{this_md} refers
to its metadata.

Another use for constraints involves specifying emptiness conditions or conditions that
certain files do not appear in certain places.  As an example, one might want to specify
that no binaries appear in a directory given to an untrusted user as scratch space.
The description below registers an error whenever a binary file appears in the described
directory. 
\begin{code}
type NoBin =
  [ b :: File Pbinary 
  | b <- matches (GL "*"), 
  <|get_kind b_att == BinaryK|> ]
  where <|List.length this == 0|>
\end{code}

\begin{figure}
\begin{center}
\begin{tabular}{l|l}
function name &  information \\
\hline
\cd{get_group} & object group\\
\cd{get_kind} & the sort of file or directory \\
\cd{get_modes} & permission string\\
\cd{get_owner} & object owner\\
\cd{get_size} & object size \\
\end{tabular}
\end{center}
\caption{Selected file attribute functions}
\label{fig:metadata-components}
\end{figure}

\subsection{Representation Coercions}
\label{sec:transforms}

One of the benefits of using \forest{} is that every description serves multiple purposes:
(1) it specifies the structure of the file system on disk, (2) it specifies structure of in-memory
representations of the file system, (3) it generates type declarations describing those in-memory
structures, and (4) it generates data structures representing error conditions and other meta data.
\reminder{jnf: above, we identified three things generated from descriptions...}

Sometimes, however, it is useful to be able to override the default structure of the generated items.
In particular, we have found that programmers occasionally want the representation of their in-memory data
structured differently than the default.  In order to give programmers choice on this matter when they want it,
\forest{} permits them to use {\em representation coercions} within a description.  As an example, consider
again the definition of \cd{Major} from subsection~\ref{sec:comprehensions}.  In that definition, the
in-memory representation of the set of majors is a list of \cd{(name.txt,filecontents)} pairs.  A more convenient
representation for programming, however, is likely a map from \cd{names} to \cd{filecontents}.  Assuming
\cd{MapName} is the coercion from lists to maps suggested, 
we insert it into the description as follows.\reminder{dpw: can we put the definition of mapname in?  I don't know
how to write it.  I can't find Kathleen's email with some mention that any Builder something something toList
function something something is how you write these functions.}
\begin{code}
type Major = 
  MapName [ s :: File (Student <|getName s|>) 
          | s <- matches txt, <|not (tpl s)|>]
\end{code}
While programmers may build their own custom coercions as above, \forest{} does supply a set of 
generic, built-in coercions as well such as \cd{Map} (convert to a map from file name to contents)
and \cd{Set} (convert to a set of contents).

\subsection{Putting it all together}

The previous subsections explain most of the interesting features of \forest{}.
These features are put to work in Figures~\ref{fig:student-description}
and~\ref{fig:coral-description}.  A set of other descriptions are available on 
the \forest{} web site~\cite{forest-web-site}.

\begin{figure}
\input{student-description}
\caption{\forest{} student description -- out of date (nov 1)}
\label{fig:student-description}
\end{figure}

\begin{figure}
\input{coral-description}
\caption{\forest{} coral description -- out of date (nov 1)}
\label{fig:coral-description}
\end{figure}
