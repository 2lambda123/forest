\section{\forest{} Design}
\label{sec:language}

\forest{} is a domain-specific language embedded within Haskell using
the Quasiquote mechanism~\cite{Mainland:quasi}.  In a typical
\forest{} description, \forest{} declarations are interleaved with ordinary
Haskell declarations.  To introduce new \forest{} declarations,
the programmer simply opens the \forest{} sublanguage scope:
\begin{code}
[forest| 
  ... forest declarations ...
|]
\end{code}

\forest{} uses a type-based metaphor to describe directory
structures, so once  within the \forest{} sublanguage, the programmer
writes declarations that look and feel very much like extended Haskell
type declarations. 
Each such type declaration serves three purposes: 
(1) it describes a fragment of the file system,
(2) it specifies the structure of the in-memory {\em representation}
    that will be constructed when the fragment is (lazily) loaded into a Haskell program, and 
(3) it specifies the structure of the in-memory {\em metadata}
    that will be generated when the fragment loaded.
Such metadata includes error information (missing file, insufficient
permissions, \etc{})  as well as file system attributes (owner, size, \etc{}).
As we explain the design of \forest{}, 
readers should keep these three different aspects in mind.  
The effectiveness of the \forest{} language comes in part from the fact that these three 
elements can all be specified in a single compact description.  

Every \forest{} description is defined relative to a
{\em current path} within the file system.  As 
\forest{} matches a description against the file system, it 
adjusts the current path to reflect its navigation.
\cut{
In general, descriptions
do not assume that the current path is a valid path in the file
system.  
When the current
path is invalid, a description will generally\footnote{The \cd{Maybe} constructor,
discussed later, is an example of an exception to the general rule.} 
register an attempt to load from that
path as an error in the associated metadata structure.}

At its core, \forest{} is a simple dependent type system in which base
types denote files of various flavors and record types describe
directories.  \forest{} also includes a list type to describe
collections of files with finer granularity than directories.  We use
other type constructors to build more refined structures from these
basic building blocks.  We discuss each of these constructs in turn in
the remainder of this section.

\subsection{Files}
\label{sec:basics}
\forest{} provides a small collection of base types for describing
files: \cd{Text} for ASCII files, \cd{Binary} for binary files, and
\cd{Any} for arbitrary files.  As with all \forest{} types, each of
these types specifies a representation type, a metadata type, and a
loading function.  The in-memory representation for an ASCII file is a
Haskell \cd{String}; for binary and arbitrary files, it is a
\cd{ByteString}.  For all three file types, the metadata type pairs
file-system metadata with metadata describing properties of the file
contents.  The file-system metadata has type \cd{Forest\_md}, shown in
\figref{fig:forest-md}.  This structure stores two kinds of
information: (1) the number and kind of any errors that occurred while
loading the file and (2) the attributes associated with the file.
File-content metadata typically describes errors within the file, but
can be used for other purposes.  For these three file types, there is
no meaningful content metadata and so this type is the unit type.
Leveraging Haskell's laziness, the loading functions create the
in-memory representations and set the metadata on demand.

\begin{figure}
\begin{code}
\kw{data} Forest_md = Forest_md 
   \{ numErrors :: Int
   , errorMsg  :: Maybe ErrMsg
   , fileInfo  :: FileInfo      
   \}
\mbox{}
\kw{data} FileInfo = FileInfo 
   \{ fullpath   :: FilePath
   , owner       :: String
   , group       :: String
   , size        :: COff
   , access_time :: EpochTime
   , mod_time    :: EpochTime
   , read_time   :: EpochTime
   , mode        :: FileMode
   , isSymLink   :: Bool
   , kind        :: FileType     
   \}
\end{code}
\caption{\forest{} metadata types.}
\label{fig:forest-md}
\end{figure}

Of course, there are many kinds of files, and the appropriate
representation and content metadata type for each such file varies.
Possible examples include XML documents, Makefiles, source files in
various languages, shell scripts, \etc{}  To support such files,
\forest{} provides a plug-in architecture, allowing third party users
to define new file base types by specifying a representation type, a
metadata type, and a corresponding loading function.

A common class of files are \textit{ad hoc data files} containing
semi-structured information, an example of which is the Princeton
student record file format (\figref{fig:student-file-example}). 
In such cases, \forest{} can leverage the \padshaskell{} data
description language to define format-specific in-memory
representations, content metadata, and loading functions. 
\padshaskell{} is a recently developed version of 
\pads{}~\cite{fisher+:pads,fisher+:popl06,mandelbaum+:pads-ml}.
Like \forest{}, \padshaskell{} is embedded in Haskell using
quasiquotation.  For example, the following code snippit 
begins the \pads{} specification of the Princeton student record
format: 
\noindent
\begin{code}
[pads| 
  \kw{data} Student (name :: String) = < pads decl >
|]
\end{code}
This description is parameterized by the name of the student whose
data is in the file; the complete description appears in the appendix.
From this specification, the \pads{} compiler
generates an in-memory representation type \cd{Student}, a content metadata
type \cd{Student_md}, and a parsing function.  

\forest{} provides the \cd{File} type constructor to lift \pads{}
types to \forest{} file types.  For example, the declaration
\begin{code}
[forest| 
  \kw{type} SFile (n::String) = File (Student n) 
|]
\end{code}
introduces a new file type named \cd{SFile} whose format is given by
the \pads{} type \cd{Student}.  As with the \pads{} type, \cd{SFile}
is parameterized by the name of the student.  

Using \padshaskell{} descriptions in \forest{} not only helps specify
the structure of ad hoc data files, but it also generates a structured
in-memory representation of the data, allowing Haskell programmers to
traverse, query and otherwise manipulate such data.  Indeed,
\padshaskell{} and \forest{} were designed to work seamlessly
together.  From the perspective of the Haskell programmer traversing
an in-memory data structure, there is effectively no difference
between iterating over files in a directory or structured sequences of
lines or tokens within a file.

While \padshaskell{} is independently interesting,
the rest of this paper focuses on \forest{}.  Henceforth, any
unadorned declarations occur within the \forest{} scope
\cd{[forest|...|]} unless otherwise noted.  Any declarations prefixed
by \cd{>} 
are ordinary Haskell declarations.

\subsection{The Maybe Type}
\label{sec:maybe}
Sometimes, a given file (or directory or symbolic link) may or may not
be present in the file system, and either situation is valid.
\forest{} provides the \cd{Maybe} type constructor for this
situation.  If \cd{T} is a \forest{} type, then \cd{Maybe T} is the
\forest{} type denoting an optional \cd{T}.  In particular, 
\cd{Maybe T} succeeds and returns representation \cd{None} when the
current path does not exist in the file system.  \cd{Maybe T} also
succeeds, returning \cd{Just v} for some \cd{v} of type \cd{T}, 
when applied to an file system object that matches \cd{T} at the
current path.  \cd{Maybe T} registers an error in the metadata when
the current path exists but the object at the current path does not
match \cd{T}. 


\subsection{Directories}
\label{sec:simple-directories}

The simplest way to specify the contents of a directory is to use
a record-like declaration.  For example, to specify the root directory
of the student repository in Figure~\ref{fig:student-pic}, we might use
the following declaration.  This declaration assumes that we have already
defined \cd{Class n}, a parameterized description that specifies
the structure of a directory holding data on the class of year \cd{n},
and \cd{Grads}, a description that specifies the structure of the directory holding
all graduated classes.   
\begin{code}
type PrincetonCS = Directory
  \{ seniors is "classof11" :: Class 11
  , juniors is "classof12" :: Class 12
  , grads is "graduates" :: Grads
  , notes is "README" :: File Ptext
  \}
\end{code}
Above, each field of the record has three components:  (1) a label
name ({\it e.g.,} seniors or juniors), (2) a file or directory name
({\it e.g.,} "classof11" or "classof12"), and (3) a \forest{} subdescription
for the contents of the named object ({\it e.g.,} \cd{Class 11} or \cd{Grads}
or \cd{File Ptext}).

With simple descriptions like this one, it is common for users to want
the label to be the same as the name of the file.  In such a case, users
may write the following abbreviated description:
\begin{code}
type All = Directory
  \{ classof11 :: Class 11
  , classof12 :: Class 12
  , graduates :: Grads
  , notes is "README" :: File Ptext
  \}
\end{code}
Above, the name of the label is used as the expected file name.  We did not
shorten \cd{notes is "README"} to \cd{README} because labels must start
with a lowercase letter in Haskell.

\paragraph*{Matching.}
In order for a file system object to match a description like the one above, it must be a
directory and each field of the record must match.  A field matches when the given
file name ({\em e.g.,} \cd{"README"}) is concatenated to the current path and the 
object at that new path matches the field's subdescription.

It is possible for the same file system object to to match multiple different fields of a description at
the same time.  For example, if "README" were a symbolic link that pointed to a text file, one 
might want to specify that using a pair of declarations:
\begin{code}
type All = Directory
  \{ ...
  , link is "README" :: SymLink
  , notes is "README" :: File Ptext
  \}
\end{code}

It is also possible for a directory to contain a number of objects that go unmatched by
a description.  We made the design choice to allow extra items in
a directory because we found it common for directories to contain files that users
simply do not care much about.  For example,
if programmers do not need to extract information out of the README file and
users do not really care whether it exists or not, one might well choose
to omit it from the description.  One might be concerned that this design choice makes it difficult to specify
the absence of files (as opposed to their presence), which can be important
for security purposes in some cases.  However, we will see shortly that in the
uncommon case that programmers want to specify absence information, they can
do so using constraints.

When a directory does match a record declaration like this one, 
\forest{} provides utilities to read the directory in
to memory and generate a convenient programmatic representation for it.  
In this case, the type of the in-memory representation is a record type
with labels \cd{seniors}, \cd{juniors}, {\em etc.} and with field types
generated from the associated \forest{} subdescriptions \cd{Class}, \cd{Grads},
{\em etc.}  When the same object is described in two different ways, one may
get two different in-memory representations of it.  For instance, in the example above,
the \cd{link} field will hold a representation of the filepath that describes the target of the
symbol link whereas the \cd{notes} field will hold a representation of the \cd{README}
file itself ({\em i.e.,} a string of characters).

When a directory does not match a record declaration, \forest{} will
construct representations for the subparts that do match and will insert dummy values
into the parts that do not match.  \forest{} will also record all errors encountered in the
matching process in the object metadata.

\paragraph*{Computed Paths}
\label{sec:computed-paths}

Both of the above descriptions are a good start for our application, but neither
are ideal.  Every year, the directory for the graduating seniors 
({\em i.e.,} \cd{classof11}) gets moved into the graduates directory,
the juniors get promoted to seniors and a new junior class gets created.
As it stands, this means we would also have to edit our description every year.
An alternative is to parameterize our description with the current year and
to construct the appropriate file names.  If we follow this strategy,
we might arrive at the following specification for the top-level student directory:
\begin{code}
> mkclass y = "classof" ++ (toString y)
\mbox{}
type All (y::Integer) = Directory
  \{ seniors is <|mkclass y|> :: Class y
  , juniors is <|mkclass (y+1)|> :: Class <|y+1|>
  , graduates :: Grads
  , notes is "README" :: File Ptext
  \}
\end{code}
%\begin{code}
%type All (sy::String, jy::String) = Directory
%  \{ seniors is <|"classof" ++ sy|> :: Class
%  , juniors is <|"classof" ++ jy|> :: Class
%  , graduates :: Grads
%  , notes is "README" :: File Ptext
%  \}
%\end{code}
In general, \cd{<|...|>} can be used to escape back in to
Haskell to perform arbitrary computations.  Note also that any description
may be parameterized by specifying a legal Haskell identifier and its type.
Parameterized specifications may be used by supplying their arguments
in the usual way.  When arguments are simple constants or variables,
they may be supplied directly.  When arguments are more complex
computed expressions, it is necessary to use explicit escapes back 
in to Haskell.

\paragraph*{Approximate Paths}
As repositories evolve over time, naming conventions may change.
Alternatively, programmers simply may not care to specify certain names
exactly.  To accomodate these possibilities, \forest{} includes mechanisms
for approximate naming of files.  For example, in each class, there may
(or may not) be some number of students that have withdrawn from the
program, transferred to a different Princeton program on gone on
temporary leave.  Over the years, slightly different directory names
have been used to represent these situations.  Given this circumstance,
we can use the following declarations to describe the class directory.
\reminder{dpw: I edited out some of the withdrawn RE options to make it
fit on a line.}\reminder{jnf:how about making all of them two characters long (``tr'', ``wd'', ``lv'')?}
\begin{code}
> transRE = RE "TRANSFER|Transfer"
> leaveRE = RE "LEAVE|Leave"
> wdRE    = RE "WITHDRAWN|WITHDRAWAL|Withdrawn"
\mbox{}
type Class (y::Integer) = Directory
  \{ bse is <|"BSE" ++ (toString y)|> :: Major
  , ab  is <|"AB"  ++ (toString y)|> :: Major   
  , trans matches transRE :: Maybe Major      
  , wd matches wdRE :: Maybe Major
  , leave matches leaveRE :: Maybe Major 
  \}
\end{code}
A field with the form \cd{<label> matches <regexp> :: T}
finds the set of paths in the files system that match \cd{currentPath/} \cd{<regexp>}.
If there are zero or one matches, the \cd{matches} form acts like the \cd{is} 
form.\footnote{Recall that when 
there are zero matches, the \cd{is} form attempts to match the type \cd{T} 
against a non-existant file system object at a non-existant path.  This may or may not be
an error, depending on \cd{T}.  The matches form constructs a non-existant path
and behaves the same way.}  If there is more than one match, one of the many matches
is selected non-deterministically, a multiple match error is registered in the metadata,
and matching once again continues as in the \cd{is} form.


\subsection{Comprehensions}
\label{sec:comprehensions}

Record directories allow programmers to specify a fixed number of file system objects.
Comprehensions, on the other hand, allow programmers to specify arbitrary numbers
of file system objects.  As an example, we might specify the contents of the
\cd{Grads} directory from Figure~\ref{fig:student-file-example} as follows.
\reminder{dpw: changed Prelude.take into take below for space reasons.}
\reminder{dpw: perhaps the definition of getYear should use Haskell composition "." instead
of all the parens? Also, I changed the type of the Class parameter to an integer. Hence, I needed the toInteger conversion -- it wasn't obvious to me from the Haskell docs if in fact toInteger will
convert from a string to an integer. In the current Students2.hs (Oct. 23), all comprehensions
are nested within records.  I unnested here. I can imagine syntax is a possible issue with doing
that but not semantics.  The record wrapper does seem unnecessary overhead for the programmer.
(But really, it just helps me with the explanation here, because it makes comprehensions orthogonal.}
\begin{code}
> cYear s = 
>   toInteger (reverse (take 2 (reverse s)))
> cRE = RE "classof[0-9][0-9]"
\mbox{}
type Grads = 
  [c :: Class <|cYear c|> | c <- matches cRE]
\end{code}
In the specification above, \cd{Grads} is a directory that contains a number of
\cd{Class} subdirectories with names \cd{c} that match the regular expression
\cd{cRE}.  The Haskell function \cd{cYear} extracts the last two digits from the
name of the directory, converts the string digits to an integer year, and passes
the year to the underlying \cd{Class} specification.
More generally, comprehensions have the following form.
\begin{code}
[path :: T | id <- gen, pred]
\end{code}
Here, \cd{id} is bound to each of the strings generated by the \cd{gen},
which may be a \cd{matches} function (used to match against the files
at the current path) or may be some other list computed in Haskell. The allowed
\cd{id}s may be filtered by \cd{pred} and they may be used in the computation
\cd{path}.  Each such computed path is concatentated to the current path and
used to match a file system object with type \cd{T}.  The predicate and path
computation may also use the path metadata by referring to the variable
\cd{id_md}, which will be in scope.  The in-memory representation of a comprehension
is a list.

Another example of a comprehension occurs in specification the \cd{Major} 
directory.  These directories contain a list of student files, and one additional
template file named \cd{sss.txt} or \cd{sxx.txt}.  The declaration below
specifies all the student files except the template files.  Note that it uses
a glob pattern as opposed to a regular expression
to describe a set of text files.\footnote{A glob pattern
is a pattern used to describe file paths in UNIX-based systems.  Such patterns include
constant strings and wildcards \cd{*} and \cd{?}.} 
\begin{code}
> tpl s = (s == "sss.txt") || (s == "sxx.txt")
> txt = GL "*.txt"
\mbox{}
type Major =   
  [ s :: File (Student <|getName s|>) 
  | s <- matches txt, <|not (tpl s)|>]
\end{code}

\paragraph*{Representation Coercions}
One of the benefits of using \forest{} is that every description serves multiple purposes:
(1) it specifies the structure of the file system on disk, (2) it specifies structure of in-memory
representations of the file system, (3) it generates type declarations describing those in-memory
structures, and (4) it generates data structures representing error conditions and other meta data.
\reminder{jnf: above, we identified three things generated from descriptions...}

Sometimes, however, it is useful to be able to override the default structure of the generated items.
In particular, we have found that programmers occasionally want the representation of their in-memory data
structured differently than the default.  In order to give programmers choice on this matter when they want it,
\forest{} permits them to use {\em representation coercions} within a description.  As an example, consider
again the definition of \cd{Major} from subsection~\ref{sec:comprehensions}.  In that definition, the
in-memory representation of the set of majors is a list of \cd{(name.txt,filecontents)} pairs.  A more convenient
representation for programming, however, is likely a map from \cd{names} to \cd{filecontents}.  Assuming
\cd{MapName} is the coercion from lists to maps suggested, 
we insert it into the description as follows.\reminder{dpw: can we put the definition of mapname in?  I don't know
how to write it.  I can't find Kathleen's email with some mention that any Builder something something toList
function something something is how you write these functions.}
\begin{code}
type Major = 
  MapName [ s :: File (Student <|getName s|>) 
          | s <- matches txt, <|not (tpl s)|>]
\end{code}
While programmers may build their own custom coercions as above, \forest{} does supply a set of 
generic, built-in coercions as well such as \cd{Map} (convert to a map from file name to contents)
and \cd{Set} (convert to a set of contents).


\subsection{Attributes and Constraints}
\label{sec:constraints}

Every file system object has a number of attributes associated with it.  In general,
if a \forest{} identifier \cd{id} refers to a path, the attributes for the object at that
path are available through the identifier named \cd{id_att}. Figure~\ref{fig:metadata-components}
lists a set of functions that extract useful information from metadata structures.

Attributes are also commonly used in {\em constraints}.  For example, if a user
wants to ensure that all her text files are private,
she might replace the use of \cd{File Ptext} in a description with the following
\cd{PrivateFile} definition.  
\reminder{dpw: The following two examples need to be tested to ensure correctness.}
\begin{code}
type PrivateFile = 
  File Ptext 
    where <|get_modes this_att == "-rw-------"|>
\end{code}
Here, the keyword \cd{where} introduces a constraint
on the underlying type.  If a constraint evaluates to false, an error
is registered in the metadata.  Within the constraint, \cd{this} refers to the representation 
of the underlying object, \cd{this_att} refers to its attributes and \cd{this_md} refers
to its metadata.


Below, metadata functions used to write a universal description.
Notice that the description also happens to be recursive, another useful feature of
\forest{}.  In the case that a symbolic link creates a cycle in the file system, the Haskell
in-memory representation will be a (lazy) infinite data structure. 
\reminder{jnf: the preceding remark is only true if the symbolic link points to a directory, right?}
\begin{code}
type Universal = Directory 
  \{ asc is [ f :: File Ptext   
           | f <- matches (GL "*"), 
            <|get_kind f_att == AsciiK|>]
  , bin is [ b :: File Pbinary
           | b <- matches (GL "*") 
           where <|get_kind b_att == BinaryK|>]
  , dir is [ d :: Universal  
           | d <- matches (GL "*") 
           where <|get_kind d_att == DirectoryK|>]
  , sym is [s :: SymLink      
           | s <- matches (GL "*") 
           where <|get_sym s_att == True|>]
  \}
\end{code}


Another use for constraints involves specifying emptiness conditions or conditions that
certain files do not appear in certain places.  As an example, one might want to specify
that no binaries appear in a directory given to an untrusted user as scratch space.
The description below registers an error whenever a binary file appears in the described
directory. 
\begin{code}
type NoBin =
  [ b :: File Pbinary 
  | b <- matches (GL "*"), 
  <|get_kind b_att == BinaryK|> ]
  where <|List.length this == 0|>
\end{code}

\begin{figure}
\begin{center}
\begin{tabular}{l|l}
function name &  information \\
\hline
\cd{get_group} & object group\\
\cd{get_kind} & the sort of file or directory \\
\cd{get_modes} & permission string\\
\cd{get_owner} & object owner\\
\cd{get_size} & object size \\
\end{tabular}
\end{center}
\caption{Selected file attribute functions}
\label{fig:metadata-components}
\end{figure}


\subsection{Gzip and Tar Type Constructors}
\label{sec:file-modifiers}

Some files need processing by a utility before they can be used.  A typical
example is a compressed file such as the gzipped log files in the Coral
example shown in Figure~\ref{fig:coral-pic}.  \forest{} allows users to describe such 
files using various modifiers.  For example, if \cd{CoralInfo} is a \padshaskell{}
description of a Coral log file then the following describes a gzipped log file.
\begin{code}
type CoralLog = Gzip (File CoralInfo)
\end{code}
Likewise, suppose \cd{logs.tar.gz} is a gzipped tar file and suppose also that 
\cd{AllLogs} describes the directory of log files that \cd{logs.tar} expands
to.  In this case, the following description will describe the contents of
\cd{logs.tar.gz} properly.
\begin{code}
type CoralLogs = Gzip (Tar AllLogs)
\end{code}

\subsection{Symbolic Links}
\label{sec:symlinks}

When symbolic links are present in the file system described,
the default behavior is to read through the symbolic links to their
targets.  Hence, the behavior of \forest{} will be intuitive to programmers who
are used to working in a standard UNIX-like environment.  In addition, however, it is possible
for a programmer to explicitly specify that she expects a symbolic link in a particular
position.  To do so, the programmer will use the \cd{SymLink} base type.  For
example:
\begin{code}
type MyFile = SymLink
\end{code}
In \forest{}, any file system object may be described in multiple different ways.
Hence, in the case of symbolic links, it is possible to use one declaration to
specify the fact that an object is a symbolic link, and a second declaration to specify
the nature of the target that link ({\em e.g.,} the target is a text file).  We will see such 
a specification in later subsections.

\subsection{Putting it all together}

The previous subsections explain most of the interesting features of \forest{}.
These features are put to work in Figures~\ref{fig:student-description}
and~\ref{fig:coral-description}.  A set of other descriptions are available on 
the \forest{} web site~\cite{forest-web-site}.

\begin{figure}
\input{student-description}
\caption{\forest{} student description -- out of date (nov 1)}
\label{fig:student-description}
\end{figure}

\begin{figure}
\input{coral-description}
\caption{\forest{} coral description -- out of date (nov 1)}
\label{fig:coral-description}
\end{figure}
