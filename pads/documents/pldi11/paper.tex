%\documentclass[fleqn]{article}
\documentclass[natbib]{sigplanconf}
%\documentclass[nocopyrightspace]{sigplanconf}

\usepackage{xspace,pads,amsmath,math-cmds,
            math-envs,inference-rules,times,
            verbatim,alltt,multicol,proof,url}
\usepackage{epsfig}
\usepackage{code} 
%\setlength{\oddsidemargin}{0in}
%\setlength{\evensidemargin}{0in}
%\setlength{\textwidth}{6.5in}
%\setlength{\textheight}{8.5in}

\begin{document}

\conferenceinfo{PLDI'11,}{} 
\copyrightyear{2011} 
\copyrightdata{} 

\title{Forest:  A Language and Toolkit For Programming with File System Fragments}

\authorinfo{Kathleen Fisher}{
	   AT\&T Labs Research}
       {\mono{kfisher@research.att.com}}
\authorinfo{Nate Foster}{
	   Cornell University}
       {\mono{jnfoster@cs.cornell.edu}}
\authorinfo{David Walker}{
	   Princeton University}
       {\mono{{dpw}@CS.Princeton.EDU}}
\input{definitions}

\maketitle{}

\begin{abstract}  
\input{abstract}
\end{abstract}

\category{D.3.m}{Programming languages}{Miscellaneous}

\terms
Languages, Algorithms

\keywords
Data description languages, file systems, domain specific languages, ad hoc data


\section {Introduction}
\label{sec:intro}

Bogus cite~\cite{fisher+:pads}

Define the problem:

\begin{itemize}
\item Data accumulates over time in sets of files organized in
hierarchically structured file systems.  Show table of examples.
\item Problem: no documentation
\item Problem: errors. No tools for consistency checking/ error dection
\item Problem: data encoded in combination of file and directory names as
well as internally to files
\item Problem: data is large: complicates infrastructure for
getting data in to and out of programs.  can't even use standard unix tools like ls * due to overexpansion
on command line.
\end{itemize}

Goal: to make programming with data on disk as easy as programming with a
data structure within your program

State the Contributions:

\begin{itemize}
\item Concept:  the idea to extend a modern programming language with
fully integrated linguistic features for describing file system fragments
and for automatically generating programming infrastructure from such 
descriptions.

\item Description Language Design:  we have carefully chosen \forest{} programming
features based on our analysis of a number of examples.  The design
is expressive, concise and tastefully integrated into Haskell.
It lowers the barrier to programming with data on disk.  We give example
.

\item Tool Generation:  tools are automatically generated so that programmers
may begin working with their described data immediately and easily.  List
tools generated.  We illustrate the use of these tools on examples.

\item Implementation: a fully functional extension of Haskell.  
We evaluate its performance briefly?  Side-comment: the implementation
acts as a case study in *extensive,* practical,
domain-specific language design in modern languages by
combining a number of experimental features of Haskell such
as quasi-quoting, template haskell, etc.

\item Semantics: we have a semantics for a core calculus.  This
guides our implementation decisions.  Unlike parser generators,
which are based on grammars over sequences, this is based
on a classical logic over trees.
\end{itemize}

\section{Example Repositiories}
\label{sec:review}

In this section, we present two example file repositories.
We will use these examples to help us motivate and explain
the design of \forest{} in future sections.

The first repository contains information about students in
Princeton's undergraduate computer science program.   
The data in the repository is used
every year to help faculty decide on undergraduate awards,
to assign honors levels (honors, high honors, highest honors)
to graduating seniors and to track grading trends.
It was
created in approximately 1990 and has been extended and
maintained ever since.  As the repository has evolved over time, there
have been a few slight changes in format -- a typical occurrence in
ad hoc data repositories.  Naturally, any description will need to cope
with the variation.
 
Figure~\ref{fig:student-pic} shows the
structure of the student data repository.  At the top level, there are
three important directories: \cd{graduates} (students who have graduated)
\cd{classof11} (this year's seniors) and \cd{classof12} (this year's juniors).
There is also a \cd{README} file containing a collection of notes.
Inside \cd{graduates}, there is another set of directories named 
\cd{classofX} where \cd{X} dates back to 92.  Inside each \cd{classofX} 
directory, there are at least the 
two degree subdirectories \cd{ABX} and \cd{BSEX} as
the computer science department gives out both Arts and Science
and Engineering degrees.  Optionally, there are also subdirectories for
students who left Princeton or transferred into another program. 
Within any degree subdirectory, there is a set of text files, one
textfile per student, that contain information on courses taken and
student grades.  Figure~\ref{fig:student-file-example} present a fragment
of a typical file.  The directory also usually contains a blank template file
named \cd{sss.txt} or something similar for creating new students.

\begin{figure}

a picture showing the student hierarchy

\caption{Princeton computer science undergraduate data.}
\label{fig:student-pic}
\end{figure}

\begin{figure}
% Note: Kessel has poor grades in COS but excels in HOC and 
% is taking a grad course in GOL(s).  :-)
\begin{code}
KESSEL, PHIL	   BSE   '11
- - - - - - - - - - - - - - - - - - -
Type    Yr  Course     Grade
         1             A+ to F
d        2             P  (  Pass )
t  D  p  3             INC
o  .  .  4  Dept  xxx  N  (Not Avail)
- - - - - - - - - - - - - - - - - - -
d  .  .  1  COS   101  C
o  .  .  1  HOC   101  A
o  .  .  1  GOL   599  A+
...
\end{code}
\caption{Example student file {\tt KESSEL.txt}.}
\label{fig:student-file-example}
\end{figure}

The second repository we will explore in detail involves
log files generated by Freedman's Coral system~\cite{freedman+:coral,freedman:coral-experience}.  Coral is a distributed content distribution network and
to monitor its health, security and performance, distributed nodes send
statistics reports back to a centralized repository.  These reports
are collected in a repository shaped as shown in Figure~\ref{fig:coral-pic}.
At the top-level, this hierarchy contains a set of subdirectories, with
one subdirectory per machine name.  Within each machine directory, there is 
another set of directories, named according to the time it was created.
Within each time directory, there are one or more gzipped log files.
For the purposes of this paper, the main log file we are interested 
in is named \cd{coralwebsrv.log.gz}; it contains a number of statistics
that Mike monitors on a regular basis. \reminder{dpw: I didn't include
an example file fragment.  This could be done later.  I'm already concerned
about space.}

\begin{figure}

a picture showing the Coral hierarchy

\caption{Coral system log data.}
\label{fig:coral-pic}
\end{figure}

\section{\forest{} Design}
\label{sec:review}

\forest{} is a domain-specific language embedded within Haskell using the
Template Haskell extension mechanism~\cite{metahaskell}.  In a typical
\forest{} description, \forest{} declarations will be interleaved with ordinary
Haskell declarations.  To introduce new \forest{} declarations in amongst
Haskell declarations,
the programmer simply opens the \forest{} sublanguage scope:
\begin{code}
[forest| 
  ... forest declarations ...
|]
\end{code}

Once within the forest sublanguage, the programmer will write declarations
that look and feel very much like extended Haskell type declarations.
Each such type declaration serves three purposes: (1) it specifies how the user
expects some fragment of the file system to appear, (2) like an ordinary type
declaration, it describes the structure of the in-memory {\em representation} of that 
file system fragment when it is read into a Haskell program, and (3) it describes 
the structure of the {\em metadata} that is associated with reading the file system
fragment into the Haskell program.  As we explain the different features of \forest{}, 
readers should keep these three different aspects of \forest{} descriptions in mind.  
The effectiveness of our design comes in part due to the fact that all three of these 
elements may be specified in a single compact notation.  

Readers should also be aware
that the validity of every description is defined relative to a 
{\em current path} or {\em current position} within the file system.  As 
the system interprets a description against the file system, the current path
will change from one directory or file path to the next.  In general, descriptions
do not assume that the current path is a valid path in the file system.  When the current
path is invalid, a description will generally\footnote{The \cd{Maybe} constructor,
discussed in later subsections, is an example of an exception to the general rule.} 
register an attempt to load from that
path as an error in the associated metadata structure.

\subsection{Simple Files}
\label{sec:basics}

The basic building blocks of any file system are the files themselves.  To get started,
\forest{} provides several different ways to describe a file at the current position.  The simplest
way is to choose from a collection of standard, built-in file descriptions:\footnote{Recall that
any text following \cd{--} is a comment in Haskell.} 
\noindent
\begin{code}
[forest| 
  type MyText = File Ptext   -- a text file
  type MyBin = File Pbin     -- a binary file
  type Whatever = File Pany  -- any file at all
|]
\end{code}
Each such declaration creates an identifier ({\it e.g.,} \cd{MyText}) that can be used in other
more complex descriptions later.  It also generates several utility functions that may
be used in the surrounding Haskell code, including functions 
for loading files that match the given description.  

Descriptions such as \cd{MyText} are useful when the user neither knows or cares much about
the internal structure of the given file.  On the other hand, when the user does know and does
care about the internal structure of a file, he or she will want to describe that structure,
and will be able to do so using \padshaskell{}.  \padshaskell{} is another sublanguage,
based on the PADS family of parser 
generators~\cite{fisher+:pads,fisher+:popl06,mandelbaum+:pads-ml}, but 
designed for use with Haskell and \forest{}.  \padshaskell{} declarations are introduced
within the pads scope:
\noindent
\begin{code}
[pads| 
  ... pads declarations ...
|]
\end{code}
These declarations are capable of generating parsers that may be referred
to later within \forest{}.  For example, it is straightforward to use \padshaskell{} to generate
a parser for student files such as the one shown in Figure~\ref{fig:student-file-example}
(see the appendix for the description we use).
Assuming that the parser for the file is named \cd{Student} and that it takes a single string parameter
(\cd{n}, the student name), we can use it within \forest{} as follows.
\begin{code}
[forest| 
  type SFile (n::String) = File (Student n) 
|]
\end{code}
Using \padshaskell{} parsers in \forest{} not only helps specify the intended grammatical structure
of a file, but it also generates a structured in-memory representation for Haskell programmers
to traverse, query or otherwise manipulate.  Indeed, \padshaskell{} and \forest{}
were designed to work seemlessly together.  From the perspective of the Haskell
programmer traversing an in-memory data structure, there is effectively
no difference between iterating over structured directories full of files or
structured sequences of lines or tokens within a file.

While the design of \padshaskell{} is interesting in its own right, the rest of this
paper focuses on \forest{}.  Henceforth, the reader should assume
any unadorned declarations 
occur within the \forest{} scope \cd{[forest| ... |]} unless otherwise noted.
The reader should also assume any declarations prefixed by \cd{>} are ordinary
Haskell declarations.

\subsection{File Modifiers}
\label{sec:file-modifiers}

Some files need processing by a utility before they can be used.  A typical
example is a compressed file such as the gzipped log files in the Coral
example shown in Figure~\ref{fig:coral-pic}.  \forest{} allows users to describe such 
files using various modifiers.  For example, if \cd{CoralInfo} is a \padshaskell{}
description of a Coral log file then the following describes a gzipped log file.
\begin{code}
type CoralLog = Gzip (File CoralInfo)
\end{code}
Likewise, suppose \cd{logs.tar.gz} is a gzipped tar file and suppose also that 
\cd{AllLogs} describes the directory of log files that \cd{logs.tar} expands
to.  In this case, the following description will describe the contents of
\cd{logs.tar.gz} properly.
\begin{code}
type CoralLogs = Gzip (Tar AllLogs)
\end{code}

\subsection{Symbolic Links}
\label{sec:symlinks}

When symbolic links are present in the file system described,
the default behavior is to read through the symbolic links to their
targets.  Hence, the behavior of \forest{} will be intuitive to programmers who
are used to working in a standard UNIX-like environment.  In addition, however, it is possible
for a programmer to explicitly specify that she expects a symbolic link in a particular
position.  To do so, the programmer will use the \cd{SymLink} base type.  For
example:
\begin{code}
type MyFile = SymLink
\end{code}
In \forest{}, any file system object may be described in multiple different ways.
Hence, in the case of symbolic links, it is possible to use one declaration to
specify the fact that an object is a symbolic link, and a second declaration to specify
the nature of the target that link ({\em e.g.,} the target is a text file).  We will see such 
a specification in later subsections.

\subsection{Simple Directories}
\label{sec:simple-directories}

The simplest way to specify the contents of a directory is to use
a record-like declaration.  For example, to specify the root directory
of the student repository in Figure~\ref{fig:student-pic}, we might use
the following declaration.  This declaration assumes that we have already
defined \cd{Class n}, a parameterized description that specifies
the structure of a directory holding data on the class of year \cd{n},
and \cd{Grads}, a description that specifies the structure of the directory holding
all graduated classes.   
\begin{code}
type All = Directory
  \{ seniors is "classof11" :: Class 11
  , juniors is "classof12" :: Class 12
  , grads is "graduates" :: Grads
  , notes is "README" :: File Ptext
  \}
\end{code}
Above, each field of the record has three components:  (1) a label
name ({\it e.g.,} seniors or juniors), (2) a file or directory name
({\it e.g.,} "classof11" or "classof12"), and (3) a \forest{} subdescription
for the contents of the named object ({\it e.g.,} \cd{Class 11} or \cd{Grads}
or \cd{File Ptext}).

With simple descriptions like this one, it is common for users to want
the label to be the same as the name of the file.  In such a case, users
may write the following abbreviated description:
\begin{code}
type All = Directory
  \{ classof11 :: Class 11
  , classof12 :: Class 12
  , graduates :: Grads
  , notes is "README" :: File Ptext
  \}
\end{code}
Above, the name of the label is used as the expected file name.  We did not
shorten \cd{notes is "README"} to \cd{README} because legal Haskell labels must start
with lowercase letters.

\paragraph*{Matching.}
In order for a file system object to match a description like the one above, it must be a
directory and each field of the record must match.  A field matches when the given
file name ({\em e.g.,} \cd{"README"}) is concatenated to the current path and the 
object at that new path matches the field's subdescription.

It is possible for the same file system object to to match multiple different fields of a description at
the same time.  For example, if "README" were a symbolic link that pointed to a text file, one 
might want to specify that using a pair of declarations:
\begin{code}
type All = Directory
  \{ ...
  , link is "README" :: SymLink
  , notes is "README" :: File Ptext
  \}
\end{code}

It is also possible for a directory to contain a number of objects that go unmatched by
a description.  We made the design choice to allow extra items in
a directory because we found it common for directories to contain files that users
simply do not care much about.  For example,
if programmers do not need to extract information out of the README file and
users do not really care whether it exists or not, one might well choose
to omit it from the description.  One might be concerned that this design choice makes it difficult to specify
the absence of files (as opposed to their presence), which can be important
for security purposes in some cases.  However, we will see shortly that in the
uncommon case that programmers want to specify absence information, they can
do so using constraints.

When a directory does match a record declaration like this one, 
\forest{} provides utilities to read the directory in
to memory and generate a convenient programmatic representation for it.  
In this case, the type of the in-memory representation is a record type
with labels \cd{seniors}, \cd{juniors}, {\em etc.} and with field types
generated from the associated \forest{} subdescriptions \cd{Class}, \cd{Grads},
{\em etc.}  When the same object is described in two different ways, one may
get two different in-memory representations of it.  For instance, in the example above,
the \cd{link} field will hold a representation of the filepath that describes the target of the
symbol link whereas the \cd{notes} field will hold a representation of the \cd{README}
file itself ({\em i.e.,} a string of characters).

When a directory does not match a record declaration, \forest{} will
construct representations for the subparts that do match and will insert dummy values
into the parts that do not match.  \forest{} will also record all errors encountered in the
matching process in the object metadata.

\subsection{Computed and Approximate Paths}
\label{sec:computed-pathes}

Both of the above descriptions are a good start for our application, but neither
are ideal.  Every year, the directory for the graduating seniors 
({\em i.e.,} \cd{classof11}) gets moved into the graduates directory,
the juniors get promoted to seniors and a new junior class gets created.
As it stands, this means we would also have to edit our description every year.
An alternative is to parameterize our description with the current year and
to construct the appropriate file names.  If we follow this strategy,
we might arrive at the following specification for the top-level student directory:
\begin{code}
> mkclass y = "classof" ++ (toString y)
\mbox{}
type All (y::Integer) = Directory
  \{ seniors is <|mkclass y|> :: Class y
  , juniors is <|mkclass (y+1)|> :: Class <|y+1|>
  , graduates :: Grads
  , notes is "README" :: File Ptext
  \}
\end{code}
%\begin{code}
%type All (sy::String, jy::String) = Directory
%  \{ seniors is <|"classof" ++ sy|> :: Class
%  , juniors is <|"classof" ++ jy|> :: Class
%  , graduates :: Grads
%  , notes is "README" :: File Ptext
%  \}
%\end{code}
In general, \cd{<|...|>} can be used to escape back in to
Haskell to perform arbitrary computations.  Note also that any description
may be parameterized by specifying a legal Haskell identifier and its type.
Parameterized specifications may be used by supplying their arguments
in the usual way.  When arguments are simple constants or variables,
they may be supplied directly.  When arguments are more complex
computed expressions, it is necessary to use explicit escapes back 
in to Haskell.

As repositories evolve over time, naming conventions may change.
Alternatively, programmers simply may not care to specify certain names
exactly.  To accomodate these possibilities, \forest{} includes mechanisms
for approximate naming of files.  For example, in each class, there may
(or may not) be some number of students that have withdrawn from the
program, transferred to a different Princeton program on gone on
temporary leave.  Over the years, slightly different directory names
have been used to represent these situations.  Given this circumstance,
we can use the following declarations to describe the class directory.
\reminder{dpw: I edited out some of the withdrawn RE options to make it
fit on a line.}
\begin{code}
> transRE = RE "TRANSFER|Transfer"
> leaveRE = RE "LEAVE|Leave"
> wdRE    = RE "WITHDRAWN|WITHDRAWAL|Withdrawn"
\mbox{}
type Class (y::Integer) = Directory
  \{ bse is <|"BSE" ++ (toString y)|> :: Major
  , ab  is <|"AB"  ++ (toString y)|> :: Major   
  , trans matches transRE :: Maybe Major      
  , wd matches wdRE :: Maybe Major
  , leave matches leaveRE :: Maybe Major 
  \}
\end{code}
A field with the form \cd{<label> matches <regexp> :: T}
finds the set of paths in the files system that match \cd{currentPath/} \cd{<regexp>}.
If there are zero or one matches, the \cd{matches} form acts like the \cd{is} 
form.\footnote{Recall that when 
there are zero matches, the \cd{is} form attempts to match the type \cd{T} 
against a non-existant file system object at a non-existant path.  This may or may not be
an error, depending on \cd{T}.  The matches form constructs a non-existant path
and behaves the same way.}  If there is more than one match, one of the many matches
is selected non-deterministically, a multiple match error is registered in the metadata,
and matching once again continues as in the \cd{is} form.

In this example, the \cd{matches} form is combined with the \cd{Maybe T} constructor.
\cd{Maybe T} succeeds and returns \cd{None} when the current path is not a path in the
file system.  \cd{Maybe T} also succeeds, returning \cd{Just v} for some \cd{v},
when applied to an object that matches \cd{T} at the current path.  \cd{Maybe T} 
registers an error in the metadata when the current path exists but 
the object at the current path does not properly match \cd{T}.

\subsection{Comprehensions}
\label{sec:comprehensions}

Record directories allow programmers to specify a fixed number of file system objects.
Comprehensions, on the other hand, allow programmers to specify arbitrary numbers
of file system objects.  As an example, we might specify the contents of the
\cd{Grads} directory from Figure~\ref{fig:student-file-example} as follows.
\reminder{dpw: changed Prelude.take into take below for space reasons.}
\reminder{dpw: perhaps the definition of getYear should use Haskell composition "." instead
of all the parens? Also, I changed the type of the Class parameter to an integer. Hence, I needed the toInteger conversion -- it wasn't obvious to me from the Haskell docs if in fact toInteger will
convert from a string to an integer. In the current Students2.hs (Oct. 23), all comprehensions
are nested within records.  I unnested here. I can imagine syntax is a possible issue with doing
that but not semantics.  The record wrapper does seem unnecessary overhead for the programmer.
(But really, it just helps me with the explanation here, because it makes comprehensions orthogonal.}
\begin{code}
> cYear s = 
>   toInteger (reverse (take 2 (reverse s)))
> cRE = RE "classof[0-9][0-9]"
\mbox{}
type Grads = Directory 
  [c :: Class <|cYear c|> | c <- matches cRE]
\end{code}
In the specification above, \cd{Grads} is a directory that contains a number of
\cd{Class} subdirectories with names \cd{c} that match the regular expression
\cd{cRE}.  The Haskell function \cd{cYear} extracts the last two digits from the
name of the directory, converts the string digits to an integer year, and passes
the year to the underlying \cd{Class} specification.
More generally, comprehensions have the following form.
\begin{code}
[path :: T | id <- gen where pred]
\end{code}
Here, \cd{id} is bound to each of the strings generated by the \cd{gen},
which may be a \cd{matches} function (used to match against the files
at the current path) or may be some other list computed in Haskell. The allowed
\cd{id}s may be filtered by \cd{pred} and they may be used in the computation
\cd{path}.  Each such computed path is concatentated to the current path and
used to match a file system object with type \cd{T}.  The predicate and path
computation may also use the path metadata by referring to the variable
\cd{id_md}, which will be in scope.  The in-memory representation of a comprehension
is a list.

Another example of a comprehension occurs in specification the \cd{Major} 
directory.  These directories contain a list of student files, and one additional
template file named \cd{sss.txt} or \cd{sxx.txt}.  The declaration below
specifies all the student files except the template files.  Note that it uses
a glob pattern as opposed to a regular expression
to describe a set of text files.\footnote{A glob pattern
is a pattern used to describe file paths in UNIX-based systems.  Such patterns include
constant strings and wildcards \cd{*} and \cd{?}.} 
\reminder{dpw: the actual description uses the Map combinator to convert the student
list to a map in the representation.  that could be mentioned here but that is an orthogonal feature.
I think it is better to have
a section on transformations, dependent on the state of transforms in the implementation
at submission time.}
\begin{code}
> tpl s = (s == "sss.txt") || (s == "sxx.txt")
> txt = GL "*.txt"
\mbox{}
type Major = Directory  
  [ s :: File (Student <|getName s|>) 
  | s <- matches txt where <|not (tpl s)|>]
\end{code}

\subsection{Metadata and Constraints}
\label{sec:constraints}

\reminder{dpw: is it "metadata" or "meta data"? I have used metadata.}

\reminder{dpw: my writing throughout the entire section
may be ambiguous with respect to the word "metadata".  I am 
guessing there are two kinds of meta data: metadata for paths, which does
not include error information and metadata for parsed objects, which does.
Under what circumstances can you get at each kind?}

Every file system object has metadata associated with it.  In general,
if a \forest{} identifier \cd{id} refers to a path, the metadata for the object at that
path is available through the identifier named \cd{id_md}. Figure~\ref{fig:metadata-components}
lists a set of functions that extract useful information from metadata structures.
Below, metadata functions used to write a universal description.
Notice that the description also happens to be recursive, another useful feature of
\forest{}.  In the case that a symbolic link creates a cycle in the file system, the Haskell
in-memory representation will be an infinite data structure. 
\begin{code}
type Universal = Directory 
  \{ asc is [ f :: File Ptext   
           | f <- matches (GL "*") 
           where <|get_kind f_md == AsciiK|>]
  , bin is [ b :: File Pbinary
           | b <- matches (GL "*") 
           where <|get_kind b_md == BinaryK|>]
  , dir is [ d :: Universal  
           | d <- matches (GL "*") 
           where <|get_kind d_md == DirectoryK|>]
  , sym is [s :: SymLink      
           | s <- matches (GL "*") 
           where <|get_sym s_md == True|>]
  \}
\end{code}

Metadata is also commonly used in {\em constraints}.  For example, if a user
wants to ensure that all her text files are private,
she might replace the use of \cd{File Ptext} in a description with \cd{PrivateFile}:
\reminder{dpw: What is the precedence of "==" vs function application? Note use of "this"
as a name is missing.}
\begin{code}
type PrivateFile = 
  File Ptext 
    where <|get_modes this_md == "-rw-------"|>
\end{code}
The \cd{PrivateFile} type matches any text file.  When the text file does
not have the specified permissions, an error is registered in the metadata.
\reminder{dpw: notice ambiguous/overlapping use of word metadata ...}

\begin{figure}
\begin{center}
\begin{tabular}{l|l}
function name &  information \\
\hline
\cd{get_group} & object group\\
\cd{get_kind} & the sort of file or directory \\
\cd{get_modes} & permission string\\
\cd{get_owner} & object owner\\
\cd{get_size} & object size \\
\end{tabular}
\end{center}
\caption{Metadata functions}
\label{fig:metadata-components}
\end{figure}

TODO: there is a forward reference earlier in the paper to an example that shows
how to enforce emptiness.

\subsection{Representation Transformations}
\label{sec:transforms}

Map transform.  What else is implemented?  Can users specify their own transforms?
If nothing else but map is there, perhaps we should omit
discussing this feature?

\subsection{Putting it all together}

The previous subsections explain most of the interesting features of \forest{}.
These features are put to work in Figures~\ref{fig:student-description}
and~\ref{fig:coral-description}.  A set of other descriptionsare available on 
the \forest{} web site~\cite{forest-web-site}.

\begin{figure}
\input{student-description}
\caption{\forest{} student description}
\label{fig:student-description}
\end{figure}

\begin{figure}
\input{coral-description}
\caption{\forest{} coral description}
\label{fig:coral-description}
\end{figure}

\section{Programming with \forest{}}
\label{sec:exp}

These utility functions may be called from the surrounding Haskell code as follows.
\begin{code}
dir = "Examples/data/text.txt"
(text_rep, text_md) = unsafePerformIO $ (myText_load dir)
\end{code}

\begin{itemize}
\item meta data
\item describe lazy semantics
\item describe how to use/load described data into memory
\item show example program to analyze student data
\end{itemize}

\section{Tools}
\label{sec:tools}
\begin{itemize}
\item tar, ...
\item Graph representation giving status
\item ??
\end{itemize}


\section{Implementation}

\begin{itemize}
\item explain implementation components: quasi-quoting, template haskell, etc.
\item explain generic programming strategy
\item evaluated performance: lazy vs. not? -- we need a graph
\end{itemize}

\section{Language Semantics}
\label{sec:exp}

Show calculus syntax and semantic definitions.  I can't decide if this
is weak and if we should dedicate the space to more important things.
I suppose we'll see when we write the paper.

\section{Related Work}
\label{sec:related}

Microsoft LINQ: Language-integrated query.  Similar high-level goal:
support smooth, language-integrated data management.  Different 
implementation and language design.

vs PADS:  
\begin{itemize}
\item our data structures are larger --> lazy parsing
\item our nice design hides differences between structure inside /
outside of files
\item our semantics based on classical tree logic matching trees vs. 
recursive descent parser matching sequences.
\end{itemize}

\section{Conclusions}
\label{sec:conclusion}


\section*{Acknowledgments}

This material is based upon work 
supported under NSF grant CCF-1016937.
Any opinions, findings, and conclusions or recommendations
   expressed in this material are those of the authors and do not
   necessarily reflect the views of the NSF.

%\newpage

%\bibliographystyle{plainnat}
\bibliographystyle{abbrv}
\bibliography{pads}

%\input{appendix}

\end{document}

%%% Local Variables:
%%% mode: outline-minor
%%% End:

