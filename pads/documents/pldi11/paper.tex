%\documentclass[fleqn]{article}
\documentclass[natbib]{sigplanconf}
%\documentclass[nocopyrightspace]{sigplanconf}

\usepackage{xspace,pads,amsmath,math-cmds,
            math-envs,inference-rules,times,
            verbatim,alltt,multicol,proof,url}
\usepackage{epsfig}
\usepackage{code} 
%\setlength{\oddsidemargin}{0in}
%\setlength{\evensidemargin}{0in}
%\setlength{\textwidth}{6.5in}
%\setlength{\textheight}{8.5in}

\begin{document}

\conferenceinfo{PLDI'11,}{} 
\copyrightyear{2011} 
\copyrightdata{} 

\title{Forest:  A Language and Toolkit For Managing File System Fragments}

\authorinfo{Kathleen Fisher}{
	   AT\&T Labs Research}
       {\mono{kfisher@research.att.com}}
\authorinfo{Nate Foster}{
	   Cornell University}
       {\mono{jnfoster@cs.cornell.edu}}
\authorinfo{David Walker}{
	   Princeton University}
       {\mono{{dpw}@CS.Princeton.EDU}}
\input{definitions}

\maketitle{}

\begin{abstract}  
\input{abstract}
\end{abstract}

\category{D.3.m}{Programming languages}{Miscellaneous}

\terms
Languages, Algorithms

\keywords
Data description languages, file systems, domain specific languages, ad hoc data


\section {Introduction}
\label{sec:intro}

Bogus cite~\cite{fisher+:pads}

Define the problem:

\begin{itemize}
\item Data accumulates over time in sets of files organized in
hierarchically structured file systems.  Show table of examples.
\item Problem: no documentation
\item Problem: errors. No tools for consistency checking/ error dection
\item Problem: data encoded in combination of file and directory names as
well as internally to files
\item Problem: data is large: complicates infrastructure for
getting data in to and out of programs.  can't even use standard unix tools like ls * due to overexpansion
on command line.
\end{itemize}

Goal: to make programming with data on disk as easy as programming with a
data structure within your program

State the Contributions:

\begin{itemize}
\item Concept:  the idea to extend a modern programming language with
fully integrated linguistic features for describing file system fragments
and for automatically generating programming infrastructure from such 
descriptions.

\item Description Language Design:  we have carefully chosen \forest{} programming
features based on our analysis of a number of examples.  The design
is expressive, concise and tastefully integrated into Haskell.
It lowers the barrier to programming with data on disk.  We give example
.

\item Tool Generation:  tools are automatically generated so that programmers
may begin working with their described data immediately and easily.  List
tools generated.  We illustrate the use of these tools on examples.

\item Implementation: a fully functional extension of Haskell.  
We evaluate its performance briefly?  Side-comment: the implementation
acts as a case study in *extensive,* practical,
domain-specific language design in modern languages by
combining a number of experimental features of Haskell such
as quasi-quoting, template haskell, etc.

\item Semantics: we have a semantics for a core calculus.  This
guides our implementation decisions.  Unlike parser generators,
which are based on grammars over sequences, this is based
on a classical logic over trees.
\end{itemize}

\section{Example Repositiories}
\label{sec:review}

In this section, we present two example file repositories.
We will use these examples to help us motivate and explain
the design of \forest{} in future sections.

The first repository contains information about students in
Princeton's undergraduate computer science program.   
The data in the repository is used
every year to help faculty decide on undergraduate awards,
to assign honors levels (honors, high honors, highest honors)
to graduating seniors and to track grading trends.
It was
created in approximately 1990 and has been extended and
maintained ever since.  As the repository has evolved over time, there
have been a few slight changes in format -- a typical occurrence in
ad hoc data repositories.  Naturally, any description will need to cope
with the variation.
 
Figure~\ref{fig:student-pic} shows the
structure of the student data repository.  At the top level, there are
three important directories: \cd{graduates} (students who have graduated)
\cd{classof11} (this year's seniors) and \cd{classof12} (this year's juniors).
There is also a \cd{README} file containing a collection of notes.
Inside \cd{graduates}, there is another set of directories named 
\cd{classofX} where \cd{X} dates back to 92.  Inside each \cd{classofX} 
directory, there are at least the 
two degree subdirectories \cd{ABX} and \cd{BSEX} as
the computer science department gives out both Arts and Science
and Engineering degrees.  Optionally, there are also subdirectories for
students who left Princeton or transferred into another program. 
Within any degree subdirectory, there is a set of text files, one
textfile per student, that contain information on courses taken and
student grades.  Figure~\ref{fig:student-file-example} present a fragment
of a typical file.  The directory also usually contains a blank template file
named \cd{sss.txt} or something similar for creating new students.

\begin{figure}

a picture showing the student hierarchy

\caption{Princeton computer science undergraduate data.}
\label{fig:student-pic}
\end{figure}

\begin{figure}
% Note: Kessel has poor grades in COS but excels in HOC and 
% is taking a grad course in GOL(s).  :-)
\begin{code}
KESSEL, PHIL	   BSE   '11
- - - - - - - - - - - - - - - - - - -
Type    Yr  Course     Grade
         1             A+ to F
d        2             P  (  Pass )
t  D  p  3             INC
o  .  .  4  Dept  xxx  N  (Not Avail)
- - - - - - - - - - - - - - - - - - -
d  .  .  1  COS   101  C
o  .  .  1  HOC   101  A
o  .  .  1  GOL   599  A+
...
\end{code}
\caption{Example student file {\tt KESSEL.txt}.}
\label{fig:student-file-example}
\end{figure}

The second repository we will explore in detail involves
log files generated by Freedman's Coral system~\cite{freedman+:coral,freedman:coral-experience}.  Coral is a distributed content distribution network and
to monitor its health, security and performance, distributed nodes send
statistics reports back to a centralized repository.  These reports
are collected in a repository shaped as shown in Figure~\ref{fig:coral-pic}.
At the top-level, this hierarchy contains a set of subdirectories, with
one subdirectory per machine name.  Within each machine directory, there is 
another set of directories, named according to the time it was created.
Within each time directory, there are one or more gzipped log files.
For the purposes of this paper, the main log file we are interested 
in is named \cd{coralwebsrv.log.gz}; it contains a number of statistics
that Mike monitors on a regular basis. \reminder{dpw: I didn't include
an example file fragment.  This could be done later.  I'm already concerned
about space.}

\begin{figure}

a picture showing the Coral hierarchy

\caption{Coral system log data.}
\label{fig:coral-pic}
\end{figure}

\section{\forest{} Design}
\label{sec:review}

\forest{} is a domain-specific language embedded within Haskell using the
Template Haskell extension mechanism~\cite{metahaskell}.  In a typical
\forest{} description, \forest{} declarations will be interleaved with ordinary
Haskell declarations.  To introduce new \forest{} declarations in amongst
Haskell declarations,
the programmer simply opens the \forest{} sublanguage scope:
\begin{code}
[forest| 
  ... forest declarations ...
|]
\end{code}

Once within the forest sublanguage, the programmer will write declarations
that look and feel very much like extended Haskell type declarations.
Each such type declaration serves three purposes: (1) it specifies how the user
expects some fragment of the file system to appear, (2) like an ordinary type
declaration, it describes the structure of the in-memory {\em representation} of that 
file system fragment when it is read into a Haskell program, and (3) it describes 
the structure of the {\em metadata} that is associated with reading the file system
fragment into the Haskell program.  As we explain the different features of \forest{}, 
readers should keep these three different aspects of \forest{} descriptions in mind.  
The effectiveness of our design comes in part due to the fact that all three of these 
elements may be specified in a single compact notation.

\subsection{Simple Files}
\label{sec:basics}

The basic building blocks of any file system are the files themselves.  To get started,
\forest{} provides several different ways to describe the {\em contents} files.  The simplest
way is to choose from a collection of standard, built-in file descriptions:\footnote{Recall that
any text following \cd{--} is a comment in Haskell.} 
\noindent
\begin{code}
[forest| 
  type MyText = File Ptext   -- a text file
  type MyBin = File Pbin     -- a binary file
  type Whatever = File Pany  -- any file at all
|]
\end{code}
Each such declaration creates a name ({\it e.g.,} \cd{MyText}) that can be used in other
more complex descriptions later.  It also generates several utility functions that may
be used in the surrounding Haskell code, including functions 
for loading files that match the given description.  

Descriptions such as \cd{MyText} are useful when the user neither knows or cares much about
the internal structure of the given file.  On the other hand, when the user does know and does
care about the internal structure of a file, he or she will want to describe that structure,
and will be able to do so using \padshaskell{}.  \padshaskell{} is another sublanguage,
based on the PADS family of parser 
generators~\cite{fisher+:pads,fisher+:popl06,mandelbaum+:pads-ml}, but 
designed for use with Haskell and \forest{}.  \padshaskell{} declarations are introduced
within the pads scope:
\noindent
\begin{code}
[pads| 
  ... pads declarations ...
|]
\end{code}
These declarations are capable of generating parsers that may be referred
to later within \forest{}.  For example, it is straightforward to use \padshaskell{} to generate
a parser for student files such as the one shown in Figure~\ref{fig:student-file-example}
(see the appendix for the description we use).
Assuming that the parser for the file is named \cd{Student} and that it takes a single string parameter
(\cd{n}, the student name), we can use it within \forest{} as follows.
\begin{code}
[forest| 
  type SFile (n::String) = File (Student n) 
|]
\end{code}
Using \padshaskell{} parsers in \forest{} not only helps specify the intended grammatical structure
of a file, but it also generates a structured in-memory representation for Haskell programmers
to traverse, query or otherwise manipulate.  Indeed, \padshaskell{} and \forest{}
were designed to work seemlessly together.  From the perspective of the Haskell
programmer traversing an in-memory data structure, there is effectively
no difference between iterating over structured directories full of files or
structured sequences of lines or tokens within a file.

While the design of \padshaskell{} is interesting in its own right, the rest of this
paper focuses on \forest{}.  Henceforth, the reader should assume
any unadorned declarations 
occur within the \forest{} scope \cd{[forest| ... |]} unless otherwise noted.
The reader should also assume any declarations prefixed by \cd{>} are ordinary
Haskell declarations.

\subsection{File Modifiers}
\label{sec:file-modifiers}

Some files need processing by a utility before they can be used.  A typical
example is a compressed file such as the gzipped log files in the Coral
example shown in Figure~\ref{fig:coral-pic}.  \forest{} allows users to describe such 
files using various modifiers.  For example, if \cd{CoralInfo} is a \padshaskell{}
description of a Coral log file then the following describes a gzipped log file.
\begin{code}
type CoralLog = Gzip (File CoralInfo)
\end{code}
Likewise, suppose \cd{logs.tar.gz} is a gzipped tar file and suppose also that 
\cd{AllLogs} describes the directory of log files that \cd{logs.tar} expands
to.  In this case, the following description will describe the contents of
\cd{logs.tar.gz} properly.
\begin{code}
type CoralLog = Gzip (Tar AllLogs)
\end{code}

\subsection{Simple Directories}
\label{sec:simple-directories}

The simplest way to specify the contents of a directory is to use
a record-like declaration.  For example, to specify the root directory
of the student repository in Figure~\ref{fig:student-pic}, we might use
the following declaration.  This declaration assumes that we have already
defined \cd{Class}, a description that specifies
the structure of a directory holding data on a single class
and \cd{Grads}, a description that specifies the structure of the directory holding
all graduated classes.  The 
\begin{code}
type All = Directory
  \{ seniors is "classof11" :: Class
  , juniors is "classof12" :: Class 
  , grads is "graduates" :: Grads
  , notes is "README" :: File Ptext
  \}
\end{code}
Above, each field of the record has three components:  (1) a label
name ({\it e.g.,} seniors or juniors), (2) a file or directory name
({\it e.g.,} "classof10" or "classof11"), and (3) a \forest{} description
for the file or directory named ({\it e.g.,} \cd{Class  "10"} or \cd{Grads}
or \cd{File Ptext}).
In order for a directory to match the description, it must
contain {\em at least} four items.  Those items must have the file or directory
names given and the contents of each item must match the corresponding description.
If a directory does match, \forest{} provides utilities to read the directory in
to memory and generate a convenient programmatic representation for it.  
In this case, the type of the in-memory representation is a record type
with labels \cd{seniors}, \cd{juniors}, {\em etc.} and with field types
generated from the associated \forest{} subdescriptions \cd{Class}, \cd{Grads},
{\em etc.}

With simple descriptions like this one, it is common for users to want
the label to be the same as the name of the file.  In such a case, users
may write the following abbreviated description:
\begin{code}
type All = Directory
  \{ classof11 :: Class
  , classof12 :: Class 
  , graduates :: Grads
  , notes is "README" :: File Ptext
  \}
\end{code}
Above, the name of the label is used as the expected file name.  We did not
abbreviate \cd{notes} to \cd{README} because legal Haskell labels must start
with lowercase letters.

In the preceding paragraphs, we emphasized that a matching directory must contain
{\em at least} four items.  We made the design choice to allow extra items in
a directory because we found it common for directories to contain files that users
simply do not care much about.  Rather than forcing users to describe such
files, we simply allow them to go unmatched by the description.  For example,
if programs do not need to extract information out of the README file and
users do not really care whether it exists or not, they might well choose
to omit it from the description.  We included it for illustrative purposes,
but it is not of much use.

One might be concerned that this design choice makes it difficult to specify
the absence of files (as opposed to their presence), which can be important
for security purposes in some cases.  However, we will see shortly that in the
uncommon case that programmers want to specify absence information, they can
do so using constraints.

\subsection{Computed Pathes}
\label{sec:computed-pathes}

Both of the above descriptions are a good start for our application, but neither
are ideal.  Every year, the directory for the graduating seniors 
({\em i.e.,} \cd{classof11}) gets moved into the graduates directory,
the juniors get promoted to seniors and a new junior class gets created.
As it stands, this means we would also have to edit our description every year.
An alternative is to parameterize our description with the current year and
to construct the appropriate file names.  If we follow this strategy,
we might arrive at the following specification for the top-level student directory:
\begin{code}
> clss y = "classof" ++  (toString y)
\mbox{}
type All (y::Integer) = Directory
  \{ seniors is <|clss y|> :: Class
  , juniors is <|clss (y+1)|> :: Class
  , graduates :: Grads
  , notes is "README" :: File Ptext
  \}
\end{code}
%\begin{code}
%type All (sy::String, jy::String) = Directory
%  \{ seniors is <|"classof" ++ sy|> :: Class
%  , juniors is <|"classof" ++ jy|> :: Class
%  , graduates :: Grads
%  , notes is "README" :: File Ptext
%  \}
%\end{code}
In general in descriptions, \cd{<|...|>} can be used to escape back in to
Haskell to perform arbitrary computations.  Note also that any description
may be parameterized by specifying a legal Haskell identifier and its type.
Parameterized specifications may be used by supplying their arguments
in the usual way.  For example:
\begin{code}
type Root = All 11
\end{code}
\reminder{dpw: Do I need \cd{<|...|>} above?  Have I declared a tuple?  Should I
Curry my\cd{All} declaration?}


\begin{itemize}
\item Overview: Files, Directories, and Symbolic Links
\item Files
\begin{itemize}
\item Atomic file types: text, binary, plugins?
\item Pads/haskell files.  Note: related to PADS/ML and PADS/C but
a completely new design and implementation for Haskell.
\end{itemize}
\item Directories
\begin{itemize}
\item Record directories, concrete and computed name matching
\item Dependency, Constraints and Parameters
\item Comprehensions and matching
\end{itemize}
\item Symbolic links
\item Maybe
\item Unions    - We don't have these at the moment.  Should we add them?
\item Gzip, Tar
\end{itemize}

Give list of examples we've coded in \forest{}.  Include universal rep?

\section{Programming with \forest{}}
\label{sec:exp}

These utility functions may be called from the surrounding Haskell code as follows.
\begin{code}
dir = "Examples/data/text.txt"
(text_rep, text_md) = unsafePerformIO $ (myText_load dir)
\end{code}

\begin{itemize}
\item meta data
\item describe lazy semantics
\item describe how to use/load described data into memory
\item show example program to analyze student data
\end{itemize}

\section{Tools}
\label{sec:tools}
\begin{itemize}
\item tar, ...
\item Graph representation giving status
\item ??
\end{itemize}


\section{Implementation}

\begin{itemize}
\item explain implementation components: quasi-quoting, template haskell, etc.
\item explain generic programming strategy
\item evaluated performance: lazy vs. not? -- we need a graph
\end{itemize}

\section{Language Semantics}
\label{sec:exp}

Show calculus syntax and semantic definitions.  I can't decide if this
is weak and if we should dedicate the space to more important things.
I suppose we'll see when we write the paper.

\section{Related Work}
\label{sec:related}

Microsoft LINQ: Language-integrated query.  Similar high-level goal:
support smooth, language-integrated data management.  Different 
implementation and language design.

vs PADS:  
\begin{itemize}
\item our data structures are larger --> lazy parsing
\item our nice design hides differences between structure inside /
outside of files
\item our semantics based on classical tree logic matching trees vs. 
recursive descent parser matching sequences.
\end{itemize}

\section{Conclusions}
\label{sec:conclusion}


\section*{Acknowledgments}

This material is based upon work 
supported under NSF grant CCF-1016937.
Any opinions, findings, and conclusions or recommendations
   expressed in this material are those of the authors and do not
   necessarily reflect the views of the NSF.

%\newpage

%\bibliographystyle{plainnat}
\bibliographystyle{abbrv}
\bibliography{pads}

%\input{appendix}

\end{document}

%%% Local Variables:
%%% mode: outline-minor
%%% End:

