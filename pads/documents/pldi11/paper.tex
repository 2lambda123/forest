%\documentclass[fleqn]{article}
\documentclass[natbib]{sigplanconf}
%\documentclass[nocopyrightspace]{sigplanconf}

\usepackage{xspace,pads,amsmath,math-cmds,
            math-envs,inference-rules,times,
            verbatim,alltt,multicol,proof,url}
\usepackage{epsfig}
\usepackage{code} 
%\setlength{\oddsidemargin}{0in}
%\setlength{\evensidemargin}{0in}
%\setlength{\textwidth}{6.5in}
%\setlength{\textheight}{8.5in}

\begin{document}

\conferenceinfo{PLDI'11,}{} 
\copyrightyear{2011} 
\copyrightdata{} 

\title{Forest:  A Language and Toolkit For Managing File System Fragments}

\authorinfo{Kathleen Fisher}{
	   AT\&T Labs Research}
       {\mono{kfisher@research.att.com}}
\authorinfo{Nate Foster}{
	   Cornell University}
       {\mono{jnfoster@cs.cornell.edu}}
\authorinfo{David Walker}{
	   Princeton University}
       {\mono{{dpw}@CS.Princeton.EDU}}
\input{definitions}

\maketitle{}

\begin{abstract}  
\input{abstract}
\end{abstract}

\category{D.3.m}{Programming languages}{Miscellaneous}

\terms
Languages, Algorithms

\keywords
Data description languages, file systems, domain specific languages, ad hoc data


\section {Introduction}
\label{sec:intro}

Bogus cite~\cite{fisher+:pads}

Define the problem:

\begin{itemize}
\item Data accumulates over time in sets of files organized in
hierarchically structured file systems.  Show table of examples.
\item Problem: no documentation
\item Problem: errors. No tools for consistency checking/ error dection
\item Problem: data encoded in combination of file and directory names as
well as internally to files
\item Problem: data is large: complicates infrastructure for
getting data in to and out of programs.  can't even use standard unix tools like ls * due to overexpansion
on command line.
\end{itemize}

Goal: to make programming with data on disk as easy as programming with a
data structure within your program

State the Contributions:

\begin{itemize}
\item Concept:  the idea to extend a modern programming language with
fully integrated linguistic features for describing file system fragments
and for automatically generating programming infrastructure from such 
descriptions.

\item Description Language Design:  we have carefully chosen Forest programming
features based on our analysis of a number of examples.  The design
is expressive, concise and tastefully integrated into Haskell.
It lowers the barrier to programming with data on disk.  We give example
.

\item Tool Generation:  tools are automatically generated so that programmers
may begin working with their described data immediately and easily.  List
tools generated.  We illustrate the use of these tools on examples.

\item Implementation: a fully functional extension of Haskell.  
We evaluate its performance briefly?  Side-comment: the implementation
acts as a case study in *extensive,* practical,
domain-specific language design in modern languages by
combining a number of experimental features of Haskell such
as quasi-quoting, template haskell, etc.

\item Semantics: we have a semantics for a core calculus.  This
guides our implementation decisions.  Unlike parser generators,
which are based on grammars over sequences, this is based
on a classical logic over trees.
\end{itemize}

\section{Running Examples}
\label{sec:review}

Throughout this paper, we will rely upon two primary example data 
repositories to illustrate the various features of Forest.

The first repository contains information about students in
Princeton's undergraduate computer science program.  It was
created in approximately 1990 and has been extended and
maintained ever since.  The data in the repository is used
every year to help faculty decide on undergraduate awards,
to assign honors levels (honors, high honors, highest honors)
to graduating seniors and to track grading trends.
Figure~\ref{fig:student-pic} shows the
structure of the data repository.  At the top level, there are
three important directories: \cd{graduates} (students who have graduated)
\cd{classof11} (this year's seniors) and \cd{classof12} (this year's juniors).
Inside \cd{graduates}, there is another set of directories named 
\cd{classofX} where \cd{X} dates back to 92.  Inside each \cd{classofX} 
directory, there are at least the 
two degree subdirectories \cd{ABX} and \cd{BSEX} as
the computer science department gives out both Arts and Science
and Engineering degrees.  Optionally, there are also subdirectories for
students who left Princeton or transferred into another program. 
Within any degree subdirectory, there is a set of text files, one
textfile per student, that contain information on courses taken and
student grades.  Figure~\ref{fig:student-file-example} present a fragment
of a typical file.  The directory also usually contains a blank template file
named \cd{sss.txt} or something similar for creating new students.

\begin{figure}

a picture showing the student hierarchy

\caption{Princeton computer science undergraduate data.}
\label{fig:student-pic}
\end{figure}

\begin{figure}
% Note: Kessel has poor grades in COS but excels in HOC and 
% is taking a grad course in GOL(s).  :-)
\begin{code}
KESSEL, PHIL	   BSE   '11
- - - - - - - - - - - - - - - - - - -
Type    Yr  Course     Grade
         1             A+ to F
d        2             P  (  Pass )
t  D  p  3             INC
o  .  .  4  Dept  xxx  N  (Not Avail)
- - - - - - - - - - - - - - - - - - -
d  .  .  1  COS   101  C
o  .  .  1  HOC   101  A
o  .  .  1  GOL   599  A+
...
\end{code}
\caption{Example student file {\tt KESSEL.txt}.}
\label{fig:student-file-example}
\end{figure}

The second repository we will explore in detail involves
log files generated by Mike Freedman's Coral system~\cite{freedman+:coral,freedman:coral-experience}.  Coral is a distributed content distribution network and
to monitor its health, security and performance, distributed nodes send
statistics reports back to a centralized repository.  These reports
are collected in a repository shaped as shown in Figure~\ref{fig:coral-pic}.
At the top-level, this hierarchy contains a set of subdirectories, with
one subdirectory per machine name.  Within each machine directory, there is 
another set of directories, named according to the time it was created.
Within each time directory, there are one or more gzipped log files.
For the purposes of this paper, the main log file we are interested 
in is named \cd{coralwebsrv.log.gz}; it contains a number of statistics
that Mike monitors on a regular basis. \reminder{dpw: I didn't include
an example file fragment.  This could be done later.  I'm already concerned
about space.}

\begin{figure}

a picture showing the Coral hierarchy

\caption{Coral system log data.}
\label{fig:coral-pic}
\end{figure}

\section{Forest Design}
\label{sec:review}

Describe the following features using the Student data example. 
Describe both the on-disk representation and the in-memory 
representation (emphasize rep, but mention pds are available).

\begin{itemize}
\item Overview: Files, Directories, and Symbolic Links
\item Files
\begin{itemize}
\item Atomic file types: text, binary, plugins?
\item Pads/haskell files.  Note: related to PADS/ML and PADS/C but
a completely new design and implementation for Haskell.
\end{itemize}
\item Directories
\begin{itemize}
\item Record directories, concrete and computed name matching
\item Dependency, Constraints and Parameters
\item Comprehensions and matching
\end{itemize}
\item Symbolic links
\item Maybe
\item Unions    - We don't have these at the moment.  Should we add them?
\item Gzip, Tar
\end{itemize}

Give list of examples we've coded in Forest.  Include universal rep?

\section{Programming with Forest}
\label{sec:exp}

\begin{itemize}
\item meta data
\item describe lazy semantics
\item describe how to use/load described data into memory
\item show example program to analyze student data
\end{itemize}

\section{Tools}
\label{sec:tools}
\begin{itemize}
\item tar, ...
\item Graph representation giving status
\item ??
\end{itemize}


\section{Implementation}

\begin{itemize}
\item explain implementation components: quasi-quoting, template haskell, etc.
\item explain generic programming strategy
\item evaluated performance: lazy vs. not? -- we need a graph
\end{itemize}

\section{Language Semantics}
\label{sec:exp}

Show calculus syntax and semantic definitions.  I can't decide if this
is weak and if we should dedicate the space to more important things.
I suppose we'll see when we write the paper.

\section{Related Work}
\label{sec:related}

Microsoft LINQ: Language-integrated query.  Similar high-level goal:
support smooth, language-integrated data management.  Different 
implementation and language design.

vs PADS:  
\begin{itemize}
\item our data structures are larger --> lazy parsing
\item our nice design hides differences between structure inside /
outside of files
\item our semantics based on classical tree logic matching trees vs. 
recursive descent parser matching sequences.
\end{itemize}

\section{Conclusions}
\label{sec:conclusion}


\section*{Acknowledgments}

This material is based upon work 
supported under NSF grant CCF-1016937.
Any opinions, findings, and conclusions or recommendations
   expressed in this material are those of the authors and do not
   necessarily reflect the views of the NSF.

%\newpage

%\bibliographystyle{plainnat}
\bibliographystyle{abbrv}
\bibliography{pads}

%\input{appendix}

\end{document}

%%% Local Variables:
%%% mode: outline-minor
%%% End:

