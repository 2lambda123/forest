%\documentclass[fleqn]{article}
\documentclass[natbib]{sigplanconf}
%\documentclass[nocopyrightspace]{sigplanconf}

\usepackage{xspace,pads,amsmath,math-cmds,
            math-envs,inference-rules,times,
            verbatim,alltt,multicol,proof,url}
\usepackage{epsfig}
\usepackage{code} 
%\setlength{\oddsidemargin}{0in}
%\setlength{\evensidemargin}{0in}
%\setlength{\textwidth}{6.5in}
%\setlength{\textheight}{8.5in}

\begin{document}

\conferenceinfo{PLDI'11,}{} 
\copyrightyear{2011} 
\copyrightdata{} 

\title{Forest:  A Language and Toolkit For Managing File System Fragments}

\authorinfo{Kathleen Fisher}{
	   AT\&T Labs Research}
       {\mono{kfisher@research.att.com}}
\authorinfo{Nate Foster}{
	   Cornell University}
       {\mono{jnfoster@cs.cornell.edu}}
\authorinfo{David Walker}{
	   Princeton University}
       {\mono{{dpw}@CS.Princeton.EDU}}
\input{definitions}

\maketitle{}

\begin{abstract}  
\input{abstract}
\end{abstract}

\category{D.3.m}{Programming languages}{Miscellaneous}

\terms
Languages, Algorithms

\keywords
Data description languages, file systems, domain specific languages, ad hoc data


\section {Introduction}
\label{sec:intro}

Bogus cite~\cite{fisher+:pads}

Define the problem:

\begin{itemize}
\item Data accumulates over time in sets of files organized in
hierarchically structured file systems.  Show table of examples.
\item Problem: no documentation
\item Problem: errors. No tools for consistency checking/ error dection
\item Problem: data encoded in combination of file and directory names as
well as internally to files
\item Problem: data is large: complicates infrastructure for
getting data in to and out of programs.  can't even use standard unix tools like ls * due to overexpansion
on command line.
\end{itemize}

Goal: to make programming with data on disk as easy as programming with a
data structure within your program

State the Contributions:

\begin{itemize}
\item Concept:  the idea to extend a modern programming language with
fully integrated linguistic features for describing file system fragments
and for automatically generating programming infrastructure from such 
descriptions.

\item Description Language Design:  we have carefully chosen Forest programming
features based on our analysis of a number of examples.  The design
is expressive, concise and tastefully integrated into Haskell.
It lowers the barrier to programming with data on disk.  We give example
.

\item Tool Generation:  tools are automatically generated so that programmers
may begin working with their described data immediately and easily.  List
tools generated.  We illustrate the use of these tools on examples.

\item Implementation: a fully functional extension of Haskell.  
We evaluate its performance briefly?  Side-comment: the implementation
acts as a case study in *extensive,* practical,
domain-specific language design in modern languages by
combining a number of experimental features of Haskell such
as quasi-quoting, template haskell, etc.

\item Semantics: we have a semantics for a core calculus.  This
guides our implementation decisions.  Unlike parser generators,
which are based on grammars over sequences, this is based
on a classical logic over trees.
\end{itemize}

\section{Running Examples}
\label{sec:review}

Throughout this paper, we will rely upon two primary example data 
repositories to illustrate the various features of Forest.

The first repository contains information about students in
Princeton's undergraduate computer science program.  It was
created in approximately 1990 and has been extended and
maintained ever since.  The data in the repository is used
every year to help faculty decide on undergraduate awards,
to assign honors levels (honors, high honors, highest honors)
to graduating seniors and to track grading trends.
Figure~\ref{fig:student-pic} shows the
structure of the data repository.  At the top level, there are
three important directories: \cd{graduates} (students who have graduated)
\cd{classof11} (this year's seniors) and \cd{classof12} (this year's juniors).
Inside \cd{graduates}, there is another set of directories named 
\cd{classofX} where \cd{X} dates back to 92.  Inside each \cd{classofX} 
directory, there are at least the 
two degree subdirectories \cd{ABX} and \cd{BSEX} as
the computer science department gives out both Arts and Science
and Engineering degrees.  Optionally, there are also subdirectories for
students who left Princeton or transferred into another program. 
Within any degree subdirectory, there is a set of text files, one
textfile per student, that contain information on courses taken and
student grades.  Figure~\ref{fig:student-file-example} present a fragment
of a typical file.  The directory also usually contains a blank template file
named \cd{sss.txt} or something similar for creating new students.

\begin{figure}

a picture showing the student hierarchy

\caption{Princeton computer science undergraduate data.}
\label{fig:student-pic}
\end{figure}

\begin{figure}
% Note: Kessel has poor grades in COS but excels in HOC and 
% is taking a grad course in GOL(s).  :-)
\begin{code}
KESSEL, PHIL	   BSE   '11
- - - - - - - - - - - - - - - - - - -
Type    Yr  Course     Grade
         1             A+ to F
d        2             P  (  Pass )
t  D  p  3             INC
o  .  .  4  Dept  xxx  N  (Not Avail)
- - - - - - - - - - - - - - - - - - -
d  .  .  1  COS   101  C
o  .  .  1  HOC   101  A
o  .  .  1  GOL   599  A+
...
\end{code}
\caption{Example student file {\tt KESSEL.txt}.}
\label{fig:student-file-example}
\end{figure}

The second repository we will explore in detail involves
log files generated by Mike Freedman's Coral system~\cite{freedman+:coral,freedman:coral-experience}.  Coral is a distributed content distribution network and
to monitor its health, security and performance, distributed nodes send
statistics reports back to a centralized repository.  These reports
are collected in a repository shaped as shown in Figure~\ref{fig:coral-pic}.
At the top-level, this hierarchy contains a set of subdirectories, with
one subdirectory per machine name.  Within each machine directory, there is 
another set of directories, named according to the time it was created.
Within each time directory, there are one or more gzipped log files.
For the purposes of this paper, the main log file we are interested 
in is named \cd{coralwebsrv.log.gz}; it contains a number of statistics
that Mike monitors on a regular basis. \reminder{dpw: I didn't include
an example file fragment.  This could be done later.  I'm already concerned
about space.}

\begin{figure}

a picture showing the Coral hierarchy

\caption{Coral system log data.}
\label{fig:coral-pic}
\end{figure}

\section{Forest Design}
\label{sec:review}

Forest is a domain-specific language embedded within Haskell using the
Template Haskell extension mechanism~\cite{metahaskell}.  In a typical
Forest description, Forest declarations will be interleaved with ordinary
Haskell declarations.  To introduce new Forest declarations in amongst
Haskell declarations,
the programmer simply opens the Forest sublanguage scope:
\begin{code}
[forest| 
  ... forest declarations ...
|]
\end{code}

Once within the forest sublanguage, the programmer will write declarations
that look and feel very much like extended Haskell type declarations.
Each such type declaration serves three purposes: (1) it specifies how the user
expects some fragment of the file system to appear, (2) like an ordinary type
declaration, it describes the structure of the in-memory {\em representation} of that 
file system fragment when it is read into a Haskell program, and (3) it describes 
the structure of the {\em metadata} that is associated with reading the file system
fragment into the Haskell program.  As we explain the different features of Forest, 
readers should keep these three different aspects of Forest descriptions in mind.  
The effectiveness of our design comes in part due to the fact that all three of these 
elements may be specified in a single compact notation.

\subsection{Simple Files}
\label{sec:basics}

The basic building blocks of any file system are the files themselves.  To get started,
Forest provides several different ways to describe the {\em contents} files.  The simplest
way is to choose from a collection of standard, built-in file descriptions:\footnote{Recall that
any text following \cd{--} is a comment in Haskell.} 
\noindent
\begin{code}
[forest| 
  type MyText = File Ptext   -- a text file
  type MyBin = File Pbin     -- a binary file
  type Whatever = File Pany  -- any file at all
|]
\end{code}
Each such declaration creates a name ({\it e.g.,} \cd{MyText}) that can be used in other
more complex descriptions later.  It also generates several utility functions that may
be used in the surrounding Haskell code, including functions 
for loading files that match the given description.  

Descriptions such as \cd{MyText} are useful when the user neither knows or cares much about
the internal structure of the given file.  On the other hand, when the user does know and does
care about the internal structure of a file, he or she will want to describe that structure,
and will be able to do so using \padshaskell{}.  \padshaskell{} is another sublanguage,
based on the PADS family of parser 
generators~\cite{fisher+:pads,fisher+:popl06,mandelbaum+:pads-ml}, but 
designed for use with Haskell and Forest.  \padshaskell{} declarations are introduced
within the pads scope:
\noindent
\begin{code}
[pads| 
  ... pads declarations ...
|]
\end{code}
These declarations are capable of generating parsers that may be referred
to later within Forest.  For example, it is straightforward to use \padshaskell{} to generate
a parser for student files such as the one shown in Figure~\ref{fig:student-file-example}
(see the appendix for the description we use).
Assuming that the parser for the file is named \cd{Student} and that it takes a single string parameter
(\cd{n}, the student name), we can use it within Forest as follows.
\begin{code}
[forest| 
  type MyStudent (n::String) = File (Student n) 
|]
\end{code}
Using \padshaskell{} parsers in Forest not only helps specify the intended grammatical structure
of a file, but it also generates a structured in-memory representation for Haskell programmers
to traverse, query or otherwise manipulate.

\subsection{File Qualifiers}
\label{sec:basics}

\begin{itemize}
\item Gzip
\item Symlinks
\item Tar
\end{itemize}

\begin{itemize}
\item Overview: Files, Directories, and Symbolic Links
\item Files
\begin{itemize}
\item Atomic file types: text, binary, plugins?
\item Pads/haskell files.  Note: related to PADS/ML and PADS/C but
a completely new design and implementation for Haskell.
\end{itemize}
\item Directories
\begin{itemize}
\item Record directories, concrete and computed name matching
\item Dependency, Constraints and Parameters
\item Comprehensions and matching
\end{itemize}
\item Symbolic links
\item Maybe
\item Unions    - We don't have these at the moment.  Should we add them?
\item Gzip, Tar
\end{itemize}

Give list of examples we've coded in Forest.  Include universal rep?

\section{Programming with Forest}
\label{sec:exp}

These utility functions may be called from the surrounding Haskell code as follows.
\begin{code}
dir = "Examples/data/text.txt"
(text_rep, text_md) = unsafePerformIO $ (myText_load dir)
\end{code}

\begin{itemize}
\item meta data
\item describe lazy semantics
\item describe how to use/load described data into memory
\item show example program to analyze student data
\end{itemize}

\section{Tools}
\label{sec:tools}
\begin{itemize}
\item tar, ...
\item Graph representation giving status
\item ??
\end{itemize}


\section{Implementation}

\begin{itemize}
\item explain implementation components: quasi-quoting, template haskell, etc.
\item explain generic programming strategy
\item evaluated performance: lazy vs. not? -- we need a graph
\end{itemize}

\section{Language Semantics}
\label{sec:exp}

Show calculus syntax and semantic definitions.  I can't decide if this
is weak and if we should dedicate the space to more important things.
I suppose we'll see when we write the paper.

\section{Related Work}
\label{sec:related}

Microsoft LINQ: Language-integrated query.  Similar high-level goal:
support smooth, language-integrated data management.  Different 
implementation and language design.

vs PADS:  
\begin{itemize}
\item our data structures are larger --> lazy parsing
\item our nice design hides differences between structure inside /
outside of files
\item our semantics based on classical tree logic matching trees vs. 
recursive descent parser matching sequences.
\end{itemize}

\section{Conclusions}
\label{sec:conclusion}


\section*{Acknowledgments}

This material is based upon work 
supported under NSF grant CCF-1016937.
Any opinions, findings, and conclusions or recommendations
   expressed in this material are those of the authors and do not
   necessarily reflect the views of the NSF.

%\newpage

%\bibliographystyle{plainnat}
\bibliographystyle{abbrv}
\bibliography{pads}

%\input{appendix}

\end{document}

%%% Local Variables:
%%% mode: outline-minor
%%% End:

