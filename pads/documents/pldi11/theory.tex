\section{A Core Calculus for \forest{}}
\label{sec:theory}
\renewcommand{\bnfdef}{\ensuremath{\mathord{::=}}}
\newcommand{\slsh}{\ensuremath{\mathord{\textsf{/}}}}
\newcommand{\File}[1]{\ensuremath{\mathsf{File}(#1)}}
\newcommand{\Dir}[1]{\ensuremath{\mathsf{Dir}(#1)}}
\newcommand{\Link}[1]{\ensuremath{\mathsf{Link}(#1)}}
\newcommand{\Set}[1]{\ensuremath{\{ #1 \}}}
\newcommand{\Map}[1]{\ensuremath{\{\!\mid #1 \mid\!\}}}
\newcommand{\PNil}{\ensuremath{\bullet}}
\newcommand{\PCons}[2]{\ensuremath{#1\,\textsf{/}\,#2}}
\newcommand{\Just}[1]{\ensuremath{\mathsf{Just(#1)}}}
\newcommand{\Nothing}{\ensuremath{\mathsf{Nothing}}}
\newcommand{\True}{\ensuremath{\mathsf{True}}}
\newcommand{\False}{\ensuremath{\mathsf{False}}}
\newcommand{\fn}[2]{\ensuremath{#1(#2)}}
\newcommand{\Sk}{k^{\tau_m}_{\tau_r}}
\newcommand{\SAdhoc}[1]{\ensuremath{\mathsf{Adhoc}({#1}^{\tau_m}_{\tau_r})}}
\newcommand{\SPred}[1]{\ensuremath{\mathsf{Pred}(#1)}}
\newcommand{\SPath}[2]{\ensuremath{#1 \mathrel{::} #2}}
\newcommand{\SPair}[3]{\ensuremath{\langle #1 {:} #2, #3 \rangle}}
\newcommand{\SOption}[1]{\ensuremath{#1?}}
\newcommand{\SSetComp}[3]{\ensuremath{\{ #1 \mid #2 \in #3 \}}}
\newcommand{\Env}{\ensuremath{\mathcal{E}}}
\newcommand{\ENil}{\ensuremath{\bullet}}
\newcommand{\yields}{\ensuremath{\rightsquigarrow}}
\newcommand{\valid}[1]{\ensuremath{\mathit{valid}(#1)}}
\newcommand{\typ}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\meta}{\typ{meta}}
\newcommand{\REP}{\ensuremath{\mathit{REP}}}
\newcommand{\PD}{\ensuremath{\mathit{PD}}}
\newcommand{\pd}[1]{\ensuremath{(#1)~\mathit{pd}}}
\newcommand{\eval}[2]{\ensuremath{\mathsf{eval}_{#1}(#2)}}
\newcommand{\pfile}{\ensuremath{\mathsf{F}}}
\newcommand{\ptext}{\ensuremath{\mathsf{T}}}
\newcommand{\pbin}{\ensuremath{\mathsf{B}}}
\newcommand{\pany}{\ensuremath{\mathsf{A}}}
\newcommand{\att}{\ensuremath{\mathsf{a}}}
\newcommand{\defaultatt}{\ensuremath{\att_{\mathsf{default}}}}
\newcommand{\repty}[1]{{\cal R}[\![ #1 ]\!]}
\newcommand{\mdty}[1]{{\cal M}[\![ #1 ]\!]}
\newcommand{\checkk}[3]{\fn{\mathit{ck}}{#1,#2,#3}}
\newcommand{\stringty}{{string}}
\newcommand{\metapdty}{{meta}}
 
\begin{figure}
\[
\begin{array}{rr@{\;}r@{\;}l}
\textit{Strings}        & n & \in & \Sigma^{\ast} \\[1ex]
\textit{Paths}          & r,s & \bnfdef & \PNil \mid \PCons{r}{n} \\[1ex]
\textit{Attributes}     & \att  & \bnfdef & \dots\\[1ex]
\textit{Filesystem}     & T  & \bnfdef & \File{n} \\
\textit{Contents}       &    & \bnfalt & \Dir{ \Set{n_1,\dots,n_k} }\\
                        &    & \bnfalt & \Link{r}\\[1ex]
\textit{Filesystems}    & F & \bnfdef & \Map{ r_1 \mapsto (\att_1,T_1), \dots r_k \mapsto (\att_k,T_k) }\\[1ex]
\textit{Values}         & v & \bnfdef & \att \bnfalt n \bnfalt r \bnfalt \True \bnfalt \False \bnfalt () \bnfalt (v_1,v_2) \\
                        &   & \bnfalt & \Just{v} \bnfalt \Nothing \bnfalt \{ v_1,\dots,v_k \}\\
\textit{Expressions}    & e & \bnfdef & x \bnfalt v \bnfalt \dots \\[1ex]
\textit{Environments}   & \Env & \bnfdef & \ENil \bnfalt E,x\mapsto v \\[1ex]
\textit{Specifications} & s & \bnfdef & \Sk \\
                        &   & \bnfalt & \SAdhoc{b}\\
                        &   & \bnfalt & \SPath{e}{s}\\
                        &   & \bnfalt & \SPair{x}{s_1}{s_2}\\
                        &   & \bnfalt & \SSetComp{s}{x}{e}\\
                        &   & \bnfalt & \SPred{e}\\
                        &   & \bnfalt & \SOption{s}\\[1ex]
\end{array}
\]
\caption{File systems and their specifications}
\label{fig:calculus-syntax}
\end{figure}

We have defined an idealized core calculus to that captures the
essence of \forest{}'s.  This calculus helped us to design various
aspects of the language and provides a compact way of describing the
central features of the language in a precise way.  It is inspired by
classical ({\em i.e.,} not separating, substructural or ambient)
unordered tree logics, customized slightly to our application domain.

\paragraph*{File system model and specification syntax.}
%
Figure~\ref{fig:calculus-syntax} presents the formal file system
model.  File paths $r$ are sequences of string names\footnote{For
  simplicity, we ignore the special path elements ``..'' and ``.''.
  It is easy to add these features, although the semantics becomes
  more complicated because path expressions must be normalized.}  and
file systems $F$ are finite partial maps from paths to pairs of file
attributes $\att$ and file system contents $T$.  We leave the
attribute records abstract; they should include the usual fields:
owner, group, date modified, {\it etc.}  We write $\defaultatt$ for
a default attribute record where necessary.  The contents $T$ of a
node in the file system may be a file $\File{n}$ (with underlying
string contents $n$), a directory $\Dir{ \Set{n_1,\dots,n_k} }$ (with
contents named $n_1, \ldots, n_k$) or a symbolic link $\Link{r}$
(where $r$ is the path pointed to by the link).

A file system model $F$ is {\em well-formed} if it is tree-shaped,
with directories forming internal nodes and files and symbolic links
at the leaves.  In addition, these conditions must hold:
\begin{itemize}
\item The domain of $F$ must be prefix-closed.
\item If $F(r) = (\att,\Dir{ \Set{n_1,\dots,n_k} })$ then for $i=1,\ldots,k$,
$\PCons{r}{n_i} \in \dom{F}$.
\item  If $F(r) = (\att,\File{n})$ or $(m,\Link{r'})$ then 
there does not exist $n$ such that $\PCons{r}{n} \in \dom{F}$.
\end{itemize}
% JNF: this sentence seems out of place...
% Checking functions for other constants such as directories, links,
% ascii or binary files may be defined similarly.

Figure~\ref{fig:calculus-syntax} also presents the syntax of a simple
computation language $e$ and our file system specifications $s$.  The
computation language $e$ contains values $v$, variables $x$, and other
operators, which we leave unspecified.  An environment $\Env$ maps
variables to values.  The semantic function $\eval{\tau}{\Env,F,r,e}$
evaluates an expression $e$ in an environment $\Env$ and file system
$F$ with respect to a current path $r$, yielding a value $v$ of type
$\tau$.

The simplest file system specifications are constants $k$, which range
over basic specifications such as those for files (\pfile), text files
(\ptext), binary files (\pbin), or any file system contents at all
(\pany).

\padshaskell{} specifications are modeled as \SAdhoc{b} where
$b^{\tau_m}_{\tau_r}$ is a parser---i.e., a total function from pairs
of environments and strings to pairs of type $\tau_r \times \tau_m$,
where the first element is the representation for the parsed data and
the second element is its metadata.

\forest{}'s surface syntax combines specifications for records and
paths into a single construct (and similarly for comprehensions and
paths). The calculus models (dependent) records, paths, and
comprehensions as independent, orthogonal constructs.  Record
specifications are written \SPair{x}{s_1}{s_2}, where $x$ may appear
in $s_2$.  Paths specifications are written $\SPath{e}{s}$, where $e$
is a path name (to be appended to the current path) and $s$ specifies
the fragment of the file system at that path. Comprenehsion
specifications are written $\SSetComp{s}{x}{e}$, where $e$ is a set of
values, $x$ is a variable, and $s$, which may depend on $x$, specifies
the fragment of the file system fragment for each value of $x$.
\forest{}'s combined record-and-path construct \cd{\{c is "c.txt" ::
  C, dat is "d.txt" :: D c\}} is encoded in the calculus as
$\SPair{x}{(\SPath{\mathtt{"c.txt"}}{C})}{(\SPath{\mathtt{"d.txt"}}{D\;
    x})}$.  Similarly, \forest{}'s comprehension-and-path construct
\cd{[x :: s | x <- e]} is encoded as the composition of
$\SSetComp{s_1}{x}{e}$ and $s_1 = \SPath{x}{s}$.

Predicate specifications $\SPred{e}$ succeed when $e$ evaluates to
\True{} and fail when $e$ evaluates to \False under the current
environment.  A \forest{} constraint of the form \cd{s where e} is
encoded in the calculus as a dependent pair with a predicate:
$\SPair{x}{s}{\SPred{e[x/\mathtt{this}]}}$

Finally, maybe specifications are written as $\SOption{s}$ in the
calculus.

\paragraph*{Calculus Semantics.}
%
The semantics of the calculus is organized into three separate
definitions, one for each of the three artifacts generated by the
\forest{} compiler. These definitions are spelled out in
Figure~\ref{fig:calculus-semantics} and \ref{fig:calculus-types}.

The first semantic judgement has the form $\Env;F;r \models s \yields
v,d$.  This judgement captures the behavior of the load function.
Intuitively, it states that in environment $\Env$ and file system $F$,
specification $s$ matches the file system fragment at current path $r$
and produces the representation $v$ and metadata $d$.  This judgement
may also be viewed as a total function from $\Env$, $F$, $r$ and $s$
to the pair $v$ and $d$.  The judgement is total because when file
system fragments fail to match the given specification, defaults are
generated for the representation $v$ and errors are recorded in the
metadata $d$.  This design is preferable to failing as it allows a
programmer to explore a file system fragment even when it contains
errors, as is common in ad hoc data repositories.

The rule for constants depends upon upon an auxiliary function 
{\it ck} (pronounced ``check'') that interprets the constants.  For
example, the {\it ck} function for the (\pfile) construct, which
describes any file (but not symbolic links or directories), is defined
as follows:
\[
\begin{array}{@{}l}
ck(\mbox{\sf F}^{\metapdty}_{\stringty},F,r) = (n,(\True,\att)), \mathrm{if } F(r) = (\att,\File{n}) \\
ck(\mbox{\sf F}^{\metapdty}_{\stringty},F,r) = ("",(\False,\att)), \mathrm{if } F(r) = (\att,T), T \not=\File{n} \\
ck(\mbox{\sf F}^{\metapdty}_{\stringty},F,r) = ("",(\False,\defaultatt)), \mathrm{otherwise}
\end{array}
\]

The rule for \padshaskell{} parsers, and several of the other rules,
use the function $valid(d)$.  This function extracts a boolean from
the metadata structure $d$, returning $\True$ if there are no errors
in the structure and $\False$ otherwise. 

The second and third semantic judgements specify the representation
and metadata types for a given specification.  They have the form
$\repty{s} = \tau$ and $\mdty{s} = \tau$, respectively.  The three
sets of definitions obey the following basic coherence property, where
$\turn v : \tau$ states that the value $v$ has type $\tau$.

\begin{proposition}
  If $\Env;F;r \models s \yields v,d$ and $\repty{s} =
  \tau_{\mathcal{R}}$ and $\mdty{s} = \tau_{\mathcal{M}}$ then $\turn
  v : \tau_{\mathcal{R}}$ and $\turn d : \tau_{\mathcal{M}}$
\end{proposition}

\jnf{ The metadata type for adhoc is $\tau_m~\mathit{pd}$ but the
  actual metadata computed by the inference rule below is
  $(\valid{d},(d,a))$ which has type $(\tau_m \times
  \meta)~\mathit{pd}$. We can fix this either by eliminating the
  metadata or by changing the definition of $\mdty{\cdot}$. I'm not
  sure which is better?}

\begin{figure}
\[
\infrule
{ }
{ \Env;F;r \models \Sk \yields \checkk{\Sk}{F}{r} }
{}
\]

\[
\infrule
{ F(r) = (\att,\File{n}) \qquad 
  b^{\tau_m}_{\tau_r}(E,n) = v,d }
{ \Env;F;r \models \SAdhoc{b} \yields v,(\valid{d},(d,\att)) }
{ }
\]

\[
\infrule
{ %\begin{array}{l}
  F(r) = (\att,T) \qquad T \neq \File{n} \qquad
  b^{\tau_m}_{\tau_r}(E,\epsilon) = (v,d)
  %\end{array} 
}
{ \Env;F;r \models \SAdhoc{b} \yields v,(\False,(d,\att)) }
{}
\]

\[
\infrule
{ 
  r \not\in \dom{F}  \qquad
  b(E,\epsilon) = (v,d)
}
{ \Env;F;r \models \SAdhoc{b} \yields v,(\False,(d,\defaultatt)) }
{}
\]

\[
\infrule
{ \Env;F;\eval{path}{E,F,r,\PCons{r}{e}} \models s \yields v,d }
{ \Env;F;r \models \SPath{e}{s} \yields v,d }
{ }
\]

\[
\infrule
{ \begin{array}{c}
  \Env;F;r \models s_1 \yields v_1,d_1 \\
  \Env[x \mapsto v_1, x_d \mapsto d_1];F;r \models s_2 \yields v_2,d_2 \\
%  v = (v_1,v_2) \qquad d = (d_1,d_2) 
  \end{array} }
{ \Env;F;r \models \SPair{x}{s_1}{s_2} \yields (v_1,v_2),(\valid{d_1} \wedge \valid{d_2}, (d_1,d_2)) }
{ }
\]

\[
\infrule
{ \begin{array}{c}
  \eval{(\tau\ set)}{\Env,F,r,e} = \{ v_1,\dots,v_k \} \\
  S = \Set{ (v,d) \mid v' \in \{ v_1,\dots,v_k \} \text{ and } \Env[x \mapsto v'];F;r \models s \yields v,d }
  \end{array} }
{ \Env;F;r \models \SSetComp{s}{x}{e} \yields \pi_1~S,(\bigwedge~\valid{\pi_2~S}, \pi_2~S) }
{ }
\]


\[
\infrule
{ }
{ \Env;F;r \models \SPred{e} \yields (),(\eval{bool}{E,F,r,e},()) }
{ }
\]


\[
\infrule
{ r \not\in \dom{F} }
{ \Env;F;r \models \SOption{s} \yields \Nothing,(\False,\Nothing) }
{ }
\]

\[
\infrule
{ r \in \dom{F} \qquad \Env;F;r \models s \yields v,d }
{ \Env;F;r \models \SOption{s} \yields \Just{v},(\valid{d},\Just{d}) }
{ }
\]


\caption{\forest{} calculus semantics}
\label{fig:calculus-semantics}
\end{figure}

\begin{figure}

\[
\begin{array}{lcl}
\repty{\Sk} & = & \tau_r \\
\repty{\SAdhoc{b}} & = & \tau_r \\
\repty{\SPath{e}{s}} & = & \repty{s} \\
\repty{\SPair{x}{s_1}{s_2}} & = & \repty{s_1} \times \repty{s_2} \\
\repty{\SSetComp{s}{x}{e}} & = & \repty{s}~\typ{list}  \\
\repty{\SPred{e}} & = & \typ{unit} \\
\repty{\SOption{s}} & = & \repty{s}~\typ{option}  \\
\\
\mdty{\Sk} & = & \tau_m~\mathit{pd}\\
\mdty{\SAdhoc{b}} & = & \tau_m~\mathit{pd}\\
\mdty{\SPath{e}{s}} & = & \mdty{s} \\
\mdty{\SPair{x}{s_1}{s_2}} & = & \pd{\mdty{s_1} \times \mdty{s_2}} \\
\mdty{\SSetComp{s}{x}{e}} & = & \pd{\mdty{s}~\typ{list}}  \\
\mdty{\SPred{e}} & = & \typ{unit}~\mathit{pd}\\
\mdty{\SOption{s}} & = & \pd{\mdty{s}~\typ{option}}  \\
\\
\tau~\mathit{pd} & = & \typ{header} \times \tau \\
\typ{header} & = & \typ{bool} 
\end{array}
\]
\caption{\forest{} calculus data and metadata types}
\label{fig:calculus-types}
\end{figure}
