***********************************************
Metavariables:

e ::= x | R        (host language expressions)
c ::= a | b | ...  (characters)
EOR                (special end-of-record character)
s ::= c1,...,cn    (strings)
i ::= 0 | 1 | ...  (integers)
re ::= epsilon | re1 . re2 | ... (regular expressions)

***********************************************
Notation:

s1.s2   (concatenation of strings)

prefix(s)  (set of prefixes of s)
sprefix(s) (set of strict prefixes of s)

***********************************************
Descriptions:

Base ::= Pint | PstringME(re) | PstringFW(e) 

D ::=
  Base 
| Sync(s)                 (* constraint: s must not be the empty string *)
| D1 * D2                 -- consider unifying with dependent down-stream
| x:D1 . D2 
| D1 + D2 
| D array(s_sep, s_term)  (* constraint: s_sep, s_term must not be empty *)
    		 	  -- consider adding switched unions, 
			  -- fixed length arrays
***********************************************
Metric:
m ::= int * int  (* number of tokens with errors, total tokens parsed  *)

(n1,n1') + (n2,n2') = (n1 + n2, n1' + n2')    (metric addition)

(n1,n1') <= (n2,n2') iff n1/n1' <= n2/n2'

-- other candidate metric: edit distance
-- good(D) = #insertions, deletions, substitutions in string needed to parse
***********************************************
Data Representation:

Representations for Base Types
BaseR ::= 
  Str s 
| Int i 
| Error          (* Base tokens either parse completely correctly or
                    not at all.  The not at all case being error. *) 

Synchronizing Token Parse Descriptor:
SyncR ::=        
  Good 
| Recovered s    (* string up to, not including good parse of synch token *)
| Fail           (* unable to parse synch token; no data is consumed *)

Representations for Complex Descriptions
R ::=
  BaseR
| SyncR 
| (R1, R2)
| inl R | inr R
| array (R list, SyncR list, SyncR)

Environment:
E : name -> R 

Main judgement:
	(R, m) \in L(D, E, s, s')

-- s is the string parsed by D
-- s' is the look-ahead

-- Generalize this to each base type having a reg exp pattern and a
   function to embed it with the right type.
-- Modified functions below to have longest match semantics for base types

(Int (int_of_string s), (0, 1)) \in L(Pint, E, s, s'), 
    if s \in L((+|-)?[0-9]+) and (L([0-9]) \intersect prefix(s') = {})
(Error, (1, 1)) \in L(Pint, E, "", s')

(Str s, (0, 1)) \in L(PstringME(re), E, s, s'),  
    if s \in L(re) and s.s'' \not\in L(re) and s'' \in prefix(s')
(Error, (1, 1)) \in L(PstringME(re), E, "", s'), if "" \not \in L(re)

(Str s, (0, 1)) \in L(PstringFW(e), E, s, s'), if E(e) = Int k and s = c1...ck 
(Error, (1, 1)) \in L(PstringFW(e), E, "", s'), if E(e) not= Int k for any k.
(Error, (1, 1)) \in L(PstringFW(e), E, "", s'), if E(e) = Int k and k > 0.

(Good, (0, 1)) \in L(Sync(s), E, s, s')
(Recovered s1, (1, 1)) \in L(Sync(s2), E, s, s'), if
                        s=s1.s2 and s2 \not\in sprefix(s1.s2)
(Fail, (1, 1)) \in L(Sync(s2), E, "", s')

((R1, R2), (m1 + m2)) \in L(D1 * D2, E, s1.s2) 
  	if (R1, m1) \in L(D1, E, s1, s2.s'),
     	   (R2, m2) \in L(D2, E, s2, s')

((R1, R2), (m1 + m2)) \in L(x:D1 . D2, E, s1.s2, s')
	if (R1, m1) \in L(D1, E, s1, s2.s'), 
	   (R2, m2) \in L(D2, E[x->R1], s2, s')

(inl R, m) \in L(D1 + D2, E, s, s') 
	if (R, m) \in L(D1, E, s, s')

(inr R, m) \in L(D1 + D2, E, s, s') 
	if (R, m) \in L(D2, E, s, s')

(array([R1,...,Rn], [SyncR1,...,SyncR(n-1)], SyncR_term), m) 
    \in L(D array (s_sep, s_term), E, s, s')
	if  
	s = s1.s(sep,1).s2.s(sep,2)...s(n-1).s(sep, n-1).sn.s',
        lookaheadfori = s(sep,i).s(i+1).....sn.s'
        lookaheadforsepi = s(i+1)....sn.s'              
        s' = s1'.lookaheadforterm

	forall i \in [1, n]:
	  (Ri, mi) \in L(D, E, si, lookaheadfori),
	forall i \in [1, n-1]:
	  (SyncRi, m(s,i)) \in L(Sync(s_sep), E, s_(sep,i), lookaheadforsepi),

	(SyncR_term, m_term) \in L(Sync(s_term), E, s1', lookaheadforterm),
	m = (\sum_(i= 1 to n) mi) + (\sum(i=1 to n-1) m(s,i)) + m_term

R \in L(D, s) iff 
  (R, m) \in L(D, ., s, "") and for all (R',m') \in L(D, ., s, ""), m <= m'

