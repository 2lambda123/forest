***********************************************
Metavariables:

e ::= x | R        (host language expressions)
c ::= a | b | ...  (characters)
s ::= c1,...,cn    (strings)
i ::= 0 | 1 | ...  (integers)
re ::= epsilon | re1 . re2 | ... (regular expressions)

***********************************************
Notation:

s1.s2   (concatenation of strings)

(n1,n1') + (n2,n2') = (n1 + n2, n1' + n2')    (metric addition)

(n1,n1') <= (n2,n2') iff n1/n1' <= n2/n2'

***********************************************
Descriptions:

Base ::= Pint | PstringME(re) | PstringFW(e) 

D ::=
  Base 
| Sync(s)                 (* constraint: s must not be the empty string *)
| D1 * D2 
| x:D1 . D2 
| D1 + D2 
| D array(s_sep, s_term)  (* constraint: s_sep, s_term must not be empty *)

***********************************************
Metric:
m ::= int * int  (* number of errors, total tokens parsed *)

***********************************************
Data Representation:

Synchronizing Token Parse Descriptor:
SyncR ::= 
  Good 
| Recovered s    (* string up to, not including good parse of synch token *)
| Fail s         (* unable to parse synch token; string s is consumed *)

Representations for Base Types
BaseR ::= 
  Str s 
| Int i 
| Error          (* Base tokens either parse completely correctly or
                    not at all.  The not at all case being error. *) 

Representations for Complex Descriptions
R ::=
  BaseR
| SyncR 
| (R1, R2)
| inl R | inr R
| array (R list, SyncR list, SyncR)

Environment:
E : name -> R 

Main judgement:
	(R, m) \in L(D, E, s)

(Int (int_of_string s), (0, 1)) \in L(Pint, E, s), if s \in L((+|-)?[0-9]+)
(Error, (1, 1)) \in L(Pint, E, "")

(Str s, (0, 1)) \in L(PstringME(re), E, s), if s \in L(re)
(Error, (1, 1)) \in L(PstringME(re), E, ""), if "" \not \in L(re)

(Str s, (0, 1)) \in L(PstringFW(e), E, s), if E(e) = Int k and s = c1...ck 
(Error, (1, 1)) \in L(PstringFW(e), E, ""), if E(e) not= Int k for any k.
(Error, (1, 1)) \in L(PstringFW(e), E, ""), if E(e) = Int k and k > 0.

(Good, (0, 1)) \in L(Sync(s), E, s)
(Recovered s1, (1, 1)) \in L(Sync(s2), E, s1.s2)
(Fail (s1.EOR), (1, 1)) \in L(Sync(s2), E, s1.EOR)
(Fail "", (1, 1)) \in L(Sync(s2), E, "")

((R1, R2), (m1 + m2)) \in L(D1 * D2, E, s1.s2) 
  	if (R1, m1) \in L(D1, E, s1),
     	   (R2, m2) \in L(D2, E, s2)

((R1, R2), (m1 + m2)) \in L(x:D1 . D2, E, s1.s2)
	if (R1, m1) \in L(D1, E, s1), 
	   (R2, m2) \in L(D2, E[x->R1], s2)

(inl R, m) \in L(D1 + D2, E, s) 
	if (R, m) \in L(D1, E, s)

(inr R, m) \in L(D1 + D2, E, s) 
	if (R, m) \in L(D2, E, s)

(array([R1,...,Rn], [SyncR1,...,SyncR(n-1)], SyncR_term), m) 
    \in L(D array (s_sep, s_term), E, s)
	if  
	s = s1.s(sep,1).s2.s(sep,2)...s(n-1).s(sep, n-1).sn.s_term,
	forall i \in [1, n]:
	  (Ri, mi) \in L(D, E, si),
	forall i \in [1, n-1]:
	  (SyncRi, m(s,i)) \in L(Sync(s_sep), E, s_(sep,i)),
	(SyncR_term, m_term) \in L(Sync(s_term), E, s_term),
	m = (\sum_(i= 1 to n) mi) + (\sum(i=1 to n-1) m(s,i)) + m_term

R \in L(D, s) iff 
  (R, m) \in L(D, ., s) and for all (R',m') \in L(D, ., s), m <= m'

