\section{\ipads{}:  An Idealized DDL}
\label{sec:ipads}

In this section, we define \ipads{}, an idealized data description
language.  \ipads{} captures the essence of \padsc{} and related data
description languages such as \padsml{}, \packettypes{}, and
\datascript{} in a fashion similar to the way that
MinML~\cite{harper:plbook} captures the essence of ML or Featherweight
Java~\cite{igarasi+:featherweight} captures the essence of Java.  The
main goal of this section is to introduce the form and function of
\ipads{} by giving its syntax and explaining several examples.  Later
sections show how to give a formal semantics to \ipads{}.

\paragraph*{Preliminary Concepts}
As in \padsc{}, \padsml{}, 
\packettypes{}, and \datascript{}, the  data
descriptions in \ipads{} are types.  These types specify both the external data
format (a sequence of bits or characters) and a mapping into a
data structure in the host programming language.  In \padsc{},
the host language is C; in \ipads, the host language is an extension
of the polymorphic lambda calculus.  For the most part, however, the
specifics of the host language are unimportant.

A complete \ipads{} description is a sequence of type definitions
terminated by a single type.  This terminal type describes the
entirety of a data source, making use of the previous 
type definitions to do so.  \ipads{} type definitions can have one of
two forms.  The form ($\alpha = \itmv$) introduces the type identifier
$\alpha$ and binds it to \ipads{} type $\itmv$.
The type identifier may be used in
subsequent types.  The second form  ($\Prec{}\; \alpha = \itmv$) introduces
a recursive type definition.  In this case, $\alpha$ may appear in 
$\itmv$.

Complex \ipads{} descriptions are built by using type constructors to glue together a collection of simpler types. In our examples, we
assume \ipads{} contains a wide variety of base types including
integers (\Puint{} is an ASCII representation of an unsigned
integer that may be represented internally in 32 bits), 
characters (\Pchar), strings (\Pstring), dates
(\Pdate), IP addresses (\Pip), and others.  In general, these base
types may be parameterized.  For instance, we will assume \Pstring{} is
parameterized by an argument that signals termination of the
string.  For example, \Pstring({\tt " "}) describes any sequence of
characters terminated by a space. 
(Note that we do not consider the space to be part of the parsed string; 
it will be part of the next object.)
Similarly, \padskw{Puint16$\_$FW}{\tt (3)} is an unsigned 16-bit
integer described in exactly {\tt 3} characters in the data source.
In general, we write $\pbase{e}$ for a base type $C$ parameterized by a
(host language) expression $e$.

When interpreted as a parser, each of these base types reads
the external data source and generates a pair of data structures
in the host language.  The first data structure is the
{\em internal representation}  and
the second is the {\em parse descriptor}, which contains metadata collected during parsing.
For instance, \Puint{} reads a series of digits and generates an unsigned 32-bit integer as its
internal representation.  \Pstring{} generates a 
host-language string.  
\Pdate{} might read dates in a multitude of
different formats, but always generates a tuple
with time, day, month, and year fields as its internal 
representation.  Whenever an \ipads{} parser encounters
an unexpected character or bit-sequence, it sets the internal representation to
$\ierr$ (\ie{} null) and notes the error in the
parse descriptor.

\paragraph*{An \ipads{} Example}
\ipads{} contains a rich collection of type constructors for creating
sophisticated descriptions of ad hoc data.  We present these
constructors through a series of examples.  The first example, shown
in \figref{fig:ipads-clf}, describes the Common Web
Log Format~\cite{wpp}, which web servers use to log the requests they
receive.  \figref{fig:ipads-clf-data} shows two sample
records.  Briefly, each line in a log file represents one request;
a complete log may contain any number of requests.  A request begins
with an IP address followed by two optional identifiers.  In the
example, the identifiers are missing and dashes stand in for them.  Next is a date,
surrounded by square brackets.  A string in
quotation marks follows, describing the request.  Finally,
a pair of integers denotes the response code and the
number of bytes returned to the client.

The \ipads{} description of web logs is most easily read from bottom to top.
The terminal type, which describes an entire web log, is an array type.
Arrays in \ipads{} take three arguments: a description
of the array elements (in this case, {\tt entry$\_$t}),
a description of the separator that appears between elements
(in this case, a newline marker \Peor{}), and 
a description of the terminator (in this case, the end-of-file marker).
\padsc{} itself provides a much wider selection of separators and
termination conditions, but these additional variations are of little semantic 
interest so we omit them from \ipads.  
The host language representation for 
an array is a sequence of elements. We do not represent separators or terminators internally.

We use a \Pstruct{} to describe the contents of each line in a web log.
Like an array, a \Pstruct{} describes a sequence of 
objects in a data source.  We represent the result of parsing a \Pstruct{} 
as a tuple in the host language.  The elements
of a \Pstruct{} are either named fields (\eg{} {\tt client {:} \Pip{}}) or
anonymous fields (\eg{} {\tt "~["}).  The \Pstruct{} {\tt
entry$\_$t} declares that the first thing on the line
is an IP address (\Pip) followed by a space
character ({\tt " "}).  Next, the data should contain an {\tt
authid$\_$t} followed by another space, \etc{}

The last field of {\tt entry$\_$t} is quite different from the others.
It has a \Pcompute{} type, meaning it does not match any characters in
the data source, but it does form a part of the internal representation
used by host programs.  The argument of a \Pcompute{}
field is an arbitrary host language expression (and its
type) that determines the value of the associated field.  In the example, the
field {\tt academic} computes a boolean that indicates whether 
the web request came from an academic site. Notice that the computation
depends upon a host language value constructed earlier --- the value
stored in the {\tt client} field.  \ipads{} structs are a form
of dependent record and, in general, later fields may
refer to the values contained in earlier ones.

The {\tt entry$\_$t} description uses the type {\tt authid$\_$t} to
describe the two fields {\tt remoteid} and {\tt localid}.  The {\tt
authid$\_$t} type is a \Punion{} with two branches.  Unions are
represented internally as sum types.  If the data source can be
described by the first branch (a dash), then the internal
representation is the first injection into the sum.  If the data
source cannot be described by the first branch, but can be described
by the second branch then the internal representation is the second
injection.  Otherwise, there is an error.

Finally, the {\tt response$\_$t} type is a \Pfun, a user-defined
parameterized type.  The parameter of {\tt response$\_$t} is a host
language integer.  The body of the \Pfun{} expression is a \padskw{Puint16$\_$FW}
where \cd{x}, the fixed width, is the argument of the function.  In
addition, the value of the fixed-width integer is constrained by the
\Pwhere{} clause.  In this case, the \Pwhere{} clause demands that
the fixed-width integer {\tt y} that is read from the source lie 
between 100 and 599.
Any value outside this range will be considered a semantic error.
In general, a \Pwhere{} clause may be attached to 
any type specification.  It closely resembles the 
semantic constraints found in practical parser generators such as
{\sc antlr}~\cite{antlr}.

% Note that $\itmv \; \Pwhere{} \, x.e$ binds $x$ in $e$. 

\begin{figure}
{\small
\begin{code}
authid\_t = \Punion{} \{
  unauthorized : "-";
  id           : \Pstring (" ");
\};
\(\qquad\)
response\_t =
  \Pfun(x:int) =
   \padskw{Puint16\_FW}(x) \Pwhere{} y.100 <= y and y < 600;
\(\qquad\)
entry\_t = \Pstruct{} \{
  client   : \Pip{};             " ";
  remoteid : authid\_t;        " ";
  localid  : authid\_t;        " [";
  date     : \Pdate("]");      "] \(\backslash\)"";
  request  : \Pstring("\(\backslash\)"");   "\(\backslash\)" ";
  response : response\_t 3;    " "; 
  length   : \Puint{};
  academic : \Pcompute (getdomain client) == "edu" : bool;
\};
\(\qquad\)
entry\_t \Parray{}(\Peor, \Peof)
\end{code}

\caption{\ipads{} Common Web Log Format Description}
\label{fig:ipads-clf}
}
\end{figure}

\begin{figure}
{\small
\begin{code}
{}207.136.97.49 - - [15/Oct/1997:18:46:51 -0700] 
"GET /tk/p.txt HTTP/1.0" 200 30
tj62.aol.com - - [16/Oct/1997:14:32:22 -0700] 
"POST /scpt/confirm HTTP/1.0" 200 941
\end{code}
\caption{Sample Common Web Log Data. Each record is broken with a
  newline to format it on this page.}
\label{fig:ipads-clf-data}
}
\end{figure}

\paragraph*{A Recursive \ipads{} Example}
Figure~\ref{fig:ipads-newick} presents a second \ipads{} example.
In this example, \ipads{} describes the Newick Standard format, a flat
representation of tree-structured data.  The leaves of the trees
are names that describe an ``entity.''   In our variant of Newick Standard, 
leaf names may be omitted.  If the leaf name does appear,
it is followed by a colon and a number.  The number describes the ``distance''
from the parent node.  Microbiologists often use
distances to describe the
number of genetic mutations that have to occur to move from the parent 
to the child.  An internal tree node may have any number of (comma-separated)
children within parentheses.  Distances follow the closing parenthesis
of the internal tree node.

The Newick Standard format and other formats that describe tree-shaped 
hierarchies~\cite{geneontology,newick-data}
provide strong motivation for including recursion in \ipads.  
We have not been able to find any useable description of Newick data as
simple sequences (structs and arrays) and alternatives (unions); some
kind of recursive description appears essential.
The definition of the type {\tt tree\_t} introduces recursion.
It also uses the type \Popt\ $t$, a trivial union that 
either parses $t$ or nothing at all.


\begin{figure}
{\small
\begin{code}
node\_t = \Popt \Pstruct \{
                name : \Pstring(":"); ":";
                dist : \Puint;  
              \};
\(\qquad\)
\Prec tree\_t = \Punion \{
    internal : \Pstruct \{
        "(";  branches : tree\_t \Parray(",",")");
        "):"; dist : \Puint;
      \};
    leaf : node\_t;
  \};
\(\qquad\)
\Pstruct \{ body : tree\_t; ";"; \}
\(\qquad\)
(* Example: (B:3,(A:5,C:10,E:2):12,D:0):32; *)
\end{code}
\caption{\ipads{} Newick Format Description}
\label{fig:ipads-newick}
}
\end{figure}

\paragraph*{Formal Syntax}
\figref{fig:ipads-syntax} summarizes the formal syntax of \ipads.
Expressions $e$ and types $\sigma$ are taken from the host language,  
described in \secref{sec:host-lang}. 
Notice, however, that we use $x$ for host
language expression variables and $\alpha$ for \ipads{} type
variables.
In the examples, we have abbreviated the syntax in places.  
For instance, we omit the operator ``\padskw{Plit}'' and formal label 
$x$ when specifying constant types in \Pstruct{}s, writing
``$c;$'' instead of ``$x :
\Plit{c};$''. In addition, all
base types $C$ formally have a single parameter, but we have omitted
parameters for base types such as \Puint.  
Finally, the type $\Palt{}$, which did not appear in the
  examples, describes data that is described by all the branches
  simultaneously and produces a set of values - one from each type.
Intuitively, $\Palt{}$ is a form of intersection type.

\begin{figure}
{\small
\begin{bnf}
%   \mname{Type Definitions}{2} \meta{d} \::= \alpha = \itmv
%   \|  \Prec{} \; \alpha = \itmv \\ \\
  \name{Types} \meta{\itmv} \::= 
    \pbase{e} \| \Plit{\const} \|
    \Pfun{} (\var:\ity) = \itmv \| \itmv\; e \nlalt
    \Pstruct{} \{\overrightarrow {\var{:}\itmv}\} \| 
    \Punion{} \{\overrightarrow {\var{:}\itmv}\} \|
    \Palt{} \{\overrightarrow {\var{:}\itmv}\} \|
    \itmv \; \Pwhere{} \, x.e \nlalt
    \Popt{}\; \itmv \|
    \iParray{\itmv}{\itmv}{\itmv}{} \| 
    \Pcompute{} \; e{:}\ity \|
     \alpha \| \Prec{} \; \alpha . \itmv
     \\
%   \mname{Host Lang. Expressions}{2} \meta{e}  \::= ... \\ \\
%   \mname{Host Lang. Types}{2} \meta{\sigma}  \::= ...
  \name{Programs} \meta{p} \::= \itmv \| \alpha = \itmv;\,\nont{p} \|
  \Prec{} \; \alpha = \itmv;\,\nont {p}
\end{bnf}
\caption{\ipads{} Syntax}
\label{fig:ipads-syntax}
}
\end{figure}


% \subsection{Example}
% \begin{itemize}
% \item Use two data sources, one buggy one not.
% \item explain data.
% \item show IPADS desc. of data source.
% \item explain remaining features.
% \end{itemize}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "semantics"
%%% End: 

