\section{A Data Description Calculus}
\label{sec:ddc}

At the heart of our work is a data description calculus (\ddc{}),
containing simple, orthogonal type constructors designed to capture
the core features of data description languages.  Consequently, the
syntax of \ddc{} is at a significantly lower level of abstraction than
that of \padsc{}, \padsml{} or \ipads.  Like any of these languages, 
however, the form and function of \ddc{} features are directly 
inspired by type theory.  

Informally, we may divide the features that make up \ddc{} into types and
type operators. Each \ddc{} type describes the external representation
of a piece of data and implicitly specifies how to transform that
external representation into an internal one.  The internal
representation includes both the transformed value and a \textit{parse
  descriptor} that characterizes the errors that occurred during
parsing. Type operators provide for description reuse by abstracting
over types.

Syntactically, the primitives of the calculus are similar to the types
found in many dependent type systems, with a number of additions
specific to the domain of data description.  The types are {\em dependent} 
because data parsed earlier often guides parsing of later data
(\ie the form of the later data {\em depends} on the earlier data).
In addition, parsing ad hoc formats correctly
often involves checking constraints 
phrased as expressions in some conventional programming language.
%
% We base our calculus on a
% {\em dependent} type theory because we both need to represent
% constraints
% the latter parts of a data format
% often depend directly on values parsed at the beginning of the format.
% However, unlike other dependent
% type systems, \ddc\ is not part of a programming language.  Therefore,
% there is no ``obvious'' choice for an expression language from which
% to draw the expressions that appear in \ddc\ types.
%
Data description languages tend to draw their expressions
from their {\em host language} -- the programming language in which
their generated software artifacts are encoded.  The host language of
\padsc{}, for example, is C and therefore the \padsc{} constraint
language is also C.  We mimic this design in
\ddc{} and choose a single language -- a variant of the polymorphic 
lambda calculus \fomega\cite{girard:SystemF,reynolds:SystemF} -- for
expressing both the expressions embedded in types and the
interpretations of \ddc. This host language is discussed further in
\secref{sec:host-lang}.

\subsection{\ddca{} Syntax}
\label{sec:ddc-syntax}

\figref{fig:ddca-syntax} shows the syntax of \ddc{}. Expressions $e$
and types $\ity$ belong to the host language, which we define in \secref{sec:host-lang}.  
We use kinds $\kind$ to classify types. 
In particular, kind $\kty$ classifies types that directly describe
data.  Types with this kind include integers, 
pairs of IP addresses and strings of length ten, \etc{}
Kind $\ity \iarrowi \kind$ describes
functions from values with type $\ity$ to types with arbitrary kind
$\kind$.  An example of a type with such a kind is base type
constructor \cd{Pstring_FW} that takes as an argument an integer
expression $e$ and returns a string with length $e$.
Finally, kind $\kty \iarrowi \kind$ classifies
functions from first-order types (those having kind $\kty$) to
arbitrary types (those having kind $\kind$).  
A useful type with such a kind is a function that takes any
first-order type $\tau$ as an argument and returns the type that
describes data corresponding to either $\tau$ or the string
\texttt{``N/A''}, indicating a missing value.
This kinding system disallows types that take type functions as
arguments.  Such types add complexity to the system, and we have not
encountered a compelling need for them in practice. 

The most basic types are $\ptrue$ and $\pfalse$.  Type $\ptrue$
describes the empty string; it succeeds on all input.  While vacuous
by itself, the type $\ptrue$ is useful when combined with 
other type constructors.  For example, a type that unions an integer
type with $\ptrue$ corresponds to an optional integer.  In contrast,
the type $\pfalse$ describes no strings; it fails on all input.  
When used within a compound type containing choices, $\pfalse$
indicates that the choice leading to $\pfalse$ fails and an
alternative branch must be chosen.  We will see another use of
$\pfalse$ when we discuss array types.

The syntax $\pbase e$ denotes a base type $C$ parameterized by 
expression $e$.  
% An instance of the \ddc{} will provide a set of base types $C$.
 Such a base type recognizes and transforms atomic values within the data
 source; typical examples include strings, various kinds of integers,
 dates, times, \etc{} The parameter expression plays a type-dependent role,
 specifying, for example, digit lengths for integers or terminating
 conditions for strings.

We provide abstraction $\plam x {} \ty$ and application
$\papp \ty e$ so that we may parameterize types by expressions.

Dependent sum types $\psig x {\ty_1} {\ty_2}$ describe a sequence
of values in which the second type may refer to the value of the first.
Sum types $\psum {\ty_1} {} {\ty_2}$
express flexibility in the data format, as they describe
data matching either $\ty_1$ or $\ty_2$. Unlike regular expressions or
context-free grammars, which allow nondeterministic choice,
sum-type parsers
are deterministic, transforming the data according to $\ty_1$
when possible and {\it only} attempting to
use $\ty_2$ if there is an error in $\ty_1$. Intersection types
$\pand {\ty_1} {\ty_2}$ describe data that match both $\ty_1$ and
$\ty_2$. They transform a single set of bits to produce
a pair of values, one from each type. Constrained types $\pset x \ty e$
transform data according to the underlying type $\ty$ and
then check that the constraint $e$ holds when $x$ is bound to the parsed value.


\begin{figure}
\begin{bnf}
  \name{Kinds} \meta{\gk} \::= \kty \| \ity \-> \gk 
                               \| \kty \-> \gk \\
  \name{Types} \meta{\ty} \::= 
    \ptrue\| \pfalse \| \pbase{e} \| 
    \plam{\var}{\ity}{\ty} \| \papp{\ty}{e} \nlalt
    \psig x \ty \ty \| \psum \ty e \ty \| \pand \ty \ty \|
    \pset x \ty e \| \pseq \ty \ty {\pterm e \ty} \nlalt
    \ptyvar       \| \pmu{\ptyvar}{\gk}{\ty} \| \ptylam{\ptyvar}{\kty}{\ty} \| \ptyapp{\ty}{\ty}
    \nlalt \pcompute e \ity \| \pabsorb \ty \| \pscan{\ty}  
\end{bnf}
\caption{\ddc{} syntax}
\label{fig:ddca-syntax}
\end{figure}

The type $\pseq \ty {\ty_s} {\pterm e {\ty_t}}$ represents a sequence
of values of type $\ty$. The type $\ty_s$ specifies the type of the
separator found between elements of the sequence. For sequences
without separators, we use $\ptrue$ as the separator type.  Expression
$e$ is a boolean-valued function that examines the parsed sequence
after each element is read to determine if the sequence has completed.
For example, a function that checks if the sequence has $100$ elements
would terminate a sequence when it reaches length $100$.  The type
$\ty_t$ is used when data following the array will signal termination.
%\edcom{M: explain singleton types or reword. Reword until end of
%  paragraph.}  
Commonly, constrained types are used to specify that a particular
value terminates the sequence.  For example, the type
$\pset{x}{\Pchar}{x = ';'}$ specifies that a semicolon terminates the
array. However, if no particular value or set of values terminates the
array, then a type that never succeeds (like $\pfalse$) could be used
to ensure that the array is not terminated based on $\ty_t$.

Type variables $\ptyvar$ are abstract descriptions; they are
introduced by recursive types and type abstractions. Recursive types
$\pmu{\ptyvar}{\gk}{\ty}$ describe recursive formats, like lists and
trees. Type abstraction $\ptylam{\ptyvar}{\kty}{\ty}$ and application
$\ptyapp{\ty}{\ty}$ allow us to parameterize types by other types.
Type variables $\ptyvar$ always have kind $\kty$. Note that we call
functions from types to types {\em type abstractions} in contrast to
{\em value abstractions}, which are functions from values to types.

\ddc{} also has a number of ``active'' types.  These types describe
actions to be taken during parsing rather than strictly describing the
data format. Type $\pcompute e \ity$ allows us to include an element
in the parsed output that does not appear in the data stream (although
it is likely dependent on elements that do), based on the value of
expression $e$.  In contrast, type $\pabsorb \ty$ parses data
according to type $\ty$ but does not return its result. This behavior
is useful for data that is important for parsing, but uninteresting to
users of the parsed data, such as a separator. The last of the
``active'' types is $\pscan \ty$, which scans the input for data that
can be successfully transformed according to $\ty$. This type provides
a form of error recovery as it allows us to discard unrecognized data
until the ``synchronization'' type $\ty$ is found.

\subsection{\Implang{} Language}
\label{sec:host-lang}
\begin{figure}[tp]
\begin{bnf}
%   \name{Variables} \meta{f,x,y} \\
%   \name{Bit}   \meta{b}   \::= 0 \| 1 \\ 
  \name{Bits}  \meta{B}   \::= \cdot \| 0\,B \| 1\,B \\ 
  \name{Constants} \meta{c} \::=
      () \| \itrue \| \ifalse \| 0 \| 1 \| -1 \| \dots \nlalt
      \ierr \| \data \| \off \| \iok \| \iecerr \| \iecpc \| \ldots \\

  \name{Values} \meta{v} \::= 
      \const \| % \ilam{\nrm \var}{\ity}{e} \| 
      \ifun {\nrm f} {\nrm x} e \| \ipair v v \nlalt
      \iinld{\ity}{v} \| \iinrd{\ity}{v} \|
      \iarr{\vec{v}} \\

  \name{Operators} \meta{op} \::= 
      = \; \| \; < \; \| \inotop % \| \isizeofop
      \| \ldots \\

  \name{Expressions} \meta{e} \::= 
      \const \| \var \| \iop{e} \|
%      \ilam {\nrm \var} \ity e \| 
      \ifun {\nrm f} {\nrm x} e \| 
      \iapp e e \nlalt
    \Lambda \alpha.e \| e \; [\ty] \nlalt
%      \iletfun {\nrm f} {\nrm x} e \; \iin \; e' \| 
      \ilet {\nrm x} e \; e \|
      \iif e \; \ithen e \; \ielse e \nlalt
      \ipair{e}{e} \| \ipi {\nrm i}{e} \|
      \iinld{\ity}{e} \| \iinrd{\ity}{e} \nlalt
      \icaseg{e}{\nrm x}{e}{\nrm x}{e} \nlalt
      \iarr{\vec e} \| \iappend {\nrm e} {\nrm e} \| \isub e {\nrm e} \nlalt
      \iroll{e}{\mu\alpha.\tau} \| \iunroll{e}{\mu\alpha.\tau}
      \\
      
  \name{Base Types} \meta{a} \::= 
      \iunitty \| \iboolty \| \iintty  \| 
      \invty \nlalt  \ibitsty \| \ioffty \| \iecty
  \\
  \name{Types} \meta{\ity} \::= 
      \ibasety \| \ityvar \| \iarrow \ity \ity \| \iprod \ity \ity \|
      \isum \ity \ity \nlalt
      \iseq \ity \| \forall \ityvar.\ity  \|
      \imu \ityvar \ity   
      \| \lambda \alpha.\ity 
      \| \ity \; \ity
  \\
  \name{Kinds} \meta{\kappa} \::= \kty \| \kappa \rightarrow \kappa
\end{bnf}
\caption{The syntax of the host language, an extension of \fomega{}
  with recursion and a variety of useful constants and operators.}
\label{fig:implang-syntax}
\end{figure}

In \figref{fig:implang-syntax}, we present the host language of
\ddc{}, a straightforward extension of \fomega{} with
recursion\footnote{The syntax for \cd{fold} and \cd{unfold},
  particularly the choice of annotating \cd{unfold} with a type, is
  based on the presentation of recursive types in Pierce~\cite{pierce:tapl}} and a
variety of useful constants and operators. 
%\edcom{M: The syntax is based on ...} 
We use this host language both to encode the parsing semantics of
\ddc{} and to write the expressions that can appear within \ddc{}
itself.

As the calculus is largely standard, we highlight only its unusual
features. The constants include bitstrings $\data$; offsets $\off$,
representing locations in bitstrings; and error codes $\iok$,
$\iecerr$, and $\iecpc$, indicating success, success with errors, and
failure, respectively. We use the constant $\ierr$ to indicate a
failed parse.  Because of its specific meaning, we forbid its use in
user-supplied expressions appearing in \ddc{} types.
%We include a special $\isizeofop$ operator, which returns the size in the data
%source of its input. 
Our expressions include arbitrary length
sequences $\iarr{\vec e}$, sequence append $\iappend {\nrm e}
{\nrm {e'}}$, and sequence indexing $\isub \iexpn {\nrm {\iexpn'}}$.

The type $\invty$ is the singleton type of the constant $\ierr$.
Types $\iecty$ and $\ioffty$ classify error codes and bit string
offsets, respectively. The remaining types have standard meanings:
function types, product types, sum types, sequence types ($\iseqty
\ty$), type variables ($\ityvar$), polymorphic types ($\forall
\ityvar.\ity$), and recursive types ($\imu \ityvar \ity$).

We extend the formal syntax with some syntactic sugar for use in the
rest of the paper: anonymous functions $\ilam {\nrm x} \ity e$ for
$\ifun {\nrm f} {\nrm x} e$, with $f \not\in {\rm FV}(e)$; function
bindings $\iletfun {\nrm f} {\nrm x} e \; \iin \; e'$ for $\ilet {\nrm
  f} {\ifun {\nrm f} {\nrm x} e} \; e'$; $\ispty$ for $\iprod \ioffty
\ioffty$.  
\edcom{S: Specify the abbreviation explicitly.} 
We often use pattern-matching syntax for pairs in place of
explicit projections, as in $\ilam {\nrm{(\idatan,\off)}}{}{e}$ and $\ilet
{\itup{\off,\nrm r,\nrm p}} e\; e'$.  Although we have no formal records with
named fields, we use a (named) dot notation for commonly occuring projections.
For example, for a pair $x$ of representation and parse descriptor, we use
$x.\codefont{rep}$ and $x.\codefont{pd}$ for the left and right
projections of $x$, respectively. \cut{Generally, the
  particular projection intended should be apparent from context, and
  will be specified when it is not.} Also, sums and products are
right-associative. Hence, for example, $a \iprodi b \iprodi c$ is
shorthand for $a \iprodi (b \iprodi c)$.

The static semantics ($\stsem[e,\ctxt,\ity]$), operational
semantics ($e \stepsto e'$), and type 
equivalence ($\ity \equiv \ity'$) are those of \fomega{} extended with
recursive functions and iso-recursive types and are entirely standard.
See, for example, Pierce~\cite{pierce:tapl}.

We only specify type
abstraction over terms and application when we feel it will clarify
the presentation. Otherwise, the polymorphism is implicit.  We also
omit the usual type and kind annotations on functions, with the
expectation the reader can construct them from context.  
\edcom{TP: add example written in \ddc}

\subsection{Example}
\label{sec:ddc-example}

As an example, we present an abbreviated description of the common log
format as it might appear in \ddc{}. For brevity,
this description does not fully capture the semantics of the
\ipads{} description from \secref{sec:ipads}. Additionally, we
use the standard abbreviation $\ty * \ty'$ for products and introduce a number of type abbreviations
in the form $\mathtt{name} = \ty$ before giving the type that describes the data source.

{\small
\[
\begin{array}{l}
\mathtt{S} = \plam {\mathtt{str}} {} {\pset {\mathtt{s}}
  {\mathtt{Pstring\_FW(1)}} {\mathtt{s = str}}}\\
\\
\mathtt{authid\_t} = 
\psum {\mathtt{S(``-")}} {} {\mathtt{Pstring(``\;")}}\\
\\
\mathtt{response\_t} = \plam {\mathtt x} {} {
      \pset {\mathtt y} {\mathtt{Puint16\_FW(x)}} 
      {\codefont{100 \leq y \iandi y < 600}}
    }\\
\\
\mathtt{entry\_t} = \\ \;
\begin{array}{lll}
\psig {\mathtt{client}} {\mathtt{Pip}} {&\mathtt{S(``\;")}} &* \\
\psig {\mathtt{remoteid}} {\mathtt{authid\_t}} {&\mathtt{S(``\;")}} &* \\
\psig {\mathtt{response}} {
  \papp
    {\mathtt{response\_t}} 3
}{} \\
\multicolumn{3}{c}{
\quad \pcompute {\codefont{getdomain\;client = ``edu"}} \iboolty}
\end{array}\\
\\
\pseq {\mathtt{entry\_t}} {\mathtt{S(``\backslash n")}}{
  \pterm {\ilam {\mathtt x} {} \ifalse} {\pfalse}
}
\end{array}
\]}%
\noindent
In the example, we define type constructor $\mathtt{S}$ to encode literals
with a constrained type. We also use the following
informal translations: \Pwhere{} becomes a set-type, \Pstruct{} a
series of dependent sums, \Punion{} a series of sums, and
\Parray{} a sequence. As the array terminates at the end of the file, we
use $\ilam {\mathtt x} {} \ifalse$ and $\pfalse$ to indicate the
absence of termination condition and terminator, respectively.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "~/projects/thesis/thesis"
%%% End: 
