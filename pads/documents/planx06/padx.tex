\section{Using \padx{} to Query Ad Hoc Data}
\label{section:padx}

\begin{figure}
\begin{center}
\epsfig{file=padx-arch.ps,width=0.47\textwidth}
\end{center}
\caption{Internal view of \padx{} Architecture}
\label{figure:padx-arch}
\end{figure}

Figure~\ref{figure:padx-arch} depicts an internal view of the \padx{}
architecture first shown in Figure~\ref{figure:padx-arch1}.
Pre-existing components (in grey boxes) include the \pads{} compiler,
the \Galax{} query engine, and the \pads{} runtime system.  In this
section, we focus on the new components (in white boxes) and describe
the compiler and run-time support for viewing \pads{} data as XML.
From a \pads{} description, the compiler generates an XML Schema
description that specifies the virtual XML view of the corresponding
\pads{} data; an XQuery prolog that imports the generated schema and
that associates the input data with the correct schema type; and a
type-specific library that maintains the information necessary to
support \padx{}'s concrete data model.  

Note that a query corral is \emph{customized} for a particular \pads{}
description, in particular, its concrete data model only supports
views of data sources that match the \pads{} description.  To maintain
the correct correspondence between a description, XML Schema, queries,
and data, the query corral explictly contains the generated query
prolog, which imports the XML Schema that corresponds to the
underlying type-specific library.  This guarantees that the XQuery
program is statically typed, compiled, and optimized with respect to
the correct XML Schema and that the underlying data model is an
instance of the specified XML Schema.  At runtime, the query corral
takes an XQuery program and a \pads{} data source and produces the
query result in XML.  We discuss the problem of producing native
\pads{} values in Section~\ref{section:future}.

\subsection{Viewing \pads{} data as XML}	

The mapping from a \pads{} description to an XML Schema is 
straight-forward.  The interesting aspect of this mapping is that
\pads{} values that are error-free and those containing errors are
accessible in the XML view.  We begin with the mapping of \pads{} base
types. 

A default XML Schema, \cd{pads.xsd}, contains the schema types that
represent the \pads{} base types shared by all \pads{} descriptions.
Figure~\ref{figure:pads.xsd} contains a fragment of this schema.
Every \pads{} base type is mapped to a schema simple type that best
subsumes the value space of the given \pads{} base type.  For example,
the \cd{Puint32} base type maps to the schema type \cd{xs:unsignedInt}
(Lines~1--3).  Recall that all parsed \pads{} values have an in-memory
representation and a parse descriptor, which records the state of the
parse, the error code of a detected error, and the location of that
error.  The XML view of a parsed value is a choice of the in-memory
representation, if no error occurred, or of the parse descriptor, if
an error occurred (Lines~4--8).  This light-weight view exposes the
parse descriptor only when an error occurs.  The parse-descriptor type
for all base types is the same and is represented by the schema type
\cd{Pbase\_pd} (Line~10--14).

\begin{figure}
\begin{small}
\begin{code}
 1. <xs:simpleType name="\kw{base\_Puint32}">
 2.  <xs:restriction base="\kw{xs:unsignedInt}"/>
 3. </xs:simpleType>
 4. <xs:complexType name="\kw{val_Puint32}">
 5.  <xs:\kw{choice}>
 6.   <xs:element name="\kw{rep}" type="\kw{p:base\_Puint32}"/>
 7.   <xs:element name="\kw{pd}"  type="\kw{p:Pbase_pd}"/>
 8.  </xs:\kw{choice}>
 9. </xs:complexType>
{10}. <xs:complexType name="\kw{Pbase_pd}">
{11}.  <xs:sequence>
{12}.   <xs:element name="\kw{pstate}"  type="\kw{p:Pflags_t}"/>
{13}.   <xs:element name="\kw{errCode}" type="\kw{p:PerrCode_t}"/>
{14}.   <xs:element name="\kw{loc}"     type="\kw{p:Ploc_t}"/>
{15}.  </xs:sequence>
{16}. </xs:complexType>
\end{code}
\end{small}
\caption{Fragment of XML Schema for \pads{} base types.}
\label{figure:pads.xsd}
\end{figure}

The fragment of the XML Schema in Figure~\ref{figure:dibbler-schema}
corresponds to the description in Figure~\ref{figure:dibbler}.  Note
that the schema imports the schema for \pads{} base types (Line~5).
Each compound type is mapped to a complex schema type with a
particular content model.  A \kw{Pstruct} is mapped to a complex type
that contains a sequence of local elements, each of which corresponds
to one field in the \kw{Pstruct}.  For example, the \kw{Pstruct}
\cd{order\_header\_t} is mapped to the complex type
\cd{order\_header\_t} (Lines~7--15), which contains an element
declaration for the field \cd{order\_num}, among others.  A
\kw{Punion} is mapped to a complex type that contains a choice of
elements, each of which corresponds to one field in the \kw{Punion}.
\begin{figure*}
\begin{small}
\begin{code}
{ 1}. <xs:schema targetNamespace="\kw{file:/example/sirius.p}"
{ 2}.            xmlns="file:/example/sirius.p"
{ 3}.            xmlns:xs="http://www.w3.org/2001/XMLSchema"
{ 4}.            xmlns:p="http://www.padsproj.org/pads.xsd">
{ 5}. <xs:import namespace = "http://www.padsproj.org/pads.xsd".../>
{ 6}. ...
{ 7}. <xs:complexType name="\kw{order_header_t}">
{ 8}.  <xs:sequence>
{ 9}.   <xs:element name="\kw{order_num}"     type="\kw{p:val_Puint32}"/>
{10}.   <xs:element name="\kw{att_order_num}" type="\kw{p:val_Puint32}"/>
{11}.   <xs:element name="\kw{ord_version}"   type="\kw{p:val_Puint32}"/>
{12}.   <!-- More local element declarations -->
{13}.   <xs:element name="\kw{pd}"            type="\kw{p:PStruct_pd}" minOccurs="0"/>
{14}.  </xs:sequence>
{15}. </xs:complexType>
{16}. <!-- More complex type declarations -->
{17}. <xs:complexType name="\kw{orders_t}">
{18}.  <xs:sequence>
{19}.   <xs:element name="\kw{elt}"    type="\kw{order_t}" maxOccurs="unbounded"/>
{20}.   <xs:element name="\kw{length}" type="\kw{p:Puint32}"/>
{21}.   <xs:element name="\kw{pd}"     type="\kw{p:Parray_pd}" minOccurs="0"/>
{22}.  </xs:sequence>
{23}. </xs:complexType>
     ...
{24}. <xs:element name="Psource" type="summary_t"/>
{25}. </xs:schema>
\end{code}
\end{small}
\caption{Fragment of XML Schema for \dibbler{} \pads{} description.}
\label{figure:dibbler-schema}
\end{figure*}

Each complex type also includes an optional \cd{pd} element that
corresponds to the type's parse descriptor (Lines~13 and~21).  All
parse-descriptor types contain the parse state, error code, and
location.  The parse-descriptor for compound types contain additional
information, \eg{}, \cd{Pstruct\_pd} contains the number of nested
errors and \cd{Parray\_pd} contains the index of the array item in
which the first error occurred.  The \cd{pd} element is absent if no
errors occurred during parsing, but if present, permits an analyst to
easily identify the kind and location of errors in the source data.
For example, this XQuery expression returns the locations of all
orders that contain at least one error:
\cd{$pads/Psource/orders/elt/pd/loc}.

The schema types for some compound types contain additional fields
from the \pads{} in-memory representation, \eg{} arrays have a length
(Line~20).  Note that \cd{Parray} types do not associate a name with
each individual array item, so in the corresponding schema type, the
default element \cd{elt} is used to encapsulate each array item.

The \pads{} compiler generates a query prolog that imports the
generated schema and specifies the type of the input variable that
contains the pads data.  Figure~\ref{figure:padx-query-prolog}
contains the query prolog for the schema in
Figure~\ref{figure:dibbler-schema}.  At run time, the user can specify
the input data as a command-line argument or by calling the
\cd{fn:doc} function, \eg{} fn:doc("pads:/example/sirius.data").
\begin{figure*}
\begin{small}
\begin{code}
import schema default element namespace "\kw{file:/example/sirius.p}";
declare variable \kw{$pads} as \kw{document-node(Psource)} external; 
\end{code}
\end{small}
\caption{\padx{} generated query prolog}
\label{figure:padx-query-prolog}
\end{figure*}

\subsection{PADX Data Model}

% Part of PADX implementation are generic functions that implement data
% model accessors.  PADS compiler generates type-specific functions for
% walking virtual XML tree.  Relate back to type-specific library
% functions mentioned in last section.

% Implementation of Galax's Abstract Tree Model.

% Minimum necessary to implement Galax DM:

% 1. Generic implementations of the DM accessors: axis::node-test(), children(),
%    attributes(), name(), etc. 

% 2. On PADX-side, we have a virtual handle for each node in the XML
%    tree--we call that a node rep.  Node rep contains pads handle
%    (maintains state for PADS parser); type-specific vtable of DM
%    accessors; other stuff...

%    Give example of vtable for event\_t and possibly code for
%    kthChildByName. 


% \begin{itemize}
% \item High-level: where does padx data model fit in? Describe division
%   into interface and implementation.
% \item what is interface? mention relationship between kthChild
%   functions and lazy lists/cursors. that is relationship between Galax
%   DM and PADX DM.
%   why the second interface? Why isn't Galax abstract data model enough?
% \item how do we implement? type-specific. Mention that node creation
%   is type specific. ONly access is generic. Again like OO model.
% \end{itemize}

\begin{figure*}
{\small
\begin{verbatim}
type childIndex
type PDCI_vtable_t
type item

class virtual nodeRep = 
  object 
    method get_parent : unit -> nodeRep

    method get_name   : unit -> string
    method get_kind   : unit -> string
    method get_typed_value : unit -> item
    method get_string_value : unit  -> string

    method get_kth_child  : childIndex -> nodeRep option
    method get_kth_child_named : string -> childIndex -> nodeRep option
  end
\end{verbatim}
}
\caption{The \padx{} \absdm.}
\label{fig:padx-absdm}
\end{figure*}

Beneath the \galax \absdm lies the \padx{} \condm, a \padx{}-specific
implementation of the \galax \absdm. This implementation is broken
into two pieces - one generic, for all \pads types, and one
type-specific. The generic portion interfaces with the type-specific
portion through the \padx \absdm.  While similar to the \galax{}
\absdm, it has a number of differences, most notably in its approach
to access to children.  Queries to the \galax data model return
sequences of children, some based on full traversals of the tree
rooted at the queried node. In contrast, the \padx{} data model
provides indexed access to individual, immediate children of the
queried node. In this way, we divide the labor between generic and
type-specific portions by assigning tree traversal to the former and
raw data access to the latter.

% As we mentioned in \secref{sec:foo}, the \padx{} data model is
% specialized to the type of the data to be processed. However, the
% \galax{} driver for the data model is not specialized. Therefore, we
% provide an abstract interface to the data model that is then
% implemented in a type specific manner. While \padx{} is implemented in
% \C{}, the design is techinically quite close to the notions of abstract classes
% and method overiding from OO-languages such as \C++{}.

In \figref{fig:padx-absdm} we present the \padx{} \absdm.  The most
interesting methods are the child accessor methods. Method {\tt
  get\_kth\_child} returns the \nth{k} child of the node starting from
zero. The {\tt get\_kth\_child\_named} function returns the node's
\nth{k} child with the specified name. This function is most relevant
to arrays, where all of the elements are given the same name ``elt.''
For both functions, an option is returned in case the requested child
does not exist.

The PADS compiler generates the type-specific implementations of the
\padx \absdm, along with the other type-specific tools.  Each
implementation of the nodeRep virtual class maintains \xml{}-relevant
meta-data, including the node's name, kind and parent as well as
references to the nodes representation, parse-descriptor and mask.  In
addition, the type-specific knowledge available at compile time is
used to generate calls to the correct nodeRep constructors in children
accessor methods.  For example, for a structure with an integer and
string field, compile-time knowledge of these types allows the
compiler to call the integer and string nodeRep implementations,
respectively, when these children are requested. Similarly for an
array with a particular element type, all requests for an ``elt''
child will return a nodeRep with the element-type specific
implementation. Other datatypes are analagous.


%%%%%%%%%%%%%%%%%%%%%%%%%%

% In order to export \pads{} data as XML, we wrap data in {\em node}
% datastructures containing all the information relevant to XML. Handles
% to these nodes are then passed to \galax which can invoke very simple
% queries on the node, such as ``what is your name? give me a list of
% your children, etc.''  Within \galax, the interface with pads is
% wrapped in a module that exports the \galax Data Model interface to
% the \galax query engine.

% The physical data model provides the means to query \pads{} data by
% walking a virtual XML tree.  At the core of the physical data model
% are the \cd{node} data structure and the generic node interface.
% Together, these play the same role as an abstract class in C++ and
% Java. They specify only common fields used by all nodes, and the
% required accessor methods. They do not, however, provide any method
% implementations. They are fixed elements of the system, independant of
% any particular \pads{} types.

% The generic node interface defines the functions that are available to the
% \pads{} data model implementation for use on nodes. The relevant portions of
% this interface are shown in \figref{fig:generic-node-interface}.

% \begin{figure}
% {\small
% \begin{verbatim}
% struct PDCI_node_s {
%   const char              *name;
%   const char              *kind;
%   PDCI_node_t             *parent;

%   void                    *m;
%   void                    *pd;
%   void                    *rep;

%   const PDCI_vtable_t     *vt;
%   P_t                     *pads;
%   ...
% }
% \end{verbatim}
% }
% \caption{The node structure}
% \label{fig:node-struct}
% \end{figure}

% The basic contents of the \cd{node} data structure are shown in
% \figref{fig:node-struct}. All nodes have a name and a kind, stored as
% C-strings. Additionally, all nodes but the document node have a parent
% in the document, hence the parent field that points to another node.
% Next we have the mask, representation and parse-descriptor fields. As
% these elements of the node are type-specific, they are all typed as
% \vptr.

% Next we have the pointer to the node's virtual table, {\tt vt}. The
% virtual functions will often need a valid \pads{} handle to execute
% correctly. Therefore, we also include a pads handle field in each
% node.

% \subsubsection{Node implementations}
% The PADS compiler generates the type-specific implementations of the
% node functions, along with the other type-specific tools.  The
% type-specific knowledge available at compile time is used not only to
% manipulate the node's data appropriately but also to select the (type)
% correct implementations of children nodes, when necessary.  For
% example, for structures, the children are the parse-descriptor and the
% fields of the structure, each with their own type and corresponding
% node implementation.  For arrays, the children are the
% parse-descriptor, the array length, and a list of nodes with name
% ``elt,'' corresponding to the elements of the array. The
% parse-descriptor is accessed through an implementation for array pds,
% the length field through an implementation for 32-bit integers, and
% each of the elements with the implementation appropriate to the
% particular element type of the array. Other datatypes are analagous.

% It is important to note that the XML representations of \pads{} data
% integrate each datastructure's parse-descriptor with the data,
% exporting it as a child of the datastructure itself. This design
% allows queries to select (or ignore) nodes based on the contents of
% their parse-descriptors in an easy and efficient manner. It also means
% that their are a fixed number of pd node implementations (approx. one for
% each type constructor), as opposed to the unlimited number of data
% node implementations, generated fresh for each new \pads{} type.

% In order to support the full range of \pads{} datatypes,
% the node data structure is designed using ``{\tt void *}
% polymorphism.'' That is, anywhere that the node architecture is not
% specific to a particular type, we use a {\tt void *} type. In this
% way, we can write type-neutral code to manipulate data nodes. For
% example, the rep and pd pointers in each node are typed as {\tt void
%   *}. 

% Each type-specific implementation will (down)cast such pointers to the
% appropriate type before use, relying on the (assumed) invariant that
% no only code specific to that type has manipulated those pointers.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
