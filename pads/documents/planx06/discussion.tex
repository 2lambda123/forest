\section{Discussion}
\label{section:relatedwork}
\label{section:future}

The \padx{} system solves important data-management tasks: it supports
declarative description of ad hoc data formats, its descriptions serve
as living documentation, and it permits exploration of ad hoc data and
vetting of erroneous data using a standard query language.  The
resulting \pads{} descriptions and queries are robust to changes that
may occur in the data format, making it possible for more than one
person to profitably use and understand a \padx{} description and
related queries.

A \padx{} query corrall is an example of partially compiled query
engine, because its concrete data model is customized for a particular
data format, but its queries are interpreted over an abstract data
model that delegates to the concrete model.  This architecture places
\padx{} on the continuum between query architectures that provide
fully interpreted query plans applied to generic data models to
architectures that provide fully compiled query plans applied to
customized data model instances~\cite{daytona}.  The latter
architectures provide very high performance on large scale data.
\padx{} has some of the benefits of such architectures but does not
have the overhead of a complete database system. 

Others share our interest in declarative descriptions of ad hoc data
formats.  \cut{Transparent, reusable descriptions of ad hoc data formats,
in particular binary formats, is a hot topic in the Grid
community~\cite{dfdl}.}  Currently, the Global Grid Forum is working on a standard
data-format description language for describing ad hoc data formats,
called \dfdl{}~\cite{dfdl-proposal,dfdl-primer}.  Like \pads{},
\dfdl{} has a rich collection of base types and supports a variety of
ambient codings.  Unlike \pads{}, \dfdl{} does not support semantic
constraints on types nor dependent types, \eg{}, it is not possible to
specify that the length of an array is determined by some field in the
data.  \dfdl{} is an annotated subset of \Xml{} Schema, which means
that the \Xml{} view of the ad hoc data is implicit in a \dfdl{}
description.  \dfdl{} is still being specified, so no \dfdl{}-aware
parsers or data analyzers exist yet.  We expect that bi-directional
translation between \pads{} and \dfdl{} to be straightforward.  Such a
translation would make it possible for \dfdl{} users to use 
\padx{} to query their ad hoc data sources.

% Architecture style and strategy
\cut{The \padx{} architecture is designed to handle with large scale data
sources without sacrificing the flexibility and generality provided by
a standard query language. }

% Related work
The steps in a data-management workflow that \padx{} addresses
typically precede the steps that require a high-performance database
system, \eg{}, asking complex OLAP queries applied to long-lived,
archived data.  Commercial database products do provide support for
parsing data in external formats so the data can be imported into
their database systems, but they typically support a limited number of
formats, \eg{}, COBOL copybooks, no declarative description of the
original format is exposed to the user for their own use, and they
have fixed methods for coping with erroneous data.  For these reasons,
\padx{} is complementary to database systems.

\cut{None serve as living documentation of the original data format as
do \pads{} descriptions.}

\cut{\Xml{} is prescriptive, \dfdl{} is descriptive}

% Open problems

We continue to focus on improving the usability and scalability of
\padx{}.  Currently, \padx{} is not compositional, because the result
of evaluating a query is in native \Xml{}, not in a \pads{} format.
Given an arbitrary XQuery expression over a \padx{} source, an open
problem is being able to infer a reasonable \pads{} format for the
result and produce the results in this format.  We have already
mentioned the important problem of detecting when a query can be
evaluated in a single scan over an input document and of producing a
fully pipelined execution plan.  Interestingly, this problem is
important in \Xml{} environments in which the \Xml{} data is an
infinite or bursty stream.  We are working on improving \Galax{}'s
ability to detect one-scan queries and to produce query plans that are
indeed fully pipelined and that use limited memory.

\cut{Streamable query plans. 
BEA~\cite{DBLP:journals/vldb/FlorescuHKLRWCS04}
Phantom XML~\cite{rose:villard:2005}
Big open problem: Given arbitrary XQuery expression, determine whether
it can be evaluated in single scan over data.  Point out that this
problem is of interest for a different reason: fully pipeline
evaluation of queries over XML token streams.

These results are very preliminary, but we expect that further
work on producing one-scan query plans and on reducing the overhead in
the \padx{} data model }

\cut{Open problem: give result of XQuery and its corresponding type,
serialize result back into PADS rep.  How are the syntactic
constraints for the new values expressed?  Tool could pick default
delimiters automatically. }

\cut{Because each \padx{} query corrall is customized to a particular
\pads{} description, the \padx{} architecture is a ``partially
compiled'' query engine.  

Database person would balk at this point!  Why aren't you just loading
this data into a real database, building indices and getting good
query performance?  B/c data is ephmeral, queries are ephmeral, but
analyst/programmer should profit from disciplined access/querying of
their data.  Don't abandon them to Perl.}

\cut{accurately and completely specifying the format of a data source, 

Unfortunately, database administrators and data analysts consider
these tasks to be tedious, uninteresting ``pre-processing'' steps that
just need to get done quickly so they can get on to the ``real work''
of cleaning and analyzing the data.

The data-management tasks solved by \pads{} and \padx{} are largely
ignored in the research community.}

\cut{ 
Boring TODO list: 
-----------------
Better use of XML Schema simple types.  We don't take complete
advantage of XML Schema, e.g., Penum types could be modeled by XML
Schema enumeration simple types, but currently unsupported.

Open problem: given an arbitrary PADS type, permit skipping and
reading at arbitrary positions within the data source. 
}

