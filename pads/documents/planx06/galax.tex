\section{Using XQuery and \Galax{}}
\label{section:galax}

In this section, we give a brief overview of \Xml{}, XQuery, and
\Galax{}, focusing on \Galax{}'s data-model support for viewing
non-XML data as XML.  Given the subject of this workshop, we assume
the reader is already familiar with XML, XQuery, and XML Schema.

XML~\cite{xml10} is a flexible format that can represent many classes
of data: structured documents with large fragments of marked-up text;
homogeneous records such as those in relational databases; and
heterogeneous records with varied structure and content such as those
in ad hoc data sources.  XML makes it possible for applications to
handle all these classes of data simultaneously and to exchange such
data in a standard format.  This flexibility has made XML the ``lingua
franca'' of data integration and exchange.

XQuery~\cite{xquery10} is a typed, functional query language for XML
that supports user-defined functions and modules for structuring large
queries.  Its type system is based on XML Schema~\cite{xmlschema-1}.  XQuery contains
XPath 2.0~\cite{xpath20} as a proper sub-language, which supports
navigation, selection, and extraction of fragments of XML documents.
XQuery also includes expressions to construct new XML values and to
integrate or join values from multiple documents.  \cut{Unusual among
industry standards, XQuery also has a formal semantics, which makes it
particularly interesting to database researchers.}

XQuery is a natural choice for querying ad hoc data.  Like XML data,
ad hoc data is semi-structured, and XQuery is tailored to 
such data.  \cut{For example, the expressions in
Figure~\ref{figure:dibbler-query} are well-defined for order records
containing any number of events and for event records containing any
number of timestamps. As noted in Section~\ref{subsec:example},}
XQuery's static type system detects type errors at compile time, which
is valuable when querying ad hoc sources: Long-running queries on
large ad hoc sources do not raise dynamic type errors, and queries
made obsolete by schema evolution are identified at compile time.
XQuery is also ideal for specifying integrated views of multiple
sources.  Although here we focus on querying one ad hoc source at a
time, XQuery supports simultaneous querying of multiple 
sources. Lastly, XQuery is practical: It will soon be a
standard; numerous manuals already exist~\cite{brundage2004}; and it is widely implemented
in commercial databases.

\Galax{} is a complete,
extensible, and efficient implementation of XQuery~1.0 that supports
XML~1.0 and XML Schema~1.0 and that was designed with database systems
research in mind.  Its architecture is modular and
documented~\cite{galax:edbt2004}, which makes it possible for other
researchers to experiment with a complete XQuery implementation.  Its
compiler produces evaluation plans in the first complete algebra
for XQuery~\cite{galax:icde2006}, which permits experimental
comparison of query-compilation techniques.  Lastly, its query
optimizer produces efficient physical plans that employ traditional
and novel join algorithms~\cite{galax:icde2006}, which makes it
possible to apply non-trivial queries to large XML sources.  Lastly,
its abstract data model permits experimenting with various physical
representations of XML and non-XML data sources.  \Galax{}'s abstract
data model is the focus of the the rest of this section.
\cut{\footnote{\texttt{http://www.galaxquery.org}}}

\subsection{\Galax{}'s Abstract Data Model}

\Galax{}'s abstract data model is an object-oriented realization of
the XQuery Data Model.  The XQuery Data Model~\cite{XPath:DataModel}
contains tree nodes, atomic values, and sequences of nodes and atomic
values.  A tree node corresponds to an entire XML document or to an
individual element, attribute, comment, or processing-instruction.
Algebraic operators in a query-evaluation plan produced by \Galax{}'s
query compiler access documents by applying methods in the data
model's object-oriented interface.

Figure~\ref{figure:galax-dm} contains part of Galax's data model
interface\footnote{\Galax{} is implemented in O'Caml, so these signatures
are in O'Caml.} for a node in the XQuery Data Model.  Node
accessors return information such as a node's name (\cd{node\_name}),
the XML Schema type against which the node was validated (\cd{type}),
and the node's atomic-valued data if it was validated against an XML
Schema simple type (\cd{typed\_value}).  The \cd{parent}, \cd{child},
and \cd{attribute} methods navigate the document and return a node
sequence containing the respective parent, child, or attribute nodes
of the given node.

\begin{figure*}
\begin{small}
\begin{code}
{ 1}. type \kw{sequence} = \kw{cursor}
{ 2}. class virtual \kw{node} : 
{ 3}. object
{ 4}.   (* Selected XQuery Data Model accessors *)
{ 5}.   method virtual \kw{node_name}   : unit -> atomicQName option
{ 6}.   method virtual \kw{type}        : unit -> (schema * atomicQName)
{ 7}.   method virtual \kw{typed_value} : unit -> atomicValue sequence
\mbox{}
{ 8}.   (* Required axes *)
{ 9}.   method virtual \kw{parent}      : node_test option -> node option
{10}.   method virtual \kw{child}       : node_test option -> node sequence
{11}.   method virtual \kw{attribute}   : node_test option -> node sequence
\mbox{}
{12}.   (* Other axes *)
{13}.   method \kw{descendant_or_self}  : node_test option -> node sequence
{14}.   method \kw{descendant}          : node_test option -> node sequence
{15}.   method \kw{ancestor_or_self}    : node_test option -> node sequence
{16}.   method \kw{ancestor}            : node_test option -> node sequence
\mbox{}
  ... Other accessors in XQuery Data Model ...
\end{code}
\end{small}
\caption{Signatures for methods in Galax's abstract node interface}
\label{figure:galax-dm}
\end{figure*}

The first six methods in Figure~\ref{figure:galax-dm} (Lines~5--11) access the
physical representation of a document, therefore, a concrete instance
of the data model must provide their implementations.  \Galax{}
provides default implementations for the four {descendant} and
ancestor axes (Lines~13--16), which are defined recursively in terms of the {child}
and {parent} methods.  These defaults may be overridden in concrete data
models that can provide more efficient implementations than the
defaults.  For example, some representations permit
axes to be implemented by range queries over relational
tables~\cite{grust03staircase}.

All the axis methods take an optional node-test argument, which is a
boolean predicate on the names or types of nodes in the given axis.
For example, the XQuery expression \cd{descendant::order} returns
nodes in the descendant axis with name \cd{order}.  \Galax{} compiles
this expression into a single axis/node-test operator that invokes the
corresponding methods in the abstract data model, delegating
evaluation of node tests to the concrete data model.  Some
implementations, like \padx{}, can provide fast access to nodes by
their name.  We describe \padx{}'s concrete data model in Section~\ref{section:padx}.

One other important feature of \Galax{}'s abstract data model is that
sequences are represented by \emph{cursors} (also known as streams),
non-functional lists that yield items lazily.  Accessing the first
item in a sequence does not require that the entire sequence be
materialized, \ie{}, evaluated eagerly.  \Galax{}'s algebraic
operators produce and consume cursors of values, which permits
pipelined and short-circuited evaluation of query plans.

In addition to the concrete data model for \padx{},which we describe in the next
section, \Galax{} has three other 
concrete data models: a DOM-like representation in main memory and two
``shredded'' representations, one in main memory and one in secondary
storage for very large documents (\eg{} $>$ 100MB).  The shredded data
model partitions a document into tables of elements, attributes, and
values that can be indexed on node names and
values~\cite{galax:ximep2004}.

\cut{The second sub-group contains operators for tree navigation and
projection (in the style of~\cite{projection}). The TreeJoinOp is a
set-at-a-time operator for navigation, which takes a set of nodes in
document order and returns a set of nodes in document order after
applying the given step. It can be implemented either as a combination
of iteration with navigational access on the data model or as an
advanced kind of XPath join, such as that proposed}

