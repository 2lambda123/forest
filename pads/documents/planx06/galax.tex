\section{Using XQuery and \Galax{}}
\label{section:galax}

XML~\cite{xml} is a flexible format that can represent many classes of
data: structured documents with large fragments of marked-up text;
homogeneous records such as those in relational databases; and
heterogeneous records with varied structure and content such as those
in ad hoc data sources.  XML makes it possible for applications to
handle all these classes of data simultaneously and to exchange such
data in a simple, extensible, and standard format.  This flexibility
has made XML the ``lingua franca'' of data
interoperability. \cut{making it possible for data to be exchanged
regardless of where it is stored or how it is processed.}

XQuery~\cite{xquery} is a typed, functional query language for XML
that supports user-defined functions and modules for structuring large
queries.  Its type system is based on XML Schema.  XQuery contains
XPath 2.0~\cite{xpath} as a proper sublanguage, which supports
navigation, selection, and extraction of fragments of XML documents.
XQuery also includes expressions to construct new XML values, and to
integrate or join values from multiple documents.  Unique among
industry standards, XQuery also has a formal semantics, which makes it
particularly interesting to database researchers. 

As XQuery was designed for querying semi-structured XML data, it is a
natural choice for querying semi-structured ad hoc data.  XQuery's
user syntax easily handles irregularly sturctured data.  For example,
the path expressions in Figure~\ref{figure:dibbler-query} are
well-defined for orders with zero or more events, and the predicates
are well-defined for events with zero or more timestamps.  As noted in
Section~\ref{subsec:example}, XQuery's static type system can detect
common errors at compile time.  Such type safety is particularly
valuable for long-running queries on large ad hoc sources and for data
sources whose schemata evolve.  XQuery is also ideal for specifying
integrated views of multiple sources.  Although here we focus on
querying one ad hoc source at a time, XQuery supports our goal of
simultaneously querying multiple \pads{} and other XML
sources. Lastly, XQuery is practical: Numerous language manuals
already exist; it is widely implemented in commercial databases; and
it will be coming an enduring standard.

\Galax{}~\footnote{\texttt{http://www.galaxquery.org}} is a complete,
extensible, and efficient implementation of XQuery~1.0.  It supports
all of XML 1.0, most of XML Schema 1.0, which is the foundation of the
XQuery type system, and all of XQuery 1.0.  \Galax{} was designed with
database systems research in mind.  Its architecture is modular and
documented~\cite{galax-edbt2004}, which makes it possible for others
to use and extend a complete XQuery implementation.  
\Galax{}'s extensibility is provided by its abstract data model.
Its query
compiler produces evaluation plans in the first complete algebra for
XQuery~\cite{galax-icde2006}, and its optimizer detects joins and
grouping constructs in algebraic plans and produces efficient physical
plans that employ traditional and novel join
algorithms~\cite{galax-icde2006}.

\subsection{Galax's Abstract Data Model}

~\cite{xquerydm}

Algebraic operators ``bottom out'' by invoking methods in 
\Galax{}'s abstract data model 


\Galax{}  an abstract data model.  which makes it possible for
\Galax{} to evaluate queries simultaneously over native and virtual
XML sources that implement the data model.   

\cut{One requirement that we did not anticipate but that has become central
to \Galax{} is extensibility, in particular, support for querying virtual
XML data sources.}

Abstract object-oriented data model that permits querying of virtual
XML sources.  

Tree data model.  Data model accessors (axis::node-tests) that can/should be implemented
efficiently by the underlying source are pushed into the OO tree data
model.  Default implementations for sources that don't do anything
clever.   
\begin{figure*}
\begin{small}
\begin{code}
class virtual node : 
object
  (* Implementation that provides this node *)
  method virtual implementation : unit -> string

  (* XQuery Data Model accessors *)
  method virtual node_name  : unit -> atomicQName option

  (* Axes *)
  method virtual parent     : node_test option -> node option
  method virtual children   : node_test option -> node cursor
  method descendant_or_self : node_test option -> node cursor

  ... Other methods of XQuery Data Model ...

\end{code}
\end{small}
\caption{Signatures for methods in Galax's abstract data model}
\end{figure*}

Motivation for abstract data model: Supporting PADS and secondary
storage system occurred at same time.  Data and information
integration.  

Implementations provided: Main-memory DOM-like rep; Main-memory
shredded (HashTable) rep; Secondary-storage shredded rep; PADS.

Part of PADX implementation are generic functions that implement data
model accessors.  PADS compiler generates type-specific functions for
walking virtual XML tree.  Relate back to type-specific library
functions mentioned in last section.

