\documentclass{sigplanconf}

\usepackage{stmaryrd}
\usepackage{epsfig}
\usepackage{alltt}
\usepackage{times}
\usepackage{code}

\include{defs}
\newcommand{\dibbler}{Sirius}
\newcommand{\ningaui}{Altair}
\newcommand{\darkstar}{Regulus}

\title{PADX\footnote{Pronounced ``paddocks'' : a usually enclosed area
for exercising race horses.} : Querying Large-scale Ad Hoc Data with XQuery}
%\title{PADX : An XQuery Interface to Ad Hoc Data Sources}
%\title{PADX : A System for Querying Ad Hoc Data Sources with XQuery}

\authorinfo{Mary Fern\'andez\\Kathleen Fisher}
       {AT\& Labs Research}
       {\mono{\{mff,kfisher\}@research.att.com}}

\authorinfo{ Robert Gruber\titlenote{Work carried out while at AT\&T
                                     Labs Research.}}
       {Google}
       {\mono{gruber@google.com}}

\authorinfo{Yitzhak Mandelbaum}
       {Princeton University}
       {\mono{yitzhakm@cs.princeton.edu}}

\date{\today}


\begin{document}

\maketitle
\begin{abstract}
\end{abstract}

\input{intro}

\section{Using \pads{} to Access Ad Hoc Data [Kathleen]}
\label{section:pads}

Focus on expressiveness of data description language.

Generated library : rep, pd, and per-type parsing functions and other
type specific tools (but we're talking about those here). 

Error-aware data processing.  

Many of PADS features are not described here b/c they are not germane
to understand this work.  See PLDI and POPL papers. 

\section{Using XQuery and \Galax{}[Mary]}
\label{section:galax}

XML is blah. One paragraph on XQuery and where to learn about it.

XQuery is a typed, functional language that supports user-defined
functions and modules for structuring large queries.  It contains
XPath 2.0~\cite{xpath} as a proper sublanguage, which supports
navigation, selection, and extraction of fragments of XML documents.
XQuery also includes expressions to construct new XML values, and to
integrate or join values from multiple documents.  XQuery's type
system is based on XML Schema. 

Establish why XQuery was a reasonable query language for PADS.
Standard.  Statically typed and PADS descriptions are types.  

XML is obvious target for all data sources.  Cite numerous
tools for converting to XML and commercial DB support for non-XML
sources.  Do not re-invent the wheel.

\subsection{Galax's Abstract Data Model}

Abstract object-oriented data model that permits querying of virtual
XML sources.  

Tree data model.  Data model accessors (axis::node-tests) that can/should be implemented
efficiently by the underlying source are pushed into the OO tree data
model.  Default implementations for sources that don't do anything
clever.   
\begin{figure}
\begin{small}
\begin{code}
  method virtual node_name  : unit -> atomicQName option
  method virtual parent     : node_test option -> node option
  method virtual children   : node_test option -> node cursor
  method descendant_or_self : node_test option -> node cursor
\end{code}
\end{small}
\caption{Signatures for methods in Galax's abstract data model}
\end{figure}

Motivation for abstract data model: Supporting PADS and secondary
storage system occurred at same time.  Data and information
integration.  

Implementations provided: Main-memory DOM-like rep; Main-memory
shredded (HashTable) rep; Secondary-storage shredded rep; PADS.

Part of PADX implementation are generic functions that implement data
model accessors.  PADS compiler generates type-specific functions for
walking virtual XML tree.  Relate back to type-specific library
functions mentioned in last section.

\section{Using \padx{} to Query Ad Hoc Data}
\label{section:padx}

\begin{figure}
\begin{center}
\epsfig{file=padx-arch.ps,width=0.47\textwidth}
\end{center}
\caption{\padx{} Architecture}
\label{figure:padx-arch}
\end{figure}

Put the pieces all together.  Sythesis of the two systems here. 
(Symbiotic)

\subsection{Virtual XML view of PADS data}

Embedding of PADS types in XML Schema.  One-to-one mapping from
PADS compound types to XML Schema complex types.  One-to-one mapping
from PADS base types to XML Schema simple types.  Field in compound
types are realized as local elements in XML Schema. 

All the compound types are annotated with an optional parse-descriptor
(absent if no errors occured).  Allows users to query error
structures, which may be most important data.  Other types annotated
with corresponding fields from PADS rep, e.g., arrays have a length. 

Extra level of indirection in representation of arrays---wrap each
item in an element. 

Extra level of indirection for base types: must contain the value of
the base type and an optional parse-descriptor, if an error has
occurred. 

We don't take complete advantage of XML Schema, e.g., Penum types
could be modeled by XML Schema enumeration simple types, but currently
unsupported.

Generated XML Schema.

\begin{figure*}
\begin{small}
\begin{code}
<xs:schema targetNamespace="file:sirius.p"
           xmlns="file:sirius.p"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:p="http://www.padsproj.org/pads.xsd">
<xs:import namespace = "http://www.padsproj.org/pads.xsd".../>
...
<xs:complexType name="\kw{order_header_t}">
 <xs:sequence>
  <xs:element name="order_num" type="p:val_Puint32"/>
  <xs:element name="att_order_num" type="p:val_Puint32"/>
  <xs:element name="ord_version" type="p:val_Puint32"/>
  <!-- More local element declarations -->
  <xs:element name="pd" type="\kw{p:PStruct_pd}" minOccurs="0"/>
 </xs:sequence>
</xs:complexType>
<!-- More complex type declarations -->
<xs:complexType name="\kw{orders_t}">
 <xs:sequence>
  <xs:element name="\kw{elt}" type="order_t" maxOccurs="unbounded"/>
  <xs:element name="\kw{length}" type="p:Puint32"/>
  <xs:element name="\kw{pd}" type="\kw{p:Parray_pd}" minOccurs="0"/>
 </xs:sequence>
</xs:complexType>
...
</xs:schema>
\end{code}
\end{small}
\caption{Fragment of XML Schema for \dibbler{} \pads{} description.}
\label{figure:dibbler-schema}
\end{figure*}

``Error-aware'' mapping from PADS type system to isomorphic XML
Schema. 
\begin{small}
\begin{code}
<xs:complexType name="\kw{val_Puint32}">
  <xs:choice>
   <xs:element name="val" type="p:Puint32"/>
   <xs:element name="pd" type="p:Pbase_pd"/>
  </xs:choice>
</xs:complexType>
<xs:complexType name="\kw{Pbase_pd}">
 <xs:sequence>
   <xs:element name="\kw{pstate}"  type="p:Pflags_t"/>
   <xs:element name="\kw{errCode}" type="p:PerrCode_t"/>
   <xs:element name="\kw{loc}"     type="p:Ploc_t"/>
 </xs:sequence>
</xs:complexType>
\end{code}
\end{small}

Example of query that uses generated schema.
\begin{small}
\begin{code}
declare namespace p = "http://www.padsproj.org/pads.xsd";
import schema default element namespace "file:sirius.p"
  schemaLocation "file:/somewhere/sirius.xsd";

$pads/p:Psource/orders/elt[events/elt[1]
  [tstamp >= xs:dateTime("2004-10-01:00:00:00") and 
   tstamp < xs:date("2004-11-01:00:00:00") ]]
\end{code}
\end{small}

\subsection{Physical Data Model}

Implementation of Galax's Abstract Tree Model.

Minimum necessary to implement Galax DM:

1. Generic implementations of the DM accessors: axis::node-test(), children(),
   attributes(), name(), etc. 

2. On PADX-side, we have a virtual handle for each node in the XML
   tree--we call that a node rep.  Node rep contains pads handle
   (maintains state for PADS parser); type-specific vtable of DM
   accessors; other stuff...

   Give example of vtable for event\_t and possibly code for
   kthChildByName. 

When to actually read from PADS data?

Options: 

1. Bulk read: Materialize entire PADS representation, populate all of the PADS
reps.  Then PADX DM lazily invoked the DM accessors over this data.
Problem: if data is big, it's all sitting in memory, even if the query
only touches a fragment of the virtual XML tree.

2. Smart read: 

Many common queries permit sequential, streamed access to underlying
XML source.  Give an example.  

Smart node rep, preserves meta-data about previously read records, but
re-uses memory for reading next item.  This rep permits multiple scans
of input (semantic problem is that DM must preserve node identity),
but slowly. 

Heuristic: records are a good level of granularity to read.   Each
smart node corresponds to one record.  When next smart node is
accessed, a little meta-data is preserved: the node rep and the
records location in the file (so we can re-read it if necessary).

3. Linear read: same as smart but does not preserve meta-data.
   Does not permit multiple scans of data source. 

Put in PADX signatures for constructing a new node and accessing
kthChild. 

\section{Performance}
\label{section:performance}

\subsection{Materialization and Loading}

Hypothesis: bulk loading should not scale for increasing document size
(limits of main memory).  Show that smart/linear does scale.

\subsection{Querying}

Give examples of queries that analyst cares about. 

Example of query that can be evaluated in single scan over data
source, but is currently not 

Database person would balk at this point!  Why aren't you just loading
this data into a real database, building indices and getting good
query performance?  B/c data is ephmeral, queries are ephmeral, but
analyst/programmer should profit from disciplined access/querying of
their data.  Don't abandon them to Perl. 

\section{Related Work}
\label{section:relatedwork}

DFDL. Contivo. 

\section{Future Work and Discussion}
\label{section:future}
Open problem: give result of XQuery and its corresponding type,
serialize result back into PADS rep.  How are the syntactic
constraints for the new values expressed?  Tool could pick default
delimiters automatically. 

Open problem: given an arbitrary PADS type, permit skipping and
reading at arbitrary positions within the data source. 

Big open problem: Given arbitrary XQuery expression, determine whether
it can be evaluated in single scan over data.  

\bibliographystyle{abbrv}
\small
\bibliography{../pldi/pads} 

\end{document}

\subsubsection{XML Generation}

\pads{} also supports converting ad hoc data into XML by providing a
canonical mapping from \pads{} descriptions into XML.  This mapping is
quite natural, as both \pads{} and XML are languages for describing
semi-structured data.  One interesting aspect of the mapping is that
we embed not just the in-memory representation of \pads{} values, but
also the parse descriptors in cases where the data was buggy.  This
choice allows users to explore the error portions of their data
sources, which can be the most interesting parts of the data.  Given a
\pads{} specification, the \pads{} compiler generates an XML Schema
describing the canonical embedding for that data source.  As an
example, the following is the portion of the generated XML Schema for
the \cd{eventSeq} type in the \dibbler{} data description.

The \pads{} compiler generates a \cd{write_xml_2io} function for each
type, an example of which is shown in \figref{figure:library}.  Given
a specification of the top level type, \pads{} can also automatically
generate a conversion program, the output of which conforms to the
generated XML Schema.

\subsection{Queries}

Our final use-scenario is querying data.  Given a data source, a
natural desire is to ask questions about the data, a desire which led
to SQL and its many variants for relational data and XQuery for XML
data~\cite{boag03XQueryDraft}.  Analysts working with ad hoc data
would also like to query their data, but the lack of tools generally
means they code their queries in an imperative fashion in languages
such as \textsc{awk}, \perl{}, or \C{}.  Indeed, the analyst working
with the \dibbler{} data took this approach.  He coded queries such as
``Select all orders starting within a certain time window," ``Count
the number of orders going through a particular state," and ``What is
the average time required to go from a particular state to another
particular state" in a mixture of \textsc{awk} and \textsc{perl}.  He
was able to get the answers to his questions, but he had to code the
queries explicitly, and the query-related code ended up embedded in
his already-brittle parsing code.

Happy with XQuery's expressiveness, we worked with the designers of
the Galax~\cite{galax} open-source implementation of XQuery to define
a data API~\cite{galaxmanual}.  This API presents the source as a tree
to Galax. With this architecture, Galax can incorporate any data
source accessible through an instance of the data API.  We then
extended the \pads{} system to produce such instances.  We were able
to define the bulk of the API generically, having to generate on a per
type basis only a handful of functions.  \figref{figure:library}
contains the key generated functions for the \cd{entry_t} type from
the \dibbler{} data.  The \cd{node_new} function creates a node in the
tree representation of the data, storing the supplied name, mask,
parse descriptor, and in-memory representation.  It makes the argument
node the parent of the newly created node.  The \cd{node_kthChild}
function takes a tree corresponding to an \cd{entry_t} node and a
child index and returns the appropriate child.  For the \cd{entry_t}
type, possible children are the header, the event sequence, or a parse
descriptor.  At the moment, it is possible to use the resulting system
to query ad hoc data sources that can be loaded entirely into memory,
and a version that allows the data to be read lazily is well underway.
How best to optimize Xqueries over ad hoc data sources is an open
research area.

PDCI_node_t *order_header_t_node_kthChild (PDCI_node_t *self,PDCI_childIndex_t idx)
{
  PDCI_node_t *result = 0;
 order_header_t *rep=(order_header_t *) (self->rep);
 order_header_t_pd *pd=(order_header_t_pd *) (self->pd);
 order_header_t_m *m=(order_header_t_m *) (self->m);
 switch(idx){
;
  case 0: result = Puint32_node_new(self,"order_num", &(m->order_num), &(pd->order_num), &(rep->order_num), "element", "order_header_t" "_node_kthChild");
 break;
  case 1: result = Puint32_node_new(self,"att_order_num", &(m->att_order_num), &(pd->att_order_num), &(rep->att_order_num), "element", "order_header_t" "_node_kthChild");
 break;
  case 2: result = Puint32_node_new(self,"ord_version", &(m->ord_version), &(pd->ord_version), &(rep->ord_version), "element", "order_header_t" "_node_kthChild");
 break;
  case 3: result = service_tn_t_node_new(self,"service_tn", &(m->service_tn), &(pd->service_tn), &(rep->service_tn), "element", "order_header_t" "_node_kthChild");
 break;
  case 4: result = billing_tn_t_node_new(self,"billing_tn", &(m->billing_tn), &(pd->billing_tn), &(rep->billing_tn), "element", "order_header_t" "_node_kthChild");
 break;
  case 5: result = nlp_service_tn_t_node_new(self,"nlp_service_tn", &(m->nlp_service_tn), &(pd->nlp_service_tn), &(rep->nlp_service_tn), "element", "order_header_t" "_node_kthChild");
 break;
  case 6: result = nlp_billing_tn_t_node_new(self,"nlp_billing_tn", &(m->nlp_billing_tn), &(pd->nlp_billing_tn), &(rep->nlp_billing_tn), "element", "order_header_t" "_node_kthChild");
 break;
  case 7: result = zip_code_t_node_new(self,"zip_code", &(m->zip_code), &(pd->zip_code), &(rep->zip_code), "element", "order_header_t" "_node_kthChild");
 break;
  case 8: result = dib_ramp_t_node_new(self,"ramp", &(m->ramp), &(pd->ramp), &(rep->ramp), "element", "order_header_t" "_node_kthChild");
 break;
  case 9: result = Pstring_node_new(self,"order_type", &(m->order_type), &(pd->order_type), &(rep->order_type), "element", "order_header_t" "_node_kthChild");
 break;
  case 10: result = Puint32_node_new(self,"order_details", &(m->order_details), &(pd->order_details), &(rep->order_details), "element", "order_header_t" "_node_kthChild");
 break;
  case 11: result = Pstring_node_new(self,"unused", &(m->unused), &(pd->unused), &(rep->unused), "element", "order_header_t" "_node_kthChild");
 break;
  case 12: result = Pstring_node_new(self,"stream", &(m->stream), &(pd->stream), &(rep->stream), "element", "order_header_t" "_node_kthChild");
 break;
  case 13: if (pd->nerr > 0) result = PDCI_structured_pd_node_new(self,"pd",pd,"ty" "_node_kthChild");
 break;
 };
  return result;
}
PDCI_node_t *order_header_t_node_kthChildNamed (PDCI_node_t *self,PDCI_childIndex_t idx,char const *name)
{
  PDCI_node_t *result = 0;
 PDCI_childIndex_t i;
 const char *fieldNames[] = {
 "order_num","att_order_num","ord_version","service_tn","billing_tn","nlp_service_tn","nlp_billing_tn","zip_code","ramp","order_type","order_details","unused","stream" , "pd",0};
 if (idx != 0) return result;
 for (i = 0;
 1;
 i++) {
 if (fieldNames[i] == 0) {
 return result;
 }
 if ((strcmp((name),(fieldNames[i])) == 0)) {
 break;
 }
 };
  return (self->vt->kth_child)(self,i);
}
