\chapter{Precurs}
\label{chap:recursion}
\cutname{recursion.html}

{\em Note: this chapter is under development.}

\Precur{} supports the description of recursive (\ie{},
tree-structured) data. It serves as a forward declaration, informing
the compiler that the type specified will be recursive.

\section{Syntax}
\label{sec:recur-syntax}
The syntax for \Precur{} is given by the following BNF grammar fragment:

\begin{tabular}{rcl}
\nont{recur\_ty}    & \is{} & \Precur{} \opt{(\nont{p\_ty})} identifier  \opt{\nont{p\_formals}};
\end{tabular}

\noindent
We explain the meaning of this syntax in the remainder of this chapter.
All non-terminals not defined in this grammar fragment were
defined previously:
\padsl{} types (\nont{p\_ty}) and parameter lists (\nont{p\_formals})
in \secref{sec:common-parameterization}. 

\subsection{Examples}
\textbf{Include some sample data to make intuitions more concrete.}
\textbf{Include citation for newick data}
Below, we present the code for a simple binary tree format, based on
the Newick format. A tree is encoded as a matched pair of parentheses
containing either nothing in the leaf case or a pair of children
separated by a comma in the interior node case.
\inputCode{code/binarytree}

In this example, types \cd{tree} and \cd{treeInterior} are mutually
recursive. As with mutually recursive types in C, we need a forward
declaration for the second type, \cd{tree}. The \kw{Precur} construct
serves as forward declaration. 

% For situations in which we cannot change the recursive types as
% described, \textbf{when would that be?} we allow the \kw{Precur}
% declaration to include an explicit 
% specfication of the underlying type. So, for example, we could rewrite
% the previous example as follows:

% \inputCode{code/binarytree2}

% Here, \cd{tree} is a pointer to the type \cd{treeImpl}. This feature
% can useful in a case where the implementation is specified elsewhere.

\section{Generated library}
% Conceptually, \Precur is a forward declaration for a \pads{} type
% declared later in the file. In \C{}, recursive types are generally
% defined by referring to the forward declared type through a
% pointer. However, pointers are specific to in-memory data structures
% and are not relevant to data descriptions. Hence, the user will refer
% directly to the forward-declared type and the compiler must handle
% inserting the pointers.

The \Precur{} construct servers two purposes. It provides a forward
declaration for a latter \pads{} type, thereby allowing for
recursive types. And, it informs the compiler that the size of the
in-memory representation and parse descriptor cannot be statically
determined. Therefore, thec compiler translates \Precur{} declarations
into forward declarations of the named type's representation, mask, and
parse descriptor types. In addition, as the sizes of these data
structures cannot be statically determined, the compiler defines all
three data structures as pointers. 


Correspondingly, the generated
functions handle the dynamic allocation and deallocation of the
representation and parse descriptor. The mask, being an input rather
than an output, is handled differently, as discussed in
\secref{sec:recur-masks}.

We will use the \cd{tree} examples to illustrate the data structures
and functions generated for recursive types.

\subsection{In-memory representation}
\label{sec:recur-rep}

% In addition, as C types cannot be
% directly recursive (that would lead to infinite types), we also change
% the (Pstruct) \textbf{which type?} type specified in the recursive
%   declaration so that it is 
% allocated dynamically. To do so, we define a new type \cd{_tree} which
% becomes the actual structure for the tree type. Then, \cd{tree} is
% defined as a pointer to \cd{_tree}.

The in-memory representation of a recursive type is a pointer to the
representation of the underlying type:

\begin{code}
typedef struct _tree_s    *tree;
\end{code}

\subsection{Mask}
\label{sec:recur-masks}
The mask for a recursive type is a pointer to the mask of the
underlying base type.

\begin{code}
typedef struct _tree_m_s  *tree_m;
\end{code}

Note the difference from \ptypedef{}s, which provide a new mask for the new type.

\subsection{Parse descriptor}
\label{sec:recur-parse-descriptors}
The parse descriptor of a \Precur{} with name \cd{myRecur} is a \C{}
struct with name \pdSuf{myRecur}.  This struct has the fields
described in \secref{sec:common-parse-descriptor}. In addition, it
contains a field \cd{val}, the type of which is a pointer to the parse
descriptor for the underlying base type.

For example, the parse descriptor type \pdSuf{tree} has
the following structure:

\begin{code}
typedef struct tree_pd_s tree_pd;

struct tree_pd_s {
  Pflags_t pstate;
  Puint32 nerr;
  PerrCode_t errCode;
  Ploc_t loc;
  struct _tree_pd_s *val;
};
\end{code}

\subsection{Operations}
The operations generated by the \pads{} compiler for a recursive type are
those described in \chapref{chap:common-features}.
The operations appear in \figref{figure:recur-ops}
\textbf{Are there any differences in how the user has to use these
  functions?}

\begin{figure}
\begin{code}
Perror_t tree_init (P_t *pads,tree *rep);

Perror_t tree_pd_init (P_t *pads,tree_pd *pd);

Perror_t tree_cleanup (P_t *pads,tree *rep);

Perror_t tree_pd_cleanup (P_t *pads,tree_pd *pd);

Perror_t tree_copy (P_t *pads,tree *rep_dst,tree *rep_src);

Perror_t tree_pd_copy (P_t *pads,tree_pd *pd_dst,tree_pd *pd_src);

void tree_m_init (P_t *pads,tree_m *mask,Pbase_m baseMask);

Perror_t tree_read (P_t *pads,tree_m *m,tree_pd *pd,tree *rep);

int tree_verify (tree *rep);

ssize_t tree_write2buf (P_t *pads,Pbyte *buf,size_t buf_len,int *buf_full,tree_pd *pd,tree *rep);

ssize_t tree_write2io (P_t *pads,Sfio_t *io,tree_pd *pd,tree *rep);

ssize_t tree_write_xml_2buf (P_t *pads,Pbyte *buf,size_t buf_len,int *buf_full,tree_pd *pd,tree *rep,char const *tag,int indent);

ssize_t tree_write_xml_2io (P_t *pads,Sfio_t *io,tree_pd *pd,tree *rep,char const *tag,int indent);

ssize_t tree_fmt2buf_final (P_t *pads,Pbyte *buf,size_t buf_len,int *buf_full,int *requestedOut,char const *delims,tree_m *m,tree_pd *pd,tree *rep);

ssize_t tree_fmt2buf (P_t *pads,Pbyte *buf,size_t buf_len,int *buf_full,int *requestedOut,char const *delims,tree_m *m,tree_pd *pd,tree *rep);

ssize_t tree_fmt2io (P_t *pads,Sfio_t *io,int *requestedOut,char const *delims,tree_m *m,tree_pd *pd,tree *rep);
\end{code}
\caption{Prototypes of operations generated for
  the \Precur{} \texttt{tree}.}
\label{figure:recur-ops}
\end{figure}


\subsubsection{Read function}
The error codes for \Precur{}s are:

\tskip{}
\begin{center}
\begin{tabular}{l|p{4in}}
Code                           & Meaning \\ \hline
 \cd{P_OK}                 & Indicates no error occurred\\[1ex]
 \cd{P_ERR}                & Indicates an unspecified error occured.\\[1ex]
\end{tabular}
\end{center}

\noindent

\subsubsection{Accumulator functions}
Accumulator functions for recursive types are not yet supported. 

\subsubsection{Histogram functions}
Histogram functions for recursive types are not yet supported.


\subsubsection{Clustering functions}
Clustering functions for recursive types are not yet supported.
