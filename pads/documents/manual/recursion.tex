\chapter{Precurs}
\label{chap:recursion}
\cutname{recursion.html}

{\em Note: this chapter is under development.}

\Precur{} supports the description of tree structured data. It serves
as a forward declaration, informing the compiler that the type
specified will be cyclic.

\section{Syntax}
\label{sec:recur-syntax}
The syntax for \Precur{} is given by the following BNF grammar fragment:
\begin{tabular}{rcl}
\nont{recur\_ty}    & \is{} & \Precur{} \opt{(\nont{p\_ty})} identifier ;
\end{tabular}

\noindent
We explain the meaning of this syntax in the remainder of this chapter.
All non-terminals not defined in this grammar fragment were
defined previously, as follows.
\padsl{} types (\nont{p\_ty}) %and parameter lists (\nont{p\_formals})
in \secref{sec:common-parameterization}. 

\subsection{Examples}
Below, we present the code for a simple binary tree format, based on
the Newick format. A tree is encoded as a matched pair of parentheses
with the two children separated by a comma or no children.
% \inputCode{code/binarytree}
\begin{code}
Precur tree;

Pstruct treeInterior {
  tree left;
  ',';
  tree right;
};

Pstruct tree{
  '(';
  Popt treeInterior;
  ')';
};
\end{code}

In this example, types \cd{tree} and \cd{treeInterior} are mutually
recursive. As with mutually recursive types in C, we need a forward
declaration for the second type, \cd{tree}. The \kw{Precur} construct
serves as forward declaration. 

In addition, as C types cannot be
directly recursive (that would lead to infinite types), we also change
the (Pstruct) type specified in the recursive declaration so that it is
allocated dynamically. To do so, we define a new type \cd{_tree} which
becomes the actual structure for the tree type. Then, \cd{tree} is
defined as a pointer to \cd{_tree}.

For situations in which we cannot change the recursive types as
described, we allow the \kw{Precur} declaration to include an explicit
specfication of the underlying type. So, for example, we could rewrite
the previous example as follows:

\begin{code}
Precur (treeImpl) tree;

Pstruct treeInterior {
  tree left;
  ',';
  tree right;
};

Pstruct treeImpl{
  '(';
  Popt treeInterior;
  ')';
};
\end{code}

Here, \cd{tree} is a pointer to the type \cd{treeImpl}. This feature
can useful in a case where the implementation is specified elsewhere.

\section{Generated library}
We will use the \cd{tree} examples to illustrate the data structures
and functions generated for recursive types.

\subsection{In-memory representation}
\label{sec:recur-rep}
The in-memory representation of a recursive type is a pointer to the
representation of the underlying base type:

\begin{code}
typedef struct _tree_s    *tree;
\end{code}
or (for second for of \Precur{}):
\begin{code}
typedef struct treeImpl    *tree;
\end{code}

\subsection{Mask}
\label{sec:recur-masks}
The mask for a recursive type is a pointer to the
mask of the underlying base type. Note the difference from
\ptypedef{}s, which provide a new mask for the new type.

\begin{code}
typedef struct _tree_m_s  *tree_m;
\end{code}
or
\begin{code}
typedef struct treeImpl_m_s  *tree_m;
\end{code}

\subsection{Parse descriptor}
\label{sec:recur-parse-descriptors}
The parse descriptor for a recursive type is a pointer to the parse
descriptor for the underlying base type.
\begin{code}
typedef struct _tree_pd_s *tree_pd;
\end{code}
or
\begin{code}
typedef struct treeImpl_pd_s *tree_pd;
\end{code}

\subsection{Operations}
The operations generated by the \pads{} compiler for a recursive type are
those described in \chapref{chap:common-features}.
The operations appear in \figref{figure:recur-ops}
\begin{figure}
\begin{code}
Perror_t tree_init (P_t *pads,tree *rep);

Perror_t tree_pd_init (P_t *pads,tree_pd *pd);

Perror_t tree_cleanup (P_t *pads,tree *rep);

Perror_t tree_pd_cleanup (P_t *pads,tree_pd *pd);

Perror_t tree_copy (P_t *pads,tree *rep_dst,tree *rep_src);

Perror_t tree_pd_copy (P_t *pads,tree_pd *pd_dst,tree_pd *pd_src);

void tree_m_init (P_t *pads,tree_m *mask,Pbase_m baseMask);

Perror_t tree_read (P_t *pads,tree_m *m,tree_pd *pd,tree *rep);

int tree_verify (tree *rep);

ssize_t tree_write2buf (P_t *pads,Pbyte *buf,size_t buf_len,int *buf_full,tree_pd *pd,tree *rep);

ssize_t tree_write2io (P_t *pads,Sfio_t *io,tree_pd *pd,tree *rep);

ssize_t tree_write_xml_2buf (P_t *pads,Pbyte *buf,size_t buf_len,int *buf_full,tree_pd *pd,tree *rep,char const *tag,int indent);

ssize_t tree_write_xml_2io (P_t *pads,Sfio_t *io,tree_pd *pd,tree *rep,char const *tag,int indent);

ssize_t tree_fmt2buf_final (P_t *pads,Pbyte *buf,size_t buf_len,int *buf_full,int *requestedOut,char const *delims,tree_m *m,tree_pd *pd,tree *rep);

ssize_t tree_fmt2buf (P_t *pads,Pbyte *buf,size_t buf_len,int *buf_full,int *requestedOut,char const *delims,tree_m *m,tree_pd *pd,tree *rep);

ssize_t tree_fmt2io (P_t *pads,Sfio_t *io,int *requestedOut,char const *delims,tree_m *m,tree_pd *pd,tree *rep);
\end{code}
\caption{Prototypes of operations generated for
  the \Precur{} \texttt{tree}.}
\label{figure:recur-ops}
\end{figure}


\subsubsection{Read function}
The error codes for \Precur{}s are:

\tskip{}
\begin{center}
\begin{tabular}{l|p{4in}}
Code                           & Meaning \\ \hline
 \cd{P_OK}                 & Indicates no error occurred\\[1ex]
 \cd{P_ERR}                & Indicates an unspecified error occured.\\[1ex]
\end{tabular}
\end{center}

\noindent

\subsubsection{Accumulator functions}
Accumulator functions for recursive types are not yet supported.. 
