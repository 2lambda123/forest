\chapter{Precurs}
\label{chap:recursion}
\cutname{recursion.html}

{\em Note: this chapter is under development.}

\Precur{} supports the description of recursive (\ie{},
tree-structured) data. It serves as a forward declaration, informing
the compiler that the type specified will be recursive.

\section{Syntax}
\label{sec:recur-syntax}
The syntax for \Precur{} is given by the following BNF grammar fragment:
\begin{tabular}{rcl}
\nont{recur\_ty}    & \is{} & \Precur{} \opt{(\nont{p\_ty})} identifier ;
\end{tabular}

\noindent
We explain the meaning of this syntax in the remainder of this chapter.
All non-terminals not defined in this grammar fragment were
defined previously:
\padsl{} types (\nont{p\_ty}) %and parameter lists (\nont{p\_formals})
in \secref{sec:common-parameterization}. 

\subsection{Examples}
\textbf{Include some sample data to make intuitions more concrete.}
\textbf{Include citation for newick data}
Below, we present the code for a simple binary tree format, based on
the Newick format. A tree is encoded as a matched pair of parentheses
containing either nothing in the leaf case or a pair of children
separated by a comma in the interior node case.
\inputCode{code/binarytree}
\cut{see code/binarytree.p }
In this example, types \cd{tree} and \cd{treeInterior} are mutually
recursive. As with mutually recursive types in C, we need a forward
declaration for the second type, \cd{tree}. The \kw{Precur} construct
serves as forward declaration. 

\textbf{This text is difficult to follow:ie, I am not sure what you
  are trying to say.  It sounds like it has to do with the generated
  representations and so should be in that section.}
In addition, as C types cannot be
directly recursive (that would lead to infinite types), we also change
the (Pstruct) \textbf{which type?} type specified in the recursive
  declaration so that it is 
allocated dynamically. To do so, we define a new type \cd{_tree} which
becomes the actual structure for the tree type. Then, \cd{tree} is
defined as a pointer to \cd{_tree}.

For situations in which we cannot change the recursive types as
described, \textbf{when would that be?} we allow the \kw{Precur}
declaration to include an explicit 
specfication of the underlying type. So, for example, we could rewrite
the previous example as follows:

\inputCode{code/binarytree2}
\cut{
\begin{code}
Precur (treeImpl) tree;

Pstruct treeInterior {
  tree left;
  ',';
  tree right;
};

Pstruct treeImpl{
  '(';
  Popt treeInterior;
  ')';
};
\end{code}
}

Here, \cd{tree} is a pointer to the type \cd{treeImpl}. This feature
can useful in a case where the implementation is specified elsewhere.

\section{Generated library}
We will use the \cd{tree} examples to illustrate the data structures
and functions generated for recursive types.

\subsection{In-memory representation}
\label{sec:recur-rep}
The in-memory representation of a recursive type is a pointer to the
representation of the underlying base type:

\begin{code}
typedef struct _tree_s    *tree;
\end{code}
or (for second form of \Precur{}):
\begin{code}
typedef struct treeImpl    *tree;
\end{code}

\subsection{Mask}
\label{sec:recur-masks}
The mask for a recursive type is a pointer to the
mask of the underlying base type. 

\begin{code}
typedef struct _tree_m_s  *tree_m;
\end{code}
or
\begin{code}
typedef struct treeImpl_m_s  *tree_m;
\end{code}

Note the difference from \ptypedef{}s, which provide a new mask for the new type.

\subsection{Parse descriptor}
\label{sec:recur-parse-descriptors}
The parse descriptor for a recursive type is a pointer to the parse
descriptor for the underlying base type.
\begin{code}
typedef struct _tree_pd_s *tree_pd;
\end{code}
or
\begin{code}
typedef struct treeImpl_pd_s *tree_pd;
\end{code}

\subsection{Operations}
The operations generated by the \pads{} compiler for a recursive type are
those described in \chapref{chap:common-features}.
The operations appear in \figref{figure:recur-ops}
\textbf{Are there any differences in how the user has to use these
  functions?}

\begin{figure}
\begin{code}
Perror_t tree_init (P_t *pads,tree *rep);

Perror_t tree_pd_init (P_t *pads,tree_pd *pd);

Perror_t tree_cleanup (P_t *pads,tree *rep);

Perror_t tree_pd_cleanup (P_t *pads,tree_pd *pd);

Perror_t tree_copy (P_t *pads,tree *rep_dst,tree *rep_src);

Perror_t tree_pd_copy (P_t *pads,tree_pd *pd_dst,tree_pd *pd_src);

void tree_m_init (P_t *pads,tree_m *mask,Pbase_m baseMask);

Perror_t tree_read (P_t *pads,tree_m *m,tree_pd *pd,tree *rep);

int tree_verify (tree *rep);

ssize_t tree_write2buf (P_t *pads,Pbyte *buf,size_t buf_len,int *buf_full,tree_pd *pd,tree *rep);

ssize_t tree_write2io (P_t *pads,Sfio_t *io,tree_pd *pd,tree *rep);

ssize_t tree_write_xml_2buf (P_t *pads,Pbyte *buf,size_t buf_len,int *buf_full,tree_pd *pd,tree *rep,char const *tag,int indent);

ssize_t tree_write_xml_2io (P_t *pads,Sfio_t *io,tree_pd *pd,tree *rep,char const *tag,int indent);

ssize_t tree_fmt2buf_final (P_t *pads,Pbyte *buf,size_t buf_len,int *buf_full,int *requestedOut,char const *delims,tree_m *m,tree_pd *pd,tree *rep);

ssize_t tree_fmt2buf (P_t *pads,Pbyte *buf,size_t buf_len,int *buf_full,int *requestedOut,char const *delims,tree_m *m,tree_pd *pd,tree *rep);

ssize_t tree_fmt2io (P_t *pads,Sfio_t *io,int *requestedOut,char const *delims,tree_m *m,tree_pd *pd,tree *rep);
\end{code}
\caption{Prototypes of operations generated for
  the \Precur{} \texttt{tree}.}
\label{figure:recur-ops}
\end{figure}


\subsubsection{Read function}
The error codes for \Precur{}s are:

\tskip{}
\begin{center}
\begin{tabular}{l|p{4in}}
Code                           & Meaning \\ \hline
 \cd{P_OK}                 & Indicates no error occurred\\[1ex]
 \cd{P_ERR}                & Indicates an unspecified error occured.\\[1ex]
\end{tabular}
\end{center}

\noindent

\subsubsection{Accumulator functions}
Accumulator functions for recursive types are not yet supported.. 
