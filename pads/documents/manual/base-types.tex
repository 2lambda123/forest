\chapter{Base types}
\label{chap:base-types}
\cutname{base.html}
\PADSL{} base types describe inidivual (typically small) values: numbers, strings, dates, and so on.
This chapter describes a large number of built-in \PADSL{} base types.
It is also possible to extend \PADSL{} with any
number of new base types; see \secref{sec:library-adding-new-base-types}.

\section{In-Memory Representation}
\label{sec:base-types-rep}

Each base type as an external and an in-memory representation, where
related base types share the same in-memory representation.  For
example, while there are 18 different string base types, all of them
use \Pd{string} as their in-memory representation.

This section reviews the different in-memory representation types.

\subsection{{\tt Pchar}}

Type \Pd{char} is the in-memory representation of an external
character.  It is equivalent to the C type \cd{unsigned char}, or type
\Pd{uint8}: all are 8-bit unsigned values.  N.B.: Regardless of the
external character that is read, the corresponding ASCII character is stored in 
the in-memory representation.

\subsection{{\tt Pstring}}

Type \Pd{string} is the in-memory representation for all forms of
external strings.  A \Pd{string} \cd{s} has two fields:
\begin{itemize}
\item \cd{s.len} : the length of the string.
\item \cd{s.str} : a pointer to a sequence of \cd{s.len} characters.
\end{itemize}
In addition, \Pd{string} has fields that are manipulated
by various string functions (some of which are described below).
Most programmers should only use \cd{s.len} and \cd{s.str}.

The library discipline has a field \cd{copy\_strings} which controls
copying behavior for string read calls.  If \cd{copy\_strings} is
non-zero, the string read functions always copy strings. Otherwise, a
copy is not made and the target \Pd{string} points to memory managed by
the current IO discipline.  \cd{copy\_strings} should only be set to
zero for record-based IO disciplines where strings from record K are
not used after \Pd{\_io\_next\_rec} has been called to move the IO cursor
to record K+1.  Note: \Pd{string\_preserve} can be used to force
a string that is using sharing to make a copy so that the string is
'preserved' (remains valid) across calls to \Pd{\_io\_next\_rec}.

When copying is used, the string copies are stored in an internal
resizable buffer, and \cd{s.str} points into this buffer. 
To ensure correct behavior, function \Pd{string\_init} should be called
prior to using a \Pd{string}, and function \Pd{string\_cleanup} should
be called when a given \Pd{string} is no longer in use.
\\[1ex]
These are the full set of string helper functions.
\myvskip{1ex}
\begin{tinycodeaux}{\leftmargin=0in}
Perror_t Pstring_init(P_t *pads, Pstring *s);
Perror_t Pstring_cleanup(P_t *pads, Pstring *s);
Perror_t Pstring_share(P_t *pads, Pstring *targ, const Pstring *src);
Perror_t Pstring_cstr_share(P_t *pads, Pstring *targ, const char *src, size_t len);
Perror_t Pstring_copy(P_t *pads, Pstring *targ, const Pstring *src);
Perror_t Pstring_cstr_copy(P_t *pads, Pstring *targ, const char *src, size_t len);
Perror_t Pstring_preserve(P_t *pads, Pstring *s);
int Pstring_eq(const Pstring *str1, const Pstring *str2);
int Pstring_eq_cstr(const Pstring *str, const char *cstr);
\end{tinycodeaux}
\mbox{}\\[1ex]
\cd{Pstring\_init(pads, s)}: Initialize \cd{s} to valid empty string (no dynamic memory allocated yet).\\[1ex]
\cd{Pstring\_cleanup(pads, s)}: Free any dynamic memory allocated for \cd{s}.\\[1ex]
\cd{Pstring\_share(pads, targ, src)}: make \cd{targ} refer to the string in \cd{src},
sharing the space with the original owner.\\[1ex]
\cd{Pstring\_cstr\_share(pads, targ, src, len)}: make \cd{targ} refer to \cd{len} characters in C-string \cd{src}.\\[1ex]
\cd{Pstring\_copy(pads, targ, src)}: Copy the string in \cd{src} into \cd{targ}; sharing is not used.\\[1ex]
\cd{Pstring\_cstr\_copy(pads, targ, src, len)}: Copy \cd{len} characters from C-string \cd{src} into \cd{targ}; sharing is not used.\\[1ex]
\cd{Pstring\_eq(str1, str2)}: returns \cd{0} if \cd{str1} equals \cd{str2}, a negative number if \cd{str1 < str2},
and a positive number if \cd{str1 > str2}.\\[1ex]
\cd{Pstring\_eq(str, cstr)}: returns \cd{0} if \cd{str} equals \cd{cstr}, a negative number if \cd{str < cstr},
and a positive number if \cd{str > cstr}.\\[1ex]

Although not strictly necessary, both \Pd{string\_copy} and \Pd{string\_cstr\_copy} null-terminate \cd{targ->str}.
Each copy function returns \Pd{\_ERR} on bad arguments or on failure to alloc space, otherwise it returns \Pd{\_OK}.

\subsection{Integer types}

There are 8 in-memory representations for integers, four types for
signed values (\Pd{int8}, \Pd{int16}, \Pd{int32}, and \Pd{int64})
and four types for unsigned values (\Pd{uint8}, \Pd{uint16}, \Pd{uint32}, and \Pd{uint64}).
The number in these type names indicates the number of bits in the in-memory representation,
thus there are signed and unsigned integers that use 1, 2, 4, or 8 bytes of memory.
The endian-ness of these in-memory representation types is the same as the
endian-ness of the processor that the code is executing on.  Thus,
the external representation, which may be in another format, is always converted
to a primitive in-memory representation supported by the processor.

For programming convenience, the header file {\tt padsc.h} includes definitions of the minimum
and maximum values for each signed type, and of the maximum value for each unsigned type:
\begin{tinycode}
P_MIN_INT8
P_MAX_INT8
P_MAX_UINT8

P_MIN_INT16
P_MAX_INT16
P_MAX_UINT16

P_MIN_INT32
P_MAX_INT32
P_MAX_UINT32

P_MIN_INT64
P_MAX_INT64
P_MAX_UINT64
\end{tinycode}

\subsection{Floating-point types}

\PADSL{} has only two in-memory floating point representations,
\Pd{float32} and \Pd{float64}, which correspond to ansi C types \cd{float}
and \cd{double}, respectively.

\subsection{Fixed-point types}

A fixed-point number is a number with a fixed number of decimal digits
(digits after the 'dot').  For example, 123.456 is a fixed-point
number with three decimal digits.  External formats for such numbers
occur, e.g., in COBOL data.  We have chosen a very simple in-memory
representation for such numbers: a struct with a numerator (\cd{num})
that contains all of the digits and a denominator (\cd{denom}) that
contains some power of 10.  For example, 123.456 would be represented
with a numerator containing 123456 and a denominator containing 1000 ($10^3$).

The in-memory representation always has an unsigned denominator. We
provide signed and unsigned representations that use signed and
unsigned numerators, respectively.  One can choose the number of bits
used for both numerator and denominator in the same way as for the
integer types, thus there are four four types for signed values
and four types for unsigned values:

\begin{tinycodeaux}{\leftmargin=0in}
typedef struct \{ Pint8   num; Puint8  denom; \} Pfpoint8;
typedef struct \{ Pint16  num; Puint16 denom; \} Pfpoint16;
typedef struct \{ Pint32  num; Puint32 denom; \} Pfpoint32;
typedef struct \{ Pint64  num; Puint64 denom; \} Pfpoint64;

typedef struct \{ Puint8  num; Puint8  denom; \} Pufpoint8;
typedef struct \{ Puint16 num; Puint16 denom; \} Pufpoint16;
typedef struct \{ Puint32 num; Puint32 denom; \} Pufpoint32;
typedef struct \{ Puint64 num; Puint64 denom; \} Pufpoint64;
\end{tinycodeaux}

There are two macros to help one use values of these in-memory types.
\Pd{\_FPOINT2FLOAT32(fp)} calculates \cd{fp.num/fp.denom} as a \Pd{float32},
while \Pd{\_FPOINT2FLOAT64(fp)} calculates \cd{fp.num/fp.denom} as a \Pd{float64}.

\section{Base Type Mask}
\label{sec:base-type-mask}

XXX \Pbasem{} was already described?

\section{Base Type Parse Descriptor}
\label{sec:base-type-parse-descriptors}

XXX already described \Pbasepd{}.  Which involves describing \Ploct{}, \Ppost{},
and \PerrCodet{}.  

Specific error codes are discussed below
when the base type read functions are described.

\section{Character Sets}

\PADSL{} currently supports two character sets for external data, ASCII and EBCDIC.
As discussed in \secref{sec:common-character-sets}, the library
discipline contain a field
\cd{def\_charset} that selects which character set to use when
one is not specified explicitly.  As a result, for each 'kind' of data
that has an external form made up of characters (characters, strings,
character-based dates, character-based integer and floating point
numbers, \etc{}), \PADSL{} has three types: a type that indicates the external
form is always ASCII, a type that indicates the external form is
always EBCDIC, and a type that indicates that the external form uses
the character set specified in \cd{def\_charset}.

In each section below describing character-based types, we give a
three-column table indicating the type(s) that use ASCII, EBCDIC, or
DEFAULT character sets.  For example, the next section begins with a
table showing types \Pa{char} (ASCII), \Pe{char} (EBCDIC), \Pd{char}
(DEFAULT).

\section{Character Base Types}

\subsection{Fixed-width character-based encoding}

\aedBegin{}
\aedLine{char}
\aedEnd{}
\\[1ex]
The corresponding read functions are:
\begin{tinycodeaux}{\leftmargin=0in}
Perror_t Pchar_read   (P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pchar *c_out);
Perror_t Pa_char_read (P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pchar *c_out);
Perror_t Pe_char_read (P_t *pads, const Pbase_m *m, Pbase_pd *pd, Pchar *c_out);
\end{tinycodeaux}

\subsection{Special character base types}

\aedBegin{}
\aedLine{countX}
\aedLine{countXtoY}
\aedEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
Perror_t PcountX     (P_t *pads, const Pbase_m *m, Puint8 x, int eor_required,
		      Pbase_pd *pd, Pint32 *res_out);
Perror_t Pa_countX   (P_t *pads, const Pbase_m *m, Puint8 x, int eor_required,
		      Pbase_pd *pd, Pint32 *res_out);
Perror_t Pe_countX   (P_t *pads, const Pbase_m *m, Puint8 x, int eor_required,
		      Pbase_pd *pd, Pint32 *res_out);

Perror_t PcountXtoY  (P_t *pads, const Pbase_m *m, Puint8 x, Puint8 y,
		      Pbase_pd *pd, Pint32 *res_out);
Perror_t Pa_countXtoY(P_t *pads, const Pbase_m *m, Puint8 x, Puint8 y,
		      Pbase_pd *pd, Pint32 *res_out);
Perror_t Pe_countXtoY(P_t *pads, const Pbase_m *m, Puint8 x, Puint8 y,
		      Pbase_pd *pd, Pint32 *res_out);
\end{tinycodeaux}

\section{String Base Types}

\subsection{Fixed-width character-based encoding}

\aedBegin{}
\aedLine{string\_FW}
\aedEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
Perror_t Pstring_FW_read   (P_t *pads, const Pbase_m *m, size_t width,
			    Pbase_pd *pd, Pstring *s_out);
Perror_t Pa_string_FW_read (P_t *pads, const Pbase_m *m, size_t width,
			    Pbase_pd *pd, Pstring *s_out);
Perror_t Pe_string_FW_read (P_t *pads, const Pbase_m *m, size_t width,
			    Pbase_pd *pd, Pstring *s_out);
\end{tinycodeaux}

\subsection{Variable-width character-based encoding}

\aedBegin{}
\aedLine{string}
\aedLine{string\_ME}
\aedLine{string\_CME}
\aedLine{string\_SE}
\aedLine{string\_CSE}
\aedEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
Perror_t Pstring_read      (P_t *pads, const Pbase_m *m, Pchar stopChar,
			    Pbase_pd *pd, Pstring *s_out);
Perror_t Pa_string_read    (P_t *pads, const Pbase_m *m, Pchar stopChar,
			    Pbase_pd *pd, Pstring *s_out);
Perror_t Pe_string_read    (P_t *pads, const Pbase_m *m, Pchar stopChar,
			    Pbase_pd *pd, Pstring *s_out);

Perror_t Pstring_ME_read   (P_t *pads, const Pbase_m *m, const char *matchRegexp,
			    Pbase_pd *pd, Pstring *s_out);
Perror_t Pa_string_ME_read (P_t *pads, const Pbase_m *m, const char *matchRegexp,
			    Pbase_pd *pd, Pstring *s_out);
Perror_t Pe_string_ME_read (P_t *pads, const Pbase_m *m, const char *matchRegexp,
			    Pbase_pd *pd, Pstring *s_out);

Perror_t Pstring_CME_read  (P_t *pads, const Pbase_m *m, Pregexp_t *matchRegexp,
			    Pbase_pd *pd, Pstring *s_out);
Perror_t Pa_string_CME_read(P_t *pads, const Pbase_m *m, Pregexp_t *matchRegexp,
			    Pbase_pd *pd, Pstring *s_out);
Perror_t Pe_string_CME_read(P_t *pads, const Pbase_m *m, Pregexp_t *matchRegexp,
			    Pbase_pd *pd, Pstring *s_out);

Perror_t Pstring_SE_read   (P_t *pads, const Pbase_m *m, const char *stopRegexp,
			    Pbase_pd *pd, Pstring *s_out);
Perror_t Pa_string_SE_read (P_t *pads, const Pbase_m *m, const char *stopRegexp,
			    Pbase_pd *pd, Pstring *s_out);
Perror_t Pe_string_SE_read (P_t *pads, const Pbase_m *m, const char *stopRegexp,
			    Pbase_pd *pd, Pstring *s_out);

Perror_t Pstring_CSE_read  (P_t *pads, const Pbase_m *m, Pregexp_t *stopRegexp,
			    Pbase_pd *pd, Pstring *s_out);
Perror_t Pa_string_CSE_read(P_t *pads, const Pbase_m *m, Pregexp_t *stopRegexp,
			    Pbase_pd *pd, Pstring *s_out);
Perror_t Pe_string_CSE_read(P_t *pads, const Pbase_m *m, Pregexp_t *stopRegexp,
			    Pbase_pd *pd, Pstring *s_out);
\end{tinycodeaux}

\subsection{Special string base types}

\aedBegin{}
\Pd{date}, \Pa{date}, \Pe{date}.
\aedEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
Perror_t Pdate_read  (P_t *pads, const Pbase_m *m, Pchar stopChar,
		      Pbase_pd *pd, Puint32 *res_out);
Perror_t Pa_date_read(P_t *pads, const Pbase_m *m, Pchar stopChar,
		      Pbase_pd *pd, Puint32 *res_out);
Perror_t Pe_date_read(P_t *pads, const Pbase_m *m, Pchar stopChar,
		      Pbase_pd *pd, Puint32 *res_out);
\end{tinycodeaux}

\section{Integer Base Types}

\subsection{Fixed-width character-based encoding}

\aedBegin{}
\aedLine{int8\_FW}
\aedLine{int16\_FW}
\aedLine{int32\_FW}
\aedLine{int64\_FW}
\aedLine{uint8\_FW}
\aedLine{uint16\_FW}
\aedLine{uint32\_FW}
\aedLine{uint64\_FW}
\aedEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
Perror_t Pa_int8_FW_read (P_t *pads, const Pbase_m *m, size_t width,
			  Pbase_pd *pd, Pint8 *res_out);
Perror_t Pa_int16_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			  Pbase_pd *pd, Pint16 *res_out);
Perror_t Pa_int32_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			  Pbase_pd *pd, Pint32 *res_out);
Perror_t Pa_int64_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			  Pbase_pd *pd, Pint64 *res_out);

Perror_t Pa_uint8_FW_read (P_t *pads, const Pbase_m *m, size_t width,
			   Pbase_pd *pd, Puint8 *res_out);
Perror_t Pa_uint16_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			   Pbase_pd *pd, Puint16 *res_out);
Perror_t Pa_uint32_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			   Pbase_pd *pd, Puint32 *res_out);
Perror_t Pa_uint64_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			   Pbase_pd *pd, Puint64 *res_out);

Perror_t Pe_int8_FW_read (P_t *pads, const Pbase_m *m, size_t width,
			  Pbase_pd *pd, Pint8 *res_out);
Perror_t Pe_int16_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			  Pbase_pd *pd, Pint16 *res_out);
Perror_t Pe_int32_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			  Pbase_pd *pd, Pint32 *res_out);
Perror_t Pe_int64_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			  Pbase_pd *pd, Pint64 *res_out);

Perror_t Pe_uint8_FW_read (P_t *pads, const Pbase_m *m, size_t width,
			   Pbase_pd *pd, Puint8 *res_out);
Perror_t Pe_uint16_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			   Pbase_pd *pd, Puint16 *res_out);
Perror_t Pe_uint32_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			   Pbase_pd *pd, Puint32 *res_out);
Perror_t Pe_uint64_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			   Pbase_pd *pd, Puint64 *res_out);

Perror_t Pint8_FW_read (P_t *pads, const Pbase_m *m, size_t width,
			Pbase_pd *pd, Pint8 *res_out);
Perror_t Pint16_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			Pbase_pd *pd, Pint16 *res_out);
Perror_t Pint32_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			Pbase_pd *pd, Pint32 *res_out);
Perror_t Pint64_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			Pbase_pd *pd, Pint64 *res_out);

Perror_t Puint8_FW_read (P_t *pads, const Pbase_m *m, size_t width,
			 Pbase_pd *pd, Puint8 *res_out);
Perror_t Puint16_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			 Pbase_pd *pd, Puint16 *res_out);
Perror_t Puint32_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			 Pbase_pd *pd, Puint32 *res_out);
Perror_t Puint64_FW_read(P_t *pads, const Pbase_m *m, size_t width,
			 Pbase_pd *pd, Puint64 *res_out);
\end{tinycodeaux}

\subsection{Variable-width character-based encoding}

\aedBegin{}
\aedLine{int8}
\aedLine{int16}
\aedLine{int32}
\aedLine{int64}
\aedLine{uint8}
\aedLine{uint16}
\aedLine{uint32}
\aedLine{uint64}
\aedEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
\codeallowbreaks
Perror_t Pa_int8_read (P_t *pads, const Pbase_m *m,
		       Pbase_pd *pd, Pint8 *res_out);
Perror_t Pa_int16_read(P_t *pads, const Pbase_m *m,
		       Pbase_pd *pd, Pint16 *res_out);
Perror_t Pa_int32_read(P_t *pads, const Pbase_m *m,
		       Pbase_pd *pd, Pint32 *res_out);
Perror_t Pa_int64_read(P_t *pads, const Pbase_m *m,
		       Pbase_pd *pd, Pint64 *res_out);

Perror_t Pa_uint8_read (P_t *pads, const Pbase_m *m,
			Pbase_pd *pd, Puint8 *res_out);
Perror_t Pa_uint16_read(P_t *pads, const Pbase_m *m,
			Pbase_pd *pd, Puint16 *res_out);
Perror_t Pa_uint32_read(P_t *pads, const Pbase_m *m,
			Pbase_pd *pd, Puint32 *res_out);
Perror_t Pa_uint64_read(P_t *pads, const Pbase_m *m,
			Pbase_pd *pd, Puint64 *res_out);

Perror_t Pe_int8_read (P_t *pads, const Pbase_m *m,
		       Pbase_pd *pd, Pint8 *res_out);
Perror_t Pe_int16_read(P_t *pads, const Pbase_m *m,
		       Pbase_pd *pd, Pint16 *res_out);
Perror_t Pe_int32_read(P_t *pads, const Pbase_m *m,
		       Pbase_pd *pd, Pint32 *res_out);
Perror_t Pe_int64_read(P_t *pads, const Pbase_m *m,
		       Pbase_pd *pd, Pint64 *res_out);

Perror_t Pe_uint8_read (P_t *pads, const Pbase_m *m,
			Pbase_pd *pd, Puint8 *res_out);
Perror_t Pe_uint16_read(P_t *pads, const Pbase_m *m,
			Pbase_pd *pd, Puint16 *res_out);
Perror_t Pe_uint32_read(P_t *pads, const Pbase_m *m,
			Pbase_pd *pd, Puint32 *res_out);
Perror_t Pe_uint64_read(P_t *pads, const Pbase_m *m,
			Pbase_pd *pd, Puint64 *res_out);

Perror_t Pint8_read (P_t *pads, const Pbase_m *m,
		     Pbase_pd *pd, Pint8 *res_out);
Perror_t Pint16_read(P_t *pads, const Pbase_m *m,
		     Pbase_pd *pd, Pint16 *res_out);
Perror_t Pint32_read(P_t *pads, const Pbase_m *m,
		     Pbase_pd *pd, Pint32 *res_out);
Perror_t Pint64_read(P_t *pads, const Pbase_m *m,
		     Pbase_pd *pd, Pint64 *res_out);

Perror_t Puint8_read (P_t *pads, const Pbase_m *m,
		      Pbase_pd *pd, Puint8 *res_out);
Perror_t Puint16_read(P_t *pads, const Pbase_m *m,
		      Pbase_pd *pd, Puint16 *res_out);
Perror_t Puint32_read(P_t *pads, const Pbase_m *m,
		      Pbase_pd *pd, Puint32 *res_out);
Perror_t Puint64_read(P_t *pads, const Pbase_m *m,
		      Pbase_pd *pd, Puint64 *res_out);
\end{tinycodeaux}

\subsection{Raw binary encoding}

\bBegin{}
\bLine{int8}
\bLine{int16}
\bLine{int32}
\bLine{int64}
\bLine{uint8}
\bLine{uint16}
\bLine{uint32}
\bLine{uint64}
\bEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
\codeallowbreaks
Perror_t Pb_int8_read (P_t *pads, const Pbase_m *m,
		       Pbase_pd *pd, Pint8 *res_out);
Perror_t Pb_int16_read(P_t *pads, const Pbase_m *m,
		       Pbase_pd *pd, Pint16 *res_out);
Perror_t Pb_int32_read(P_t *pads, const Pbase_m *m,
		       Pbase_pd *pd, Pint32 *res_out);
Perror_t Pb_int64_read(P_t *pads, const Pbase_m *m,
		       Pbase_pd *pd, Pint64 *res_out);

Perror_t Pb_uint8_read (P_t *pads, const Pbase_m *m,
			Pbase_pd *pd, Puint8 *res_out);
Perror_t Pb_uint16_read(P_t *pads, const Pbase_m *m,
			Pbase_pd *pd, Puint16 *res_out);
Perror_t Pb_uint32_read(P_t *pads, const Pbase_m *m,
			Pbase_pd *pd, Puint32 *res_out);
Perror_t Pb_uint64_read(P_t *pads, const Pbase_m *m,
			Pbase_pd *pd, Puint64 *res_out);
\end{tinycodeaux}

\subsection{Serialize binary encoding}

\sbBegin{}
\sbLine{int8}
\sbLine{int16}
\sbLine{int32}
\sbLine{int64}
\sbLine{uint8}
\sbLine{uint16}
\sbLine{uint32}
\sbLine{uint64}
\bEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
\codeallowbreaks
Perror_t Psbl_int8_read    (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Pint8 *res_out);
Perror_t Psbl_int16_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Pint16 *res_out);
Perror_t Psbl_int32_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Pint32 *res_out);
Perror_t Psbl_int64_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Pint64 *res_out);

Perror_t Psbl_uint8_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Puint8 *res_out);
Perror_t Psbl_uint16_read  (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Puint16 *res_out);
Perror_t Psbl_uint32_read  (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Puint32 *res_out);
Perror_t Psbl_uint64_read  (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Puint64 *res_out);

Perror_t Psbh_int8_read    (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Pint8 *res_out);
Perror_t Psbh_int16_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Pint16 *res_out);
Perror_t Psbh_int32_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Pint32 *res_out);
Perror_t Psbh_int64_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Pint64 *res_out);

Perror_t Psbh_uint8_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Puint8 *res_out);
Perror_t Psbh_uint16_read  (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Puint16 *res_out);
Perror_t Psbh_uint32_read  (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Puint32 *res_out);
Perror_t Psbh_uint64_read  (P_t *pads, const Pbase_m *m, Puint32 num_bytes,
			    Pbase_pd *pd, Puint64 *res_out);
\end{tinycodeaux}

\subsection{EBC and BCD encoding}

\cBegin{}
\cLine{int8}
\cLine{int16}
\cLine{int32}
\cLine{int64}
\cLine{uint8}
\cLine{uint16}
\cLine{uint32}
\cLine{uint64}
\cEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
\codeallowbreaks
Perror_t Pebc_int8_read   (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Pint8 *res_out);
Perror_t Pebc_int16_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Pint16 *res_out);
Perror_t Pebc_int32_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Pint32 *res_out);
Perror_t Pebc_int64_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Pint64 *res_out);

Perror_t Pebc_uint8_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Puint8 *res_out);
Perror_t Pebc_uint16_read (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Puint16 *res_out);
Perror_t Pebc_uint32_read (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Puint32 *res_out);
Perror_t Pebc_uint64_read (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Puint64 *res_out);

Perror_t Pbcd_int8_read   (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Pint8 *res_out);
Perror_t Pbcd_int16_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Pint16 *res_out);
Perror_t Pbcd_int32_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Pint32 *res_out);
Perror_t Pbcd_int64_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Pint64 *res_out);

Perror_t Pbcd_uint8_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Puint8 *res_out);
Perror_t Pbcd_uint16_read (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Puint16 *res_out);
Perror_t Pbcd_uint32_read (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Puint32 *res_out);
Perror_t Pbcd_uint64_read (P_t *pads, const Pbase_m *m, Puint32 num_digits,
			   Pbase_pd *pd, Puint64 *res_out);
\end{tinycodeaux}

\section{Floating Point Base Types}

\subsection{Fixed-width character-based encoding}

\aedBegin{}
\aedLine{float32\_FW}
\aedLine{float64\_FW}
\aedEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
\end{tinycodeaux}

\subsection{Variable-width character-based encoding}

\aedBegin{}
\aedLine{float32}
\aedLine{float64}
\aedEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
\end{tinycodeaux}

\subsection{Raw binary encoding}

\bBegin{}
\bLine{float32}
\bLine{float64}
\bEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
\end{tinycodeaux}

\subsection{Serialized binary encoding}

\sbBegin{}
\sbLine{float32}
\sbLine{float64}
\sbEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
\end{tinycodeaux}

\section{Fixed Point Base Types}

\subsection{Serialized binary encoding}

\sbBegin{}
\sbLine{fpoint8}
\sbLine{fpoint16}
\sbLine{fpoint32}
\sbLine{fpoint64}
\sbLine{ufpoint8}
\sbLine{ufpoint16}
\sbLine{ufpoint32}
\sbLine{ufpoint64}
\bEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
\codeallowbreaks
Perror_t Psbl_fpoint8_read    (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pfpoint8 *res_out);
Perror_t Psbl_fpoint16_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pfpoint16 *res_out);
Perror_t Psbl_fpoint32_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pfpoint32 *res_out);
Perror_t Psbl_fpoint64_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pfpoint64 *res_out);

Perror_t Psbl_ufpoint8_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pufpoint8 *res_out);
Perror_t Psbl_ufpoint16_read  (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pufpoint16 *res_out);
Perror_t Psbl_ufpoint32_read  (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pufpoint32 *res_out);
Perror_t Psbl_ufpoint64_read  (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pufpoint64 *res_out);

Perror_t Psbh_fpoint8_read    (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pfpoint8 *res_out);
Perror_t Psbh_fpoint16_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pfpoint16 *res_out);
Perror_t Psbh_fpoint32_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pfpoint32 *res_out);
Perror_t Psbh_fpoint64_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pfpoint64 *res_out);

Perror_t Psbh_ufpoint8_read   (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pufpoint8 *res_out);
Perror_t Psbh_ufpoint16_read  (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pufpoint16 *res_out);
Perror_t Psbh_ufpoint32_read  (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pufpoint32 *res_out);
Perror_t Psbh_ufpoint64_read  (P_t *pads, const Pbase_m *m, Puint32 num_bytes, Puint32 d_exp,
			       Pbase_pd *pd, Pufpoint64 *res_out);
\end{tinycodeaux}

\subsection{EBC and BCD encoding}

\cBegin{}
\cLine{fpoint8}
\cLine{fpoint16}
\cLine{fpoint32}
\cLine{fpoint64}
\cLine{ufpoint8}
\cLine{ufpoint16}
\cLine{ufpoint32}
\cLine{ufpoint64}
\cEnd{}

\begin{tinycodeaux}{\leftmargin=0in}
\codeallowbreaks
Perror_t Pebc_fpoint8_read   (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pfpoint8 *res_out);
Perror_t Pebc_fpoint16_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pfpoint16 *res_out);
Perror_t Pebc_fpoint32_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pfpoint32 *res_out);
Perror_t Pebc_fpoint64_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pfpoint64 *res_out);

Perror_t Pebc_ufpoint8_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pufpoint8 *res_out);
Perror_t Pebc_ufpoint16_read (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pufpoint16 *res_out);
Perror_t Pebc_ufpoint32_read (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pufpoint32 *res_out);
Perror_t Pebc_ufpoint64_read (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pufpoint64 *res_out);

Perror_t Pbcd_fpoint8_read   (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pfpoint8 *res_out);
Perror_t Pbcd_fpoint16_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pfpoint16 *res_out);
Perror_t Pbcd_fpoint32_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pfpoint32 *res_out);
Perror_t Pbcd_fpoint64_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pfpoint64 *res_out);

Perror_t Pbcd_ufpoint8_read  (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pufpoint8 *res_out);
Perror_t Pbcd_ufpoint16_read (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pufpoint16 *res_out);
Perror_t Pbcd_ufpoint32_read (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pufpoint32 *res_out);
Perror_t Pbcd_ufpoint64_read (P_t *pads, const Pbase_m *m, Puint32 num_digits, Puint32 d_exp,
			      Pbase_pd *pd, Pufpoint64 *res_out);

\end{tinycodeaux}
