
\chapter{Base Types Overview}
\label{chap:base-types}
\cutname{base.html}

\PADSL{} base types describe inidivual, small values: numbers, strings, dates, and so on.
This chapter provides an overview of some of the most important built-in \PADSL{} base types,
with a focus on how these types are used within \PADSL{} source files.
\appref{ap:base-types} gives detailed descriptions of each of the built-in base types,
including the full set of library API calls for each type.  (As discussed in
\chapref{chap:common-features}, each type has correspond read, write,
format, and accumulator functions.) 

In addition to the built-in types, it is possible to extend \PADSL{} with 
new base types; see \secref{sec:library-adding-new-base-types}.

\section{In-Memory Representation}
\label{sec:base-types-rep}

Each base type has an external and an in-memory representation. 
Related base types share the same in-memory representation.  For
example, while there are 18 different string base types, all of them
use \Pd{string} as their in-memory representation.

This section reviews the different in-memory representation types.

\subsection{{\tt Pchar}}

Type \Pd{char} is the in-memory representation of an external
character.  It is equivalent to the C type \cd{unsigned char}, or type
\Pd{uint8}: all are 8-bit unsigned values.  {\bf N.B.}: Regardless of the
external character that is read, the corresponding ASCII character is stored in 
the in-memory representation.

\subsection{{\tt Pstring}}

Type \Pd{string} is the in-memory representation for all forms of
external strings.  A \Pd{string} \cd{s} has two fields:
\begin{itemize}
\item \cd{s.len} : the length of the string.
\item \cd{s.str} : a pointer to a sequence of \cd{s.len} characters.
\end{itemize}
In addition, \Pd{string} has fields that are manipulated
by various string functions (some of which are described below).
Most programmers should only use \cd{s.len} and \cd{s.str}.

The library discipline has a field \cd{copy\_strings} which controls
copying behavior for string read calls.  If \cd{copy\_strings} is
non-zero, the string read functions always copy strings. Otherwise, a
copy is not made and the target \Pd{string} points to memory managed by
the current IO discipline.  \cd{copy\_strings} should only be set to
zero for record-based IO disciplines where strings from record K are
not used after \Pd{\_io\_next\_rec} has been called to move the IO cursor
to record K+1.  Note: \Pd{string\_preserve} can be used to force
a string that is using sharing to make a copy so that the string is
'preserved' (remains valid) across calls to \Pd{\_io\_next\_rec}.

When copying is used, the string copies are stored in an internal
resizable buffer, and \cd{s.str} points into this buffer. 
To ensure correct behavior, function \Pd{string\_init} should be called
prior to using a \Pd{string}, and function \Pd{string\_cleanup} should
be called when a given \Pd{string} is no longer in use.
Generated initialization and cleanup functions call these routines for
any \pads{} type containing a \Pd{string}.

The full set of string helper functions appears in \figref{fig:string-functions}.
\begin{figure}
\inputCode{code/strings}
\caption{Library functions for manipulating \texttt{Pstring}s.}
\label{fig:string-functions}
\end{figure}

The following list describes the behaviors of these functions.
\begin{description}
\item[\cd{Pstring\_init(pads, s)}] 
  Initialize \cd{s} to valid empty string (no dynamic memory allocated yet).
\item[\cd{Pstring\_cleanup(pads, s)}] 
  Free any dynamic memory allocated for \cd{s}.
\item[\cd{Pstring\_share(pads, targ, src)}] 
  Make \cd{targ} refer to the string in \cd{src}, sharing the space with the original owner.
\item[\cd{Pstring\_cstr\_share(pads, targ, src, len)}] 
  Make \cd{targ} refer to \cd{len} characters in C-string \cd{src}.
\item[\cd{Pstring\_copy(pads, targ, src)}]
  Copy the string in \cd{src} into \cd{targ}; sharing is not used.
\item[\cd{Pstring\_cstr\_copy(pads, targ, src, len)}] 
 Copy \cd{len} characters from C-string \cd{src} into \cd{targ}; sharing is not used.
\item[\cd{Pstring\_eq(str1, str2)}] 
 Returns \cd{1} if \cd{str1} and \cd{str2} are of equal length and
 \cd{str1} equals \cd{str2} (based on strncmp). Otherwise, returns \cd{0}.
\item[\cd{Pstring\_eq\_cstr(str, cstr)}]
 Returns \cd{1} if \cd{str1} and \cd{str2} are of equal length and
 \cd{str1} equals \cd{str2} (based on strncmp). Otherwise, returns \cd{0}.
\end{description}

Although not strictly necessary, both \Pd{string\_copy} and
\Pd{string\_cstr\_copy} null-terminate \cd{targ->str}.  Each copy
function returns \Pd{\_ERR} on bad arguments or on failure to allocate
space, otherwise it returns \Pd{\_OK}.

The various Pstring2NUMERIC functions convert a string to the
specified numeric type.  If the contents of the string cannot be
converted to the specified type, the minumum value for the numeric
type is returned for signed numeric types, or the maximum value is
returned for unsigned numeric types.

\subsection{Integer types}

There are eight in-memory representations for integers, four types for
signed values (\Pd{int8}, \Pd{int16}, \Pd{int32}, and \Pd{int64})
and four types for unsigned values (\Pd{uint8}, \Pd{uint16}, \Pd{uint32}, and \Pd{uint64}).
The number in these type names indicates the number of bits in the in-memory representation,
thus there are signed and unsigned integers that use 1, 2, 4, or 8 bytes of memory.
The endian-ness of these in-memory representation types is the same as the
endian-ness of the processor that the code is executing on. 
The external representation, which may be in another format, is always converted
to the primitive in-memory representation supported by the processor.

For programming convenience, the header file {\tt pads.h} includes definitions of the minimum
and maximum values for each signed type, and of the maximum value for
each unsigned type.  \figref{fig:limits} list these constants.
\begin{figure}
\inputCode{code/limits}
\caption{Minimum and maximum values for \pads{} integer types.}
\label{fig:limits}
\end{figure}


\subsection{Floating-point types}

\PADSL{} has only two in-memory floating point representations,
\Pd{float32} and \Pd{float64}, which correspond to ANSI C types \cd{float}
and \cd{double}, respectively.

\subsection{Fixed-point types}

A fixed-point number is a number with a fixed number of decimal digits
(digits after the 'dot').  For example, 123.456 is a fixed-point
number with three decimal digits.  External formats for such numbers
occur, e.g., in COBOL data.  We have chosen a very simple in-memory
representation for such numbers: a struct with a numerator (\cd{num})
that contains all of the digits and a denominator (\cd{denom}) that
contains some power of 10.  For example, 123.456 would be represented
with a numerator containing 123456 and a denominator containing 1000 ($10^3$).

The in-memory representation always has an unsigned denominator. We
provide signed and unsigned representations that use signed and
unsigned numerators, respectively.  One can choose the number of bits
used for both numerator and denominator in the same way as for the
integer types, thus there are four types for signed values
and four types for unsigned values:

\inputCode{code/fixedpoint}

There are two macros to help one use values of these in-memory types.
\Pd{\_FPOINT2FLOAT32(fp)} calculates \cd{fp.num/fp.denom} as a \Pd{float32},
while \Pd{\_FPOINT2FLOAT64(fp)} calculates \cd{fp.num/fp.denom} as a \Pd{float64}.

\section{Base Type Mask}
\label{sec:base-type-mask}
The mask for base types is just an integer type, treated as an array
of bits:

\begin{centercode}
 typedef Puint32 Pbase\_m;
\end{centercode}
%
\noindent
Masks for accessing individual bits of the base type masks are described in
sections describing operations that use mask. (\cf{}
\secref{sec:common-features-read-function}). 
More information about how base types handle masks is available in
\appref{ap:base-types}

\section{Base Type Parse Descriptor}
\label{sec:base-type-parse-descriptors}
Parse descriptors for base types contain only the fields described in 
\secref{sec:common-parse-descriptor}.
Specific error codes are discussed when the base type read functions
are described.


\section{Character Sets}

\PADSL{} currently supports two character sets for external data, ASCII and EBCDIC.
As discussed in \secref{sec:common-character-sets}, the library
discipline contains a field
\cd{def\_charset} that selects which character set to use when
one is not specified explicitly.  As a result, for each 'kind' of data
that has an external form made up of characters (characters, strings,
character-based dates, character-based integer and floating point
numbers, \etc{}), \PADSL{} has three types: a type that indicates the external
form is always ASCII, a type that indicates the external form is
always EBCDIC, and a type that indicates that the external form uses
the character set specified in \cd{def\_charset}.

In each section describing character-based types, we give a
three-column table indicating the type(s) that use ASCII, EBCDIC, or
DEFAULT character sets.  For example, the next section begins with a
table showing types \Pa{char} (ASCII), \Pe{char} (EBCDIC), \Pd{char}
(DEFAULT).

\section{Character Base Types}

\subsection{Fixed-width character-based encoding}

\aedBegin{}
\aedLine{char}
\aedEnd{}
\myvskip{1ex}

\noindent
For example,  writing

\inputCode{code/char-decl}
%
\noindent
in a \PADSL{} source file (within a Pstruct, for example) indicates
that a single ASCII character is expected.  Writing a constraint
such as 

\inputCode{code/char-constraint-decl}
%
\noindent
indicates that an EBCDIC capital letter A or B is expected.
{\bf NB:}\/ Note that the constraint expression is applied to the
{\em in-memory\/} representation of c, which is an ASCII value,
thus the C character constants (ASCII constants)
are used to specify letters A and B.

\subsection{Special character counting base types}

\aedBegin{}
\aedLine{countX}
\aedLine{countXtoY}
\aedEnd{}

Unlike all other base types, these counting base types
never advance the IO cursor.  You can think of these types as
``peeking ahead'' to see how many occurrences of a given character
appear forward of the current IO cursor position.

The PcountX types count the number of occurences of character X
between the current IO cursor position and the fist EOR (end of
record) or EOF (end of file).  They take three parameters, \cd{x},
\cd{eor_required}, and \cd{count_max}.  \cd{x} is the character to count.  If
\cd{eor_required} is non-zero, then encountering EOF before EOR produces
an error.  If \cd{count_max} is non-zero, EOR/EOF must be encountered
before scanning \cd{count_max} characters, otherwise an error is returned.
For example,

\inputCode{code/countX}
%
\noindent
will count the number of ASCII equals-sign characters between
the IO cursor and the next EOR or EOF, with no limit on
the maximum scan distance.

\section{String Base Types (including dates and times)}

The large number of string base types arises from the fact that there
are many different ways to indicate the extent of a string.  The
entire input (up to end-of-file or end-of-record) is a sequence of
bytes that can be included in a string, so when specifying a string
type in a \padsl{} description, we need to indicate how much of that
input we would like included in the string.

\subsection{Pstring\_FW}

\aedBegin{}
\aedLine{string\_FW}
\aedEnd{}

One of the simplest ways to specify the extent of a string is to give the
exact number of characters, or width, that will be included in the string.
For example,
\inputCode{code/stringFW}
%
\noindent
Specifies a string with width 10.  In this case the default character set
will determine whether ASCII or EBCDIC characters are expected in the
input stream.  Regardless of the input character set, the resulting in-memory 
Pstring contains ASCII characters. 

An error occurs if the specified width is not available.  See \appref{ap:base-types}
for details.

\subsection{Pstring}

\aedBegin{}
\aedLine{string}
\aedEnd{}

For the Pstring type one specifies a 'stop character' that is
expected immediately {\em following\/} the string.  The extent of the
string is all characters from the IO cursor up
to but not including the first occurrence of the stop char.
For example,

\inputCode{code/string-stop}
%
\noindent
Indicates that a series of EBCDIC characters is expected, followed by
an EBCDIC vertical bar.  Note that the stop char is always specified
in ASCII (in this case usng a C character constant).  When the
character set that is being read from the input is EBCDIC, the read
function looks for the EBCDIC character that is equivalenet to the
specified ASCII character.

\subsection{Pstring\_ME}

\aedBegin{}
\aedLine{string\_ME}
\aedEnd{}

For type \cd{Pstring\_ME}, a regular expression called the {\em matching
expression\/} is given, and the extent of the string is the longest
sequence of characters starting at the current IO position which match
this expression.  Note that when you specify a regular expression as
a \C{} string, you must use two backslashes to indicate a single
backslash character (otherwise C will think you are applying the
special backslash operator to the following character). 
In a language such as Perl, which does not have this requirement,
you might write

\inputCode{code/reg-exp}
%
\noindent
to create a regular expression which will match a
sequence of zero or more non-space characters.  To use the
same regular expression in a PADSL description
with the \cd{Pa\_string\_ME} type, you would write:

\inputCode{code/string-match}
%
\noindent
This will match a sequence of zero or non-space characters and assign
it to \cd{my\_string}.  Note that if a space occurs immediatley, a match
still occurs, since we specified that zero characters was OK;
\cd{my\_string} would be a string of length zero.  The extent is bound be
end-of-record/end-of-file, so if there are no spaces before an
end-of-record, \cd{my\_string} will end up containing all characters
remaining in the record.

As a concrete example, if the input at the current IO cursor is {\tt hello
world} when the above string declaration is used to read from the
input, \cd{my\_string} will end up containing {\tt hello}.  Note that the
space that follows {\tt hello} is {\em not} included, since it does not
part of the match.

\subsection{Pstring\_SE}

\aedBegin{}
\aedLine{string\_SE}
\aedEnd{}

For type \cd{Pstring\_SE}, a regular expression called the {\em stop
expression\/} is given, and the extent of the string is the longest
sequence of characters starting at the current IO position such that
the characters immediately following successfully match the stop
expression.  None of the characters matching the stop expression
are included in the result.
For example,

\inputCode{code/string-stope}
%
\noindent
The stop expression will match {\em either\/} a space character (due to the backslash-s) {\em or\/}
end-of-record/end-of-file (due to the special dollar-sign character).  As a result,
\cd{my\_string} will end up containing all non-space characters up to (but not including) the 
first space characer that is found, or up to the end of the current record if no space
character is found.  

You may have noticed that the \cd{Pa\_string\_ME} and
\cd{Pa\_string\_SE} examples actually specify exactly the same extent.  
Because of the power of regular expressions, it is often the case that you can
choose to use either type.  You should use whichever type results in a
clearer description of what is expected in the input.  (In this case,
the\cd{Pa\_string\_ME} form is simpler and therefore clearer.)

\subsection{Timestamp\_explicit}

\begin{small}
\aedBegin{}
\aedLine{timestamp\_explicit\_FW}
\aedLine{timestamp\_explicit}
\aedLine{timestamp\_explicit\_ME}
\aedLine{timestamp\_explicit\_SE}
\aedEnd{}
\end{small}

\noindent
A timestamp is a combination of a calendar date and a time of day.
The corresponding in-memory representation is a \cd{Puint32} which
represents the number of seconds since {\tt 00:00:00 1-Jan-1970 UTC},
also knows as ``seconds since the epoch.''
Thus, the time {\tt 00:00:20 1-Jan-1970 UTC} would be represented
internally as the number 1200, since it occurs 1200 seconds
(20 minutes) past the epoch.

If the input is \texttt{``midnight Jan 1 1970''} and the time zone is \literal{UTC}, then
this produces a value of 0 since this is actually the epoch.  If the
time zone is \literal{EST}, then this produces 5 * 60 * 60 since midnight in the
\literal{EST} timezone occurred 5 hours after the start of the epoch.

If  the input explicitly has a time zone, as in \texttt{``midnight Jan 1 1970
UTC''} then the time zone in the input is used, so this would produce 0,
regardless of the time zone specified for the type.  Of course, not
all timestamp input formats allow you to explicitly give the time
zone!


The input values are ASCII or EBCDIC strings.  Each
\cd{Ptimestamp\_explicit} type takes as first argument the same form of
specifying the string's extent as the corresponding \cd{Pstring} type, and
takes as second argument a timestamp format string which describes
what the input string should contain.

Timestamp formats consists of literal characters that are are simply
expected to be present in the input and special combinations of a
percent-sign and a character used to indicate expected parts of the
timestamp.  For example, the input format
\literal{\cd{"\%Y-\%m-\%d+\%H:\%M"}} 
indicates that a format that starts with a 
four digit year, then a dash, then a two digit month, then a dash,
then a two-digit day, then a plus sign, then a two digit hour, then a
colon, then a two digit minutes.  (To specify that a literal percent
sign must appear in the input, use two percent signs in a row.)  A
full description of supported formats appears on the webpage:
\ifthenelse{\boolean{hevea}}{
\myurl{www.research.att.com/\~gsf/man/man3/tm.html}}{
\myurl{www.research.att.com/~gsf/man/man3/tm.html}}


Each of the \cd{Ptimestamp\_explicit} types corresponds to one of the \cd{Pstring}
types that has already been described, where each takes one additional argument
to specify the input format.  For example,

\inputCode{code/timestamp-explicit}
%
\noindent
Reads an ASCII string, up to but not including a vertical bar, and
converts that string into a \cd{Puint32} timestamp.  The conversion will be
successful only if the string has the specified format.

Some timestamp formats include explicit time zone information,such as
the one above.  \pads{} provides the function \cd{P\_cstr2timezone} to convert a
string representation of a time zone into an value of type
\cd{Tm\_zone\_t *}.  This function is described in \chapref{chap:library-use}.

For the rest,the input time zone is taken
from the \pads{} discipline field \cd{ disc->in\_time\_zone}, as
described in \secref{sec:library-customization-input-time-zone}.

\subsection{Timestamp}

\aedBegin{}
\aedLine{timestamp\_FW}
\aedLine{timestamp}
\aedLine{timestamp\_ME}
\aedLine{timestamp\_SE}
\aedEnd{}

The timestamp types are the same as the \cd{timestamp\_explicit} types,
except no timestamp format is given.  Instead, the \pads{}
discipline field \cd{disc->in\_formats.timestamp} is used
for all \cd{Ptimestamp} types.

\subsection{Date\_explicit}

\aedBegin{}
\aedLine{date\_explicit\_FW}
\aedLine{date\_explicit}
\aedLine{date\_explicit\_ME}
\aedLine{date\_explicit\_SE}
\aedEnd{}

Dates are calendar days (no time of day).  Like timestamps, we
represent a date as a \cd{Puint32} recording ``seconds since the epoch.''

The \cd{Pdate\_explicit} types take a second argument, a date format,
which accepts the same special characters as the \cd{Ptimestamp\_explcit} types.
So, technically there is nothing to stop you from using the date types
to input time of day fields.  However, we encourage you to use the
\cd{Ptimestamp} types when both a calendar day and a time of day are to be
input, and to use the \cd{Pdate} types when just the calendar day is to be
input.

\subsection{Date}

\aedBegin{}
\aedLine{date\_FW}
\aedLine{date}
\aedLine{date\_ME}
\aedLine{date\_SE}
\aedEnd{}

The date types are the same as the \cd{date\_explicit} types,
except no date format is given.  Instead, the \pads{}
discipline field \cd{disc->in\_formats.date} is used
for all \cd{Pdate} types.

\subsection{Time\_explicit}

\aedBegin{}
\aedLine{time\_explicit\_FW}
\aedLine{time\_explicit}
\aedLine{time\_explicit\_ME}
\aedLine{time\_explicit\_SE}
\aedEnd{}

Times give the time of day, with no calendar date.  They are
represented as a \cd{Puint32} recording seconds since midnight.  For
examle, the time 1am is represented as 3600 (i.e., 3600 seconds, or 60
minutes, after midnight).

The \cd{Ptime\_explicit} types take a second argument, a time format, which
accepts the same special characters as the timestamp and date types.
However, we encourage you to use the \cd{Ptimes} types when just a time of
day is expected.

\subsection{Time}

\aedBegin{}
\aedLine{time\_FW}
\aedLine{time}
\aedLine{time\_ME}
\aedLine{time\_SE}
\aedEnd{}

The time types are the same as the \cd{time\_explicit} types,
except no time format is given.  Instead, the \pads{}
discipline field \cd{disc->in\_formats.time} is used
for all \cd{Ptime} types.

\subsection{IP}

\aedBegin{}
\aedLine{time\_FW}
\aedLine{time}
\aedLine{time\_ME}
\aedLine{time\_SE}
\aedEnd{}

The \cd{Pip} type reads an IP address string from the input that is in
numeric dotted form (as in {\tt 10.1.0.17}) using ASCII or EBCDIC
digits and periods (dots).  The string consists of up to four
parts with values between 0 and 255, separated by periods,
with an optional trailing period.  When there are
fewer than four parts, the missing parts are treated as implicitly
zero, and are inserted as shown in the following diagram,
which shows the eight legal input forms and the equivalent expanded form.

{\tt
\begin{center}
\begin{tabular}{lcl}
  <part1>                          & ~~$\longrightarrow{}$~~ & <part1>.0.0.0\\
  <part1>.                         & ~~$\longrightarrow{}$~~ & <part1>.0.0.0.\\
  <part1>.<part4>                  & ~~$\longrightarrow{}$~~ & <part1>.0.0.<part4>\\
  <part1>.<part4>.                 & ~~$\longrightarrow{}$~~ & <part1>.0.0.<part4>.\\
  <part1>.<part2>.<part4>          & ~~$\longrightarrow{}$~~ & <part1>.<part2>.0.<part4>\\
  <part1>.<part2>.<part4>.         & ~~$\longrightarrow{}$~~ & <part1>.<part2>.0.<part4>.\\
  <part1>.<part2>.<part3>.<part4>  & ~~$\longrightarrow{}$~~ & same\\
  <part1>.<part2>.<part3>.<part4>. & ~~$\longrightarrow{}$~~ & same\\
\end{tabular}
\end{center}}

Each $<$part$>$ is made up of 1 to 3 digits which specify a number
in the range [0, 255].

The result is a single \cd{Puint32} value with each part encoded in one
of the four bytes.  part1 is stored in the high-order byte, part4
in the low-order byte.  You can obtain each part using the macro

\begin{centercode}
  P\_IP\_PART(addr, part)
\end{centercode}
where \cd{part} must be an integer between 1 and 4.

The digits and the "." char are read as EBCDIC chars if the EBCDIC
form is used or if the default form is used and
\cd{pads->disc->def\_charset} is \cd{Pcharset\_EBCDIC}.  Otherwise the data is
read as ASCII chars.

\section{Integer Base Types}

\subsection{Fixed-width character-based encoding}

\aedBegin{}
\aedLine{int8\_FW}
\aedLine{int16\_FW}
\aedLine{int32\_FW}
\aedLine{int64\_FW}
\aedLine{uint8\_FW}
\aedLine{uint16\_FW}
\aedLine{uint32\_FW}
\aedLine{uint64\_FW}
\aedEnd{}

The above types are used when the input representation for an integer
is a fixed number of ASCII or EBCDIC characters.  The \cd{int} types are
signed types, while the \cd{uint} types are unsigned.  The number in the
type name specifies how many bits are used in the in-memory
represenation, thus a \cd{Puint32} is a 32-bit (4 byte) representation of
an unsigned integer.

The characters in the input can have an optional plus or minus sign for
signed types, or an optional plus signed for unsigned types, followed
by a set of one or more digits.   In addition, leading or
trailing whitespace can occur, but only if the \pads{} discipline field
\cd{disc->flags} has the \cd{WSPACE\_OK} flag set.
The data is read as EBCDIC chars if an EBCDIC
form (such as \cd{Pe\_int8}) is used, or if the default form (\cd{Pint8}) is used and
\cd{pads->disc->def\_charset} is \cd{Pcharset\_EBCDIC}.  Otherwise, the data is
read as ASCII chars.

\subsection{Variable-width character-based encoding}

\aedBegin{}
\aedLine{int8}
\aedLine{int16}
\aedLine{int32}
\aedLine{int64}
\aedLine{uint8}
\aedLine{uint16}
\aedLine{uint32}
\aedLine{uint64}
\aedEnd{}

The expected input for these types is an optional sign character
followed by a sequence of digits.  The number of characters that make
the input is variable: after the first digit, the digits are read
until (but not including) the first non-digit or EOR/EOF.
If the \pads{} discipline field
\cd{disc->flags} has the \cd{WSPACE\_OK} flag set, then
leading whitespace is allowed.

\subsection{Raw binary encoding}

\bBegin{}
\bLine{int8}
\bLine{int16}
\bLine{int32}
\bLine{int64}
\bLine{uint8}
\bLine{uint16}
\bLine{uint32}
\bLine{uint64}
\bEnd{}

These are the first binary types described in this chapter. The input
is not made up of ASCII or EBCDIC characters that need to be interpreted
to see what number they are describing.  Instead, the number itself is
encoded in binary form, as a sequence of bytes.  

There are binary types for signed or unsigned {\em binary\/} integers
of common bit widths (8, 16, 32, and 64 bit widths).  \cd{Pb\_int8} corresponds
to one byte of input, \cd{Pb\_int16} to two bytes of input, and so on.

The representation in memory is just the corresponding signed or
unsigned type, thus \cd{Pb\_uint16} has representation type \cd{Puint16}.  The bytes from
the input are simply copied into the bytes that make up the representation.  If
the endian-ness of input data is different from the endian-ness of the
machine, then the byte order is reversed to form the in-memory
representation; otherwise the byte order is preserved.

The endian-ness of the machine running the \pads{} program is fixed: it
is determined automatically by the \pads{} libary.  
The input data endianess is described by \pads{} disipline 
field \cd{disc->d\_endian}. 

In some cases it is possible to have \pads{} determine the
proper setting for \cd{disc->d\_endian} automatically, by
using the annotation \cd{Pendian}
with the first multi-byte binary integer field that appears
in the data.  For example, consider this header definition:

\inputCode{code/pendian}
%
\noindent
This \padsl{} description indicates the first value in the header
is a 2-byte unsigned binary integer, \cd{version},
whose value should be less than ten.   The \cd {Pendian} annotation indicates that there
should be two attempts at reading the version field: once with the
current \cd{disc->d\_endian} setting, and (if the read fails) once with the
opposite \cd{disc->d\_endian} setting.  If the second read succeeds, then
the new \cd{disc->d\_endian} setting is retained, otherwise the original
setting is retained.

Note that the \cd{Pendian} pragma is only able to determine the correct endian
choice for a field that has an attached constraint, where the
wrong choice of endian setting will always cause the constraint to fail.
(In the above example, if a value less than ten is read with the wrong \cd{d\_endian}
setting, the result is a value that is much greater than ten. )

\subsection{Serialize binary encoding}

\sbBegin{}
\sbLine{int8}
\sbLine{int16}
\sbLine{int32}
\sbLine{int64}
\sbLine{uint8}
\sbLine{uint16}
\sbLine{uint32}
\sbLine{uint64}
\bEnd{}

These types describe signed or unsigned binary integers
that have been encoded with a specified number of bytes $K$.
For the \cd{PPsbl\_} types, the first byte on the input
stream is treated as the low-order byte of the $K$ byte value,
For the \cd{PPsbh\_} types, the first byte on the input
stream is treated as the high-order byte of the $K$ byte value,
For example, \cd{Psbl\_int32(:3:)} describes a 3 byte
binary encoding where the first byte encountered is the
low-order byte.

These types are more general than the simpler \cd{Pb\_} types because
you explicitly specify the number of bytes (from 1 to 8) independently
of the target in-memory type, allowing for types such as the
\cd{Psbl\_int32(:3:)} type just described.  These types
also explicitly specify the endian-ness of the data bytes,
rather than using \cd{disc->d\_endian}.

The following table shows those cases where serialized
binary types have equivalent simple binary types.

\begin{tabular}{l|l|l} \\ \hline
{\bf Serialized}       & \multicolumn{2}{|c|}{\bf Equivalent type if} \\
{\bf Binary}           & \multicolumn{2}{|c|}{\cd{disc->d\_endian} \bf is}  \\
{\bf Type}             & {\bf PlittleEndian} & {\bf PbigEndian}       \\ \hline \hline
\cd{Psbl\_int8(:1:)}   &                     & \cd{Pb\_int8}          \\ \hline
\cd{Psbl\_int16(:2:)}  &                     & \cd{Pb\_int16}         \\ \hline
\cd{Psbl\_int32(:4:)}  &                     & \cd{Pb\_int32}         \\ \hline
\cd{Psbl\_int64(:8:)}  &                     & \cd{Pb\_int64}         \\ \hline
\cd{Psbl\_uint8(:1:)}  &                     & \cd{Pb\_uint8}         \\ \hline
\cd{Psbl\_uint16(:2:)} &                     & \cd{Pb\_uint16}        \\ \hline
\cd{Psbl\_uint32(:4:)} &                     & \cd{Pb\_uint32}        \\ \hline
\cd{Psbl\_uint64(:8:)} &                     & \cd{Pb\_uint64}        \\ \hline \hline

\cd{Psbh\_int8(:1:)}   &  \cd{Pb\_int8}      &                        \\ \hline
\cd{Psbh\_int16(:2:)}  &  \cd{Pb\_int16}     &                        \\ \hline
\cd{Psbh\_int32(:4:)}  &  \cd{Pb\_int32}     &                        \\ \hline
\cd{Psbh\_int64(:8:)}  &  \cd{Pb\_int64}     &                        \\ \hline
\cd{Psbh\_uint8(:1:)}  &  \cd{Pb\_uint8}     &                        \\ \hline
\cd{Psbh\_uint16(:2:)} &  \cd{Pb\_uint16}    &                        \\ \hline
\cd{Psbh\_uint32(:4:)} &  \cd{Pb\_uint32}    &                        \\ \hline
\cd{Psbh\_uint64(:8:)} &  \cd{Pb\_uint64}    &                        \\ \hline
\end{tabular}

\subsection{EBC encoding}

\ebcBegin{}
\ebcLine{int8}
\ebcLine{int16}
\ebcLine{int32}
\ebcLine{int64}
\ebcLine{uint8}
\ebcLine{uint16}
\ebcLine{uint32}
\ebcLine{uint64}
\ebcEnd{}

These types describe signed or unsigned EBCDIC numeric encoded
integers with a specified number of digits.  {\bf N.B.:} the specified
number of digits must be odd if the value on disk can be negative.
For example, \cd{Pebc_int32(:5:)} describes a 5 digit signed
integer.

Each byte on disk encodes one digit (using the low 4 bits).  For signed
values, the final byte encodes the sign (high 4 bits \cd{==} \cd{0xD} for negative).
E.g., a signed or unsigned 5 digit value is encoded in 5 bytes.

The legal range of values for the number of digits, \cd{num_digits},
depends on target type:
\begin{tabular}{l|l|l} \\ \hline
{\bf Type}    &  {\bf num\_digits} &  {\bf Min / Max values} \\ \hline \hline
\cd{Pint8}    &  $1-3$             &  \cd{P_MIN_INT8}  / \cd{P_MAX_INT8}    \\ \hline
\cd{Puint8}   &  $1-3$             &  \cd{0}           / \cd{P_MAX_UINT8}   \\ \hline
\cd{Pint16}   &  $1-5$             &  \cd{P_MIN_INT16} / \cd{P_MAX_INT16}   \\ \hline
\cd{Puint16}  &  $1-5$             &  \cd{0}           / \cd{P_MAX_UINT16}  \\ \hline
\cd{Pint32}   &  $1-10$            &  \cd{P_MIN_INT32} / \cd{P_MAX_INT32}   \\ \hline
\cd{Puint32}  &  $1-10$            &  \cd{0}           / \cd{P_MAX_UINT32}  \\ \hline
\cd{Pint64}   &  $1-19$            &  \cd{P_MIN_INT64} / \cd{P_MAX_INT64}   \\ \hline
\cd{Puint64}  &  $1-20$            &  \cd{0}           / \cd{P_MAX_UINT64}  \\ \hline
\end{tabular}

\subsection{BCD encoding}

\bcdBegin{}
\bcdLine{int8}
\bcdLine{int16}
\bcdLine{int32}
\bcdLine{int64}
\bcdLine{uint8}
\bcdLine{uint16}
\bcdLine{uint32}
\bcdLine{uint64}
\bcdEnd{}

These types describe signed or unsigned BCD numeric encoded
integers with a specified number of digits.  {\bf N.B.:} the specified
number of digits must be odd if the value on disk can be negative.
For example, \cd{Pbcd_int32(:5:)} describes a 5 digit signed
integer.

Each byte on disk encodes two digits, 4 bits per digit.  For signed
values, a negative number is encoded by having number of digits be odd
so that the remaining low 4 bits in the last byte are available for
the sign.  (low 4 bits \cd{==} \cd{0xD} for negative).  A signed or
unsigned 5 digit value is encoded in 3 bytes, where the unsigned value
ignores the final 4 bits and the signed value uses them to get the
sign.

The legal range of values for the number of digits, \cd{num_digits},
depends on target type:
\begin{tabular}{l|l|l} \\ \hline
{\bf Type}    &  {\bf num\_digits} &  {\bf Min / Max values} \\ \hline \hline
\cd{Pint8}    &  $1-3$             &  \cd{P_MIN_INT8}  / \cd{P_MAX_INT8}    \\ \hline
\cd{Puint8}   &  $1-3$             &  \cd{0}           / \cd{P_MAX_UINT8}   \\ \hline
\cd{Pint16}   &  $1-5$             &  \cd{P_MIN_INT16} / \cd{P_MAX_INT16}   \\ \hline
\cd{Puint16}  &  $1-5$             &  \cd{0}           / \cd{P_MAX_UINT16}  \\ \hline
\cd{Pint32}   &  $1-11${\bf **}    &  \cd{P_MIN_INT32} / \cd{P_MAX_INT32}   \\ \hline
\cd{Puint32}  &  $1-10$            &  \cd{0}           / \cd{P_MAX_UINT32}  \\ \hline
\cd{Pint64}   &  $1-19$            &  \cd{P_MIN_INT64} / \cd{P_MAX_INT64}   \\ \hline
\cd{Puint64}  &  $1-20$            &  \cd{0}           / \cd{P_MAX_UINT64}  \\ \hline
\end{tabular}
{\bf ** Note:} For type \cd{Pbcd_int32} only, even though the min and
max int32 have 10 digits, we allow \cd{num_digits} \cd{== 11} due to the fact
that 11 is required for a 10 digit negative value.  (An actual 11
digit number would cause a range error, so the leading digit must be
0.)

\section{Floating Point Base Types}


\subsection{Variable-width character-based encoding}

\aedBegin{}
\aedLine{float32}
\aedLine{float64}
\aedEnd{}

These types describe ASCII or EBCDIC character-based encodings of floating point numbers.
The input representation must have this form:
\begin{centercode}
    [+|-]DIGITS[.][DIGITS][(e|E)[+|-]DIGITS]
\end{centercode}
Where \cd{DIGITS} is a sequence of one or more digit characters,
\cd{(e|E)} indicates either a lower- or upper-case letter 'E',
and elements in square brackets are optional.  Note that there
must be at least one digit before the (optional) dot (period) character.

If the input has a valid sequence of input characters that make up a float,
then the float is converted to a \cd{Pfloat32} or \cd{Pfloat64}, according
to the type.  For example, if you specify a \cd{Pa_float32} then
a characters making up a float will be read from the input and converted
to an in-memory \cd{Pfloat32}.

\section{Fixed Point Base Types}

The following types encode a numerator value on the input stream
in different formats, as described below.  They all
produce an in-memory \cd{Pfpoint} value whose denominator is
determined from the second type argument, \cd{d_exp}, where the
denominator is implicitly $10^{d_exp}$ and is not encoded on
disk.

The legal range of values for \cd{d_exp} depends on the target
in-memory type:
\begin{tabular}{l|l|r} \\ \hline
{\bf Type}                 & {\bf d\_exp}  & {\bf Max denominator (min is 1)}   \\ \hline \hline
\cd{Pfpoint8  /  ufpoint8} &   $0-2$   &                          \cd{100}  \\ \hline
\cd{Pfpoint16 / ufpoint16} &   $0-4$   &                       \cd{10,000}  \\ \hline
\cd{Pfpoint32 / ufpoint32} &   $0-9$   &                \cd{1,000,000,000}  \\ \hline
\cd{Pfpoint64 / ufpoint64} &   $0-19$  &   \cd{10,000,000,000,000,000,000}  \\ \hline
\end{tabular}

\subsection{Serialized binary encoding}

\sbBegin{}
\sbLine{fpoint8}
\sbLine{fpoint16}
\sbLine{fpoint32}
\sbLine{fpoint64}
\sbLine{ufpoint8}
\sbLine{ufpoint16}
\sbLine{ufpoint32}
\sbLine{ufpoint64}
\bEnd{}

These types describe fixed-point numbers where the numerator is
encoded in serialized binary form on the input stream.  Serialized
binary encodings are described above for the \cd{Psbl_} and \cd{Psbh_}
integer types.  Like those integer types, the number of bytes on the
input is specified as the first type argument.  The legal range
of values for the number of bytes depends on target type, and follows
the same rule specified for the \cd{Psbl_} and \cd{Psbh_} integer types.

Each type takes a second argument,
\cd{d_exp}, where the denominator value
is implicitly $10^{d_exp}$ and is not encoded on disk.  For example,
\cd{sbl_fpoint32(:3, 2:)} specifies that a numererator is encoded on the
input as a three binary bytes with the low-order byte appearing first,
where the resulting in-memory
\cd{Pfpoint32} has the value read from the input as its numerator, and
the number $10^2$ (i.e., $100$) as its denominator.

\subsection{EBC encoding}

\ebcBegin{}
\ebcLine{fpoint8}
\ebcLine{fpoint16}
\ebcLine{fpoint32}
\ebcLine{fpoint64}
\ebcLine{ufpoint8}
\ebcLine{ufpoint16}
\ebcLine{ufpoint32}
\ebcLine{ufpoint64}
\ebcEnd{}

These types describe fixed-point numbers where the numerator is
encoded as EBCDIC numeric digits on the input stream.  This encoding
is described above for the \cd{Pebc_} integer types.  Like those
integer types, the number of digits on the input is specified as the first
type argument.  The legal range of values for the number of
digits depends on target type, and follows the same rule specified for
the \cd{Pebc_} integer types.

Each type takes a second argument,
\cd{d_exp}, where the denominator value
is implicitly $10^{d_exp}$ and is not encoded on disk.  For example,
\cd{ebc_fpoint32(:3, 2:)} specifies that a numererator is encoded on the
input as three EBCDIC digits, where the resulting in-memory
\cd{Pfpoint32} has the value read from the input as its numerator, and
the number $10^2$ (i.e., $100$) as its denominator.

\subsection{BCD encoding}

\bcdBegin{}
\bcdLine{fpoint8}
\bcdLine{fpoint16}
\bcdLine{fpoint32}
\bcdLine{fpoint64}
\bcdLine{ufpoint8}
\bcdLine{ufpoint16}
\bcdLine{ufpoint32}
\bcdLine{ufpoint64}
\bcdEnd{}

These types describe fixed-point numbers where the numerator is
encoded as BCD numeric digits on the input stream.  This encoding
is described above for the \cd{bcd_} integer types.  Like those
integer types, the number of digits on the input is specified as the first
type argument.  The legal range of values for the number of
digits depends on target type, and follows the same rule specified for
the \cd{bcd_} integer types.

Each type takes a second argument,
\cd{d_exp}, where the denominator value
is implicitly $10^{d_exp}$ and is not encoded on disk.  For example,
\cd{bcd_fpoint32(:3, 2:)} specifies that a numererator is encoded on the
input as three BCD digits, where the resulting in-memory
\cd{Pfpoint32} has the value read from the input as its numerator, and
the number $10^2$ (i.e., $100$) as its denominator.

