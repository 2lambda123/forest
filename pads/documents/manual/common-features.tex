\chapter{Common features}
In this chapter, we describe \PADSL{} features shared by all types. 
Subsequent chapters describe features particular to various \PADSL{}
types. 

\section{Overall structure}
\label{sec:common-overall}
\begin{tabular}{rcll}
\nont{p\_ty} & \is{} & \nont{base\_ty} \\[1ex]
& \alt{} & \nont{struct\_ty} \\[1ex]
& \alt{} & \nont{union\_ty} \\[1ex]
& \alt{} & \nont{array\_ty} \\[1ex]
& \alt{} & \nont{typedef\_ty} \\[1ex]
& \alt{} & \nont{enum\_ty} \\[1ex]
\end{tabular}

\section{Comments}
\label{sec:common-comments}
c-style and /-- form, which are reflected into output.

\section{Predicates}
\label{sec:common-predicates}
 written in C. integer type
 assumed to be side-effect free
 \term{predicate}

\section{Literals}
\label{sec:common-literals}

\begin{tabular}{l}
\term{char\_lit} \\[1ex]
\term{str\_lit} \\[1ex]
\end{tabular}

\PADSL{} supports C-style character and string literals such as {\tt '}\cd{a}{\tt '} and
\cd{"foo"}.  These literals may use all of C character escapes such as
\begin{verbatim}\" and \'\end{verbatim}.

Character and string literals are used to read external characters
without putting any corresponding data in the resulting in-memory representation.
\Ie, they 'skip over' some expected character(s).
They are typically used in \Pstruct{}s; see \secref{sec:sec:structs-literal-fields}.

\section{Character Sets}
\label{sec:common-character-sets}

The library discipline contains a field \cd{def_charset} that
indicates the expected character set of the external representation of
character and string literals, as well as the external representation of all character and string
base types that do not explicitly name a character set.  Supported
character sets include ASCII (\cd{PDC_charset_ASCII}) and EBCDIC
(\cd{PDC_charset_EBCDIC}), where ASCII is the default character set.
\secref{sec:library-customization-character-encodings} describes how
to set \cd{def_charset}.

\section{White Space}
\label{sec:common-features-white-space}
Is there anything we need to say here?

\section{Parameterization}
\label{sec:common-parameterization}
 mechanism to pass values from earlier portions of data to later
 portions
 
 reduce number of type declarations.

\nont{formal\_param\_list}
\nont{actual\_param\_list}

\section{\Precord{} modifier}

\section{\Pfile{} modifier}

\section{Error model}
\label{sec:common-error-model}
 panic versus non-panic errors

\appref{app:error-codes} contains a list of all error codes and
describes their meanings.

describe the type \cd{PDC\_error\_t} and the possible error codes.

\section{In-memory representations}
\label{sec:common-rep}
Each \PADS{} type \cd{foo} has an associated in-memory representation
type of the same name.  The structure of this representation depends
upon the particular \PADS{} type.  
In general, these representations fall into two broad categories:
\textit{static} representations, whose size can be computed at
library-generation time, and \textit{dynamic} representations, whose size 
depends on the data being parsed. 
Details appear in 
\secref{sec:base-types-rep}, \secref{sec:structs-rep},
\secref{sec:unions-rep}, \secref{sec:arrays-rep}, 
\secref{sec:enums-rep}, and \secref{sec:typedefs-rep}.

\section{Masks}
\label{sec:common-masks}
Each \PADS{} type \cd{foo} has an associated mask type, \csmSuf{foo}.
Masks allow the library user to customize operations on portions of
the associated data.  The structure of the mask for a given \PADS{}
type mirrors the structure of the representation type.  Details about
the structure for various types
appear in \secref{sec:base-types-masks}, \secref{sec:structs-masks},
\secref{sec:unions-masks}, \secref{sec:arrays-masks}, 
\secref{sec:enums-masks}, and \secref{sec:typedefs-masks}.


\section{Parse descriptors}
\label{sec:common-parse-descriptor}
Each \PADS{} type \cd{foo} has an associated parse descriptor type, 
\pdSuf{foo}, coded as a \C{} struct with at least the following four
fields:
\vskip 1ex
\begin{tabular}{lp{4in}}
 \cd{PDC\_uint32 pstate} & Flags that describe the state after parsing the
                           associated value.\\[1ex]
 \cd{PDC\_errCode\_t errCode} & A code indicating the nature of the 
                               first detected error.\\[1ex]
 \cd{PDC\_loc\_t loc}  & The location in the data source of the first 
                         error.\\[1ex]
 \cd{PDC\_uint32 nerr} & The number of errors detected during parsing
                        of the associated value.\\[1ex]
\end{tabular}

\noindent
Field \cd{pstate} contains the following flags:
\vskip 1ex
\begin{tabular}{lp{3.5in}}
 \cd{PDC\_Panic} & Set if the parser was in panic mode during the
                  parsing of the associated data.\\[1ex]
\end{tabular}

\noindent
The \pads{} library provides a collection of functions (macros
actually) for manipulating the parse state field:
\vskip 1ex
\begin{code}
void PDC_PS_init(void *pd);         
void PDC_PS_setPanic(void *pd);     
void PDC_PS_unsetPanic(void *pd);   
int  PDC_PS_isPanic(void *pd);      
\end{code}

Details about how parse descriptors are customized for various \PADS{}
types appear in
\secref{sec:base-types-parse-descriptors}, \secref{sec:structs-parse-descriptors},
\secref{sec:unions-parse-descriptors}, \secref{sec:arrays-parse-descriptors}, 
\secref{sec:enums-parse-descriptors} and \secref{sec:typedefs-parse-descriptors}.

\section{Operations}
\label{common-operations}
For each \pads{} type, the generated library contains a collection of
functions for manipulating the associated data.  For structured types,
the \pads{} compiler generates these functions;  for base types, the
\pads{} library provides them.  This section describes the common
features of such functions.  Type-specific information may be found in
the appropriate chapter.

All operations take a pointer to an
initialized \pads{} handle as their first parameter.  Information
about how to manage \pads{} library handles appears in
\chapref{chap:using-library}. 

\subsection{Initialization and cleanup functions}
For each type \cd{foo}, the generated library contains
initialization and cleanup functions for the associated representation
\cd{foo} and parse descriptor \pdSuf{foo} types.  Each initialization
function take a pointer to allocated space and initializes the space
appropriately.  Each cleanup function takes a pointer to allocated and
initialized space and deallocates any memory allocated by \pads{} functions.
It does not deallocate the space pointed to by the parameter.  
\begin{code}
PDC_error_t foo_init (PDC_t *pdc, foo *rep);

PDC_error_t foo_cleanup (PDC_t *pdc, foo *rep);

PDC_error_t foo_pd_init (PDC_t *pdc, foo_pd *pd);

PDC_error_t foo_pd_cleanup (PDC_t *pdc, foo_pd *pd);
\end{code}
Because all masks have statically-known size, the library does not
contain initialization and cleanup functions for masks.  
\begin{code}
void foo_m_init (PDC_t *pdc, foo_m *mask, PDC_base_m baseMask);
\end{code}
Instead, it
contains a function for setting all nested base masks 
to a specified value.  The function takes two parameters (in
addition to the \pads{} handle): a pointer to allocated space for the
mask and a base mask value.  Because mask initialization
functions cannot fail, the return type is \cd{void} instead of
\cd{PDC_error_t}. 

\subsection{Utilty functions}
Each type \cd{foo} comes equipped with copy functions for both the
in-memory representation and the parse descriptor.  Both the source
and destination pointers are assumed to point to allocated space.  In
addition, the src pointers are assumed to point to initialized space.
\begin{code}
PDC_error_t foo_copy (PDC_t *pdc, foo *rep_dst, foo *rep_src);

PDC_error_t foo_pd_copy (PDC_t *pdc, foo_pd *pd_dst, foo_pd *pd_src);
\end{code}

\subsection{Read function}
The read function for a \pads{} type \cd{foo} takes as an input parameter a
pointer to a mask \cd{m} and returns as output parameters a pointer to
a parse descriptor \cd{pd} and a pointer to an in-memory
reprsentation \cd{rep}.  If any errors occurred during the parsing, the return
value for the function is \cd{PDC_ERROR}.  Otherwise, the function
will return \cd{PDC_OK}.  

\begin{code}
PDC_error_t foo_read (PDC_t *pdc, foo_m *m, foo_pd *pd, foo *rep);
\end{code}

The mask argument allows the library user to specify independently
which constraints the parser should check and which portions of the
in-memory representation it should fill in.  Conceptually, there are
three different ``knobs'' associated with each atomic element of a
\pads{} type:

\vskip 1ex
\begin{tabular}{ll}
\cd{PDC_SynCheck} & Check syntactic constraints\\
\cd{PDC_SymCheck} & Check semantic constraints\\
\cd{PDC_Set}      & Set the in-memory reprsentation\\[1ex]
\end{tabular}

\noindent
At the base-type level, the mask consists of one or more of the
above flags.
For structured types, the mask consists of a combination of base masks
and the masks associated with nested types, the exact combination of
which depends upon the kind of structured type.  Note that for a
structured type \cd{foo}, the mask initialization function
\cd{foo_m_init} can be used to initialize all nested masks to the
supplied value.

Details about the read functions for particular types may be found in
the appropriate chapters.

For convenience, the \pads{} library provides the following abbreviations:

\vskip 1ex
\begin{tabular}{ll}
\cd{\#define PDC\_CheckAndSet} & \cd{PDC\_Set|PDC\_SynCheck|PDC\_SemCheck}\\
\cd{\#define PDC\_BothCheck}   & \cd{PDC\_SynCheck|PDC\_SemCheck} \\
\cd{\#define PDC\_Ignore}      & no flags set\\[1ex]
\end{tabular}

\noindent
The library also provides the following macros for testing or
modifying base read-function flags:

\vskip 1ex
\begin{tabular}{ll}
\cd{\#define PDC\_Test\_Set(m)}            & \cd{(m \& PDC\_Set)} \\
\cd{\#define PDC\_Test\_SynCheck(m)}       & \cd{(m \& PDC\_SynCheck)}\\
\cd{\#define PDC\_Test\_SemCheck(m)}       & \cd{(m \& PDC\_SemCheck)}\\
\\
\cd{\#define PDC\_Test\_NotSet(m)}         & \cd{(!PDC\_Test\_Set(m))}\\
\cd{\#define PDC\_Test\_NotSynCheck(m)}    & \cd{(!PDC\_Test\_SynCheck(m))}\\
\cd{\#define PDC\_Test\_NotSemCheck(m)}    & \cd{(!PDC\_Test\_SemCheck(m))}\\
\\
\cd{\#define PDC\_Test\_CheckAndSet(m)}\\
\multicolumn{2}{r}{ \cd{((m \& PDC\_CheckAndSet) == PDC\_CheckAndSet)}}\\
\cd{\#define PDC\_Test\_BothCheck(m)}\\
\multicolumn{2}{r}{ \cd{((m \& PDC\_CheckAndSet) == PDC\_BothCheck)}}\\
\cd{\#define PDC\_Test\_Ignore(m)}\\
\multicolumn{2}{r}{ \cd{((m \& PDC\_CheckAndSet) == PDC\_Ignore)}}\\
\\
\cd{\#define PDC\_Test\_NotCheckAndSet(m)}\\
\multicolumn{2}{r}{ \cd{((m \& PDC\_CheckAndSet) != PDC\_CheckAndSet)}}\\
\cd{\#define PDC\_Test\_NotBothCheck(m)}\\
\multicolumn{2}{r}{ \cd{((m \& PDC\_CheckAndSet) != PDC\_BothCheck)}}\\
\cd{\#define PDC\_Test\_NotIgnore(m)}\\
\multicolumn{2}{r}{  \cd{((m \& PDC\_CheckAndSet) != PDC\_Ignore)}}\\
\\
\cd{\#define PDC\_Do\_Set(m)}              & \cd{(m |= PDC\_Set)}\\
\cd{\#define PDC\_Do\_SynCheck(m)}         & \cd{(m |= PDC\_SynCheck)}\\
\cd{\#define PDC\_Do\_SemCheck(m)}         & \cd{(m |= PDC\_SemCheck)}\\
\\
\cd{\#define PDC\_Dont\_Set(m)}            & \cd{(m \&= (~PDC\_Set))}\\
\cd{\#define PDC\_Dont\_SynCheck(m)}       & \cd{(m \&= (~PDC\_SynCheck))}\\
\cd{\#define PDC\_Dont\_SemCheck(m)}       & \cd{(m \&= (~PDC\_SemCheck))}\\[1ex]
\end{tabular}

\subsection{Write functions}
For each \pads{} type, the generated library provides 
two functions for writing out the in-memory representation of the type
in a format as close as possible to its original form.
\begin{code}
ssize\_t foo\_write2io (PDC\_t *pdc, Sfio\_t *io, foo\_pd *pd, foo *rep);

ssize\_t foo\_write2buf (PDC\_t *pdc, PDC\_byte *buf, size\_t buf\_len, 
                        int *buf\_full, foo\_pd *pd, foo *rep);
\end{code}
The first of these functions emits its output to an SFIO file;
the second to an in-memory buffer.  Information about SFIO may be
found from \url{www.research.att.com/sw/tools/sfio}.  For the buffer
version, the parameter \cd{buf} points to an allocated sequence of
bytes and \cd{buf\_len} indicates the size of the buffer.  Out
parameter \cd{buf\_full} is a boolean which is set if the requested
write would have overflowed the buffer. The return value
for both of the functions is the number of bytes written, with \cd{-1}
indicating an error occurred.  

Issues that may cause the written data to differ from the original
data include skipping white space
(\secref{sec:library-customization-white-space}) and omitting fields in
\Pstruct{}s (\secref{sec:structs-qualifiers}). 

Passing the \texttt{-wnone} flag to the \pads{} compiler suppresses
the generation of these functions for structured types.

We anticipate adding more write functions in the future.

\subsection{Additional functions}
In addition to the basic functionality described in the preceeding
sections, \pads{} provides more advanced features described in later
chapters. 

\begin{tabular}{lp{4in}}
Accumulators (\chapref{chap:accumulators})  & Provide structures and
functions for automatically summarizing data.\\
\end{tabular}
