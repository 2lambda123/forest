\chapter{Common features}
In this chapter, we describe \PADSL{} features shared by all types. 
Subsequent chapters describe features particular to various \PADSL{}
types. 

\section{\pads{} types}
\label{sec:common-overall}
Each \padsl{} type specifies the external representation of a
particular kind of data.  \padsl{} base types describe the
representations of atomic pieces of data, while structured types
specify how compound representations are built from more basic ones. 
\padsl{} provides a large and extensible collection of base types
and a family of type constructors for building structured types: 
\pstruct{}s for record-like sequences, 
\punion{}s for alternatives, 
\parray{}s for sequences, 
\penum{}s for fixed collections of strings, and
\ptypedef{}s for refinements of existing types.

Syntactically, a \padsl{} type (\nont{p\_ty}) must have the following form:

\vskip 1ex
\begin{tabular}{rcll}
\nont{p\_ty} & \is{} & \nont{base\_ty} & (* \chapref{chap:base-types} *) \\[1ex]
& \alt{} & \nont{struct\_ty}           & (* \chapref{chap:structs} *)\\[1ex]
& \alt{} & \nont{union\_ty}            & (* \chapref{chap:unions} *)\\[1ex]
& \alt{} & \nont{array\_ty}            & (* \chapref{chap:arrays} *)\\[1ex]
& \alt{} & \nont{enum\_ty}             & (* \chapref{chap:enums} *)\\[1ex]
& \alt{} & \nont{typedef\_ty}          & (* \chapref{chap:typedefs} *)\\[1ex]
\end{tabular}

\noindent
The grammar for each of the above non-terminals is given in the
associated chapter.

\section{Comments}
\label{sec:common-comments}
In addition to \C{} and \Cplusplus{} style comments of the form 
\cd{/* ... */} and \cd{//...}, which may appear anywhere in a \pads{}
description, \padsl{} also supports \nont{p\_comment}s, which may
appear only in particular locations in the grammar.  Syntactically,

\vskip 1ex
\begin{tabular}{rcll}
\nont{p\_comment} & \is{} & \cd{/-} text  \\[1ex]
\end{tabular}

\noindent
These comments are reflected to the generated \texttt{.h} file as documentation.



\section{Predicates}
\label{sec:common-predicates}
 written in C. integer type
 assumed to be side-effect free
 \term{predicate}

\section{Literals}
\label{sec:common-literals}

\begin{tabular}{l}
\term{char\_lit} \\[1ex]
\term{str\_lit} \\[1ex]
\end{tabular}

\PADSL{} supports C-style character and string literals such as {\tt '}\cd{a}{\tt '} and
\cd{"foo"}.  These literals may use all of C character escapes such as
\begin{verbatim}\" and \'\end{verbatim}
.

Character and string literals are used to read external characters
without putting any corresponding data in the resulting in-memory representation.
\Ie, they 'skip over' some expected character(s).
They are typically used in \Pstruct{}s; see \secref{sec:sec:structs-literal-fields}.

\section{Character Sets}
\label{sec:common-character-sets}

The library discipline contains a field \cd{def_charset} that
indicates the expected character set of the external representation of
character and string literals, as well as the external representation of all character and string
base types that do not explicitly name a character set.  Supported
character sets include ASCII (\cd{PDC_charset_ASCII}) and EBCDIC
(\cd{PDC_charset_EBCDIC}), where ASCII is the default character set.
\secref{sec:library-customization-character-encodings} describes how
to set \cd{def_charset}.

\section{White Space}
\label{sec:common-features-white-space}
Is there anything we need to say here?

\section{Parameterization}
\label{sec:common-parameterization}
To reduce the number of necessary type declarations and to permit the
format of later portions of the data to depend upon earlier portions, 
\PADSL{} types can be parameterized by values.  A common example of
the latter use is a data source which first specifies the length of a
sequence and then gives the sequence itself.  The length is read,
stored in the in-memory representation, and then passed to the type
that describes the sequence to specify the termination condition for
the sequence. Syntactically, 
\vskip 1ex
\begin{tabular}{rcl}
\nont{p\_actuals} & \is{} & \nont{expression} \alt{} \nont{expression}, \nont{p\_actuals} \\[1ex]
\nont{p\_actual\_list} & \is{} & (: \nont{p\_actuals} :)\\[2ex]
\end{tabular}

\noindent
where \nont{expression} is any \C{} expression. Formal parameter lists
\nont{formals} are the same as in \C{}. 

\subsection{Example}
The following \padsl{} fragment illustrates both declaring and passing
parameters to \pads{} types.
\begin{code}
\input{code/struct.parameters}
\end{code}

\section{\Precord{} modifier}

\section{\Pfile{} modifier}

\section{Error model}
\label{sec:common-error-model}
 panic versus non-panic errors



\section{In-memory representations}
\label{sec:common-rep}
Each \PADS{} type \cd{foo} has an associated in-memory representation
type of the same name.  The structure of this representation depends
upon the particular \PADS{} type.  
In general, these representations fall into two broad categories:
\textit{static} representations, whose size can be computed at
library-generation time, and \textit{dynamic} representations, whose size 
depends on the data being parsed. 
Details appear in 
\secref{sec:base-types-rep}, \secref{sec:structs-rep},
\secref{sec:unions-rep}, \secref{sec:arrays-rep}, 
\secref{sec:enums-rep}, and \secref{sec:typedefs-rep}.

\section{Masks}
\label{sec:common-masks}
Each \PADS{} type \cd{foo} has an associated mask type, \csmSuf{foo}.
Masks allow the library user to customize operations on portions of
the associated data.  The structure of the mask for a given \PADS{}
type mirrors the structure of the representation type.  Details about
the structure for various types
appear in \secref{sec:base-types-masks}, \secref{sec:structs-masks},
\secref{sec:unions-masks}, \secref{sec:arrays-masks}, 
\secref{sec:enums-masks}, and \secref{sec:typedefs-masks}.


\section{Parse descriptors}
\label{sec:common-parse-descriptor}
Each \PADS{} type \cd{foo} has an associated parse descriptor type, 
\pdSuf{foo}, coded as a \C{} struct with at least the following four
fields:
\vskip 1ex
\begin{tabular}{lp{4in}}
 \cd{PDC\_uint32 pstate} & Flags that describe the state after parsing the
                           associated value.\\[1ex]
 \cd{PDC\_errCode\_t errCode} & A code indicating the nature of the 
                               first detected error.\\[1ex]
 \cd{PDC\_loc\_t loc}  & The location in the data source of the first 
                         error.\\[1ex]
 \cd{PDC\_uint32 nerr} & The number of errors detected during parsing
                        of the associated value.\\[1ex]
\end{tabular}

\noindent
Field \cd{pstate} contains the following flags:
\vskip 1ex
\begin{tabular}{lp{3.5in}}
 \cd{PDC\_Panic} & Set if the parser was in panic mode during the
                  parsing of the associated data.\\[1ex]
\end{tabular}

\noindent
The \pads{} library provides a collection of functions (macros
actually) for manipulating the parse state field:
\vskip 1ex
\begin{code}
void PDC_PS_init(void *pd);         
void PDC_PS_setPanic(void *pd);     
void PDC_PS_unsetPanic(void *pd);   
int  PDC_PS_isPanic(void *pd);      
\end{code}

\cd{errCode}: \appref{app:error-codes} contains a list of all error codes and
describes their meanings.

\cd{loc} : describe the structure of this data.

Details about how parse descriptors are customized for various \PADS{}
types appear in
\secref{sec:base-type-parse-descriptors}, \secref{sec:structs-parse-descriptors},
\secref{sec:unions-parse-descriptors}, \secref{sec:arrays-parse-descriptors}, 
\secref{sec:enums-parse-descriptors} and \secref{sec:typedefs-parse-descriptors}.

\section{Operations}
\label{common-operations}
For each \pads{} type, the generated library contains a collection of
functions for manipulating the associated data.  For structured types,
the \pads{} compiler generates these functions;  for base types, the
\pads{} library provides them.  This section describes the common
features of such functions.  Type-specific information may be found in
the appropriate chapter.

All operations take a pointer to an
initialized \pads{} handle as their first parameter.  Information
about how to manage \pads{} library handles appears in
\chapref{chap:using-library}. 

Many of the operations that can fail return a value of type
\cd{PDC\_error\_t} to indicate success or failure.  This type has two
values: \cd{PDC\_OK} and \cd{PDC\_ERROR}. 


\subsection{Initialization and cleanup functions}
For each type \cd{foo}, the generated library contains
initialization and cleanup functions for the associated representation
\cd{foo} and parse descriptor \pdSuf{foo} types.  Each initialization
function take a pointer to allocated space and initializes the space
appropriately.  Each cleanup function takes a pointer to allocated and
initialized space and deallocates any memory allocated by \pads{} functions.
It does not deallocate the space pointed to by the parameter.  
\begin{code}
PDC_error_t foo_init (PDC_t *pdc, foo *rep);

PDC_error_t foo_cleanup (PDC_t *pdc, foo *rep);

PDC_error_t foo_pd_init (PDC_t *pdc, foo_pd *pd);

PDC_error_t foo_pd_cleanup (PDC_t *pdc, foo_pd *pd);
\end{code}
Because all masks have statically-known size, the library does not
contain initialization and cleanup functions for masks.  
\begin{code}
void foo_m_init (PDC_t *pdc, foo_m *mask, PDC_base_m baseMask);
\end{code}
Instead, it
contains a function for setting all nested base masks 
to a specified value.  The function takes two parameters (in
addition to the \pads{} handle): a pointer to allocated space for the
mask and a base mask value.  Because mask initialization
functions cannot fail, the return type is \cd{void} instead of
\cd{PDC_error_t}. 

\subsection{Utilty functions}
Each type \cd{foo} comes equipped with copy functions for both the
in-memory representation and the parse descriptor.  Both the source
and destination pointers are assumed to point to allocated space.  In
addition, the src pointers are assumed to point to initialized space.
\begin{code}
PDC_error_t foo_copy (PDC_t *pdc, foo *rep_dst, foo *rep_src);

PDC_error_t foo_pd_copy (PDC_t *pdc, foo_pd *pd_dst, foo_pd *pd_src);
\end{code}

\subsection{Read function}
The read function for a \pads{} type \cd{foo} takes as an input parameter a
pointer to a mask \cd{m} and returns as output parameters a pointer to
a parse descriptor \cd{pd} and a pointer to an in-memory
reprsentation \cd{rep}.  If any errors occurred during the parsing, the return
value for the function is \cd{PDC_ERROR}.  Otherwise, the function
will return \cd{PDC_OK}.  

\begin{code}
PDC_error_t foo_read (PDC_t *pdc, foo_m *m, foo_pd *pd, foo *rep);
\end{code}

The mask argument allows the library user to specify independently
which constraints the parser should check and which portions of the
in-memory representation it should fill in.  Conceptually, there are
three different ``knobs'' associated with each atomic element of a
\pads{} type:

\vskip 1ex
\begin{tabular}{ll}
\cd{PDC_SynCheck} & Check syntactic constraints\\
\cd{PDC_SymCheck} & Check semantic constraints\\
\cd{PDC_Set}      & Set the in-memory reprsentation\\[1ex]
\end{tabular}

\noindent
At the base-type level, the mask consists of one or more of the
above flags.
For structured types, the mask consists of a combination of base masks
and the masks associated with nested types, the exact combination of
which depends upon the kind of structured type.  Note that for a
structured type \cd{foo}, the mask initialization function
\cd{foo_m_init} can be used to initialize all nested masks to the
supplied value.

Details about the read functions for particular types may be found in
the appropriate chapters.

For convenience, the \pads{} library provides the following abbreviations:

\vskip 1ex
\begin{tabular}{ll}
\cd{\#define PDC\_CheckAndSet} & \cd{PDC\_Set|PDC\_SynCheck|PDC\_SemCheck}\\
\cd{\#define PDC\_BothCheck}   & \cd{PDC\_SynCheck|PDC\_SemCheck} \\
\cd{\#define PDC\_Ignore}      & no flags set\\[1ex]
\end{tabular}

\noindent
The library also provides the following macros for testing or
modifying base read-function flags:

\vskip 1ex
{\small
\begin{tabular}{ll}
\cd{\#define PDC\_Test\_Set(m)}            & \cd{(m \& PDC\_Set)} \\
\cd{\#define PDC\_Test\_SynCheck(m)}       & \cd{(m \& PDC\_SynCheck)}\\
\cd{\#define PDC\_Test\_SemCheck(m)}       & \cd{(m \& PDC\_SemCheck)}\\
\\
\cd{\#define PDC\_Test\_NotSet(m)}         & \cd{(!PDC\_Test\_Set(m))}\\
\cd{\#define PDC\_Test\_NotSynCheck(m)}    & \cd{(!PDC\_Test\_SynCheck(m))}\\
\cd{\#define PDC\_Test\_NotSemCheck(m)}    & \cd{(!PDC\_Test\_SemCheck(m))}\\
\\
\cd{\#define PDC\_Test\_CheckAndSet(m)}    & \cd{((m \& PDC\_CheckAndSet) == PDC\_CheckAndSet)}\\
\cd{\#define PDC\_Test\_BothCheck(m)}      & \cd{((m \& PDC\_CheckAndSet) == PDC\_BothCheck)}\\
\cd{\#define PDC\_Test\_Ignore(m)}         & \cd{((m \& PDC\_CheckAndSet) == PDC\_Ignore)}\\
\\
\cd{\#define PDC\_Test\_NotCheckAndSet(m)} & \cd{((m \& PDC\_CheckAndSet) != PDC\_CheckAndSet)}\\
\cd{\#define PDC\_Test\_NotBothCheck(m)}   & \cd{((m \& PDC\_CheckAndSet) != PDC\_BothCheck)}\\
\cd{\#define PDC\_Test\_NotIgnore(m)}      & \cd{((m \& PDC\_CheckAndSet) != PDC\_Ignore)}\\
\\
\cd{\#define PDC\_Do\_Set(m)}              & \cd{(m |= PDC\_Set)}\\
\cd{\#define PDC\_Do\_SynCheck(m)}         & \cd{(m |= PDC\_SynCheck)}\\
\cd{\#define PDC\_Do\_SemCheck(m)}         & \cd{(m |= PDC\_SemCheck)}\\
\\
\cd{\#define PDC\_Dont\_Set(m)}            & \cd{(m \&= (~PDC\_Set))}\\
\cd{\#define PDC\_Dont\_SynCheck(m)}       & \cd{(m \&= (~PDC\_SynCheck))}\\
\cd{\#define PDC\_Dont\_SemCheck(m)}       & \cd{(m \&= (~PDC\_SemCheck))}\\[1ex]
\end{tabular}
}
\subsection{Write functions}
For each \pads{} type, the generated library provides 
two functions for writing out the in-memory representation of the type
in a format as close as possible to its original form.
\begin{code}
ssize\_t foo\_write2io (PDC\_t *pdc, Sfio\_t *io, foo\_pd *pd, foo *rep);

ssize\_t foo\_write2buf (PDC\_t *pdc, PDC\_byte *buf, size\_t buf\_len, 
                        int *buf\_full, foo\_pd *pd, foo *rep);
\end{code}
The first of these functions emits its output to an SFIO file;
the second to an in-memory buffer.  Information about SFIO may be
found from \url{www.research.att.com/sw/tools/sfio}.  For the buffer
version, the parameter \cd{buf} points to an allocated sequence of
bytes and \cd{buf\_len} indicates the size of the buffer.  Out
parameter \cd{buf\_full} is a boolean which is set if the requested
write would have overflowed the buffer. The return value
for both of the functions is the number of bytes written, with \cd{-1}
indicating an error occurred.  

Issues that may cause the written data to differ from the original
data include skipping white space
(\secref{sec:library-customization-white-space}) and omitting fields in
\Pstruct{}s (\secref{sec:structs-qualifiers}). 

Passing the \texttt{-wnone} flag to the \pads{} compiler suppresses
the generation of these functions for structured types.

We anticipate adding more write functions in the future.

\subsection{Additional functions}
In addition to the basic functionality described in the preceeding
sections, \pads{} provides more advanced features described in later
chapters. 

\begin{tabular}{lp{4in}}
Accumulators (\chapref{chap:accumulators})  & Provide structures and
functions for automatically summarizing data.\\
\end{tabular}
