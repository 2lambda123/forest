\chapter{Common features}
\label{chap:common-features}
\cutname{common.html}
In this chapter, we describe the \PADSL{} features shared by all types. 
Subsequent chapters describe features particular to individual \PADSL{}
types. 

\section{\pads{} types}
\label{sec:common-overall}
Each \padsl{} type specifies the external representation of a
particular kind of data.  \padsl{} base types describe the
representations of atomic pieces of data, while structured types
specify how compound representations are built from more basic ones. 
\padsl{} provides a large and extensible collection of base types
and a family of type constructors for building structured types: 
\pstruct{}s for record-like sequences, 
\punion{}s for alternatives, 
\parray{}s for sequences, 
\penum{}s for fixed collections of strings, and
\ptypedef{}s for refinements of existing types.

Syntactically, a \padsl{} type declaration (\nont{p\_ty\_decl}) must
have the following form: 

\myvskip{1ex}
\begin{tabular}{rcll}
\nont{p\_ty\_decl} & \is{} & \nont{base\_ty} & (* \chapref{chap:base-types} *) \\[1ex]
& \alt{} & \nont{struct\_ty}           & (* \chapref{chap:structs} *)\\[1ex]
& \alt{} & \nont{union\_ty}            & (* \chapref{chap:unions} *)\\[1ex]
& \alt{} & \nont{array\_ty}            & (* \chapref{chap:arrays}*)\\[1ex]
& \alt{} & \nont{enum\_ty}             & (* \chapref{chap:enums} *)\\[1ex]
& \alt{} & \nont{opt\_ty}              & (* \chapref{chap:opts} *)\\[1ex]
& \alt{} & \nont{typedef\_ty}          & (* \chapref{chap:typedefs} *)\\[1ex]
\end{tabular}

We use the terminal \term{p\_ty\_name} for an identifier bound to one
of the above types.  

\noindent
The grammar for each of the above non-terminals is given in the
associated chapter.

\section{Comments}
\label{sec:common-comments}
In addition to \C{} and \Cplusplus{} style comments of the form 
\cd{/* ... */} and \cd{//...}, which may appear anywhere in a \pads{}
description, \padsl{} also supports \nont{p\_comment}s, which may
appear only in particular locations in the grammar.  Syntactically,

\myvskip{1ex}
\begin{tabular}{rcll}
\nont{p\_comment} & \is{} & \cd{/-} \term{text}  \\[1ex]
\end{tabular}

\noindent
where \term{text} is a new-line terminated sequence of characters.
\pads{} comments are reflected to the generated \texttt{.h} file as
documentation. We indicate where such comments may appear in the
source as the locations arise in the descriptions of the various
\padsl{} features. 



\section{Predicates}
\label{sec:common-predicates}
\pads{} descriptions permit the user to supply \term{predicates}
for validating semantic properties of syntactically correct data. 
Syntactically, such predicates are arbitrary \C{} expressions of
integer type.  Predicates that evaluate to \cd{false} (\ie{}, \cd{0})
imply the data is invalid, while all other values imply the data is
valid.  Predicates are assumed to be side-effect free.

To allow users to express constraints involving the size and position
of physical data, \padsl{} supports \nont{p\_parsecheck} expressions within
predicates.  Syntactically,

\myvskip{1ex}
\begin{tabular}{rcl}
\nont{p\_parsecheck} & \is{} & \pparsecheck{}(\nont{aug\_expression})\\
\end{tabular}
\myvskip{1ex}

\noindent
In the production, \nont{aug\_expression} is an integer-valued \C{}
expression that is allowed to refer 
to special constants providing location information.  The precise constants
depend upon the context of the \pparsecheck{} clause in the \pads{}
description, but always include the constant \cd{position} of type 
\Ppost{}, bound to the current position in the physical
source.  

For integration with general predicates, \pparsecheck{} expressions
are treated as \C{} expressions with type \texttt{int}.

\section{Literals}
\label{sec:common-literals}
\PADSL{} supports \C{}-style character and string
literals, referred to in the \pads{} grammar as \term{char\_lit} and
\term{str\_lit}, respectively.  
These literals may contain \C{} character escapes such as \literal{\cd{\escdquote{}}} and
\literal{\cd{\escquote{}}}.  \PADSL{} also supports regular expression literals,
described in more detail in \secref{sec:regular-expressions}, and the
special literal \Peor{}, which denotes the end of a record.  We use
the non-terminal \term{regexp\_lit} to refer to regular expressions.
Syntactically, 

\myvskip{1ex}
\begin{tabular}{rcl}
\nont{p\_coreliteral}& \is{} & \term{char\_lit} \alt{} \nont{str\_lit} 
                            \alt{} \Pre{} \nont{regexp\_lit} 
			    \alt{} \Peor{} \\[1ex]
\nont{p\_literal}    & \is{} & \nont{p\_coreliteral} 
                            \alt{} \term{C\_identifer} \Pfrom{} (\nont{p\_coreliteral})\\[1ex]
\end{tabular}

\noindent
Literals (as opposed to core literals) also support a renaming form.
The supplied \C{} identifier gives the programmatic name for the
literal, while the core literal supplied in the \Pfrom{} clause
describes the on-disk representation.  Renaming can useful when the
literal is not a valid \C{} identifier.

\cut{
One use of character and string literals are used to read external
characters without storing any corresponding data in the resulting in-memory
representation, \ie, they ``skip over'' some expected character(s) in
the external representation.
They are typically used in \Pstruct{}s (\cf{}
\secref{sec:structs-literal-fields}). 

The above use in only one use of literals.  They are also used in
arrays to describe separators and terminators and in enums to describe
the branches.  In addition, they may be used as arguments to
parameterized functions.}

\section{Character Sets}
\label{sec:common-character-sets}

The library discipline contains a field \cd{def_charset} that
indicates the expected character set of the external representation of
character and string literals, as well as the external representation
of all character and string 
base types that do not explicitly name a character set.  Supported
character sets include ASCII (\cd{Pcharset_ASCII}) and EBCDIC
(\cd{Pcharset_EBCDIC}), where ASCII is the default character set.
\secref{sec:library-customization-character-encodings} describes how
to set \cd{def_charset}.

\section{White Space}
\label{sec:common-features-white-space}
Is there anything we need to say here?

\section{Parameterization}
\label{sec:common-parameterization}
To reduce the number of necessary type declarations and to permit the
format of later portions of the data to depend upon earlier portions, 
\PADSL{} types can be parameterized by values.  A common example of
the latter use is a data source which first specifies the length of a
sequence and then gives the sequence itself.  The length is read,
stored in the in-memory representation, and then passed to the type
that describes the sequence to specify the termination condition for
the sequence. Syntactically, 
\myvskip{1ex}
\begin{tabular}{rcl}
\nont{p\_actual\_list} & \is{} & \nont{expression} \alt{} \nont{expression}, \nont{p\_actual\_list} \\[1ex]
\nont{p\_actuals} & \is{} & (: \nont{p\_actual\_list} :)\\[1ex]
\nont{p\_ty} & \is{} & p\_ty\_name \opt{\nont{p\_actuals}}\\[2ex]
\end{tabular}

\noindent
where \nont{expression} is any \C{} expression. Formal parameter lists
are similar to \C{}'s, except they are deliminated differently:
\myvskip{1ex}
\begin{tabular}{rcl}
\nont{p\_formals} & \is{} & (: \nont{c\_formal\_list} :)\\[1ex]
\end{tabular}

\subsection{Example}
The \cd{formalParamExample} type declaration in the following \padsl{}
fragment illustrates declaring parameters to \pads{} types, while
the \cd{actualParamExample} illustrates passing parameters.
\begin{code}
\inputCode{code/struct.parameters}
\end{code}
Type \cd{formalParamExample} expects its single field \cd{data} to be
less than a supplied value \cd{limit}, while the type \cd{actualParamExample}
describes an external representation with two pieces: an integer
\cd{limit} and then an instance of \cd{formalParamExample}.  The value
of \cd{limit} is passed as the actual parameter to the \cd{formalParamExample}
\pstruct{}. 

\section{\Precord{} modifier}
\label{sec:commong-precord}
The \Precord{} modifier may be used as an annotation on any \pads{}
type, indicating that the type describes a \textit{record} in the
external representation of the data.  \pads{} supports a number of
different interpretations of what constitutes a record:

\begin{center}
\begin{tabular}{l|l}
Record type         & Description\\ \hline
New-line terminated & End of record marked by new-line character\\
Fixed-width record  & Records contain a specified number of bytes\\
IBM-style record    & Record header indicates size\\
\end{tabular}
\end{center}

\noindent
\secref{sec:library-customization-character-encodings} describes how
to set the appropriate record discipline for a data source. 


\section{\Psource{} modifier}
\label{sec:common-pfile}
The \Psource{} modifier may be used as an annotation on any \pads{}
type, indicating that the type in question describes the entirety of
the external representation of the data.

\section{Error model}
\label{sec:common-error-model}
During parsing, \pads{} read functions detect when the data does not
conform to the given specification.  Detected violations fall into two
classes, which differ in their severity.  The less severe of these,
\textit{semantic} errors are those in which the parser detects a
violation of the specified format but does not ``lose its place.''  A
typical example of this kind of error is a violation of a
user-specified constraint, such as a requirement that a given field be
greater than a threshold value.  The more severe type of error,
\textit{syntactic} errors, involve the parser finding raw data that
cannot be reconciled with the physical aspects of the description.
Typical examples include failing to find literals required by
\Pstruct{} declarations or separators from \Parray{} declarations. We
say that a read function enters \textit{panic} mode when it detects
such an error. Read functions set the \cd{P_Panic} flag in the
\cd{pstate} field of the appropriate parse descriptor when entering
panic mode (\secref{sec:common-parse-descriptor} describes the general
role and structure of parse descriptors).

\pads{} read functions attempt to recover from panic mode by scanning
for possible synchronization points in the data source.
For example, if the read function for a \pads{} type \cd{foo} annotated with
the \Precord{} qualifier enters panic mode, it tries to
recover by scanning to the end of the record.  If it succeeds in
finding the record boundary, it lowers the panic flag in the \cd{foo}
parse descriptor, although the nested parse descriptor for the portion
of the data description that caused the panic will still be set.  The parse
descriptions for all portions of the data description that were
skipped during the scanning process will also have the panic flag set.
Type-specific information regarding error-recovery appears in the
corresponding chapter.



\section{In-memory representations}
\label{sec:common-rep}
Each \PADS{} type \cd{foo} has an associated in-memory representation
type of the same name.  The structure of this representation depends
upon the particular \PADS{} type.  
In general, these representations fall into two broad categories:
\textit{static} representations, whose size can be computed at
library-generation time, and \textit{dynamic} representations, whose size 
depends on the data being parsed. 
Details appear in 
\secref{sec:base-types-rep}, \secref{sec:structs-rep},
\secref{sec:unions-rep}, \secref{sec:arrays-rep}, 
\secref{sec:enums-rep}, and \secref{sec:typedefs-rep}.

\section{Masks}
\label{sec:common-masks}
Each \PADS{} type \cd{foo} has an associated mask type, \csmSuf{foo}.
Masks allow the library user to customize operations on portions of
the associated data.  The structure of the mask for a given \PADS{}
type mirrors the structure of the representation type.  Details about
the structure for various types
appear in \secref{sec:base-type-mask}, \secref{sec:structs-masks},
\secref{sec:unions-masks}, \secref{sec:arrays-masks}, 
\secref{sec:enums-masks}, and \secref{sec:typedefs-masks}.
Different operations in the generated library interpret masks
differently.  Details about how a given operation treats its mask
argument appear in the sections describing the operations.

\section{Parse descriptors}
\label{sec:common-parse-descriptor}
Each \PADS{} type \cd{foo} has an associated parse descriptor type, 
\pdSuf{foo}, coded as a \C{} struct with at least the following four
fields:

\myvskip{1ex}
\begin{tabular}{l|p{4in}}
 Field & Description \\ \hline
 \cd{Puint32 pstate} & Flags that describe the state after parsing the
                           associated value.\\[1ex]
 \cd{PerrCode_t errCode} & A code indicating the nature of the 
                               first detected error. 
                               \appref{app:error-codes} contains a 
                               list of all error codes and 
			       describes their meanings. \\[1ex]
 \cd{Ploc_t loc}  & The location in the data source of the first 
                         error.\\[1ex]
 \cd{Puint32 nerr} & The number of errors detected during parsing
                        of the associated value.\\[1ex]
\end{tabular}

\noindent
Field \cd{pstate} contains the following flags:
\myvskip{1ex}
\begin{tabular}{lp{3.5in}}
 \cd{PPanic} & Set if the parser was in panic mode during the
                  parsing of the associated data.  See
                  \secref{sec:common-error-model} for more information.\\[1ex]
\end{tabular}

\noindent
The \pads{} library provides a collection of functions (macros
actually) for manipulating the parse state field:
\inputCode{code/parse-state}


\note{To Do:} Describe the structure of location data. 

Details about how parse descriptors are customized for various \PADS{}
types appear in
\secref{sec:base-type-parse-descriptors}, \secref{sec:structs-parse-descriptors},
\secref{sec:unions-parse-descriptors}, \secref{sec:arrays-parse-descriptors}, 
\secref{sec:enums-parse-descriptors} and \secref{sec:typedefs-parse-descriptors}.

\section{Regular Expressions}
\label{sec:regular-expressions}
\begin{tabular}{rcl}
\nont{p\_regexp\_lit} & \is{} & ... \\[1ex]
\nont{p\_regexp\_expression} & \is{} & \Pre{} \nont{expression} \\[1ex]
\end{tabular}

\textbf{To do:}

Perhaps we should have a separate chapter devoted to regular expressions?

Need to describe \Pcharclass{}.

Need to describe semantics currently supported.

Need to mention extra backslashes.

Need to describe compiled (type \Pregexpt{}) vs. strings.

Mention uses:  library discipline, read functions.

\section{Expressions}
Expression forms include \C{} expressions, regular expressions, and
the special symbol \Peor{}.

\label{sec:expressions}
\begin{tabular}{rcl}
\nont{p\_expression} & \is{} & \nont{expression} \alt{}  \Pre{} \nont{expression} \alt{} \Peor{} \\[1ex]
\end{tabular}


\section{Operations}
\label{common-operations}
For each \pads{} type, the generated library contains a collection of
functions for manipulating the associated data.  For structured types,
the \pads{} compiler generates the functions;  for base types, the
\pads{} library provides them.  This section describes the common
features of such functions.  Type-specific information may be found in
the appropriate chapter.

All operations take a pointer to an
initialized \pads{} handle as their first parameter.  Information
about how to manage \pads{} library handles appears in
\chapref{chap:library-use}. 

Many of the operations that can fail return a value of type
\cd{Perror_t} to indicate success or failure.  This type has two
values: \cd{P_OK} and \cd{P_ERR}. 


\subsection{Initialization and cleanup functions}
For each type \cd{foo}, the generated library contains
initialization and cleanup functions for the associated representation
\cd{foo} and parse descriptor \pdSuf{foo} types.  Each initialization
function take a pointer to allocated space and initializes the space
appropriately.  Each cleanup function takes a pointer to allocated and
initialized space and deallocates any memory allocated by \pads{} functions.
It does not deallocate the space pointed to by the parameter.  

\inputCode{code/init}

Because all masks have statically-known size, the library does not
contain initialization and cleanup functions for masks.  
Instead, it contains a function for setting all nested base masks 
to a specified value:  

\inputCode{code/init-mask}

The function takes two parameters (in
addition to the \pads{} handle): a pointer to allocated space for the
mask and a base mask value.  Because mask initialization
functions cannot fail, the return type is \cd{void} instead of
\cd{Perror_t}. 

\subsection{Utilty functions}
Each type \cd{foo} comes equipped with copy functions for both the
in-memory representation and the parse descriptor.  Both the source
and destination pointers are assumed to point to allocated space.  In
addition, the source pointers are assumed to point to initialized
space.

\inputCode{code/utility}

\noindent
Each type \cd{foo} also has a predicate function that returns true if
the supplied in-memory representation satisfies all of the
non-\pparsecheck{} constraints.

\inputCode{code/verify}


\subsection{Read function}
The read function for a \pads{} type \cd{foo} takes as an input parameter a
pointer to a mask \cd{m} and returns as output parameters a pointer to
a parse descriptor \cd{pd} and a pointer to an in-memory
reprsentation \cd{rep}.  If any errors occur during the parsing,
the function will return \cd{P_ERR}.  Otherwise, it
will return \cd{P_OK}.  

\inputCode{code/read}

The mask argument allows the library user to specify independently
which constraints the parser should check and which portions of the
in-memory representation it should fill in.  Conceptually, there are
three different ``knobs'' associated with each atomic element of a
\pads{} type:

\myvskip{1ex}
\begin{center}
\begin{tabular}{l|l}
Flag name       & Definition    \\ \hline
\cd{P_SynCheck} & Check syntactic constraints\\
\cd{P_SymCheck} & Check semantic constraints\\
\cd{P_Set}      & Set the in-memory representation\\[1ex]
\end{tabular}
\end{center}

\noindent
At the base-type level, the mask consists of one or more of the
above flags.
For structured types, the mask consists of a combination of base masks
and the masks associated with nested types, the exact combination of
which depends upon the kind of structured type.  Note that for a
structured type \cd{foo}, the mask initialization function
\cd{foo_m_init} can be used to initialize all nested masks to the
supplied value.

Details about the read functions for particular types may be found in
the appropriate chapters.

For convenience, the \pads{} library provides the following abbreviations:

\myvskip{1ex}
\begin{center}
\begin{tabular}{l@{ }l}
\cd{\#define P_CheckAndSet} & \cd{P_Set|P_SynCheck|P_SemCheck}\\
\cd{\#define P_BothCheck}   & \cd{P_SynCheck|P_SemCheck} \\
\cd{\#define P_Ignore}      & no flags set\\[1ex]
\end{tabular}
\end{center}

\noindent
The library also provides macros for testing and modifying base
read-function flags, which are listed in \figref{figure:read-flags}.

\begin{figure*}
{\small
\begin{tabular}{l@{ }l}
\cd{\#define P_Test_Set(m)}            & \cd{(m \& P_Set)} \\
\cd{\#define P_Test_SynCheck(m)}       & \cd{(m \& P_SynCheck)}\\
\cd{\#define P_Test_SemCheck(m)}       & \cd{(m \& P_SemCheck)}\\
\\
\cd{\#define P_Test_NotSet(m)}         & \cd{(!P_Test_Set(m))}\\
\cd{\#define P_Test_NotSynCheck(m)}    & \cd{(!P_Test_SynCheck(m))}\\
\cd{\#define P_Test_NotSemCheck(m)}    & \cd{(!P_Test_SemCheck(m))}\\
\\
\cd{\#define P_Test_CheckAndSet(m)}    & \cd{((m \& P_CheckAndSet) == P_CheckAndSet)}\\
\cd{\#define P_Test_BothCheck(m)}      & \cd{((m \& P_CheckAndSet) == P_BothCheck)}\\
\cd{\#define P_Test_Ignore(m)}         & \cd{((m \& P_CheckAndSet) == P_Ignore)}\\
\\
\cd{\#define P_Test_NotCheckAndSet(m)} & \cd{((m \& P_CheckAndSet) != P_CheckAndSet)}\\
\cd{\#define P_Test_NotBothCheck(m)}   & \cd{((m \& P_CheckAndSet) != P_BothCheck)}\\
\cd{\#define P_Test_NotIgnore(m)}      & \cd{((m \& P_CheckAndSet) != P_Ignore)}\\
\\
\cd{\#define P_Do_Set(m)}              & \cd{(m |= P_Set)}\\
\cd{\#define P_Do_SynCheck(m)}         & \cd{(m |= P_SynCheck)}\\
\cd{\#define P_Do_SemCheck(m)}         & \cd{(m |= P_SemCheck)}\\
\\
\cd{\#define P_Dont_Set(m)}            & \cd{(m \&= (~P_Set))}\\
\cd{\#define P_Dont_SynCheck(m)}       & \cd{(m \&= (~P_SynCheck))}\\
\cd{\#define P_Dont_SemCheck(m)}       & \cd{(m \&= (~P_SemCheck))}\\[1ex]
\end{tabular}
}
\caption{Provided macros for setting and testing base read-function flags.}
\label{figure:read-flags}
\end{figure*}

\subsection{Write functions}
For each \pads{} type, the generated library provides 
two functions for writing out the in-memory representation of the type
in a format as close as possible to its original form.

\inputCode{code/write}

\noindent
The first of these functions emits its output to an SFIO file;
the second to an in-memory buffer.  Information about SFIO may be
found from \myurl{www.research.att.com/sw/tools/sfio}.  For the buffer
version, the parameter \cd{buf} points to an allocated sequence of
bytes and \cd{buf_len} indicates the size of the buffer.  Out
parameter \cd{buf_full} is a boolean which is set if the requested
write would have overflowed the buffer. The return value
for both of the functions is the number of bytes written, with \cd{-1}
indicating an error occurred.  

Issues that may cause the written data to differ from the original
data include skipping white space
(\secref{sec:library-customization-white-space}) and omitting fields in
\Pstruct{}s (\secref{sec:structs-qualifiers}). 

Passing the \texttt{-wnone} flag to the \pads{} compiler suppresses
the generation of write functions for structured types.


\subsection{Additional functions}
In addition to the basic functionality described in the preceeding
sections, \pads{} provides more advanced features described in later
chapters. 

\begin{tabular}{lp{4in}}
Accumulators (\chapref{chap:accumulators})  & Provide structures and
functions for automatically summarizing data.\\
\end{tabular}
