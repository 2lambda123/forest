\chapter{Tutorial}
\label{chap:example}
In this chapter, we use examples to give an overview of \pads{}.
The examples used in this chapter appear in the \pads{} distribution in the 
\texttt{pads/demo} directory.


\section{Example data formats}
We start by briefly describing the data formats we will use as running examples. 

\subsection{CLF: Common log format}
\label{sec:example:common-log-format}
One of the formats that web servers use to log client
requests is the Common Log Format (CLF)~\cite{wpp}.  Researchers use such logs to measure 
properties of web workloads and to evaluate protocol changes
by "replaying" the user activity recorded in the log.
This ASCII format consists of a sequence of
records, each of which has seven fields: the host name or IP address
of the client making the request, the account associated with the
request on the client side, the name the user provided for
authentication, the time of the request, the actual request, the
\textsc{http} response code, and the number of bytes returned as a
result of the request.  The actual request has three parts: the
request method (\eg, \texttt{GET}, \texttt{PUT}), the requested
\textsc{uri}, and the protocol version.  In addition, the second and
third fields are often recorded only as a '-' character to indicate
the server did not record the actual data.  \figref{figure:clf-records}
shows a couple of typical records.

\subsection{Provisioning data}

In the telecommunications industry, the term \textit{provisioning}
refers to the steps necessary to convert an order for phone service
into the actual service.  To track AT\&T's provisioning process, the
\dibbler{} project compiles weekly summaries of the state of certain
types of phone service orders.  These ASCII summaries store the
summary date and one record per order.  Each order record contains a
header followed by a sequence of events.  The header has 13 pipe
separated fields: the order number, AT\&T's internal order number, the
order version, four different telephone numbers associated with the
order, the zip code of the order, a billing identifier, the order
type, a measure of the complexity of the order, an unused field, and
the source of the order data.  Many of these fields are optional, in
which case nothing appears between the pipe characters.  The billing
identifier may not be available at the time of processing, in which
case the system generates a unique identifier, and prefixes this value
with the string ``no\_ii'' to indicate the number was generated. The
event sequence represents the various states a service order goes
through; it is represented as a new-line terminated, pipe separated
list of state, timestamp pairs.  There are over 400 distinct states
that an order may go through during provisioning.  The sequence is
sorted in order of increasing
timestamps. \figref{figure:dibbler-records} shows a small example of
this format.


\begin{figure*}[t!]
\begin{footnotesize}
\begin{verbatim}
207.136.97.49 - - [15/Oct/1997:18:46:51 -0700] "GET /tk/p.txt HTTP/1.0" 200 30
tj62.aol.com - - [16/Oct/1997:14:32:22 -0700] "POST /scpt/dd@grp.org/confirm HTTP/1.0" 200 941
\end{verbatim}
\vskip -2ex
\caption{Tiny example of web server log data.}
\label{figure:clf-records}
\end{footnotesize}
\end{figure*}

\begin{figure*}
\begin{footnotesize}
\begin{center}
\begin{verbatim}
0|1005022800
9152|9152|1|9735551212|0||9085551212|07988|no_ii152272|EDTF_6|0|APRL1|DUO|10|1000295291
9153|9153|1|0|0|0|0||152268|LOC_6|0|FRDW1|DUO|LOC_CRTE|1001476800|LOC_OS_10|1001649601
\end{verbatim}
\caption{Tiny example of \dibbler{} provisioning data.}
\label{figure:dibbler-records}
\end{center}
\end{footnotesize}
\end{figure*}

\begin{figure}
\input{wsl}
\caption{\pads{} description for web server log data.}
\label{figure:wsl}
\end{figure}

\begin{figure}
\input{sirius}
\caption{Partial \pads{} description for \dibbler{} provisioning data.}
\label{figure:dibbler}
\end{figure}



\section{\padsl{} descriptions}
\label{sec:example:padsl-description}
\figref{figure:wsl} gives the \pads{} description for CLF web server
logs,  while \figref{figure:dibbler} gives the description for the
\dibbler{} provisioning data.  We use these examples to illustrate
various features of the \pads{} language.  In \pads{} descriptions,
types are declared before they are used, so the type that describes
the totality of the data source appears at the bottom of the
description.

\kw{Pstruct}s describe fixed sequences of data with unrelated types.
In the CLF description, the type declaration for \cd{version_t}
illustrates a simple \kw{Pstruct}. It starts with a string literal
that matches the constant \cd{HTTP/} in the data source.  It then has
two unsigned integers recording the major and minor version numbers
separated by the literal character \kw{'.'}.  \pads{} supports
character, string, and regular expression literals, which are
interpreted with the ambient character encoding. The type
\cd{request_t} similarly describes the request portion of a CLF
record.  In addition to physical format information, this \kw{Pstruct}
includes a semantic constraint on the \cd{version} field.
Specifically, it requires that obsolete methods \cd{LINK} and
\cd{UNLINK} occur only under HTTP/1.1.  This constraint illustrates
the use of predicate functions and the fact that earlier fields are in
scope during the processing of later fields, as the constraint refers
to both the \cd{meth} and \cd{version} fields in the \kw{Pstruct}.
\chapref{chap:structs} describes \kw{Pstruct}s in detail.

\kw{Punion}s describe variation in the data source.  For example, the
\cd{client_t} type in the CLF description indicates that the first
field in a CLF record can be either an IP address or a hostname.
During parsing, the branches of a \kw{Punion} are tried in order; the
first branch that parses without error is taken.  The \cd{auth_id_t}
type illustrates the use of a constraint: the branch \cd{unauthorized}
is chosen only if the parsed character is a dash.  \pads{} also
supports a \textit{switched} union that uses a selection expression to
determine the branch to parse.  Typically, this expression depends
upon already-parsed portions of the data source.

\pads{} provides \kw{Parray}s to describe varying-length sequences of
data all with the same type.  The \cd{eventSeq_t} declaration in the
\dibbler{} data description uses a \kw{Parray} to characterize the
sequence of events an order goes through during processing.  This
declaration indicates that the elements in the sequence have type
\cd{event_t}.  It also specifies that the elements will be separated
by vertical bars, and that the sequence will be terminated by an
end-of-record marker (\kw{Peor}).  In general, \pads{} provides a rich
collection of array-termination conditions: reaching a maximum size,
finding a terminating literal (including end-of-record and
end-of-source), or satisfying a user-supplied predicate over the
already-parsed portion of the \kw{Parray}.  Finally, this type
declaration includes a \kw{Pwhere} clause to specify that the sequence
of timestamps must be in sorted order.  It uses the \kw{Pforall}
construct to express this constraint.  In general, the body of a
\kw{Pwhere} clause can be any boolean expression.  In such a context
for arrays, the pseudo-variable \cd{elts} is bound to the in-memory
representation of the sequence and \cd{length} to its length.

Returning to the CLF description in \figref{figure:wsl}, the
\kw{Penum} type \cd{method_t} describes a collection of data literals.
During parsing, \pads{} interprets these constants using the ambient
character encoding.  The \kw{Ptypedef} \cd{response_t} describes
possible server response codes in CLF data by adding the constraint
that the three-digit integer must be between 100 and 600.

The \cd{order_header_t} type in the \dibbler{} data description
contains several anonymous uses of the \kw{Popt} type.  This type is
syntactic sugar for a stylized use of a \kw{Punion} with two branches:
the first with the indicated type, and the second with the ``void''
type, which always matches but never consumes any input.



\subsection{Generated library}
\label{sec:example:generated-library}
From a description, the \pads{} compiler generates a \C{} library
for parsing and manipulating the associated data source.  
\setcounter{totalnumber}{1}
\setcounter{dbltopnumber}{1}
\renewcommand{\topfraction}{0.85}
\renewcommand{\textfraction}{0.1}
\renewcommand{\floatpagefraction}{0.75}
\begin{figure*}
\begin{tiny}
\input{library}
\caption{Selected portions of the library generated for the \texttt{entry\_t}
  declaration from \dibbler{} data description.}
\label{figure:library}
\end{tiny}
\end{figure*}
To give a feeling for the library that \pads{} generates, 
\figref{figure:library} includes selected portions of the generated 
library for the \dibbler{} \cd{entry_t} declaration.


\subsection{Example library use}
\label{sec:example:library-use}
\figref{figure:sirius-filter} shows a simple use of 
the generated \dibbler{} library to filter out ill-formed records and normalize the representation of optional phone numbers. 
The code first initializes the \pads{} library handle, \texttt{p}, by invoking the core library function \texttt{P\_open}.  The second argument to this function allows the user to customize behavior in the \pads{} library by passing a (pointer to a) \texttt{Pdisc\_t} \textit{discipline}. With this discipline, the user can specify properties such as the endianness of the data, the default character set (ASCII or EBCIDC), error handling, \etc{}  The third argument to the \texttt{P\_open} function specifies a (pointer to a) \texttt{Pio\_disc\_t} discipline, which allows the user to describe how to detect record boundaries, \ie{}, are records new-line terminated, fixed width, EBCDIC-style, \etc{} 
Passing zero in these argument positions triggers default behavior, which 
means ASCII encoded, little endian, new-line terminated records.
\chapref{chap:library-customization} describes the use of disciplines in more detail. 

After initializing the \pads{} handle, the code uses the core library function \texttt{P\_io\_fopen} to open the data source by specify the path to the data on disk.  
 and opening the data source, the code sets
the \texttt{entry\_t} \texttt{mask} to check all conditions in the \dibbler{} description except the
sorting of the timestamps.  We have omitted from the figure the code to read and write the header. 
The code then echoes error records to one file and cleaned ones to another.
The raw data has two different representations of unavailable phone numbers:
simply omitting the number altogether, which corresponds to the \cd{NONE}
branch of the \kw{Popt}, or having the value \cd{0} in the data.  
The function \cd{cnvPhoneNumbers} unifies these two representations 
by converting the zeroes into \cd{NONE}s.  The function \cd{entry_t_verify}
ensures that our computation hasn't broken any of the semantic properties
of the in-memory representation of the data.


\begin{figure*}
\input{code/sirius-filter}
\caption{Fragment of a program to filter and normalize \dibbler{} data.}
\label{figure:sirius-filter}
\end{figure*}

























