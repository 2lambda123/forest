\chapter{Parrays}
\label{chap:arrays}
\Parray{}s are used to describe sequences of values of the same type.
We call the repeated type the \textit{base type} of the sequence.
\section{Syntax}
\label{sec:arrays-syntax}
The syntax for \Parray{}s is given by the following BNF grammar fragment:
\tskip{}
\begin{tabular}{rcl}
\nont{p\_size\_spec} & \is{} & \opt{\nont{expresssion}} \alt{}\opt{\nont{expression}} : \opt{\nont{expression}}\\[1ex]
\\
\nont{p\_term\_expression} & \is{} & \Pnosep{} \alt{} \nont{p\_expression}\\[1ex]
\nont{p\_array\_constraint} & \is{}  & \Psep{}(\nont{p\_expression})  \alt{} \Pterm{}(\nont{p\_term\_expression})\\
                            & \alt{} & \Plast{}(\nont{predicate}) \alt{} \Pended{}(\nont{predicate})\\
                            & \alt{} & \Plongest{}  \alt{} \Pomit{}(\nont{predicate})\\[1ex]
\nont{p\_array\_constraints} & \is{} & \nont{p\_array\_constraint} 
\alt{} \nont{p\_array\_constraint} \&\& \nont{p\_array\_constraints}\\[1ex]
\\
\nont{p\_range}  & \is{} & `[' \nont{expression} .. \nont{expression}`]'  \alt{} identifier\\
\nont{p\_forall} & \is{} & \Pforall{} ( identifier \Pin{} \nont{p\_range} : \nont{expression} )\\
\nont{p\_array\_post}  & \is{} & \nont{predicate} \alt{} \nont{p\_forall}\\
\nont{p\_array\_posts} & \is{} & \nont{p\_array\_post} \alt{} \nont{p\_array\_post} \&\& \nont{p\_array\_posts}\\[1ex]
\\
\nont{array\_ty} & \is{} &  \Parray{} identifier \opt{\nont{p\_formals}} \{\\
&& \quad \nont{p\_ty} `['\nont{p\_size\_spec}`]' \opt{: \nont{p\_array\_constraints}}\\
&& \}\ \opt{ \Pwhere{} \ \{\ \nont{p\_array\_posts}\ \}}; \\[4ex]
\end{tabular}

\noindent
We explain the meaning of this syntax in the remainder of this chapter.
All non-terminals not defined in this grammar fragment were
defined previously.
Predicates (\nont{predicate}) are described in \secref{sec:common-predicates}.
\padsl{} types (\nont{p\_ty}) and formal parameters (\nont{p\_formals})
are described in \secref{sec:common-parameterization}.
\padsl{} expressions \nont{p\_expressions} are defined in \secref{sec:regular-expressions}.
Literals (\nont{p\_literal})  are described in
\secref{sec:common-literals}.
Expressions (\nont{expression}) represent any \C{} expression.
We put single quotation marks around the left and right brackets to
indicate they appear in the grammer, rather than as a meta-notation
for optionality.

\subsection{Examples}
In this section, we illustrate various uses of \Parray{}s.
\subsubsection{Resolved IP address}
To describe a resolved IP address in ASCII, an example of which is:
\begin{center}
\begin{verbatim}
135.207.26.22
\end{verbatim}
\end{center}
we use the specification:
\input{code/nIP}
\noindent
which indicates that \Parray{} \cd{nIP} is a sequence of
four \cd{Puint8}'s.  The elements of the sequence are separated by
dots and the sequence is terminated by a space.  As a part of parsing
the sequence, the generated read function for this type will read the
separators.  It will check that the terminator is present, but will
not consume it.  This specification has two termination conditions: a
maximum size (4) and a terminator (a space).  Parsing will terminate
when either condition is satisified.  An error will be reported if the
other condition is not also satisifed.

\subsubsection{Binary sequence of integers}
As another example, the \Parray{} \cd{seq_t}
\input{code/seq_t}
\noindent
uses the \Plast{} predicate to terminate a
sequence of 32-bit binary integers as soon as one of those integers is
greater than ten.  The special variable \cd{elts} refers to the
sequence matched so far, while \cd{current} is the index of the most
recently read element.  If the expression within the \Plast{} clause
evaluates to true, parsing for the array terminates.  The current
element is then the last element in the array.

\subsubsection{Sorted sequence of structs}
In the next example, the \Parray{} \cd{sorted_t} uses a \Pwhere{}
clause to check that the elements of the sequence were sorted by the
\cd{id} field of the element type..
\input{code/sorted_t}
A \Pforall{} expression executes its body once for each value in the
range. The index variable, \cd{i} in the example, is bound to the
range value in the body.

\subsection{Special variables}
\label{sec:special-variables}
Within the various expression contexts of \Parray{} declarations, a
number of variables are in scope.  The following table lists the
variables, their types, and their bindings.
\vskip 1ex
\begin{tabular}{|l|l|l|l|}
\hline
Variable & Type & Contexts & Binding \\\hline \hline
\texttt{numRead}  & \texttt{int}     & all & Number of elements read from source. \\ \hline
\texttt{length}   & \texttt{int}     & all & Length of in-memory representation of sequence.\\ \hline
\texttt{elts}     & \texttt{rep\_t *}& all & In-memory representation of element sequence. \\ \hline
\texttt{pds}      & \texttt{pd\_t *} & all & In-memory representation of parse descriptor sequence. \\ \hline
\texttt{current}  & \texttt{int}     & all & Index of most recently read element.  \\ \hline
\texttt{elt}      & \texttt{rep\_t}  & all & Most recently read element of sequence. \\ \hline
\texttt{pd}       & \texttt{pd\_t}   & \Pparsecheck{} & Most recently set  parse descriptor. \\ \hline
\texttt{consume}  & \texttt{int}     & \Pended{} & See \Pended{} section for explanation. \\ \hline
\texttt{begin}    & \Ppost{}         & \Pparsecheck{} & Position in input source before reading sequence. \\ \hline
\texttt{end}      & \Ppost{}         & \Pparsecheck{} & Position in input source after reading sequence. \\ \hline
\texttt{elemBegin}& \Ppost{}         & \Pparsecheck{} & Position in input source before reading element. \\ \hline
\texttt{elemEnd}  & \Ppost{}         & \Pparsecheck{} & Position in input source after reading element. \\ \hline
\end{tabular}
\vskip 1ex

\noindent
In the table, we use \texttt{rep\_t} to denote the type of the
in-memory representation of the base type of the sequence \ie{},
\texttt{rep\_t} is the base type for the sequence.  Similarly,
\texttt{pd\_t} denotes the type of the parse descriptor for the base
type of the sequence.

In addition to these variables, the name of the array type is in scope
in every context; it is a synonym for the special variable \texttt{elts}.


\subsection{Size specifications}
There are five different kinds of size specifications possible:

\begin{tabular}{ll}
  \texttt{[]}         & unbounded \\
  \texttt{[n]}        & exactly size \texttt{n}\\
  \texttt{[low:high]} & at least \texttt{low}, at most \texttt{high}\\
  \texttt{[low:]}     & at least \texttt{low}, no upper bound\\
  \texttt{[:high]}    & at most  \texttt{high}, no lower bound\\
\end{tabular}

\noindent
As an example, the following specification describes an integer
sequence of length at least \texttt{min} and at most \texttt{max}:

\input{code/size}

A maximum size specification constitutes a termination condition for
reading the array.  It is an error for the lower bound to be greater
than the upper bound.

\subsection{\Psep}
The \Psep{} constraint is used to specify separators, \ie{} data in
the source that occurs between sequence elements.  The body of the
\Psep{} constraint can be a character, string, or regular expression. 

\subsection{\Pterm}
The \Pterm{} constraint is used to specify a terminator, \ie{} data in
the source that occurs after the last element of the sequence and
indicates that the sequence has ended.  The body of the \Pterm{}
constraint can be a character, string, or regular expression, or the
special keyword \Pnosep{}, which indicates that the lack of a
separator should be interpreted as signalling the end of the
sequence.   The terminator is not consumed by the read function for
the array.  The following description uses \Pnosep{} to indicate that
an IP address should be terminated by the lack of a period.
\input{code/nosep}

\subsection{\Plast}
The \Plast{} constraint is used to specify an arbitrary termination
condition.  The body of the constraint is a predicate expression (\cf{}
\ref{sec:common-predicates}).  It is evaluated after reading each
element in the array.  If it evaluates to true, array parsing
terminates. \secref{sec:special-variables} lists the variables that
are in scope within the predicate.

The following description uses a \Plast{} predicate to 
terminate array parsing if the number of input bytes consumed by
reading the sequence is greater than a specified amount.
\input{code/last}


\subsection{\Plongest{}}
The \Plongest{} specifier indicates that the sequence continues
until an element is read that contains an error.  The parser returns the
erroneous value to the input.  If the array declaration includes a
separator, the separator preceding the returned element
is also returned to the input.  The following \pads{} code describes a
non-empty sequence of even integers separated by the character
\cd('a'), followed by a character \cd('a'), followed by a non-empty
sequence of odd integers, separated by the character \cd('a') and
terminated by the character \cd('b'):
\input{code/longest}

\subsection{\Pended}
The \Pended{} clause is similar to \Plast{}, except that it allows 
the specification writer to indicate whether to consume the terminating
element.   As with \Plast{}, \Pended{} takes a predicate and has in
scope the variables describd in \secref{sec:special-variables}.  When the
predicate returns true, the array terminates.  By default, the
terminating element is returned to the input, as is any preceeding
separator.  To indicate that the terminating element should 
instead be considered part of the array, the predicate can set the
special variable \texttt{consume} to true as a side-effect. 

The following specification describes a sequence of comma-separated
integers.  The \cd{isDone} function in the \Pended{} clause examines
the most recently read value and the parse descriptor to determine if
the sequence has terminated.  Because the function takes the parse
descriptor as an argument, it must be within the scope of a
\Pparsecheck{} clause.

\input{code/ended}


\subsection{\Pomit}
Like \Plast{} and \Pended{}, the \Pomit{} clause takes a predicate and
has the variables in scope described in
\secref{sec:special-variables}. 
The predicate is evaluated after reading each element in the array.
When the predicate returns true, the just-read element is not stored
into the array;  it is ``omitted''.  It is because of the \Pomit{}
predicate that the special variables \texttt{numRead} and
\texttt{length} need not be the same.  Variable \texttt{numRead}
indicates the total number of possible elements that have been read,
while \texttt{length} indicates the number that have been stored into
the array.  Consequently, \texttt{numRead} will always be greater than
or equal to \texttt{length}.  


The following code reads a sequence of up to four space-separated, signed
integers terminated by the end of the record.  It omits each of the
negative numbers from the in-memory representation.
\input{code/array-omit}

\subsection{Optional \Pwhere{} clause}
If given, a \Pwhere{} clause expresses constraints over the entirety
of a \Parray{} value. The special variables that are in scope are
described in \secref{sec:special-variables}.
If the predicate given in
the \Pwhere{} clause evaluates to false (\ie{}, zero), the error code
in the associated parse descriptor will indicate a user-constraint
error has occurred.   Syntactically,  \Pwhere{} clauses for arrays are
a \cd{\&\&}-separated sequence of clauses.   There are three types of
clauses: general expressions, \Pparsecheck{} constraints, and
\Pforall{} 


\subsection{\Pparsecheck}
\subsection{\Pforall}
\begin{verbatim}

semantic constraints

name.length in scope after array

Parray recList(a_uint32 h, int x, int size) {
  test(:h,x:) [size] : forall i in [0 .. length - 2]
       { recList[i].id < recList[i+1].id };
};
\end{verbatim}

\section{termination conditions}
reach upper limit on size, reach terminator, reach end-of-file, 
not: violate constraint on individual element. (perhaps this should be
choosable by programmer?)


\section{common idiom}
struct with length followed by parameterized array.


\section{Generated library}
\subsection{In-memory representation}
\label{sec:arrays-rep}
\subsection{Mask}
\label{sec:arrays-masks}
\subsection{Parse descriptor}
\label{sec:arrays-parse-descriptors}
\subsection{Operations}
init/cleanup rep
pinit/cleanup ed
\subsubsection{read}
  error codes
\subsubsection{Accumulator functions}

