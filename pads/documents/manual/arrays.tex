\chapter{Parrays}
\label{chap:arrays}
\Parray{}s are used to describe sequences of values of the same type.
\section{Syntax}
\label{sec:arrays-syntax}
The syntax for \Parray{}s is given by the following BNF grammar fragment:
\tskip{}
\begin{tabular}{rcl}
\nont{p\_size\_spec} & \is{} & \opt{\nont{expresssion}} \alt{}\opt{nont{expression}} : \opt{\nont{expression}}\\[1ex]
\\
\nont{p\_term\_expression} & \is{} & \Pnosep{} \alt{} \nont{p\_expression}\\[1ex]
\nont{p\_array\_constraint} & \is{}  & \Psep{}(\nont{p\_expression})  \alt{} \Pterm{}(\nont{p\_term\_expression})\\
                            & \alt{} & \Plast{}(\nont{predicate}) \alt{} \Pended{}(\nont{predicate})\\
                            & \alt{} & \Pomit{}(\nont{predicate})\\[1ex]
\nont{p\_array\_constraints} & \is{} & \nont{p\_array\_constraint} 
\alt{} \nont{p\_array\_constraint} \&\& \nont{p\_array\_constraints}\\[1ex]
\\
\nont{p\_range}  & \is{} & \{ \nont{expression} .. \nont{expression}\}  \alt{} identifier\\
\nont{p\_forall} & \is{} & ( identifier \Pin{} \nont{p\_range} : \nont{expression} )\\
\nont{p\_array\_post}  & \is{} & \nont{predicate} \alt{} \nont{p\_forall}\\
\nont{p\_array\_posts} & \is{} & \nont{p\_array\_post} \alt{} \nont{p\_array\_post} \&\& \nont{p\_array\_posts}\\[1ex]
\\
\nont{array\_ty} & \is{} &  \Parray{} identifier \opt{\nont{p\_formals}} \{\\
&& \quad \nont{p\_ty} `['\nont{p\_size\_spec}`]' \opt{: \nont{p\_array\_constraints}}\\
&& \}\ \opt{ \Pwhere{} \ \{\ \nont{p\_array\_posts}\ \}}; \\[4ex]
\end{tabular}

\noindent
We explain the meaning of this syntax in the remainder of this chapter.
All non-terminals not defined in this grammar fragment were
defined previously.
Predicates (\nont{predicate}) are described in \secref{sec:common-predicates}.
\padsl{} types (\nont{p\_ty}) and formal parameters (\nont{p\_formals})
are described in \secref{sec:common-parameterization}.
\padsl{} expressions \nont{p\_expressions} are defined in \secref{sec:regular-expressions}.
Literals (\nont{p\_literal})  are described in
\secref{sec:common-literals}.
Expressions (\nont{expression}) represent any \C{} expression.
We put single quotation marks around the left and right brackets to
indicate they appear in the grammer, rather than as a meta-notation
for optionality.


\begin{verbatim}
Parray name ( param list ){
 basetype sizespec : [sep == char] && [term == char] && semantic constraint
}
sizespec 
  []  : unbounded
  [n] : exactly size n
  [low:high] : at least low, at most high
  [low:] : at least low, no upper bound
  [:high] : at most high, no lower bound
optional separation specifier
optional termination specifier

semantic constraints

name.length in scope after array

Parray recList(a_uint32 h, int x, int size) {
  test(:h,x:) [size] : forall i in [0 .. length - 2]
       { recList[i].id < recList[i+1].id };
};
\end{verbatim}

\section{termination conditions}
reach upper limit on size, reach terminator, reach end-of-file, 
not: violate constraint on individual element. (perhaps this should be
choosable by programmer?)


\section{common idiom}
struct with length followed by parameterized array.


\section{Generated library}
\subsection{In-memory representation}
\label{sec:arrays-rep}
\subsection{Mask}
\label{sec:arrays-masks}
\subsection{Parse descriptor}
\label{sec:arrays-parse-descriptors}
\subsection{Operations}
init/cleanup rep
init/cleanup ed
\subsubsection{read}
  error codes
\subsubsection{Accumulator functions}

