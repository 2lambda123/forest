\chapter{Ptypedefs}
\label{chap:typedefs}
\cutname{typedefs.html}
\ptypedef{}s allow additional constraints to be added to an existing type.

\section{Syntax}
\begin{tabular}{rcl}
\nont{typedef\_predicates} & \is{}  & identifier identifier \cd{=>} \{ \nont{predicate} \}\\
\nont{typedef\_ty}    & \is{} & \Ptypedef{} \nont{p\_ty} identifier \opt{\nont{p\_formals}} \opt{\cd{:} \nont{typedef\_predicates}};\\[4ex]
\end{tabular}

\noindent
We explain the meaning of this syntax in the remainder of this chapter.
All non-terminals not defined in this grammar fragment were
defined previously, as follows.
Predicates (\term{predicate}) are defined in \secref{sec:common-predicates},
\padsl{} types (\nont{p\_ty}) and parameter lists (\nont{p\_formals})
in \secref{sec:common-parameterization}. 

\subsection{Examples}
\Ptypedef{} predicates (\nont{typedef\_predicates}) are written over a variable bound to the
in-memory representation of the base type of the \Ptypedef{}.
For example, the declaration
\inputCode{code/simple-typedef}
defines a new type \cd{bid_t} to be a \cd{Puint32} with the additional
constraint that any legal bid must be greater than 100.  We read
this constraint ``If \cd{x} is a \cd{bid_t}, then \cd{x} must be
greater than 100.''  In the body of the constraint, the variable
\cd{x} has type \cd{bid\_t}, the in-memory represention type of the \Ptypedef{}.

Like all other \pads{} types, \Ptypedef{}s can be parameterized.  The declaration
\inputCode{code/parameterized-typedef}
introduces a new type \cd{pn_t}.  The base type for this declaration
is a 64-bit unsigned integer, represented in the source as a sequence of
\cd{len} ASCII digits.  The declaration adds the constraint
that any \cd{pn_t} must have a value less than \cd{hi}.  In general,
the constraint can be any integer-valued expression.


\section{Generated library}
We will use the \cd{bid\_t} example to illustrate the data structures
and functions generated for \ptypedef{}s.

\subsection{In-memory representation}
\label{sec:typedefs-rep}
The in-memory representation of a \ptypedef{} is the same as the
representation of the underlying base type:

\inputCode{code/typedef.TypedefRep}

\subsection{Mask}
\label{sec:typedefs-masks}
The mask for a \Ptypedef{} is a \C{} struct containing a pair of masks.  The
\cd{base} field stores a mask of the base mask type.  This
mask specifies how to handle the underlying type.  The
\cd{user} mask allows the user to toggle behavior at the level
of the \Ptypedef{} as a whole.  For example, during parsing, the
\cd{base} mask lets the user control constraint checking of the
base type, while the
\cd{user} mask lets the user control checking the constraint
associated with the \Ptypedef{} itself.

\inputCode{code/typedef.TypedefCSM}

\subsection{Parse descriptor}
\label{sec:typedefs-parse-descriptors}
The parse descriptor for a \Ptypedef{} is the same as the parse
descriptor for the underlying base type.
\inputCode{code/typedef.TypedefPD}

\subsection{Operations}
The operations generated by the \pads{} compiler for a \Ptypedef{} are
those described in \chapref{chap:common-features}.
The operations appear in \figref{figure:typedef-ops}
\begin{figure}
\inputCode{code/typedef.TypedefOps}
\caption{Prototypes of operations generated for
  the \Ptypedef{} \texttt{bit\_t}.}
\label{figure:typedef-ops}
\end{figure}


\subsubsection{Read function}
The error codes for \Ptypedef{}s are:

\tskip{}
\begin{center}
\begin{tabular}{l|p{4in}}
Code                           & Meaning \\ \hline
 \cd{P_NO_ERR}                 & Indicates no error occurred\\[1ex]
 \cd{P_TYPEDEF_CONSTRAINT_ERR} & Indicates that the typedef constraint failed.\\[1ex]
\end{tabular}
\end{center}

\noindent

\subsubsection{Accumulator functions}
Accumulator functions for \Ptypedef{}s are described in
\chapref{chap:accumulators}. 
