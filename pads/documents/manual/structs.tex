\chapter{Pstructs}
\label{chap:structs}
\Pstruct{}s are used to describe sequences of values with
potentially unrelated types.  Intuitively, they correspond to
record-like structures \external ly and \C{}-\cd{structs} in memory.
\section{Syntax}
\label{sec:structs-syntax}
The syntax for \Pstruct{}s is given by the following BNF grammar fragment:
\tskip{}
\begin{tabular}{rcl}
\nont{qualifier}  & \is{} & \Pomit{} \alt{} \Pendian{}\\[1ex]
\nont{qualifiers}  & \is{} & \nont{qualifier} \alt{} \nont{qualifier} \nont{qualifiers}\\[1ex]
\nont{constraint} & \is{} & : \nont{predicate}\\[1ex]
\nont{full\_field} & \is{} & \opt{\nont{qualifiers}}
     \nont{p\_ty} \opt{\nont{p\_actual\_list}} identifier 
       \opt{\nont{constraint}}; \opt{\nont{p\_comment}} \\[1ex]
\nont{literal\_field} & \is{} & \term{char\_lit}; \alt{} \term{str\_lit};\\[1ex]
\nont{comp\_field} & \is{} & \Pcompute{} \nont{c\_ty} identifier \cd{=} \nont{expression};\\[1ex]
\nont{field} & \is{} & \nont{full\_field} \alt{} \nont{literal\_field}  \alt{} \nont{comp\_field}\\[1ex]
\nont{fields} & \is{} & \nont{field} \alt{} \nont{field} \ \nont{fields}\\[1ex]
\nont{struct\_ty} & \is{} &  \Pstruct{} identifier \opt{\nont{formals}} \{\\
&& \quad \nont{fields}\\
&& \}\ \opt{ \Pwhere{} \ \{\ \nont{predicate}\ \}}; \\[4ex]
\end{tabular}

\noindent
We explain the meaning of this syntax in the remainder of this chapter.
All non-terminals not defined in this grammar fragment were
defined previously.
Predicates (\nont{predicate}) are described in \secref{sec:common-predicates}.
Actual (\nont{p\_actuals}) and formal (\nont{formals}) parameter lists
are described in \secref{sec:common-parameterization}.
\PADS{} types (\nont{p\_ty}) are listed in \secref{sec:common-overall}.
\PADS{} comments (\nont{p\_comment}) are described in \secref{sec:common-comments}.
Character (\term{char\_lit}) and string (\term{str\_lit}) literals are described in
\secref{sec:common-literals}.
Expressions (\nont{expression}) represent any \C{} expression, 
while \nont{c\_ty} denotes any \C{} type.


\subsection{Example}
The following \Pstruct{} describes the request portion of a
common-log format web-server log, an example of which is:
\begin{center}
\begin{verbatim}
GET /research.att.com/projects/PADS/index.html HTTP/1.0
\end{verbatim}
\end{center}
\input{code/httpRequest}
\noindent
The \Pstruct{} \cd{http\_request\_t} has full fields \cd{meth},
\cd{req\_uri}, and \cd{version} that use the (omitted) auxiliary types
\cd{http_method_t},
\cd{Pstring}, and
\cd{http_v_t} to describe
the HTTP method, URI, and  version formats, respectively.  
It has literal fields \cd{'\\"'} and
\cd{' '} to describe the quotations and spaces in the external
representation. 
The \cd{version} field uses the \C{}
function \cd{checkVersion}:
\input{code/checkVersion}
to ensure that the obsolete HTTP methods
\cd{LINK} and \cd{UNLINK} are only used with HTTP version \cd{1.0}.

\subsection{Full fields}
\label{sec:structs-full-fields}
Each full field in a \Pstruct{} must include the name of the field
and its type.  
The name serves to document the data and to permit later reference.  
The type determines how that piece of the \Pstruct{} will be
processed.  If the field type is parameterized 
(\cf{} \secref{sec:common-parameterization}), the field type must be
followed by appropriate actual parameters, as in the \cd{Pstring} type
of the \cd{req\_uri} field in the \cd{http\_request\_t} example.

Optionally, each full field may be followed by a constraint (\cf{}
\secref{sec:common-predicates}).  Such a constraint is used to express
the conditions under which a properly parsed value of the field type
is a legal value for the field.  The field itself and all earlier
fields in the \Pstruct{} are in scope in the constraint, as are any
parameters to the \Pstruct{}.  As an example, the \cd{checkVersion}
predicate on the \cd{version} field uses the values of the \cd{meth}
and \cd{version} fields to determine if the \cd{version} value is
legal.  If the constraint associated with a field evaluates to false
(\ie{}, zero) after parsing, then the parse descriptor returned with
the in-memory representation will indicate a user-constraint violation
has occurred for the field.

Each full field in a \Pstruct{} may optionally be followed by a \PADSL{}
comment. Such comments are reflected by the \PADS{} compiler into the
output library as comments. 

\subsubsection{Qualifiers}
\label{sec:structs-qualifiers}
Each full field can take one or more qualifiers.
\begin{description}
\item[\Pomit{}] This qualifier indicates that the field
  should not be included in the in-memory representation of the
  \Pstruct{}. 
\item[\Pendian{}] During initialization, the \PADS{} library
  determines the endian-ness of the underlying machine and stores the
  result in the library handle.  Each library handle discipline stores
  the endian-ness of the data being parsed, initially assuming the
  endian-ness of the data matches that of the machine.  The \Pendian{}
  qualifier directs the generated parser to check the endian-ness of
  the data; it can only be used in the presence of a user constraint.
  The qualifier causes the parser to read the field and check the
  associated constraint.  If the constraint is violated, the bytes
  associated with the field are swapped, and the constraint is
  re-tested.  If this second attempt succeeds, the endian-ness of the
  data is toggled in the library discipline.  The value of the data
  endian-ness flag can also be set programmatically (\cf
  \secref{sec:library-customization-endian}).
\end{description}

\subsection{Literal fields}
\label{sec:structs-literal-fields}
Literal fields can either be character or string literals.  They are
written using the notation described in \secref{sec:common-literals}.  

In addition to specifying literals to consume from the external
representation, literal fields also play a role in error recovery.  If
the generated parser encounters a syntactic error while parsing a full
field, causing it to enter panic mode (\cf{}
\secref{sec:common-error-model}), the parser will scan to find the next
literal, marking all intervening fields as errors in the
associated parse descriptor.  The library discipline has parameters
that allow the library user to tune the extent of such scanning
(\cf{} \secref{sec:library-customization-scanning-extent}).

\subsection{Computed fields}
\label{sec:structs-computed-fields}
Instead of being read from the external source, the value of a
computed field is set from an initializing expression.  Such fields
are marked by the \Pcompute{} keyword.  Each such field gives its name
and the \C{} type to be included in the in-memory representation.  It
also gives a \C{} expression that must have the type declared for the
field.  Previously read fields in the \Pstruct{} and any parameters
to the \Pstruct{} are in scope in this expression.

The \cd{computeExample} \Pstruct{} sets the value of its computed
field \cd{index} from the full field \cd{base} and the \cd{offset}
parameter. 

\input{code/struct.computedfield}

\subsection{Optional \texttt{Pwhere} clause}
If given, a \Pwhere{} clause expresses constraints over the entirety
of a \Pstruct{} value.  The values of all previous fields and any
parameters to the \Pstruct{} are in scope.  If the predicate given in
the \Pwhere{} clause evaluates to false (\ie{}, zero), the error code
in the associated parse descriptor will indicate a user-constraint
error has occurred.  

The \Pwhere{} clause in the \cd{whereExample} \Pstruct{} ensures
that the sum of the first two fields is less than the given limit.
\input{code/struct.whereclause}

\section{Generated library}
\subsection{In-memory representation}
\label{sec:structs-rep}
The in-memory representation of a \Pstruct{} is a \C{} struct of the
same name.  Each field of the \C{} struct corresponds to a full or
computed field of the \Pstruct{}.  The type of each full field in
the \C{} struct is the in-memory representation of the \PADSL{} type
associated with the field.  The type of each computed field is 
the given \C{} type. 

The \C{} type \cd{http\_request\_t} is the in-memory representation of
the \PADSL{} type of the same name.
\input{code/ai.httpRequestRep}
The type \cd{PDC\_string} is the in-memory representation of the base
type \cd{Pstring} (\cf{} \chapref{chap:base-types}).  Note that literal fields
do not appear in the in-memory representation. 

\subsection{Mask}
\label{sec:structs-masks}
The mask of a \Pstruct{} with name \cd{myStruct} is a \C{} struct 
with name \csmSuf{\cd myStruct}.  For each full field in
\cd{myStruct}, there is a corresponding field in the mask struct, the
type of which is the mask type for
the field.  In addition, there is a 
\cd{structLevel} field, which has the base mask type.  This field allows
library users to toggle operations at the level of the structure as a
whole. 

For example, the mask type \csmSuf{http\_request\_t} has the
following structure:
\input{code/ai.httpRequestCSM}

\subsection{Parse descriptor}
\label{sec:structs-parse-descriptors}
The parse descriptor of a \Pstruct{} with name \cd{myStruct} is a \C{}
struct with name \pdSuf{myStruct}.  This struct has the fields
described in \secref{sec:common-parse-descriptor}. In addition, for
each full field in \cd{myStruct}, there is a corresponding field in
the parse descriptor struct, the type of which is the parse descriptor
type for the field.

For example, the parse descriptor type \pdSuf{http\_request\_t} has
the following structure:
\input{code/ai.httpRequestPD}
\subsection{Operations}
The operations generated by the \pads{} compiler for a \Pstruct{} are
those described in \chapref{chap:common-features}.  For the \Pstruct{}
\cd{http\_request\_t}, the prototypes of the generated functions are:
\input{code/ai.httpRequestOps}

\subsubsection{Read function}
The error codes for \Pstruct{}s are:

\tskip{}
\begin{tabular}{lp{4in}}
 \cd{PDC_NO\_ERR}                 & Indicates no error occurred\\[1ex]
 \cd{PDC_STRUCT_FIELD_ERR}        & Indicates
                                    that an error occurred during
                                    parsing one of the full fields of
                                    the \Pstruct{}. The parse
                                    descriptor for each full field with an
                                    error will contain more
                                    information describing the precise
                                    nature of the error.\\[1ex]
 \cd{PDC_STRUCT_EXTRA_BEFORE_SEP} & Indicates that there were
                                    unexpected data before a 
                                    literal field in the \Pstruct{}.\\[1ex]
\cd{PDC_MISSING_LITERAL}          & Indicates that the read function
                                    failed to find a literal field\\[1ex]

\end{tabular}

\noindent
If multiple errors occur during the parsing of a \Pstruct{}, the
\cd{errCode} field will reflect the first detected error.  The parse
descriptors for nested pieces will describe any errors detected while
reading those pieces.

\warning{At the moment, read functions do not check that all
referenced data in constraint expressions are meaningful before
checking the constraint.  Referenced data might be meaningless either
because there was an error parsing earlier data or because the
supplied mask directed the read function to skip the field.}

\subsubsection{Accumulator functions}
Accumulator functions for \Pstruct{}s are described in
\chapref{chap:accumulators}. 
