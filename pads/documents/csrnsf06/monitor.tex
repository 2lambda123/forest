\begin{figure}[t]
\begin{center}
\centerline{\psfig{file=codeen_screen2.ps,width=5in}}
\end{center}
\caption{\label{fig_codeenmon}Screenshot of the CoDeeN monitoring
system, which is the model for our PADS-based system. Rows are
PlanetLab nodes, and most columns contain two data values, with the
column headings indicating the metrics being displayed. The bottom of
the window shows a 2-day history of any cell value. Other windows can
show histories on all nodes for a given metric, or histories of all
metrics for a given node.}
\end{figure}

To harness the power of PADS and make it easy to use for a variety of
system monitoring tasks, we will implement a generic monitoring
framework capable of scaling from monitoring single feeds at a single
location to monitoring data on thousands of machines in distributed
environments. This framework will consist of the following components:

\begin{enumerate}

\item {\bf Fetch} grab the data from one or more sources, in parallel if
needed, and perform whatever aggregation is necessary to begin parsing
the data. While this step may be application-specific, many
applications will use either TCP or UDP combined with a
request/response mechanism. By providing some example code for common
formats, such as HTTP/HTTPS, FTP/SFTP, SCP, SNMP, etc., we can reduce
or eliminate this portion of the ``buy-in'' cost for using our system.
While basic parameterization support will be included, this portion
will obviously be extensible, so that developers can customize it if
needed.

\item {\bf Display} once we have the raw data for one or more systems, we
can use the PADS descriptions to extract and appropriately format the
data for display. We will use HTML tables so that the data can be
viewed and manipulated interactively in Web browsers, but will also
support other export formats, such as plain text, CSV (comma-separated
values), tab-delimited format, and, where appropriate, XML
output. Using tables, we can devote one or more rows for each sensor,
machine, or instance, and show multiple data items as columns. In
cases where aggregate representations are appropriate, such as showing
sub-clusters, or multiple machines at a site, we can also show
composite information to summarize more information in the available
screen real estate. Since PADS can also automatically maintain
statistical information about the data it gathers, cell values can be
color-coded automatically, if no additional input is provided by the
developers.

\item {\bf Query} using the type information from the PADS description,
provide a mechanism where rows can be selected from the table based on
their contents. Users would be able to provide logical and arithmetic
expressions that could be evaluated using the per-row data, with the
selected rows being shown in the table format, or outputted to one of
the other formats mentioned above. This kind of support can be used to
easily identify sensors/machines behaving strangely, which need some
attention, or have situations of interest. For example, in a Grid
environment, when deploying a new experiment, it may be useful to
select the nodes with lower-than-average utilization.

\item {\bf Archive} the data fetched from the machines can be archived
along the with the description to process it. In this way, the data is
self-documenting, and can be accessed in the future using the same
tools as current data. The same support for viewing, querying, etc.,
can be applied to older data, allowing users to easily explore
behaviors over time. Given a reasonably robust description of the data
along with statistical information generated by PADS, it should also
be possible to optimize the on-disk format such that heavily-accessed
data is processed and cached in a post-processed, indexed form, even
if all of the data is stored in a raw format. This optimization can be
transparent to the developer and the users of the tools.

\end{enumerate}

What makes these tasks especially attractive in our context is that
they can be almost entirely automated given a well-formed data
description, making an interactive monitoring tool almost free, given
that the developer provides only slightly more information than is
necessary for parsing. Some of the extra information is entirely
presentational, such as the names used for displaying column headings
on data fields.

To get a sense of how this monitoring system can work, a screenshot of
the custom-built monitor for the CoDeeN content-distribution network
is shown in Figure~\ref{fig_codeenmon}. The entire process was
time-consuming and manual -- the display format and headings for each
row was manually specified, as was the sorting logic. The display
logic for each line was also manually written, to hide irrelevant
fields when nodes are dead or unreachable. Despite the fact that it
was developed for a specific project, it was widely used as a
general-purpose monitoring system for PlanetLab itself. Our proposal
will make generating such systems trivial, and will exploit
optimization opportunities that are time-consuming in
manually-generated systems. More importantly, as the data format
evolves, not only will the monitoring system automatically adapt, but
the archived data will still be available to the monitor, without
requiring multiple versions of the monitoring code for different points
in time.
