\section{The Semantics of Polymorphic Types}
\label{sec:ddc}

{\em Should we use a different meta-variable for fomega contexts given
  that they contain both types and variables?}
{\em Modify a\_pd to a\_pd\_body, everywhere. This name is more
  appropriate.  Note that the new scheme for translating type
  variables will affect WF rules. a will be in D but a\_rep and
  a\_pd\_body could appear in a sigma

  Consider a new convention: for compute type, any references to type
  interepretations should be done with the type interpretation
  functions rather than being hard coded. Otherwise, type substitution gets
  messed up,e.g., when unfolding a recursive type. 
  For example, should be compute(e:[a]\_rep) instead of
  compute(e:a\_rep). Then, substitution on DDC types will burrow into
  the type annotation $\gs$ of compute types. To support, need new
  syntax for type annotations $\gs$ and need to explicitly translate
  annotation types into F-omega types.
  
}

\begin{itemize}
\item Review of DDC.
\item Discussions of extensions.
\item Relationship between host language and F-omega(i.e. \fomega
  with following changes).
\item Theory overview and Description of how judgements change from POPL.
\item Describe simplification to theory/meta-theory of recursive types
  and relationship to poly types.
\item Example from pads/ml
  shown in DDC. (name-value pairs?)
\item Meta-theory.
\end{itemize}

\subsection{\ddc{} Syntax}
\begin{figure}
{\small
\begin{bnf}
  \name{Kinds} \meta{\gk} \::= \kty \| \ity \-> \gk 
                               \| \kty \-> \gk \\
  \name{Types} \meta{\ty} \::= 
    \ptrue\| \pfalse \| \pbase{e} \| 
    \plam{\var}{\ity}{\ty} \| \papp{\ty}{e} \nlalt
    \psig x \ty \ty \| \psum \ty e \ty \| \pand \ty \ty \|
    \pset x \ty e \| \pseq \ty \ty {\pterm e \ty} \nlalt
    \ptyvar       \| \pmu{\ptyvar}{\gk}{\ty} \| \ptylam{\ptyvar}{\kty}{\ty} \| \ptyapp{\ty}{\ty}
    \nlalt \pcompute e \ity \| \pabsorb \ty \| \pscan{\ty}  
\end{bnf}
}
\caption{\ddc{} Syntax}
\label{fig:ddc-syntax}
\end{figure}

In previous work, Fisher et. al specified a low-level data description
language \ddcold{} intended to capture the core features of many existing
and future data description langauges~\cite{fisher+:next700ddl}.
Syntactically, \ddcold{} is a calculus of dependent types extended
with a number of type constructors specific to the domain of data
description. Semantically, however, rather than describing the
properties of expressions, \ddcold{} types describe data sources. The
base types describe atomic fragments of data, while the type
constructors capture complex structures within a source.

While \ddcold{} was intended as a general-purpose low-level
description language, one of the essential novelties of the \padsml{}
language -- support for \textit{polymorphic types}, or user-defined
type constructors parameterized by types, cannot be expressed in
\ddcold{}.  Therefore, we extend \ddcold{} with support for
polymorphic types to enable reasoning about the semantics of \padsml{}
and any future description language with similar features.

Specifically, we capture the semantics of polymorphic types by
extending \ddcold{} with type-parameterized types
$\ptylam{\ptyvar}{\kty}{\ty}$ and type-type application
$\ptyapp{\ty}{\ty}$. We refer to the extended calculus as \ddc{}. Its
syntax is shown in \figref{fig:ddc-syntax}.

\subsection{\Implang{} Language}
\label{sec:host-lang}
\begin{figure}[tp]
\small
\begin{bnf}
%   \name{Variables} \meta{f,x,y} \\
%   \name{Bit}   \meta{b}   \::= 0 \| 1 \\ 
  \name{Bits}  \meta{B}   \::= \cdot \| 0\,B \| 1\,B \\ 
  \name{Constants} \meta{c} \::=
      () \| \itrue \| \ifalse \| 0 \| 1 \| -1 \| \dots \nlalt
      \ierr \| \data \| \off \| \iok \| \iecerr \| \iecpc \| \ldots \\

  \name{Values} \meta{v} \::= 
      \const \| % \ilam{\nrm \var}{\ity}{e} \| 
      \ifun {\nrm f} {\nrm x} e \| \ipair v v \nlalt
      \iinld{\ity}{v} \| \iinrd{\ity}{v} \|
      \iarr{\vec{v}} \\

  \name{Operators} \meta{op} \::= 
      = \; \| \; < \; \| \inotop % \| \isizeofop
      \| \ldots \\

  \name{Expressions} \meta{e} \::= 
      \const \| \var \| \iop{e} \|
%      \ilam {\nrm \var} \ity e \| 
      \ifun {\nrm f} {\nrm x} e \| 
      \iapp e e \nlalt
    \Lambda \alpha.e \| e \; [\ty] \nlalt
%      \iletfun {\nrm f} {\nrm x} e \; \iin \; e' \| 
      \ilet {\nrm x} e \; e \|
      \iif e \; \ithen e \; \ielse e \nlalt
      \ipair{e}{e} \| \ipi {\nrm i}{e} \|
      \iinld{\ity}{e} \| \iinrd{\ity}{e} \nlalt
      \icaseg{e}{\nrm x}{e}{\nrm x}{e} \nlalt
      \iarr{\vec e} \| \iappend e e \| \isub e {\nrm e} \nlalt
      \iroll{e}{\mu\alpha.\tau} \| \iunroll{e}
      \\
      
  \name{Base Types} \meta{a} \::= 
      \iunitty \| \iboolty \| \iintty  \| 
      \invty \nlalt  \ibitsty \| \ioffty \| \iecty
  \\
  \name{Types} \meta{\ity} \::= 
      \ibasety \| \ityvar \| \iarrow \ity \ity \| \iprod \ity \ity \|
      \isum \ity \ity \nlalt
      \iseq \ity \| \forall \ityvar.\ity  \|
      \imu \ityvar \ity   
      \| \lambda \alpha.\ity 
      \| \ity \; \ity
  \\
  \name{Kinds} \meta{\kappa} \::= \kty \| \kappa \rightarrow \kappa
  
\end{bnf}
\caption{\Implang{} Language: F$^\omega$}
\label{fig:implang-syntax}
\end{figure}

In \figref{fig:implang-syntax}, we present the host language of \ddc{}, an
extension of \fomega. 
We use this host language both to encode the parsing semantics of \ddc{} 
and to write the expressions that can appear within \ddc{} itself. We
will discuss in~\secref{sec:ddc-sem} our choice of \fomega in place
of the polymorphic lamda calculus used in \ddcold{}.

As the host language is largely standard, we highlight only its
unusual features. The constants include bitstrings $\data$; offsets
$\off$, representing locations in bitstrings; and error codes $\iok$,
$\iecerr$, and $\iecpc$, indicating success, success with errors and
failure, respectively. We use the constant $\ierr$ to indicate a
failed parse.  Because of its specific meaning, we forbid its use in
user-supplied expressions appearing in \ddc{} types.
Our expressions include first-class polymorphic functions $\Lambda \alpha.e$ and their
instantiation $e \; [\ty]$. Unlike \fomega, we do not include kind
annotations on type parameters, as we only use parameterization over
types at kind $\kty$. Expressions also include arbitrary length
sequences $\iarr{\vec e}$, sequence append $\iappend e
{e'}$, and sequence indexing $\isub e {\nrm i}$.

The type $\invty$ is the singleton type of the constant $\ierr$.
Types $\iecty$ and $\ioffty$ classify error codes and bit string
offsets, respectively. The remaining types have standard
meanings: function types, product types, sum types, sequence types
$\iseqty \ty$; universal types $\forall \ityvar.\ity$ and type
variables $\ityvar$; recursive types $\imu \ityvar \ity$; and type
constructors $\lambda \alpha.\ity$ and their application $\ity \;
\ity$. Once again, note that universal types and type constructors do
not include kind annotations, for the reason cited above.

We extend the formal syntax with some syntactic sugar 
for use in the rest of the paper: anonymous functions
$\ilam {\nrm x} \ity e$ for $\ifun {\nrm f} {\nrm x} e$, with $f
\not\in {\rm FV}(e)$; function bindings $\iletfun {\nrm f} {\nrm x} e
\; \iin \; e'$ for $\ilet {\nrm f} {\ifun {\nrm f} {\nrm x} e} \; e'$;
$\ispty$ for $\iprod \ioffty \ioffty$.  We often use
pattern-matching syntax for pairs in place of explicit projections, as
in $\lampair{\codefont e}$ and $\ilet {\itup{\off,r,p}} e\; e'$.  Although
we have no formal records with named fields, we use a dot notation for
commonly occuring projections. For example, for a pair $\mathtt x$ of
rep and PD, we use $\codefont{x.rep}$ and $\codefont{x.pd}$ for the
left and right projections of $\codefont{x}$, respectively. Also, sums and products are
right-associative. 

The static semantics ($\stsem[e,{\ctxt},\ity]$) and operational
semantics ($e \stepsto e'$) are those of \fomega extended with
recursion functions and recursive types and are entirely standard.
See, for example, Pierce~\cite{pierce:tapl} for details.

\subsection{\ddc{} Semantics}
\label{sec:ddc-sem}

The primitives of \ddc{} each have three interpretations: two
datatypes in the host language -- one for the data representation
itself and one for its parse descriptor -- and a transformation from
bit strings, including invalid ones, into data and corresponding
meta-data.  We therefore specify the semantics of \ddc{} types using three semantic
functions, each of which precisely conveys a particular facet of a
type's meaning.  The functions $\itsem[\cdot]$ and $\itpdsem[\cdot]$
describe the {\it representation semantics} of \ddc{}, detailing the
types of the data's in-memory representation and parse descriptor. The
function $\trans[\cdot,,]$ describes the {\it parsing semantics} of
\ddc{}, defining a \implang{} language function for each type that
parses bit strings to produce a representation and parse descriptor.

Fisher, et. al~\cite{fisher+:next700ddl} discuss the semantics of
\ddcold{} in detail. We will focus only on those aspects of the
semantics that are new or modified from the original presentation.

\begin{table}
  \begin{center}
    \renewcommand{\arraystretch}{1.35}
    \begin{tabular}{l l}
      $\ddck[\ty,{\pctxt;\ctxt},\kind,\mcon]$ & {\it \ddc{}-type
        kinding}\\
      $\itsem[\ty] = \ity$ & {\it representation types of \ddc{} types}\\
      $\itpdsem[\ty] = \ity$ & {\it pd types of \ddc{} types}\\
      $\trans[\ty,\ctxt,\gk] = e$   & {\it \ddc{}-type semantics} \\
      $\kTrans[\gk,\ty] = \ity$     & {\it parser type} \\
      $\ptyc \pctxt = \ctxt$     & {\it parser-type context }\\
      $\fotyc \pctxt = \ctxt$     & {\it \fomega version of poly. context }\\
      $\fortyc \pctxt = \ctxt$     & {\it Rep. type variables in $\fotyc \pctxt$ }\\
      $\fopdtyc \pctxt = \ctxt$     & {\it PD type variables in $\fotyc \pctxt$ }\\
      $\stsem[e,\ctxt,\ity]$ & {\it \fomega expression typing} \\
    \end{tabular}
    \caption{Translations and Judgments}
    \label{tab:judg-list}
  \end{center}
\end{table}

For reference, we provide in
\tblref{tab:judg-list} a listing of all the functions and judgments
defined in this section and a brief description of each.  


\subsubsection{\ddc{} Kinding}
\label{sec:ddc-kinding}

\begin{figure*}[t]
\small
\fbox{$\ddck[\ty,\pctxt;\ctxt,\kind,\mcon]$}\\[-2ex]
\[
\infer[\text{Unit}]{
    \ddck[\ptrue,\pctxt;\ctxt,\kty,\con]
  }{\wfd {} {\fotyc \pctxt,\ctxt}}
\quad 
\infer[\text{Bottom}]{
    \ddck[\pfalse,\pctxt;\ctxt,\kty,\con]
  }{\wfd {} {\fotyc \pctxt, \ctxt}}
\quad 
\infer[\text{Const}]{
    \ddck[\pbase{e},\pctxt;\ctxt,\kty,\con]
  }{
    \begin{semcond}
      \wfd {} {\fotyc \pctxt,\ctxt} &
      \stsem[e,{\fotyc \pctxt,\ctxt},\ity] \\
      \vlet {\ity \iarrowi \kty} {\Ikind(C)}
    \end{semcond}
  }
\]

\[
\infer[\text{Abs}]{
    \ddck[\plam{\var}{\ity}{\ty},
         \pctxt;\ctxt,\ity \iarrowi \kind,\mcon]
  }{
    \ddck[\ty,\pctxt;\ectxt{\var{:}\ity},\kind,\mcon]
  }
\quad
\infer[\text{App}]{
  \ddck[\papp{\ty}{e},\pctxt;\ctxt,\gk,\mcon]
}{
  \ddck[\ty,\pctxt;\ctxt,\ity \iarrowi \gk,\mcon] &
  \stsem[e,{\fotyc \pctxt,\ctxt},\ity]
}
\]

\[
\infer[\text{Prod}]{
    \ddck[\psig{x}{\ty}{\ty'},\pctxt;\ctxt,\kty,\con]
  }{       
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] &
    \ddck[\ty',\pctxt;
          \ectxt {x{:}\iprod {\itsem[\ty]} 
              {\itpdsem[\ty]}},
          \kty,\mcon']
  }
\]

\[
\infer[\text{Sum}]{
    \ddck[\psum{\ty}{e}{\ty'},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] & \ddck[\ty',\pctxt;\ctxt,\kty,\mcon'] 
  }
\quad
  \infer[\text{Intersection}]{
    \ddck[\pand \ty {\ty'},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] & \ddck[\ty',\pctxt;\ctxt,\kty,\mcon'] 
  }
\]

\[
  \infer[\text{Con}]{
    \ddck[\pset x \ty e,\pctxt;\ctxt,\kty,\con]
  }{ 
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] & 
    \stsem[e,
     {\fotyc \pctxt,
    \ectxt{x{:}\iprod{\itsem[\ty]} 
      {\itpdsem[\ty]}}},\iboolty]
  }
\]

\[\infer[\text{Seq}]{
    \ddck[\pseq \ty {\ty_s} {\pterm e {\ty_t}},\pctxt;\ctxt,\kty,\con]
  }{
    \begin{array}{c}
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] \qquad
    \ddck[{\ty_s},\pctxt;\ctxt,\kty,\mcon_s] \qquad
    \ddck[{\ty_t},\pctxt;\ctxt,\kty,\mcon_t] \\
    \stsem[e,{\fotyc \pctxt,\ctxt},
    \iprod {\itsem[{\ty_m}]}      
    {\itpdsem[{\ty_m}]}
    \iarrowi \iboolty]
    \quad (\ty_m = \pseq \ty {\ty_s} {\pterm e {\ty_t}})
    \end{array}
  }
\]

\[
  \infer[\text{TyVar}]{
    \ddck[\ptyvar,{\pctxt;\ctxt},\kty,\ncon]
  }{\wfd {}{\fotyc \pctxt, \ctxt} \quad \tyvar{:}\kty \in \pctxt}
\quad
  \infer[\text{Rec}]{
    \ddck[\pmu \ptyvar \kty \ty,\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,{\pctxt,\ptyvar{:}\kty;\ctxt},\kty,\con]
  }
\quad
\infer[\text{TyAbs}]{
    \ddck[\ptylam{\tyvar}{\kty}{\ty},
         \pctxt;\ctxt,\kty \iarrowi \kind,\mcon]
  }{
    \ddck[\ty,{\pctxt,\tyvar{:}\kty;\ctxt},\kind,\mcon]
  }
\quad
\infer[\text{TyApp}]{
  \ddck[\ptyapp{\ty_1}{\ty_2},\pctxt;\ctxt,\gk,\mcon]
}{
  \ddck[\ty_1,\pctxt;\ctxt,\kty \iarrowi \gk,\mcon] &
  \ddck[\ty_2,\pctxt;\ctxt,\kty,\mcon]
}
\]



\[
  \infer[\text{Compute}]{       
    \ddck[\pcompute{e}{\ity},\pctxt;\ctxt,\kty,\con]
  }{
    \wfd {}{\fotyc \pctxt, \ctxt} &
    \stsem[e,{\fotyc \pctxt,\ctxt},\ity] & 
    \fomegak{\fortyc \pctxt}{\ity}{\kty}
  }      
\quad
\infer[\text{Absorb}]{
    \ddck[\pabsorb{\ty},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon]
  }
\quad
  \infer[\text{Scan}]{
    \ddck[\pscan{\ty},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon]
  }
\]
\caption{\ddc{} Kinding Rules}
\label{fig:ddc-kinding}
\end{figure*}

The kinding judgment defined in \figref{fig:ddc-kinding} determines
well-formed \ddc{} types, assigning kind $\kty$ to basic types and
kind $\ity \iarrowi \kind$ to type abstractions.  We use two contexts to express our kinding judgment:
\[
\begin{array}{ll}
\ctxt  & \mathrel{::=} \cdot \bnfalt \ctxt,{\var{:}\ity}\\
\pctxt  & \mathrel{::=} \cdot \bnfalt \pctxt,\tyvar{:}\kty
\end{array}
\]

Context $\Gamma$ is a finite partial map that binds expression
variables to their types.
Context $\pctxt$ is a finite partial map that binds type
variables to their kinds. We provide the following translations from
type contexts $\pctxt$ to \fomega type-and-variable contexts $\ctxt$.

\[
\begin{array}{ll}
\fortyc {(\cdot)} &= \cdot \\
\fortyc {(\pctxt,\ptyvar{:}\kty)} &= \fortyc \pctxt, \ptyvar_\repname
{\mathrel{::}} \kty \\
\fopdtyc {(\cdot)} &= \cdot \\
\fopdtyc {(\pctxt,\ptyvar{:}\kty)} &= \fopdtyc \pctxt, \ptyvar_\pdbname
{\mathrel{::}} \kty \\
\fotyc \pctxt &= \fortyc \pctxt, \fopdtyc \pctxt
\end{array}
\]

The translation $\fortyc \pctxt$ ($\fopdtyc \pctxt$ ) maps type variables of \ddc{} to the
corresponding representation-type (parse descriptor-type) variables in
\fomega. Translation $\fotyc \pctxt$ is simply a combination of the
two.  These translations are used when checking the well-formedness of
contexts $\ctxt$ with open type variables.

An essential difference in the kinding rules between \ddcold{} and
\ddc{} is that we replace the context $M$ of \ddcold{}, which mapped
recursive-type variables to their definitions, with a simpler context
$\pctxt$ which merely assigns a kind (always $\kty$) to open type
variables. Recursive-type variables are now treated as abstract, just
like the type variables arising from type abstractions.
Correspondingly, the rule for type variables (TyVar) now has an
entirely standard form, and the premise of rule of recursive types
(Rec) is now identical to the premise of rule for type abstractions
(TyAbs). The rule for type application (TyApp) is almost standard,
except that parameters are restricted to having kind $\kty$. Finally,
with the introduction of potentially open \implang types, we now check
that $\ity$ in rule Compute is closed with respect to any types but
the representation type variables corresponding to $\pctxt$.

\subsubsection{Representation Semantics}
\label{sec:intty-sem}

\begin{figure}
\fbox{$\itsem[\ty] = \ity$}
\[
\begin{array}{lcl} 
\itsem[\ptrue] & = & \iunitty \\
\itsem[\pfalse] & = & \invty \\
\itsem[\pbase{e}] & = & \isum {\Irty(C)} \invty   \\
\itsem[\plam{\var}{\ity}{\ty}] & = & \itsem[\ty] \\
\itsem[\papp \ty e] & = & \itsem[\ty] \\
\itsem[\psig \var {\ty_1} {\ty_2}]  & = & \iprod {\itsem[\ty_1]} {\itsem[\ty_2]}    \\
\itsem[\psum {\ty_1} e {\ty_2}]     & = & \isum {\itsem[\ty_1]} {\itsem[\ty_2]} \\
\itsem[\pand {\ty_1} {\ty_2}]  & = & \iprod {\itsem[\ty_1]}{\itsem[\ty_2]}\\
\itsem[\pset x \ty e] & = & \isum {\itsem[\ty]}{\itsem[\ty]}\\
% field names: length, elts
\itsem[\pseq \ty {\ty_{\text{sep}}} {\pterm e {\ty_{\text{term}}}}] & = & 
    \iprod \iintty {(\iseq{\itsem[\ty]})}             \\
%% \itsem[\pcase e c {\ty_1} {\ty_2}]       & = & \isum {\itsem[\ty_1]} {\itsem[\ty_2]}\\
\itsem[\ptyvar] & = & \ptyvar_\repname \\
\itsem[\pmu{\ptyvar}{\gk}{\ty}] & = & \imu{\ptyvar_\repname}{\itsem[\ty]} \\
\itsem[\lambda \ptyvar.\ty]       & = & \lambda \ptyvar_\repname.\itsem[\ty] \\
\itsem[\ty_1 \ty_2]              & = & \itsem[\ty_1] \itsem[\ty_2] \\
\itsem[\pcompute e \ity]                 & = & \ity \\
\itsem[\pabsorb \ty]                     & = & \isum \iunitty \invty \\
\itsem[\pscan \ty] & = & \isum {\itsem[\ty]} \invty
%% \pext{
%% \itsem[\ptransform e e \ty]              & = & \itsem[\ty]\\
%% }
\end{array}
\]
\caption{Representation Types}
\label{fig:rep-tys}
\end{figure}

In Figure~\ref{fig:rep-tys}, we present the representation type
of each \ddc{} primitive. While the primitives are
dependent types, the mapping to the \implang{} language erases the dependency because the \implang{} language does not have dependent types. For \ddc{} types in which expressions appear,
the translation drops the expressions to remove the dependency.
With these expressions gone, variables become useless, so we drop 
variable bindings as well, as in product and constrained types.
Similarly, as value-type abstraction and application are only relevant for
dependency, we translate them according to their underlying
types.

Type variables in \ddc{} are mapped into type variables in \fomega{},
although tagged as corresponding to a representation type, to
distinguish from the similarly named variable for the parse-descriptor
type. Recursive types generate recursive representations with the type
variable named appropriately. Polymorphic types and their application become type
constructors and type application, respectively.

\begin{figure}
\fbox{$\itpdsem[\ty] = \ity$}
\[ 
\begin{array}{lcl} 
%% %% example: \ua.(int * a) + None
%% %%          pd = \ua.pd_hdr  * ((pd_hdr * ([int]_pd * [a]_pd)) + [None]_pd)
%% %%             = \ua.pd_hdr  * ((pd_hdr * ([int]_pd * a)) + [None]_pd)
\itpdsem[\ptrue] & = & \ipty \iunitty \\                                                  
\itpdsem[\pfalse] & = & \ipty \iunitty \\                                                  
\itpdsem[\pbase{e}] & = & \ipty \iunitty\\
\itpdsem[\plam \var \ity \ty] & = & \itpdsem[\ty] \\
\itpdsem[\papp \ty e] & = & \itpdsem[\ty] \\
\itpdsem[\psig \var {\ty_1} {\ty_2}] & = & 
               \ipty {\iprod {\itpdsem[\ty_1]} {\itpdsem[\ty_2]}} \\
\itpdsem[\psum {\ty_1} e {\ty_2}] & = & 
               \ipty {(\isum {\itpdsem[\ty_1]} {\itpdsem[\ty_2]})} \\
\itpdsem[\pand {\ty_1} {\ty_2}] & = & \ipty {\iprod {\itpdsem[\ty_1]} {\itpdsem[\ty_2]}}    \\
\itpdsem[\pset x \ty e] & = & \ipty {\itpdsem[\ty]} \\
\itpdsem[\pseq \ty {\ty_{\text{sep}}} {\pterm e {\ty_{\text{term}}}}] & = & 
  \iapty {\itpdsem[\ty]} \\
\itpdsem[\ptyvar] & = & \ipty{\ptyvar_\pdbname} \\
\itpdsem[\pmu \ptyvar \kty \ty] & = & 
  \ipty{\imu{\ptyvar_\pdbname}{\itpdsem[\ty]}} \\
\itpdsem[\lambda \ptyvar.\ty]      
     & = & \lambda \ptyvar_\pdbname.\itpdsem[\ty] \\
\itpdsem[\ty_1 \ty_2]            & = & \itpdsem[\ty_1] \itpdsemstrip[\ty_2] \\
\itpdsem[\pcompute e \ity]            & = & \ipty \iunitty \\
\itpdsem[\pabsorb \ty]                & = & \ipty \iunitty \\
\itpdsem[\pscan{\ty}] & = & \ipty {(\isum {(\iprod \iintty
    {\itpdsem[\ty]})} \iunitty)}
\end{array}
\]

\fbox{$\itpdsemstrip[\ty] = \ity$}

\[
\begin{array}{lcl} 
\itpdsemstrip[\ty] & = & \ity \ \ \mbox{where}\ \itpdsem[\ty] \equiv \ipty{\ity}
\end{array}
\]
\caption{Parse Descriptor Types}
\label{fig:pd-tys}
\end{figure}

In \figref{fig:pd-tys}, we give the parse descriptor
type for each \ddc{} type. Each PD type has a header and body.
This common shape allows us to define functions that polymorphically
process PDs based on their headers. Each header stores the number of
errors encountered during parsing, an error code indicating the degree
of success of the parse -- success, success with errors, or failure --
and the span of data described by the descriptor.  Formally, the type
of the header  ($\tyface{pd\_hdr}$) is $\iintty \iprodi \iecty \iprodi
\ispty$.  Each body consists of subdescriptors corresponding to the
subcomponents of the representation and any type-specific meta-data. For types with neither subcomponents nor special meta-data, we
use $\iunitty$ as the body type.

{\em Discuss new PD types here.}

\begin{figure}
\small
\fbox{$\kTrans[\gk,\ty] = \ity$} 
    
\begin{align*}
  &\kTrans[\kty,\ty] = \extdom * \offdom \iarrowi \offdom * \itsem[\ty] * \itpdsem[\ty]
   \\
   &\kTrans[\ity \iarrowi \gk,\ty] = \ity \iarrowi \kTrans[\gk,\ty e],
   \; \mbox{for any e}.
   \\
   &\kTrans[\kty \iarrowi \gk,\ty] = 
      \forall\tyvar_\repname.\forall\tyvar_\pdbname.
         \kTrans[\kty,\tyvar] \iarrowi \kTrans[\gk,\ty \tyvar]\; 
         (\ptyvar_\repname.\ptyvar_\pdbname \not \in \ftv \kind \cup
         \ftv \ty)
\end{align*}  
  \caption{\Implang{} Language Types for Parsing Functions}
  \label{fig:parser-types}
\end{figure}

\subsubsection{Parsing Semantics of \ddc{}}
\label{sec:parse-sem}

\begin{figure*}
\small
\fbox{$\trans[\ty,\ctxt,\gk] = e$} 

\[
\begin{array}{l}
  %% None 
\trans[\ptrue,\ctxt,\kty] =
  \lampair{\spair<\off,\newrep{unit}{},\newpd{unit}{\off}>}
\\[3pt] %\\
%% False 
\trans[\pfalse,,] =
  \lampair{\spair<\off,\newrep {bottom}{},\newpd {bottom}{\off}>}
\\[3pt] %\\ 
%% Const 
\trans[\pbase{e},\ctxt,\kty] =
  \lampair{\iapp {\iapp {\Iimp(C)} (e)} {\itup {\idata,\off}}}
\\[3pt] %\\
%% Abs 
\trans[\plam{\var}{\ity}{\ty},,] =
   \sfn{\nrm\var}{\ity}{\trans[\ty,\ectxt{\var{:}\ity},\kind]}
\\[3pt] %\\
%% App 
\trans[\papp{\ty}{e},\ctxt,\gk] =
  \trans[\ty,,] \sapp e  
\\[3pt]
%% Prod 
%\begin{array}{l}
\trans[\psig{x}{\ty}{\ty'},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampair{} \\
    \quad  \ilet {\spair<\off',r,p>} 
    {{\trans[\ty,,]} \sapp \spair<\idata,\off>} \\
    \quad  \ilet x {\ictup{r,p}}\\
    \quad  \ilet {\spair<\off'',r',p'>} 
    {{\trans[\ty',,]} \sapp \spair<\idata,\off'>} \\
    \quad \spair<\off'',\newrep {\gS}{r,r'},\newpd {\gS}{p,p'}>
  \end{array}  
%\end{array}
\\
%% Sum 
%\begin{array}{l}
  \trans[\psum{\ty}{e}{\ty'},,] = \\
  \begin{array}{l}  
  \lampair{} \\
  \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
  \quad \iif {\pdok p} \; \ithen {
    \def \r {\newrep {+left}{r}}
    \def \p {\newpd {+left}{p}}
    \spair<\off',\r,\p>} \\
  \quad \ielse {\ilet {\itup{\off',r,p}}{\trans[\ty',,] \sapp \spair<\idata,\off>}} \\
  \quad 
  {  % begin scope
    \def \r {\newrep {+right}{r}}
    \def \p {\newpd {+right}{p}}
    %% 
    \spair<\off',\r,\p>
  }\\ % end scope
  \end{array}
\\
%% Intersection 
  \trans[\pand{\ty}{\ty'},,] = \\
  \begin{array}{l}  
     \lampair{} \\
     \quad \ilet {\itup{\off',r,p}} {\trans[\ty,,] \sapp \spair<\idata,\off>} \\
     \quad \ilet {\itup{\off'',r',p'}} {\trans[\ty',,] \sapp \spair<\idata,\off>} \\
     \quad {\spair<\codefont{max}(\off',\off''),\newrep {\&}{r,r'},\newpd {\&}{p,p'}>}
   \end{array}
\\
%\quad
%% Set 
  \trans[\pset{x}{\ty}{e},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampair{} \\
    \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
    \quad \ilet x {\ictup{r,p}}\\
    \quad \ilet c e \\
    \quad \spair<\off',\newrep {con} {c,r},\newpd {con} {c,p}>
  \end{array}
\\
\end{array}
\begin{array}{l}
%% Array 
\trans[\pseq{\ty}{\ty_s}{\pterm e {\ty_t}},,] = \\
  \begin{array}{l}  
    \lampair{}\\
      \quad \iletfun {isDone}{\itup{\off,r,p}}{\\
        \qquad \ior {\eofpred {\idata,\off}} {e\codefont {\sapp
          \spair<r,p>}} \iori \\
        \qquad \ilet {\itup{\off',r',p'}}{\trans[\ty_t,,] \spair<\idata,\off>}\\
        \qquad \pdok{p'}
      }\\
      \quad \iin \\
      \quad \iletfun {continue} {\itup{\off,\off',r,p}} {\\
        \qquad \iif  {\off = \off' \iori \isdone {\off',r,p}} \; \ithen {\itup{\off',\codefont{r,p}}} \\
        \qquad \ielse {
          \ilet {\itup{\off_s,r_s,p_s}}{\trans[\ty_s,,] \sapp \spair<\idata,\off'>}}\\
        \qquad \ilet {\itup{\off_e,r_e,p_e}}{\trans[\ty,,] \sapp \ictup{\idata,\off_s}}\\
        \qquad \mathtt{continue} \sapp \ictup{
            \off,\off_e,\newrep {seq} {r,r_e}, \newpd {seq} {p, p_s, p_e}
        }}\\
      \quad \iin
   \end{array}\\
  \begin{array}{l}  
      \quad \ilet {\mathtt{r}} {\newrep {seq\_init}{}}\\
      \quad \ilet {\mathtt{p}} {\newpd {seq\_init}{\off}}\\
      \quad \iif {\isdone{\off,r,p}} \; \ithen {\itup{\off,\codefont{r,p}}}\\
      \quad \ielse {\ilet {\itup{\off_e,r_e,p_e}}{\trans[\ty,,] \sapp
          \spair<\idata,\off>}} \\
      \quad \mathtt{continue} \sapp \ictup{\off,\off_e,
        \newrep {seq} {r,r_e}, \newpd {seq} {p, \newpd {unit} \off, p_e}}      
  \end{array}  
\\
%\end{array}
%\quad
%\begin{array}{l}
%% Var
\trans[\ptyvar,,] = \codefont{f_\ptyvar}
\\[3pt]
%% Mu
\trans[\pmu \ptyvar \gk \ty,,] = \\
  \begin{array}{l}
  \ifun {f_\ptyvar} {\itup{\data{:}\ibitsty,\off{:}\ioffty}  
           : \ioffty * \pmu \ptyvar \gk \itsem[\ty] 
                    * (\ipty{\pmu \ptyvar \kty \itpdsem[\ty]}) } {}\\
  \quad \ilet {\itup{\off',r,p}} 
   {\trans[\ty,,] \iappi \ictup{\data,\off}} \\ 
  \qquad \ictup{\off',\iroll{r}{\pmu \ptyvar \gk \itsem[\ty]},
     (p.h,\iroll{p}{\pmu \ptyvar \kty \itpdsem[\ty]})}
%}}
  \end{array}  
\\[3pt]
%% lambda \alpha
\trans[\lambda\tyvar . \ty,,] = %\\
%  \begin{array}{l}
    \Lambda \tyvar_\repname. 
    \Lambda \tyvar_\pdbname. \lambda \codefont{f_\ptyvar}. \trans[\ty,,]
%  \end{array}  
\\
%% t1 t2
\trans[\ty_1 \ty_2,,] = 
    \trans[\ty_1,,]\; [\itsem[\ty_2]]\; [\itpdsemstrip[\ty_2]]\; \trans[\ty_2,,]
\\
%% Compute
\trans[\pcompute e \ity,,] = \\
  \quad \lampair{\itup{\off,\newrep {compute} {\nrm e},\newpd {compute} \off}}
\\[3pt]
%% Absorb
\trans[\pabsorb \ty,,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \ilet {\itup {\off',r,p}} {\trans[\ty,,] \sapp \spair<\idata,\off>}\\
    \quad \itup{\off',\newrep {absorb} p,\newpd {absorb} p}   
  \end{array}  
\\
%% Scan
\trans[\pscan \ty,,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \iletfun {try} {i} {\\
      \qquad \ilet {\itup{\off',r,p}} {\trans[\ty,,] \sapp
        \codefont{\spair<\data,\off + i>}} \\
      \qquad \iif {\pdok p}\; \ithen \\
      \qquad {\ictup{\off',\newrep {scan} r,
        \newpd {scan} {i,p}}}\; \ielse {}\\
      \qquad \iif {\codefont{i = scanMax}}\; \ithen \\
      \qquad {\ictup{\off,\newrep {scan\_err} {},
        \newpd {scan\_err} {\off}}}\; \ielse {}\\
      \qquad \codefont {try \sapp (i+1)}
   }\\
   \quad \iin \sapp \codefont{try \sapp 0} \\
  \end{array}  
\\
\end{array}
\]
%\caption{\ddc{} Semantics (cont.)}
\caption{\ddc{} Semantics}
\label{fig:ddc-sem}
\end{figure*}

\begin{figure}
\small
\begin{itemize}
\renewcommand{\labelitemi}{}

%\item %[Unit:]
\item $\ifun {R_{unit}} \iuval \iuval$
\item $\ifun {P_{unit}} \off {\itup{\itup{0,\iok,\ipair \off \off},\iuval}}$

%\item %[Bottom:]
\item $\ifun {R_{bottom}} \iuval \ierr$
\item $\ifun {P_{bottom}} \off ((1,\iecpc,\ipair \off \off),())$

\item %[Pair:]
\item $\ifun {R_{\gS}} {\ipair {r_1} {r_2}} {\itup {\codefont{r_1,r_2}}}$
\item $\ifun{H_{\gS}} {\ictup{h_1,h_2}}{}$ \\
  $\begin{array}{l}
    \ilet {nerr} {\codefont{pos \itup{{h_1}.{nerr}} + pos \itup{{h_2}.{nerr}}}}\\
    \ilet {ec} {\iif {\codefont{h_2.ec} = \iecpc}\; \ithen {\iecpc}\\
    \quad \ielse {\codefont{max\_ec} \iappi \codefont{h_1.ec} \iappi \codefont{h_2.ec}}} \\
    \ilet {sp} {\ictup{h_1.sp.begin, h_2.sp.end}} \\
    \quad \ictup {nerr,ec,sp}
  \end{array}$

\item $\ifun {P_{\gS}} {\ictup{p_1, p_2}} {\ictup {H_{\gS} \itup{p_1.h,p_2.h},\itup{p_1,p_2}}}$

\end{itemize}
\caption{Selected Constructor Functions. 
The type of PD headers is $\iintty
  \iprodi \iecty \iprodi \ispty$. 
  We refer to the projections using
  dot notation as $\codefont{nerr}$, $\codefont{ec}$ and
  $\codefont{sp}$, respectively. A span is a pair of offsets, referred
  to as $\codefont{begin}$ and $\codefont{end}$, respectively.  The full collection of such constructor functions appears in \appref{app:asst-functions}.}
\label{fig:cons-funs}
%\caption{Constructor Functions (cont.)}
\end{figure}


The parsing semantics of a type $\tau$ (with kind $\kty$) is a
function that transforms some amount of input into a pair of a
representation and a parse descriptor, the types of which are
determined by $\tau$.  \figref{fig:parser-types} specifies the
\implang{} language types of the parsers generated from well-kinded
\ddc{} types.  Note that parameterized \ddc{} types require their
arguments before they can parse any input.

\figref{fig:ddc-sem} shows the parsing semantics function.  For each
type, the input to the corresponding parser is a bit string and an
offset which indicates the point in the bit string at which parsing
should commence.  The output is a new offset, a representation of the
parsed data, and a parse descriptor. As the bit string input is
never modified, it is not returned as an output.  In addition
to specifying how to handle correct data, each function describes how
to transform corrupted bit strings, marking detected errors in
a parse descriptor.

For any type, there are three steps to parsing: parse the
subcomponents of the type (if any), assemble the resultant representation, and
tabulate meta-data based on subcomponent meta-data
(if any).For the sake of clarity, we have factored the latter two
steps into separate representation and PD constructor functions which we define for
each type. For some types, we additionally factor the PD header
construction into a separate function. For example, the representation 
and PD constructors for $\ptrue$ are $\newrepf {unit}$ and $\newpdf
{unit}$, respectively, and the header constructor for products is
${\codefont{H_{\gS}}}$. Selected constructors are shown in
\figref{fig:cons-funs}. We have also factored out some commonly
occuring code into ``built-in'' functions, explained as needed and
defined formally in \appref{app:asst-functions}.

The PD constructors determine the error code and
calculate the error count.  There are three possible error codes:
$\iok$, $\iecerr$, and $\iecpc$, corresponding to the three possible results of a parse: 
it can succeed, parsing the data without errors; it can succeed,
but discover errors in the process; or, it can find an
unrecoverable error and fail.
\trversion{
Note that the the purpose of the $\iecpc$ code is to indicate to any
higher level elements that some form of error recovery is required.
Hence, the whole parse is marked as failed exactly when the parse ends
in failure.}
The error count is determined by subcomponent error counts and any errors associated directly with the type
itself.  
\trversion{
If a subcomponent has errors then the error count is
increased by one; otherwise its not increased at all. We use the
function $\codefont {pos}$, which maps all positive numbers to 1
(leaving zero as is), to assist in calculating the contribution of
subcomponents to the total error count.  Errors at the level of the
element itself - such as constraint violation in constrained types - are
generally counted individually.}

We translate recursive types into
recursive functions with a special
function name corresponding to the name of the 
bound type   variable.
Recursive type variables translate to these special names.

{\em Discuss translation of poly types here.}

\subsection{Meta-theory}
\label{sec:meta-theory}


{\em I think that conditions one and three should be moved to a
  separate specification of simple well-formedness of the
  interfaces. Condition two should stay here.}

\begin{condition}[Conditions on Base-type Interfaces]
  \begin{enumerate}
  \item $\dom {\Ikind} = \dom {\Iimp}$.
  \item If $\Ikind(C) = {\ity \iarrowi \kty}$ then $\Iopty(C) =
    \ioparrow \ity {\kTrans[\kty,\pbase e]}$ (for any $e$).
  \item $\fomegak{}{\Irty(C)}{\kty}$.
    \label{cond:closed-op}
  \end{enumerate}
\end{condition}

\begin{definition}
$\pda \ptyvar = \ipty \ptyvar$
\end{definition}

\begin{lemma}[Types of Constructors]
\label{lem:types-of-constructors}
\begin{itemize}
\item $\newrepf {unit} : \iarrow \iunitty \iunitty$
\item $\newpdf  {unit} : \iarrow \ioffty {\ipty \iunitty}$
\item $\newrepf {bottom} : \iarrow \iunitty \invty$
\item $\newpdf  {bottom} : \iarrow \ioffty {\ipty \iunitty}$
\item $\newrepf {\gS} : \forall \ga,\gb.\iarrow {\iprod \ga \gb} {\iprod \ga \gb}$
\item $\newpdf {\gS} : \forall \ga,\gb. 
  \iarrow {\iprod {\pda \ga} {\pda \gb}}
  {\pda {(\pda \ga \iprodi \pda \gb)}}
$
\item $\newrepf {+left} : \forall \ga.\forall \gb.\iarrow \ga 
                            {\isum \ga \gb}$
\item $\newrepf {+right} : \forall \ga.\forall \gb.\iarrow \gb {\isum \ga \gb}$
\item $\newpdf {+left} : \forall \ga, \gb.\iarrow {\pda \ga} 
  {\ipty {(\isum {\pda \ga}{\pda \gb})}}$
\item $\newpdf {+right} :\forall  \ga, \gb. \iarrow {\pda \gb} 
                            {\ipty {(\isum {\pda \ga} {\pda \gb})}}$
\item $\newrepf {\&} : \forall \ga,\gb.\iarrow {\iprod \ga \gb} {\iprod \ga \gb}$
\item $\newpdf {\&} : 
\forall \ga,\gb.
  \pda \ga \iprodi
  \pda \gb \iarrowi 
         {\ipty {(\pda \ga \iprodi \pda \gb)}}
$.
\item $\newrepf {con} : \forall \ga.\iprod \iboolty \ga 
  \iarrowi {\isum \ga \ga}$
\item $\newpdf {con} :\forall  \ga. \iprod \iboolty \iarrow {\pda \ga} {\ipty {\pda \ga}}$
\item $\newrepf {seq\_init} : \forall \ga.\iarrow \iunitty {\iintty \iprodi \iseq \ga}$
\item $\newpdf {seq\_init} : \forall \ga. \iarrow \ioffty {\iapty {\pda\ga}}$
\item $\newrepf {seq} : \forall \ga.\iarrow
  {(\iintty \iprodi \iseq \ga) \iprodi \ga}
  {\iintty \iprodi \iseq \ga}$
\item $\newpdf {seq} :\forall  {\ga_{elt}},{\ga_{sep}}. 
  (\iapty {\pda {\ga_{elt}}}) \iprodi
  \pda {\ga_{sep}} \iprodi 
  \pda {\ga_{elt}} \iarrowi \\
  \iapty {\pda {\ga_{elt}}}$
\item $\newrepf {compute} : \forall \ga.\iarrow \ga \ga$
\item $\newpdf {compute} : \iarrow \ioffty {\ipty \iunitty}$
\item $\newrepf {absorb} : \forall \ga.\iarrow {\pda \ga} {\isum
    \iunitty \invty}$
\item $\newpdf {absorb} :\forall  \ga. \iarrow {\pda \ga} {\ipty
    \iunitty}$
\item $\newrepf {scan} : \forall \ga.\iarrow \ga {\isum \ga \invty}$
\item $\newpdf {scan} :\forall  \ga. \iarrow {\iprod \iintty {\pda \ga}}
  {\ipty {(\isum {\iprod \iintty {\pda \ga}} \iunitty)}}$
\item $\newrepf {scan\_err} : \forall \ga.\iarrow \iunitty {\isum \ga \invty}$
\item $\newpdf {scan\_err} :\forall  \ga. \iarrow \ioffty
  {\ipty {(\isum {\iprod \iintty \ga} \iunitty)}}$
\end{itemize}  
\end{lemma}

\begin{proof}
  By typing rules of \fomega.
\end{proof}

To prove our type correctness theorem by induction, we must account
for the fact that any free type variables in
a \ddc{} type $\ty$ will become free function variables
in $\trans[\ty,,]$.  

To that end, we define the function $\ptyc \pctxt$, 
which maps type-variable contexts
$\pctxt$ to typing contexts $\ctxt$:
\vskip -1.5ex
{\small
\[
\begin{array}{l}
  \ptyc{\cdot} = \cdot \\[1ex]
  \ptyc{\pctxt,\ptyvar{:}\kty} = \ptyc \pctxt,\codefont{f_\ptyvar}{:}\kTrans[\kty,\ptyvar]
\end{array}
\]
}

\begin{theorem}[Type Correctness]
\label{thm:type-correctness}
  If $\ddck[\ty,{\pctxt;\ctxt},\gk,{}]$ then
  $\stsem[{\trans[\ty,,]},{\fotyc \pctxt, \ctxt,\ptyc \pctxt},
            {\kTrans[\kind,\ty]}]$.
\end{theorem}

\begin{proof}
  By induction on the height of the kinding derivation.
\end{proof}

\begin{corollary}[Type Correctness of Closed Types]
  If $\ddck[\ty,,\gk,\con]$ then
  $\stsem[{\trans[\ty,,]},,\kTrans[\kind,\ty]]$.  
\end{corollary}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
