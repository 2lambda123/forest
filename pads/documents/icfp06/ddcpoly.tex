\section{The Semantics of Polymorphic Types}
\label{sec:ddc}
{\em Should we use a different meta-variable for fomega contexts given
  that they contain both types and variables?}

\emph{Do we want to show an example from pads/ml shown in DDC.
  (e.g. name-value pairs?). It think it would be nice, but I don't
  know that there is space.  }

\trversion{\em Modify a\_pd to a\_pd\_body, everywhere. This name is more
  appropriate.  Note that the new scheme for translating type
  variables will affect WF rules. a will be in D but a\_rep and
  a\_pd\_body could appear in a sigma

  Consider a new convention: for compute type, any references to type
  interepretations should be done with the type interpretation
  functions rather than being hard coded. Otherwise, type substitution gets
  messed up,e.g., when unfolding a recursive type. 
  For example, should be compute(e:[a]\_rep) instead of
  compute(e:a\_rep). Then, substitution on DDC types will burrow into
  the type annotation $\gs$ of compute types. To support, need new
  syntax for type annotations $\gs$ and need to explicitly translate
  annotation types into F-omega types.
  
}

\padsml{} is a complex language and we wish to explain its semantics
in a clear and concise form. Doing so serves a number of purposes. The
process of specifying the semantics forces us to crystallize
invariants of our design and implementation and thereby allows us to
(informally) reason more easily about both. Furthermore, a semantics
allows us to reason formally about the system, and even prove
properties that we feel should hold. In addition, the model of the
language that we build provides a convenient setting for experimenting
with the language, because we can add new features and quickly see how
they effect and interact with the existing ones. Finally, perhaps the
most underated value of a semantics is that it allows us to convey the
core ideas of the system to other researchers, language implementers,
and even users.

Previously, we designed a semantic framework for understanding a range
of data description languages and guiding us in developing future
ones~\cite{fisher+:next700ddl}. At the core of this framework is a
low-level data description language \ddcold{}, intended to capture the
essential features used in data description.  Syntactically, \ddcold{}
is a calculus of dependent types extended with a number of type
constructors specific to the domain of data description. Semantically,
however, rather than describing the properties of expressions,
\ddcold{} types describe data sources. The base types describe atomic
fragments of data, while the type constructors capture compound
structures within a source.

We we would like to use \ddcold{} to specify the semantics of
\padsml{}. \emph{Does this sound too negative about the original
  \ddcold{}?}  However, the polymorphic types of \padsml{} cannot be
expressed in \ddcold{}. Therefore, we capture the
semantics of polymorphic types by extending \ddcold{} with type
abstractions $\ptylam{\ptyvar}{\kty}{\ty}$ and type application
$\ptyapp{\ty}{\ty}$. We refer to the extended calculus as \ddc{}.

Note, however, that \padsml{} is not alone. As we discuss in more
detail in our section on related work, there are a number of different
data description languages. Therefore, the utility of \ddc{} is not
limited to explaining \padsml{}, but should be useful for any data
description language with similar features. Indeed, in the remainder
of this section, we focus exclusively on \ddc{}, its syntax,
semantics, and meta-theory and leave the connection to \padsml{}
implicit.

A final note before we begin. The benefits of \ddc{} have not been
hypothetical alone. All of the essential design of polymorphic types
occured within the setting of \ddc{}. With it and \ocaml{} functors,
the implementation of polymophic types in \padsml{} took about a week.

\subsection{\ddc{} Syntax}
\begin{figure}
{\small
\begin{bnf}
  \name{Kinds} \meta{\gk} \::= \kty \| \ity \-> \gk 
                               \| \kty \-> \gk \\
  \name{Types} \meta{\ty} \::= 
    \ptrue\| \pfalse \| \pbase{e} \| 
    \plam{\var}{\ity}{\ty} \| \papp{\ty}{e} \nlalt
    \psig x \ty \ty \| \psum \ty e \ty \|
    \pset x \ty e \nlalt
    \ptyvar \| \pmu{\ptyvar}{\gk}{\ty} \| 
    \ptylam{\ptyvar}{\kty}{\ty} \| \ptyapp{\ty}{\ty} \| ...
\end{bnf}
}
\caption{Selected \ddc{} Syntax}
\label{fig:ddc-syntax}
\end{figure}

The syntax of \ddc{} is shown in \figref{fig:ddc-syntax}.The base
types of \ddc{} include $\ptrue$ and $\pfalse$, describing the empty
data fragment and no data fragment, respectively, and $\pbase{e}$, for
abstract base types parameterized by an expression $e$ from the host
language. Value abstraction and application, $\plam{\var}{\ity}{\ty}$
and $\papp{\ty}{e}$, allow us to parameterize arbitrary types much as
base types are parameterized. The dependent sum type, $\psig x \ty
\ty$, describes a pair of values, where the value of the first element
of the pair can be referenced when describing the second element.
Variation in a data source can be described with the sum type $\psum
\ty e \ty$, which deterministicly describes a data source that either
matches the first type, or does not and matches the second type.
Intersections $\pand \ty \ty$ describe data sources which can be
described in two ways simultaneously. We specify semantic constraints
over a data source with $\pset x \ty e$, which describes any value $x$
that satisfies the description $\ty$ and the predicate $e$. Type
variables $\ptyvar$ are abstract descriptions and are introduced by
recursive types and type abstractions. Recursive types
$\pmu{\ptyvar}{\gk}{\ty}$ describe recursive formats, like lists and
trees. Type abstraction $\ptylam{\ptyvar}{\kty}{\ty}$ and application
$\ptyapp{\ty}{\ty}$ allow us to parameterize types by other types.

\subsection{\Implang{} Language}
\label{sec:host-lang}

The host language of \ddc{} is an extension of \fomega.  We use this
host language both to write the expressions that can appear within
\ddc{} itself and to encode the parsing semantics of \ddc{}.

As the host language is largely standard, we highlight only its
unusual features. The constants include bitstrings $\data$; offsets
$\off$, representing locations in bitstrings; and error codes $\iok$,
$\iecerr$, and $\iecpc$, indicating success, success with errors and
failure, respectively. We use the constant $\ierr$ to indicate a
failed parse.  Because of its specific meaning, we forbid its use in
user-specified expressions appearing in \ddc{} types.

Our base types include the type $\invty$, the singleton type of the
constant $\ierr$, and rypes $\iecty$ and $\ioffty$, which classify
error codes and bit string offsets, respectively.

Unlike \fomega, we do not include kind annotations on the parameters
of type abstractions, type constrcutors or universal types, as we only
use parameterization over types at kind $\kty$.

We extend the formal syntax with some syntactic sugar 
for use in the rest of the paper: anonymous functions
$\ilam {\nrm x} \ity e$ for $\ifun {\nrm f} {\nrm x} e$, with $f
\not\in {\rm FV}(e)$; function bindings $\iletfun {\nrm f} {\nrm x} e
\; \iin \; e'$ for $\ilet {\nrm f} {\ifun {\nrm f} {\nrm x} e} \; e'$;
$\ispty$ for $\iprod \ioffty \ioffty$.  We often use
pattern-matching syntax for pairs in place of explicit projections, as
in $\lampair{\codefont e}$ and $\ilet {\itup{\off,r,p}} e\; e'$.  Although
we have no formal records with named fields, we use a dot notation for
commonly occuring projections. For example, for a pair $\mathtt x$ of
rep and PD, we use $\codefont{x.rep}$ and $\codefont{x.pd}$ for the
left and right projections of $\codefont{x}$, respectively. Also, sums and products are
right-associative.  Finally, we only specify type abstraction (over
terms) and application when we feel it will clarify the
presentation. Otherwise, the polymorphism is implicit.

The static semantics ($\stsem[e,{\ctxt},\ity]$), operational
semantics ($e \stepsto e'$), and type equality ($\ity \equiv \ity'$) are those of \fomega extended with
recursion functions and recursive types and are entirely standard.
See, for example, Pierce's TAPL~\cite{pierce:tapl}.

\subsection{\ddc{} Semantics}
\label{sec:ddc-sem}

The primitives of \ddc{} each have three interpretations: two
datatypes in the host language -- one for the data representation
itself and one for its parse descriptor -- and a transformation from
bit strings, including invalid ones, into data and corresponding
meta-data.  We therefore specify the semantics of \ddc{} types using three semantic
functions, each of which precisely conveys a particular facet of a
type's meaning.  The functions $\itsem[\cdot]$ and $\itpdsem[\cdot]$
describe the {\it representation semantics} of \ddc{}, detailing the
types of the data's in-memory representation and parse descriptor. The
function $\trans[\cdot,,]$ describes the {\it parsing semantics} of
\ddc{}, defining a \implang{} language function for each type that
parses bit strings to produce a representation and parse descriptor.

Fisher, et. al~\cite{fisher+:next700ddl} discuss the semantics of
\ddcold{} in detail. We will focus only on those aspects of the
semantics that are new or modified from the original presentation.

\trversion{
\begin{table}
  \begin{center}
    \renewcommand{\arraystretch}{1.35}
    \begin{tabular}{l l}
      $\ddck[\ty,{\pctxt;\ctxt},\kind,\mcon]$ & {\it \ddc{}-type
        kinding}\\
      $\itsem[\ty] = \ity$ & {\it representation types of \ddc{} types}\\
      $\itpdsem[\ty] = \ity$ & {\it pd types of \ddc{} types}\\
      $\trans[\ty,\ctxt,\gk] = e$   & {\it \ddc{}-type semantics} \\
      $\kTrans[\gk,\ty] = \ity$     & {\it parser type} \\
      $\ptyc \pctxt = \ctxt$     & {\it parser-type context }\\
      $\fotyc \pctxt = \ctxt$     & {\it \fomega version of poly. context }\\
      $\fortyc \pctxt = \ctxt$     & {\it Rep. type variables in $\fotyc \pctxt$ }\\
      $\fopdtyc \pctxt = \ctxt$     & {\it PD type variables in $\fotyc \pctxt$ }\\
      $\stsem[e,\ctxt,\ity]$ & {\it \fomega expression typing} \\
    \end{tabular}
    \caption{Translations and Judgments}
    \label{tab:judg-list}
  \end{center}
\end{table}

For reference, we provide in
\tblref{tab:judg-list} a listing of all the functions and judgments
defined in this section and a brief description of each.  
}

\subsubsection{\ddc{} Kinding}
\label{sec:ddc-kinding}

\begin{figure*}[t]
\small
\fbox{$\ddck[\ty,\pctxt;\ctxt,\kind,\mcon]$}\\[-2ex]
\[
\infer[\text{Unit}]{
    \ddck[\ptrue,\pctxt;\ctxt,\kty,\con]
  }{\wfd {} {\fotyc \pctxt,\ctxt}}
\quad 
\infer[\text{Bottom}]{
    \ddck[\pfalse,\pctxt;\ctxt,\kty,\con]
  }{\wfd {} {\fotyc \pctxt, \ctxt}}
\quad 
\infer[\text{Const}]{
    \ddck[\pbase{e},\pctxt;\ctxt,\kty,\con]
  }{
      \wfd {} {\fotyc \pctxt,\ctxt} &
      \stsem[e,{\fotyc \pctxt,\ctxt},\ity] &
      \Ikind(C) = {\ity \iarrowi \kty}
  }
\]

\[
\infer[\text{Abs}]{
    \ddck[\plam{\var}{\ity}{\ty},
         \pctxt;\ctxt,\ity \iarrowi \kind,\mcon]
  }{
    \ddck[\ty,\pctxt;\ectxt{\var{:}\ity},\kind,\mcon]
  }
\quad
\infer[\text{App}]{
  \ddck[\papp{\ty}{e},\pctxt;\ctxt,\gk,\mcon]
}{
  \ddck[\ty,\pctxt;\ctxt,\ity \iarrowi \gk,\mcon] &
  \stsem[e,{\fotyc \pctxt,\ctxt},\ity]
}
\]

\[
\infer[\text{Prod}]{
    \ddck[\psig{x}{\ty}{\ty'},\pctxt;\ctxt,\kty,\con]
  }{       
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] &
    \ddck[\ty',\pctxt;
          \ectxt {x{:}\iprod {\itsem[\ty]} 
              {\itpdsem[\ty]}},
          \kty,\mcon']
  }
\quad
\infer[\text{Sum}]{
    \ddck[\psum{\ty}{e}{\ty'},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] & \ddck[\ty',\pctxt;\ctxt,\kty,\mcon'] 
  }
\quad
  \infer[\text{Con}]{
    \ddck[\pset x \ty e,\pctxt;\ctxt,\kty,\con]
  }{ 
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] & 
    \stsem[e,
     {\fotyc \pctxt,
    \ectxt{x{:}\iprod{\itsem[\ty]} 
      {\itpdsem[\ty]}}},\iboolty]
  }
\]

\[
  \infer[\text{TyVar}]{
    \ddck[\ptyvar,{\pctxt;\ctxt},\kty,\ncon]
  }{\wfd {}{\fotyc \pctxt, \ctxt} \quad \tyvar{:}\kty \in \pctxt}
\quad
  \infer[\text{Rec}]{
    \ddck[\pmu \ptyvar \kty \ty,\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,{\pctxt,\ptyvar{:}\kty;\ctxt},\kty,\con]
  }
\quad
\infer[\text{TyAbs}]{
    \ddck[\ptylam{\tyvar}{\kty}{\ty},
         \pctxt;\ctxt,\kty \iarrowi \kind,\mcon]
  }{
    \ddck[\ty,{\pctxt,\tyvar{:}\kty;\ctxt},\kind,\mcon]
  }
\quad
\infer[\text{TyApp}]{
  \ddck[\ptyapp{\ty_1}{\ty_2},\pctxt;\ctxt,\gk,\mcon]
}{
  \ddck[\ty_1,\pctxt;\ctxt,\kty \iarrowi \gk,\mcon] &
  \ddck[\ty_2,\pctxt;\ctxt,\kty,\mcon]
}
\]
\caption{Partial listing of \ddc{} kinding rules}
\label{fig:ddc-kinding}
\end{figure*}

The kinding judgment defined in \figref{fig:ddc-kinding} determines
well-formed \ddc{} types, assigning kind $\kty$ to basic types, kinds
$\ity \iarrowi \kind$ to value abstractions, and kinds $\kty \iarrowi
\kind$ to type abstractions. We use two contexts to express our
kinding judgment:
\[
\begin{array}{ll}
\ctxt  & \mathrel{::=} \cdot \bnfalt \ctxt,{\var{:}\ity}\\
\pctxt  & \mathrel{::=} \cdot \bnfalt \pctxt,\tyvar{:}\kty
\end{array}
\]

Context $\Gamma$ is a finite partial map that binds expression
variables to their types.
Context $\pctxt$ is a finite partial map that binds type
variables to their kinds. We provide the following translations from
type contexts $\pctxt$ to \fomega type-and-variable contexts $\ctxt$.

\begin{align*}
\fortyc {\cdot} &= \cdot &
\fortyc {\pctxt,\ptyvar{:}\kty} &= \fortyc \pctxt, \ptyvar_\repname
{\mathrel{::}} \kty \\
\fopdtyc {\cdot} &= \cdot &
\fopdtyc {\pctxt,\ptyvar{:}\kty} &= \fopdtyc \pctxt, \ptyvar_\pdbname
{\mathrel{::}} \kty \\
\fotyc \pctxt =& \fortyc \pctxt, \fopdtyc \pctxt
\end{align*}

The translation $\fortyc \pctxt$ and $\fopdtyc \pctxt$ respectively map type
variables of \ddc{} to the corresponding representation-type and parse
descriptor-type variables in \fomega. Translation
$\fotyc \pctxt$ is simply a combination of the two.  These
translations are used when checking the well-formedness of contexts
$\ctxt$ with open type variables.

An essential difference in the kinding rules between \ddcold{} and
\ddc{} is that we replace the context $M$ of \ddcold{}, which mapped
recursive-type variables to their definitions, with a simpler context
$\pctxt$ which merely assigns a kind (always $\kty$) to open type
variables. Recursive-type variables are now treated as abstract, just
like the type variables arising from type abstractions.
Correspondingly, the rule for type variables (TyVar) now has an
entirely standard form, and the premise of the rule for recursive types
(Rec) is now identical to the premise of the rule for type abstractions
(TyAbs). The rule for type application (TyApp) is almost standard,
except that parameters are restricted to having kind $\kty$. 

\subsubsection{Representation Semantics}
\label{sec:intty-sem}

\begin{figure}
\fbox{$\itsem[\ty] = \ity$}
\[
\begin{array}{lcl} 
\itsem[\ptrue] & = & \iunitty \\
\itsem[\pfalse] & = & \invty \\
\itsem[\pbase{e}] & = & \isum {\Irty(C)} \invty   \\
\itsem[\plam{\var}{\ity}{\ty}] & = & \itsem[\ty] \\
\itsem[\papp \ty e] & = & \itsem[\ty] \\
\itsem[\psig \var {\ty_1} {\ty_2}]  & = & \iprod {\itsem[\ty_1]} {\itsem[\ty_2]}    \\
\itsem[\psum {\ty_1} e {\ty_2}]     & = & \isum {\itsem[\ty_1]} {\itsem[\ty_2]} \\
\itsem[\pset x \ty e] & = & \isum {\itsem[\ty]}{\itsem[\ty]}\\
\itsem[\ptyvar] & = & \ptyvar_\repname \\
\itsem[\pmu{\ptyvar}{\gk}{\ty}] & = & \imu{\ptyvar_\repname}{\itsem[\ty]} \\
\itsem[\lambda \ptyvar.\ty]       & = & \lambda \ptyvar_\repname.\itsem[\ty] \\
\itsem[\ty_1 \ty_2]              & = & \itsem[\ty_1] \itsem[\ty_2] \\
\end{array}
\]
\caption{Partial listing of representation types}
\label{fig:rep-tys}
\end{figure}

In Figure~\ref{fig:rep-tys}, we present the representation type
of each \ddc{} primitive. While the primitives are
dependent types, the mapping to the \implang{} language erases the dependency because the \implang{} language does not have dependent types. For \ddc{} types in which expressions appear,
the translation drops the expressions to remove the dependency.
With these expressions gone, variables become useless, so we drop 
variable bindings as well, as in product and constrained types.
Similarly, as value abstraction and application are only relevant for
dependency, we translate them according to their underlying
types.

Type variables in \ddc{} are mapped into type variables in \fomega{},
although tagged as corresponding to a representation type, to
distinguish from the similarly named variable for the parse-descriptor
type. Recursive types generate recursive representations with the type
variable named appropriately. Polymorphic types and their application become type
constructors and type application, respectively.

\begin{figure}
\fbox{$\itpdsem[\ty] = \ity$}
\[ 
\begin{array}{lcl} 
%% %% example: \ua.(int * a) + None
%% %%          pd = \ua.pd_hdr  * ((pd_hdr * ([int]_pd * [a]_pd)) + [None]_pd)
%% %%             = \ua.pd_hdr  * ((pd_hdr * ([int]_pd * a)) + [None]_pd)
\itpdsem[\ptrue] & = & \ipty \iunitty \\                                                  
\itpdsem[\pfalse] & = & \ipty \iunitty \\                                                  
\itpdsem[\pbase{e}] & = & \ipty \iunitty\\
\itpdsem[\plam \var \ity \ty] & = & \itpdsem[\ty] \\
\itpdsem[\papp \ty e] & = & \itpdsem[\ty] \\
\itpdsem[\psig \var {\ty_1} {\ty_2}] & = & 
               \ipty {\iprod {\itpdsem[\ty_1]} {\itpdsem[\ty_2]}} \\
\itpdsem[\psum {\ty_1} e {\ty_2}] & = & 
               \ipty {(\isum {\itpdsem[\ty_1]} {\itpdsem[\ty_2]})} \\
\itpdsem[\pset x \ty e] & = & \ipty {\itpdsem[\ty]} \\
\itpdsem[\ptyvar] & = & \ipty{\ptyvar_\pdbname} \\
\itpdsem[\pmu \ptyvar \kty \ty] & = & 
  \ipty{\imu{\ptyvar_\pdbname}{\itpdsem[\ty]}} \\
\itpdsem[\lambda \ptyvar.\ty]      
     & = & \lambda \ptyvar_\pdbname.\itpdsem[\ty] \\
\itpdsem[\ty_1 \ty_2]            & = & \itpdsem[\ty_1] \itpdsemstrip[\ty_2] \\
\end{array}
\]

\fbox{$\itpdsemstrip[\ty] = \ity$}

\[
\begin{array}{lcl} 
\itpdsemstrip[\ty] & = & \ity \ \ \mbox{where}\ \itpdsem[\ty] \equiv \ipty{\ity}
\end{array}
\]
\caption{Partial listing of parse-descriptor types}
\label{fig:pd-tys}
\end{figure}

All parse descriptors share a common strucutre, consisting of two
components, a header and a body.  The header reports on a
corresponding representation as a whole. It stores the number of
errors encountered during parsing, an error code indicating the degree
of success of the parse -- success, success with errors, or failure --
and the span of data described by the descriptor.  Formally, the type
of the header ($\tyface{pd\_hdr}$) is $\iintty \iprodi \iecty \iprodi
\ispty$. The body contains parse descriptors for the subcomponents of
the representation. For types without subcomponents, we use $\iunitty$
as the body type.
% For types with base kind, the corresponding parse
% descriptor will always have a header and body. 

In \figref{fig:pd-tys}, we give the types of the parse descriptors
corresponding to each \ddc{} type. The majority of the types shown are
tuples of the type $\tyface{pd\_hdr}$ for the header, and another
host-language type for the body. Note that this majority includes
recursive types, which were not translated in this manner in our
presentation of \ddcold{}. This common shape enables us to write
polymorphic functions that treat parse descriptors in a generic
mannner. Indeed, the parsing semantics of types rely on this
structure, as discussed in \secref{sec:parse-sem}.

The PD types without the common shape are those corresponding to
abstractions and applications. Value abstractions and applications are
translated in an identical manner for PD types as for representation
types.  Type abstractions and applications, however, are translated in
a subtly different manner. As with the rep-type interpretation, type
abstractions correspond to parse decriptor-type constructors in
\fomega. The major difference is that PD-type constructors are
parameterized over the PD \emph{body} type, rather than over the PD
type itself. Correspondingly, type application $\papp {\ty_1}{\ty_2}$ applies
the PD interpretation of $\ty_1$ to the body portion of the PD
interpretation of $\ty2$ (specified formally with the $\itbdsem[\ty]$
function). Similarly, type variables are translated to tuples of a
header and a type variable, rather than to a type variable alone. 

The reason for the parameterization over PD-body types (rather than
parse-descriptor types) in the translation scheme will be
explained in the next section, once we have discussed the parsing
semantics of type abstractions and applications. Note, however, that
an important result of this design is that the PD interpretation is no
longer defined for all types. The problem lies with
the interpretation of type application. It requires that
$\itbdsem[\ty_2]$ be defined, which, in turn, requires that 
$\itpdsem[\ty_2] \equiv \ipty{\ity}$, for some $\ity$. Yet, this
requirement is not by some types; for example, $\lambda \ptyvar.\ty$.

However, in reasoning about the theory, we do not need
$\itpdsem[\cdot]$ to be total. Rather, we only require that it be well
defined for all well-formed types. We prove that this property holds
in \secref{sec:meta-theory}.


\begin{figure}
\small
\fbox{$\kTrans[\gk,\ty] = \ity$} 
    
\begin{align*}
  &\kTrans[\kty,\ty] = \extdom * \offdom \iarrowi \offdom * \itsem[\ty] * \itpdsem[\ty]
   \\
   &\kTrans[\ity \iarrowi \gk,\ty] = \ity \iarrowi \kTrans[\gk,\ty e],
   \; \mbox{for any e}.
   \\
   &\kTrans[\kty \iarrowi \gk,\ty] = 
      \forall\tyvar_\repname.\forall\tyvar_\pdbname.
         \kTrans[\kty,\tyvar] \iarrowi \kTrans[\gk,\ty \tyvar]\; 
         (\ptyvar_\repname.\ptyvar_\pdbname \not \in \ftv \kind \cup
         \ftv \ty)
\end{align*}  
  \caption{\Implang{} Language Types for Parsing Functions}
  \label{fig:parser-types}
\end{figure}

\subsubsection{Parsing Semantics of \ddc{}}
\label{sec:parse-sem}

\begin{figure}
\small
\fbox{$\trans[\ty,\ctxt,\gk] = e$} 

\[
\begin{array}{l}
  %% None 
\trans[\ptrue,\ctxt,\kty] =
  \lampair{\spair<\off,\newrep{unit}{},\newpd{unit}{\off}>}
\\[3pt] %\\
%% False 
\trans[\pfalse,,] =
  \lampair{\spair<\off,\newrep {bottom}{},\newpd {bottom}{\off}>}
\\[3pt] %\\ 
%% Const 
\trans[\pbase{e},\ctxt,\kty] =
  \lampair{\iapp {\iapp {\Iimp(C)} (e)} {\itup {\idata,\off}}}
\\[3pt] %\\
%% Abs 
\trans[\plam{\var}{\ity}{\ty},,] =
   \sfn{\nrm\var}{\ity}{\trans[\ty,\ectxt{\var{:}\ity},\kind]}
\\[3pt] %\\
%% App 
\trans[\papp{\ty}{e},\ctxt,\gk] =
  \trans[\ty,,] \sapp e  
\\[3pt]
%% Prod 
%\begin{array}{l}
\trans[\psig{x}{\ty}{\ty'},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampair{} \\
    \quad  \ilet {\spair<\off',r,p>} 
    {{\trans[\ty,,]} \sapp \spair<\idata,\off>} \\
    \quad  \ilet x {\ictup{r,p}}\\
    \quad  \ilet {\spair<\off'',r',p'>} 
    {{\trans[\ty',,]} \sapp \spair<\idata,\off'>} \\
    \quad \spair<\off'',\newrep {\gS}{r,r'},\newpd {\gS}{p,p'}>
  \end{array}  
%\end{array}
\\[3pt]
%% Sum 
%\begin{array}{l}
  \trans[\psum{\ty}{e}{\ty'},,] = \\
  \begin{array}{l}  
  \lampair{} \\
  \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
  \quad \iif {\pdok p} \; \ithen {
    \def \r {\newrep {+left}{r}}
    \def \p {\newpd {+left}{p}}
    \spair<\off',\r,\p>} \\
  \quad \ielse {\ilet {\itup{\off',r,p}}{\trans[\ty',,] \sapp \spair<\idata,\off>}} \\
  \quad 
  {  % begin scope
    \def \r {\newrep {+right}{r}}
    \def \p {\newpd {+right}{p}}
    %% 
    \spair<\off',\r,\p>
  }\\ % end scope
  \end{array}
\\[3pt]
%\quad
%% Set 
  \trans[\pset{x}{\ty}{e},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampair{} \\
    \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
    \quad \ilet x {\ictup{r,p}}\\
    \quad \ilet c e \\
    \quad \spair<\off',\newrep {con} {c,r},\newpd {con} {c,p}>
  \end{array}
\\[3pt]
%% Var
\trans[\ptyvar,,] = \codefont{f_\ptyvar}
\\[3pt]
%% Mu
\trans[\pmu \ptyvar \gk \ty,,] = \\
  \begin{array}{l}
  \ifun {f_\ptyvar} {\itup{\data,\off} :
    \ioffty * \pmu \ptyvar \gk \itsem[\ty] 
                    * (\ipty{\pmu \ptyvar \kty \itpdsem[\ty]}) } {}\\
  \quad \ilet {\itup{\off',r,p}} 
   {\trans[\ty,,] \iappi \ictup{\data,\off}} \\ 
  \quad \ictup{\off',\iroll{r}{\pmu \ptyvar \gk \itsem[\ty]},
     (p.h,\iroll{p}{\pmu \ptyvar \kty \itpdsem[\ty]})}
%}}
  \end{array}  
\\[3pt]
%% lambda \alpha
\trans[\lambda\tyvar . \ty,,] = %\\
%  \begin{array}{l}
    \Lambda \tyvar_\repname. 
    \Lambda \tyvar_\pdbname. \lambda \codefont{f_\ptyvar}. \trans[\ty,,]
%  \end{array}  
\\[3pt]
%% t1 t2
\trans[\ty_1 \ty_2,,] = 
    \trans[\ty_1,,]\; [\itsem[\ty_2]]\; [\itpdsemstrip[\ty_2]]\; \trans[\ty_2,,]
\\
\end{array}
\]
%\caption{\ddc{} Semantics (cont.)}
\caption{Partial list of \ddc{} parsing semantics}
\label{fig:ddc-sem}
\end{figure}

\begin{figure}
\small
\begin{itemize}
\renewcommand{\labelitemi}{}

%\item %[Unit:]
\item $\ifun {R_{unit}} \iuval \iuval$
\item $\ifun {P_{unit}} \off {\itup{\itup{0,\iok,\ipair \off \off},\iuval}}$

%\item %[Bottom:]
\item $\ifun {R_{bottom}} \iuval \ierr$
\item $\ifun {P_{bottom}} \off ((1,\iecpc,\ipair \off \off),())$

\item %[Pair:]
\item $\ifun {R_{\gS}} {\ipair {r_1} {r_2}} {\itup {\codefont{r_1,r_2}}}$
\item $\ifun{H_{\gS}} {\ictup{h_1,h_2}}{}$ \\
  $\begin{array}{l}
    \ilet {nerr} {\codefont{pos \itup{{h_1}.{nerr}} + pos \itup{{h_2}.{nerr}}}}\\
    \ilet {ec} {\iif {\codefont{h_2.ec} = \iecpc}\; \ithen {\iecpc}\\
    \quad \ielse {\codefont{max\_ec} \iappi \codefont{h_1.ec} \iappi \codefont{h_2.ec}}} \\
    \ilet {sp} {\ictup{h_1.sp.begin, h_2.sp.end}} \\
    \quad \ictup {nerr,ec,sp}
  \end{array}$

\item $\ifun {P_{\gS}} {\ictup{p_1, p_2}} {\ictup {H_{\gS} \itup{p_1.h,p_2.h},\itup{p_1,p_2}}}$

\end{itemize}
\caption{Selected Constructor Functions. 
The type of PD headers is $\iintty
  \iprodi \iecty \iprodi \ispty$. 
  We refer to the projections using
  dot notation as $\codefont{nerr}$, $\codefont{ec}$ and
  $\codefont{sp}$, respectively. A span is a pair of offsets, referred
  to as $\codefont{begin}$ and $\codefont{end}$, respectively.  The full collection of such constructor functions appears in \appref{app:asst-functions}.}
\label{fig:cons-funs}
%\caption{Constructor Functions (cont.)}
\end{figure}


The parsing semantics of a type $\tau$ with kind $\kty$ is a function
that transforms some amount of input into a pair of a representation
and a parse descriptor, the types of which are determined by $\tau$.
The parsing semantics for types with higher kind, then, are functions
to construct parsers, or functions to construct functions to construct parsers,
etc. Formally, \figref{fig:parser-types} specifies the \implang{}
language types of the functions generated from well-kinded \ddc{}
types.

For each (unparameterized) type, the input to the corresponding parser
is a bit string and an offset which indicates the point in the bit
string at which parsing should commence.  The output is a new offset,
a representation of the parsed data, and a parse descriptor. As the
bit string input is never modified, it is not returned as an output.
In addition to specifying how to handle correct data, each function
describes how to transform corrupted bit strings, marking detected
errors in a parse descriptor.

For any type, there are three steps to parsing: parse the
subcomponents of the type (if any), assemble the resultant
representation, and tabulate meta-data based on subcomponent meta-data
(if any). For the sake of clarity, we have factored the latter two
steps into separate representation and PD constructor functions which
we define for each type. For some types, we additionally factor the PD
header construction into a separate function. For example, the
representation and PD constructors for $\ptrue$ are $\newrepf {unit}$
and $\newpdf {unit}$, respectively, and the header constructor for
products is ${\codefont{H_{\gS}}}$. Selected constructors are shown in
\figref{fig:cons-funs}. We have also factored out some commonly
occuring code into ``built-in'' functions, explained as needed and
defined formally in \appref{app:asst-functions}.

The PD constructors determine the error code and calculate the error
count.  There are three possible error codes: $\iok$, $\iecerr$, and
$\iecpc$, corresponding to the three possible results of a parse: it
can succeed, parsing the data without errors; it can succeed, but
discover errors in the process; or, it can find an unrecoverable error
and fail.  The error count is determined by subcomponent error counts
and any errors associated directly with the type itself.

In \figref{fig:ddc-sem}, we specify the parsing semantics of a portion
of \ddc{}. We will explain the interpretations of select types, from
which interpretation of the remaining types may be understood. The
interpretation of dependent sums parses the data with the
interpretation of the first type, and then binds the resulting
representation and PD to $x$, before parsing the data with the
interpretation of the second type. Finally, it bundles together the
results using the appropriate constructor functions.

Type variables translate to an expression variables whose name
corresponds directly to the name of the type variable. These
expression variables are bound in the interpretations of recursive
types and type abstractions. We interpret recursive types as recursive
functions whose corresponds to the name of the recursive type
variable. For clarity, we annotate the recursive function with its
type.

Type abstraction, in essence, is interpreted as a function
over other parsing functions. However, as those parsing functions
could correspond to arbitrary \ddc{} types (of kind $\kty$), the
interpretation must be a polymorphic function, parameterized by the
representation and PD-body type of the of the \ddc{} type parameter.
For clarity, we present this type parameterization explicitly.  Type
application $\papp {\ty_1}{\ty_2}$ simply becomes the application of
the interpretation of $\ty_1$ to the representation, PD, and parsing
interpretations of $\ty_2$.

At this point, we can explain why the PD and parsing interpretations
of type abstraction and application involve the PD-body interpretation
rather than just the PD interpretation. Notice that the constructor
functions for dependent sums (and for many other types as well) are
polymorphic. No matter the types of the subcomponent types $\ty$ and
$\ty'$, we use the same functions $\newrepf \Sigma$ and $\newpdf
\Sigma$. The PD constructor is not fully polymorphic, though, in that
it assumes that the parse descriptors given to it have the familiar PD
shape of header and body.  Therefore, in order to judge the type of
this function, we must be sure that the PD types of the subcomponents
$\ty$ and $\ty'$ satisfy this constraint.

What happens, then, when we have $\ptyvar$ as a subcomponent? We must
ensure that its PD type has the appropriate shape. To do so, we
specify the translation of type variables explicitly as a tuple of
a header and a type variable for the body, rather than simply as a
type variable for the whole PD type. Therefore, all parameterization
related to PD types must be over the PD-body type, rather than the PD
type as a whole.

\subsection{Meta-theory}
\label{sec:meta-theory}

In \secref{sec:intty-sem}, we informally noted that the parse
descriptor-type semantics is only well-defined for well formed types.
The cause of this limitation was that, for type application, we
require that the PD-type of the argument describe a tuple of a PD
header and (arbitrary) body. In the previous section, we explained why
this ``header-body'' shape of parse descriptors is important for the
parsing semantics as well. In general, we require that the PD-type of
all well formed types with base kind either describes such a shape, or
is equivalent to a type that does.  Now, we formally state this
property and then prove that it holds for all well-formed types.
However, before doing so, we must note that we cannot prove this
property alone as it is too weak. Instead, we must state and prove a
stronger property of the theory, and then derive this desired property
from it.  The stronger property is a form of logical relation, defined
below.

\begin{definition}
\begin{itemize}
\item $\hhpred \ty \kty$ iff $\exists\,\ity$ s.t. $\itpdsem[\ty] \equiv
  {\ipty \ity}$.
\item $\hhpred \ty {\kty \iarrowi \kind}$ iff $\exists\,\ity$
  s.t. $\itpdsem[\ty] \equiv \ity$ and whenever $\hhpred
  {\ty'}{\kty}$, we have $\hhpred {\papp \ty {\ty'}}{\kind}$.
\item $\hhpred \ty {\ity \iarrowi \kind}$ iff $\exists\,\ity'$
  s.t. $\itpdsem[\ty] \equiv \ity'$ and $\hhpred{\papp \ty e}{\kind}$ (for any $e$).
\end{itemize}
\end{definition}

We can now prove the following by induction on kinding derivations
(with $\ty[\ty_1/\ptyvar_1,...,\ty_n/\ptyvar_n]$ denoting simultaneous
capture-avoiding substitution defined in the standard way):
\begin{lemma}
   If
   $\ddck[\ty,{\pctxt,\ptyvar_1{:}\kty,...,\ptyvar_n{:}\kty;\ctxt},\kind,{}]$ and $\hhpred {\ty_i} \kty$ then $\hhpred {\ty[\ty_1/\ptyvar_1,...,\ty_n/\ptyvar_n]} \kind$.
\end{lemma}

From this, we can derive our original goals as a corrollary:
\begin{lemma}
  \begin{itemize}
  \item If $\ddck[\ty,\pctxt;\ctxt,\kind,{}]$ then $\exists
     \ity.\itpdsem[\ty] = \ity$.
   \item If $\ddck[\ty,\pctxt;\ctxt,\kty,{}]$ then $\exists
     \ity.\itpdsem[\ty] \equiv \ipty \ity$.
  \end{itemize}
\end{lemma}

With this lemma, we can now present the essential theoretical result
of this paper. The intuitive relationship between the representation
and parsing semantics of \ddc{} is that the former specifies the types
of the data structures returned by the latter. We formalize this
intuitition and prove it correct with a ``type-correctness'' theorem
for well-formed types. A practical implication of this theorem is that
it is sufficient to check data descriptions (i.e. \ddc{} types) for
well-formedness in order to ensure that the generated types and
functions are well formed. This property is sorely lacking in many
common implementation of Lex and YACC, for which users must examine
generated code in order to debug compile-time errors in
specifications.

\trversion{
\begin{definition}
$\pda \ptyvar = \ipty \ptyvar$
\end{definition}

\begin{lemma}[Types of Constructors]
\label{lem:types-of-constructors}
\begin{itemize}
\item $\newrepf {unit} : \iarrow \iunitty \iunitty$
\item $\newpdf  {unit} : \iarrow \ioffty {\ipty \iunitty}$
\item $\newrepf {bottom} : \iarrow \iunitty \invty$
\item $\newpdf  {bottom} : \iarrow \ioffty {\ipty \iunitty}$
\item $\newrepf {\gS} : \forall \ga,\gb.\iarrow {\iprod \ga \gb} {\iprod \ga \gb}$
\item $\newpdf {\gS} : \forall \ga,\gb. 
  \iarrow {\iprod {\pda \ga} {\pda \gb}}
  {\pda {(\pda \ga \iprodi \pda \gb)}}
$
\item $\newrepf {+left} : \forall \ga.\forall \gb.\iarrow \ga 
                            {\isum \ga \gb}$
\item $\newrepf {+right} : \forall \ga.\forall \gb.\iarrow \gb {\isum \ga \gb}$
\item $\newpdf {+left} : \forall \ga, \gb.\iarrow {\pda \ga} 
  {\ipty {(\isum {\pda \ga}{\pda \gb})}}$
\item $\newpdf {+right} :\forall  \ga, \gb. \iarrow {\pda \gb} 
                            {\ipty {(\isum {\pda \ga} {\pda \gb})}}$
\item $\newrepf {\&} : \forall \ga,\gb.\iarrow {\iprod \ga \gb} {\iprod \ga \gb}$
\item $\newpdf {\&} : 
\forall \ga,\gb.
  \pda \ga \iprodi
  \pda \gb \iarrowi 
         {\ipty {(\pda \ga \iprodi \pda \gb)}}
$.
\item $\newrepf {con} : \forall \ga.\iprod \iboolty \ga 
  \iarrowi {\isum \ga \ga}$
\item $\newpdf {con} :\forall  \ga. \iprod \iboolty \iarrow {\pda \ga} {\ipty {\pda \ga}}$
\item $\newrepf {seq\_init} : \forall \ga.\iarrow \iunitty {\iintty \iprodi \iseq \ga}$
\item $\newpdf {seq\_init} : \forall \ga. \iarrow \ioffty {\iapty {\pda\ga}}$
\item $\newrepf {seq} : \forall \ga.\iarrow
  {(\iintty \iprodi \iseq \ga) \iprodi \ga}
  {\iintty \iprodi \iseq \ga}$
\item $\newpdf {seq} :\forall  {\ga_{elt}},{\ga_{sep}}. 
  (\iapty {\pda {\ga_{elt}}}) \iprodi
  \pda {\ga_{sep}} \iprodi 
  \pda {\ga_{elt}} \iarrowi \\
  \iapty {\pda {\ga_{elt}}}$
\item $\newrepf {compute} : \forall \ga.\iarrow \ga \ga$
\item $\newpdf {compute} : \iarrow \ioffty {\ipty \iunitty}$
\item $\newrepf {absorb} : \forall \ga.\iarrow {\pda \ga} {\isum
    \iunitty \invty}$
\item $\newpdf {absorb} :\forall  \ga. \iarrow {\pda \ga} {\ipty
    \iunitty}$
\item $\newrepf {scan} : \forall \ga.\iarrow \ga {\isum \ga \invty}$
\item $\newpdf {scan} :\forall  \ga. \iarrow {\iprod \iintty {\pda \ga}}
  {\ipty {(\isum {\iprod \iintty {\pda \ga}} \iunitty)}}$
\item $\newrepf {scan\_err} : \forall \ga.\iarrow \iunitty {\isum \ga \invty}$
\item $\newpdf {scan\_err} :\forall  \ga. \iarrow \ioffty
  {\ipty {(\isum {\iprod \iintty \ga} \iunitty)}}$
\end{itemize}  
\end{lemma}

\begin{proof}
  By typing rules of \fomega.
\end{proof}
}

We prove the type correctness theorem using a more general induction
hypothesis for open types. This hypothesis must account for the fact
that any free type variables in a \ddc{} type $\ty$ will become free
function variables in $\trans[\ty,,]$. To that end, we define the function $\ptyc \pctxt$, 
which maps type-variable contexts
$\pctxt$ to typing contexts $\ctxt$:
\vskip -1.5ex
{\small
\[
  \ptyc{\cdot} = \cdot \qquad
  \ptyc{\pctxt,\ptyvar{:}\kty} = \ptyc \pctxt,\codefont{f_\ptyvar}{:}\kTrans[\kty,\ptyvar]
\]
}

\begin{lemma}[Type Correctness Lemma]
\label{thm:type-correctness}
  If $\ddck[\ty,{\pctxt;\ctxt},\gk,{}]$ then
  $\stsem[{\trans[\ty,,]},{\fotyc \pctxt, \ctxt,\ptyc \pctxt},
            {\kTrans[\kind,\ty]}]$.
\end{lemma}

\begin{proof}
  By induction on the height of the kinding derivation.
\end{proof}

The type correctness theorem now follows as a direct corrollary of
the above lemma:

\begin{theorem}[Type Correctness of Closed Types]
  If $\ddck[\ty,,\gk,\con]$ then
  $\stsem[{\trans[\ty,,]},,\kTrans[\kind,\ty]]$.  
\end{theorem}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
