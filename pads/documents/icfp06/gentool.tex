\section{The Generic Tool Framework}
\label{sec:gen-tool}

\begin{itemize}
\item show signature of traversal functor.
\item show interface - explain that one module/constructor and base types.
\item constrast records and one other module.
\item x Make it 3 tools: accum, XML, debuger.
\item x Focus on accumulator. describe in more detail.
\item show implementations,  including base types to show how they differ.
\item x then, describe XML, debugger as pretty printers.
\item use ``generic tool'' in consistent way. I like it better than
  tool generator.
\end{itemize}

An essential benefit of \padsml{} is that it can provide the users
with a high return-on-investment for describing their data. While the
generated parser alone is often enough to justify the user's effort,
we aim to increase the return by producing a large suite of data
analysis tools for every data source described in \padsml{}. However,
there is a limit, both in resources and expertise, to the range of
tool generators that we can develop. Indeed, new and interesting data
analysis tools are constantly being developed, and we have no hope of
integrating even a fraction of them into the \padsml{} system
ourselves.

Fortunately, we don't have to. A large class of data analysis tools
share a common data processing method while differing in the details
of how they transform data. These tools traverse the data
representation and parse descriptor in a depth-first, left-to-right
manner, often carrying some auxiliary state.  For each element
visited, they perform some action involving the auxiliary state,
either before, after or between visiting the element's subcomponents.
Often, the most interesting computations occur at the leaves, where
the computation is based on the leaf's type.  

To the experienced functional programmer, these tools essentially
perform a generalized fold over the representation and parse
descriptor, viewed as trees of components. Therefore, we have created
a generic tool framework modeled after \ml{}'s fold: we decouple the
mechanism of data traversal from the operations performed on
individual data items. A format-dependent traversal mechanism is
generated by the \padsml{} compiler. \emph{Generic tools}, which
specify how to process individual data elements, is developed
separately. The two interact through a signature that every generic
tool must match.

Unlike lists, the elements of data representations and PD's do not
have a uniform type. Therefore, the generic tool must provide
different processing functions for different types. The generated
traversal mechanism, which is format specific, can then choose the
correct function to apply to each element of the data. Therefore, the
generic-tool signature specifies a particular collection of types and
functions for every construct in \padsml{}.

The new, generic tool architecture of \padsml{} delivers a number of
benefits over the fixed architecture of \padsc{}. In \padsc{}, all
tools are generated from within the compiler. Therefore, developing a
new tool generator requires understanding and modifying the compiler.
Furthermore, the set of tools to be generated is chosen by the user
when compiling the description.  In \padsml{}, tool generators can be
developed independent of the compiler and they can be developed more
rapidly, as the ``boilerplate'' code to traverse data need not be
replicated for each tool generator. In addition, the user controls
which tools to ``generate'' for a given data format, and the choice
can differ on a program-by-program basis.

\subsection{The Generic-Tool Interface}
\label{sec:gentool-interface}

\begin{figure}
\begin{code}\scriptsize
\kw{module} \kw{type} S = \kw{sig}
  \kw{type} state
  ...
  \kw{module} Record : \kw{sig}
    \kw{type} partial_state
    \kw{val}  init          : (string * state) list -> state
    \kw{val}  start         : state -> Pads.pd_header 
                         -> partial_state
    \kw{val}  project       : state -> string -> state
    \kw{val}  process_field : partial_state -> string
                         -> state -> partial_state
    \kw{val}  finish        : partial_state -> state
  \kw{end}

  \kw{module} Datatype : \kw{sig}
    \kw{type} partial_state
    \kw{val}  init            : unit -> state
    \kw{val}  start           : state -> Pads.pd_header 
                           -> partial_state
    \kw{val}  project         : state -> string -> state option
    \kw{val}  process_variant : partial_state -> string 
                           -> state -> state
  \kw{end}
   ...
\kw{end}
\end{code}
\caption{An excerpt of the generic-tool interface \cd{Generic_tool.S}.}
\label{fig:gentool-interface}
\end{figure}

The generic tool interface specifies a type for abstract state that is
threaded through the traversal, and, for every type constructor in
\padsml{}, a set of types and functions -- grouped together in a
module -- that a generic tool must implement. Every module has an
\cd{init} function to create an initial state object for data
processed by that module. In addition, a \cd{project} function
retrieves the state of a subcomponent from the state of an element. As
processing an element can occur before, after, or between processing
an element's children, the signature includes functions corresponding
to each of these events. The function \cd{start} begins processing the
element, \cd{process_...} to process a subcomponent, and \cd{finish}
to complete processing the element. For type constructs with only one
subcomponent, the \cd{process} and \cd{finish} functions are combined.

% The generated traversal function processes the data in a
% depth-first, left-to-right manner. In general, given an abstract
% state object for a a data element, it is traversed as follows.
% First, it provides the generic tool with the state and the PD header
% and receive a new, ``in-progress'' state object in return.  Next,
% for each child of the node, it will ask the tool for the child's
% state based on the node's state, recursively process the child node
% with the given state, and then give the child's new state to the
% tool.  For nodes with more than one child, such as records and
% tuples, it will tell the tool that it has finished, at which point
% the tool converts the ``in-progress'' state into a new state object.

An excerpt of the generic tool interface is shown in
\figref{fig:gentool-interface}. It includes the signatures of the
\cd{Record} and \cd{Datatype} modules. Both modules include a type
\cd{partial_state} that allows tools to represent intermediate state
in a different form than the general state while processing
subcomponents. Also, both \cd{start} functions receive the PD header
for the data element being traversed.

\begin{figure}
\begin{code}\scriptsize
  \kw{module} Traverse (Tool : Generic_tool.S) :
  \kw{sig}
    \kw{val} init : unit -> Tool.state
    \kw{val} traverse : rep -> pd -> Tool.state -> Tool.state
  \kw{end}
\end{code}
\caption{The signature of the Traversal functor within the signature \cd{Type.s}.}
\label{fig:traversal-interface}
\end{figure}

In~\figref{fig:traversal-interface}, we show the signature for the
traversal functor as it appears in the signature \cd{Type.s},
discussed in \secref{sec:padsml-impl}. The functor takes a generic
tool and produce a specific tool with two functions: \cd{init}, to
create the initial state for the tool, and \cd{traverse}, which
traverses the representation and parse descriptor for the type and
updates the given tool state.

\subsection{Example Tools}
\label{sec:gentool-motivation-ex}

% \begin{figure}
%   \centering
%   \small
% \begin{verbatim}
% 122Joe|Wright|450|95|790
% n/aEd|Wood|10|47|31
% 124Chris|Nolan|80|93|85
% 125Tim|Burton|30|82|71
% 126George|Lucas|32|62|40
% \end{verbatim}  
%   \caption{A fictitious data fragment in the Movie-director Bowling
%     Score (MBS) format. Note that the first record contains semantic
%     errors (in that the minimum is larger than the maximum and the
%     average is larger than both the minimum and the maximum).}
%   \label{fig:gentool-mbs-sample}
% \end{figure}

\begin{figure}
  \centering
  \scriptsize
\begin{verbatim}
<Order>
   <summary>
      <errors>1</errors> <total>2</total>        
   </summary>
   <Order_header>
      <summary>
         <errors>1</errors> <total>2</total>        
      </summary>
      <order_num>
         <errors>0</errors> <total>2</total>        
      </order_num>
      <att_order_num>
         <summary>
            <errors>1</errors> <total>2</total>        
         </summary>
         <val>
            <errors>0</errors> <total>2</total>                
         </val>
      </att_order_num>
      <ord_version>
         <errors>0</errors> <total>2</total>                
      </ord_version>
      ...
   </Order_header>
</Order>
\end{verbatim}  
  \caption{A fragment of the accumulator output for \dibbler{}. The
    output is encoded in XML.}
  \label{fig:gentool-acc-output}
\end{figure}

We have implemented three generic tools that illustrate important
features of the framework: a tool for generating statistical
overviews of the data, a data printer for debugging, and an XML
formatter.

A common desire of a data analyst upon receiving a new data source is
to get a sense of the quality of the data. In particular, they might
be interested in knowing what percentage of the source has errors, or
which fields are the most problematic. For this purpose, \padsc{}
provides an \emph{accumulator} tool for \padsc{} that statistically
summarizes data sources. The accumulator is designed for data sources
whose basic structure is series of records of the same type.
\emph{another sentence or two here. explain notion of one
  acccumulator, many records}

We have implemented a generic tool that provides some of the basic
features of \padsc{} accumulators. Our accummulator counts the number
of errors and the total number of values for every element of a
description. In \figref{fig:gentool-acc-output}, we show a sample
portion of accumulator output for the \dibbler{} data
from~\figref{figure:dibbler-records}.

The accumulator data shows that 1 out of the 2 \cd{Order}s has an
error. Investigating further, we notice that the problem lies in the
\cd{Order_header}, in particular within the \cd{att_order_num} field.
This field has a constraint on it, and one of the values violates the
constraint. A quick glance at the data fragment reveals that the
second order is contains the offending field. In general, specific
information like this could be found in the parse descriptor.

\begin{figure}
\begin{code}\scriptsize
\kw{type} baseAcc = int * int
\kw{type} acc = baseAcc G.metadata
\kw{type} state = acc

\kw{module} Record = \kw{struct}
  \kw{type} partial_state = baseAcc * acc Table.t
  ... 
  \kw{let} start state header =
    \kw{match} state \kw{with}
      G.RecordData ((errs, total), accs) ->
	\kw{let} errs' = if header.nerr > 0
                    then errs + 1 else errs
	\kw{in} ((errs', total + 1), accs))
    | _ -> \kw{raise} ...
	  
  \kw{let} project state label = \kw{match} state \kw{with}
      G.RecordData (_, accs) -> (\kw{try} Table.find accs label
                                 \kw{with} _ -> \kw{raise} ...)
    | _ -> \kw{raise} ...

  \kw{let} process_field (bAcc, accs) label acc =
    (bAcc, Table.update accs label acc)
      
  \kw{let} finish (bAcc, accs) = G.RecordData (bAcc, accs)
\kw{end}
    
\kw{module} Datatype = \kw{struct}
  \kw{type} partial_state = baseAcc * acc Table.t
	
  \kw{let} init () = G.DatatypeData (initBaseAcc, Table.empty)

  \kw{let} start state header = 
    \kw{match} state \kw{with}
      G.DatatypeData ((errs, total), accs) ->
	\kw{let} errs' = if header.nerr > 0
                    then errs + 1 else errs
	\kw{in} ((errs', total + 1), accs))
    | _ -> \kw{raise} ...
	  
  \kw{let} project state label = \kw{match} state \kw{with}
    G.DatatypeData (_, accs) -> (\kw{try} Some (Table.find accs label)
                                 \kw{with} _ -> None)
  | _ -> \kw{raise} ...
	  
  \kw{let} process_variant (bAcc, accs) label acc =
    G.DatatypeData (bAcc, Table.update accs label acc)
\kw{end}
...
\end{code}
\caption{Excerpts from the implementation of the accumulator.}
\label{fig:gentool-accum-code}
\end{figure}

\emph{Discuss implementation of accum briefly here.}

In addition to the accumulator, we have implemented two different
kinds of pretty printers for parsed data.  One formats the data in
XML. The other prints the data in a simple text format that is helpful
for debugging descriptions. Importantly, both tool's output corresponds to the in-memory
representation of the data rather than its original format (which may,
for example, have delimiters that are not present in the
representation).

% \begin{figure}
% \begin{code}\scriptsize
%   \kw{type} state = Xml.xml \kw{exception} Tool_error \kw{of} state
%   * string \kw{let} init () = () ...  \kw{module} Record =
%   \kw{struct} (* Partial state is a list of XML objects *
%   representing the fields processed so far * tagged with the
%   record's PD header *) \kw{type} partial_state = Pads.pd_header *
%   (Xml.xml list)

%   \kw{let} init named_states =
%     ... (* Create initial "blank" state with no data *)

%   \kw{let} start state header =
%     ... (* Initialize processing of a new record *)

%   \kw{let} project state field_name =
%     ... (* Extract named field's state *)

%   \kw{let} process_field (header, fields) field_name state =
%     (header, fields@[Xml.Element 
%     	(field_name, [], [state])])

%   \kw{let} finish pstate =
%     ... (* Convert a partial state into a final state *)
% \kw{end}
% ...
% \end{code}
% \caption{Excerpts from the implementation of the generic XML formatter
%   tool in {\tt xml\_formatter.ml}.}
% \label{fig:gentool-xmlf-code}
% \end{figure}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
