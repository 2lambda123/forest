\section{A Generic Tool Framework}
\label{sec:gen-tool}
An important feature of PADS/ML is the generic tool framework, which leverages the power of the existing PADS system to allow users to rapidly develop data-processing tools. This framework is motivated by the fact that PADS type specifications are useful for many tasks beyond data parsing, and it strikes a balance between providing common functionality for such tools and enabling users to flexibly specify the concrete behavior of different tools.

The main design principle for this framework, as detailed below, is that generic tools are defined by their behavior on the various components of PADS types, while the framework provides a uniform mechanism for traversing data satisfying any PADS description and applying the customized tool behavior at each node of the data tree. We have implemented two such data processing tools, the accumulator (for generating brief summaries of the value distributions for each type) and the XML formatter (for outputting data elements in using XML structure), as a proof-of-concept of the generic tool framework.

\subsection{Motivation: Traversal as a Generic Idiom for Data Processing}
\label{sec:gen-tool-motivation}
A system such as PADS that provides a concise, declarative language for specifying data formats lends itself naturally to many applications beyond the construction of parsers. Because parsers are generated from PADS specifications with a dedicated compiler, it would appear, at first glance, that each tool would need to be developed as a separate compiler that would take PADS specifications and output type-specific code. Such an architecture would require tool developers to, essentially, write compiler modules that would work in parallel with the parser generator; it would also mean that the development of a new tool cannot be done without modifying and augmenting the PADS compiler itself.

In the general case, tools that perform arbitrary data manipulation must indeed be written as separate compiler modules. In the PADS/C system, this is how all tools are developed. However, there is an important class of \emph{generic} tools that all share a common overall data processing method while differing in the details of how they transform data. These tools are characterized by a \emph{traversal} of the data, viewed as a (possibly recursive) tree of components. In broad terms, the process of traversal involves picking out a data item (i.e., a node in the tree), performing some operation on it (while possibly updating some state), and recursively traversing any of its subcomponents (represented as child nodes in a tree). The tools in this category share two important properties:
\begin{itemize}
\item For any specific PADS data type, the generic tools traverse the data in the same manner, differing only in the operations they perform on individual data items.
\item For any given generic tool, the operations performed on individual data items are fixed; different PADS types are handled by different data traversal orders.
\end{itemize}

Thus, it is evident that the traversal mechanism is common for all generic tools and depends only on the data format, while, conversely, the data-processing code is tool-specific but format-independent. The generic tool framework presented here exploits these properties by decoupling the mechanism of data traversal from the operations performed on individual data items. The common traversal mechanism, since it is format-dependent, is generated by a traversal generator module in the PADS compiler. By contrast, the tool-specific data node processing code is provided by tool developers as a separate module that implements a common \emph{generic tool interface}. This interface, described below, declares that data-processing operations be available for each kind of PADS type (including structures, unions, and so on). The following benefits accrue due to this architecture:
\begin{itemize}
\item Tool developers need not modify the compiler code itself, since the common traversal mechanism is tool-independent and is generated based on the PADS type specification by the provided PADS compiler.
\item Tool development is simplified because it involves merely implementing the generic tool interface with operations to be invoked on each kind of data item.
\item Tools that (statically) satisfy the generic tool interface are certain to be applicable to all PADS types, though they are developed without reference to any specific type.
\item Tools are completely portable and independent. Under this framework, they become "pluggable modules" that can be installed, in any combination, on any PADS system without modifying other parts of the system.
\end{itemize}

\subsection{Traversing a Data Source: A Conceptual Overview}
\label{sec:gen-tool-traversal}
As described above, all generic tools share a common type-specific data source traversal algorithm, differing only in how they treat individual data items. This traversal mechanism views a data source as a tree structure whose leaves are elements of the PADS base types and whose internal nodes represent compound types: structures, data types (i.e., unions), and constrained types. The root of this tree is taken to be the element of the type declared as a \kw{Psource}.

Traversal proceeds by processing the root of the tree and recursing on subcomponents. To be expanded:
\begin{itemize}
\item Traversing a base type involves calling a user-defined processing routine.
\item Traversing a compound type consists of performing user-defined initialization, processing each subcomponent, and doing user-defined post-processing.
\item The user-defined processing routines can accumulate information via the notion of a \emph{state} that is the only means of communication between the processing tasks of different data items in the tree.
\end{itemize}

\subsubsection{User-Defined Processing and the Notion of State in Traversal}
\label{sec:gen-tool-traversal-state}
\begin{itemize}
\item Table describing the precise order of steps for each of the different PADS types (structures, datatypes, constraints).
\item A user provides one custom processing routine for base types, structures, datatypes, and constrained types.
\item Besides side effects, each processing routine takes as input and returns as output a state object that is updated by the routine; this state object's type is tool-specific and is defined by the tool developer.
\item A separate state object is accumulated for each PADS type defined in the specification. In other words, two different Pstructs will each have their own associated state objects. Each base type has one global state object associated with it.
\item User-defined routines are also provided to initialize these state objects for each PADS type.
\item From the tool invoker's point of view, a traversal of a data source can be thought of as a procedure that takes an initial state object and a data source (including a representation and a parse descriptor) and returns an updated state that is the result of the processing.
\item Error handling: tools can abort processing in exceptional conditions while providing a snapshot of the state at the time of the error as a debugging tool.
\end{itemize}

\subsubsection{Example: Traversing the Movie Director Bowling Score Format}
\label{sec:gen-tool-traversal-mbs}

\subsection{The Generic Tool Interface in PADS/ML}
\label{sec:gen-tool-interface}

\subsubsection{The Structure of a Tool}
\label{sec:gen-tool-interface-tool-struct}

\subsubsection{Implementation of the Generic Tool Framework in PADS/ML}
\label{sec:gen-tool-interface-implementation}

\subsection{Example Tools}
\label{sec:gen-tool-examples}

\subsubsection{The Accumulator Tool}
\label{sec:gen-tool-examples-acc}

\subsubsection{The XML Formatter}
\label{sec:gen-tool-examples-xml}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
