\section{The Generic Tool Framework}
\label{sec:gen-tool}

\begin{itemize}
\item show interface - explain that one module/constructor and base types.
\item constrast records and one other module.
\item x Make it 3 tools: accum, XML, debuger.
\item x Focus on accumulator. describe in more detail.
\item show implementations,  including base types to show how they differ.
\item x then, describe XML, debugger as pretty printers.
\end{itemize}

An essential benefit of \padsml{} is that it can provide the users
with a high return-on-investment for describing their data. While the
generated parser alone is often enough to justify the user's effort,
we aim to increase the return by producing a large suite of data
analysis tools for every data source described in \padsml{}. However,
there is a limit, both in resources and expertise, to the range of
tool generators that we can develop. Indeed, new and interesting data
analysis tools are constantly being developed, and we have no hope of
integrating even a fraction of them into the \padsml{} system
ourselves.

Fortunately, we don't have to. A large class of data analysis tools
share a common data processing method while differing in the details
of how they transform data. These tools are characterized by a
\emph{traversal} of the data, viewed as a (possibly recursive) tree of
components. In broad terms, the process of traversal involves picking
out a data item (i.e., a node in the tree), performing some operation
on it (while possibly updating some state), and recursively traversing
any of its subcomponents (represented as child nodes in a tree). 

The tools in this category share two important properties. First, for
any specific \padsml{} data type, the generic tools traverse the data
in the same manner, differing only in the operations they perform on
individual data items. Second, for any given generic tool, the operations
performed on individual data items are fixed; different \padsml{}
types are handled by different data traversal orders. To the
experienced functional programmer, these tools are essentially
depth-first, left-to-right folds over the data.

% Thus, it is evident that the traversal mechanism is common for all
% generic tools and depends only on the data format, while, conversely,
% the data-processing code is tool-specific but format-independent. 

Therefore, we have created a generic tool framework by decoupling the
mechanism of data traversal from the operations performed on
individual data items. The format-dependent traversal mechanism is
generated by a traversal generator module in the \padsml{} compiler.
By contrast, the tool-specific data-node processing code is provided
by tool developers as a separate module that implements a
\emph{generic tool interface}.

% An important feature of \padsml{} is the generic tool framework, which
% leverages the power of the existing \padsml{} system to allow users to
% rapidly develop data-processing tools. This framework is motivated by
% the fact that \padsml{} type specifications are useful for many tasks
% beyond data parsing, and it strikes a balance between providing common
% functionality for such tools and enabling users to flexibly specify
% the concrete behavior of different tools.

% The main design principle for this framework, as detailed below, is
% that generic tools are defined by their behavior on the various
% components of \padsml{} types, while the framework provides a uniform
% mechanism for traversing data satisfying any \padsml{} description and
% applying the customized tool behavior at each node of the data tree.
% We have implemented two such data processing tools, the accumulator
% (for keeping track of errors in data sources) and the XML formatter
% (for outputting \pads{} representations as XML), as a proof-of-concept
% of the generic tool framework.


% The operations defined by concrete tools are callback methods that are
% invoked by the traversal functor as it walks over a data source. An
% important consequence of this is that the tools' operations cannot
% return results directly to the original invoker of the traversal.
% Instead, the operations are provided a \emph{state} object that is
% passed to, and returned from, every operation invoked by the
% traversal. The state itself is held abstract by the interface, and the
% types of all operations are defined in terms of this type. Thus, an
% important task for the tool developer is to decide on an appropriate
% notion of state that will serve to specify a tool's initialization
% parameters, carry information between different stages of the
% traversal, and encapsulate the desired results of the traversal to be
% returned to the user.

The new, generic tool architecture of \padsml{} delivers a number of
benefits over the fixed architecture of \padsc{}. In \padsc{}, all
tools are generated from within the compiler. Therefore, developing a
new tool generator requires understanding and modifying the compiler.
Furthermore, the set of tools to be generated is chosen by the user
when compiling the description.  In \padsml{}, tool generators can be
developed independent of the compiler and they can be developed more
rapidly, as the ``boilerplate'' code to traverse data need not be
replicated for each tool generator. In addition, the user controls
which tools to ``generate'' for a given data format, and the choice
can differ on a program-by-program basis.

\subsection{The Generic Tool Interface}
\label{sec:gentool-interface}

\begin{figure}
\begin{code}\scriptsize
\kw{module} \kw{type} S = \kw{sig}
  \kw{type} state
  ...
  \kw{module} Record : \kw{sig}
    \kw{type} partial_state
    \kw{val}  init          : (string * state) list -> state
    \kw{val}  start         : state -> Pads.pd_header 
                         -> partial_state
    \kw{val}  project       : state -> string -> state
    \kw{val}  process_field : partial_state -> string
                         -> state -> partial_state
    \kw{val}  finish        : partial_state -> state
  \kw{end}

  \kw{module} Datatype : \kw{sig}
    \kw{type} partial_state
    \kw{val}  init            : unit -> state
    \kw{val}  start           : state -> Pads.pd_header 
                           -> partial_state
    \kw{val}  project         : state -> string -> state option
    \kw{val}  process_variant : partial_state -> string 
                           -> state -> state
    \kw{module} Empty : \kw{sig}
      \kw{val} init     : unit -> state
      \kw{val} process  : state -> state
    \kw{end}
  \kw{end}
   ...
\kw{end}
\end{code}
\caption{Details of the record-related portion of the {\tt
    Generic\_tool.S} interface.}
\label{fig:gentool-interface}
\end{figure}

An excerpt of the generic tool interface is show in
\figref{fig:gentool-interface} It defines the abstract view that the
traversal mechanism takes of all tools.

...

\subsection{Example Tools}
\label{sec:gentool-motivation-ex}

% \begin{figure}
%   \centering
%   \small
% \begin{verbatim}
% 122Joe|Wright|450|95|790
% n/aEd|Wood|10|47|31
% 124Chris|Nolan|80|93|85
% 125Tim|Burton|30|82|71
% 126George|Lucas|32|62|40
% \end{verbatim}  
%   \caption{A fictitious data fragment in the Movie-director Bowling
%     Score (MBS) format. Note that the first record contains semantic
%     errors (in that the minimum is larger than the maximum and the
%     average is larger than both the minimum and the maximum).}
%   \label{fig:gentool-mbs-sample}
% \end{figure}

\begin{figure}
  \centering
  \scriptsize
\begin{verbatim}
<Order>
   <summary>
      <errors>1</errors> <total>2</total>        
   </summary>
   <Order_header>
      <summary>
         <errors>1</errors> <total>2</total>        
      </summary>
      <order_num>
         <errors>0</errors> <total>2</total>        
      </order_num>
      <att_order_num>
         <summary>
            <errors>1</errors> <total>2</total>        
         </summary>
         <val>
            <errors>0</errors> <total>2</total>                
         </val>
      </att_order_num>
      <ord_version>
         <errors>0</errors> <total>2</total>                
      </ord_version>
      ...
   </Order_header>
</Order>
\end{verbatim}  
  \caption{A fragment of the accumulator output for \dibbler{}. The
    output is encoded in XML.}
  \label{fig:gentool-acc-output}
\end{figure}

We have implemented three generic tools that illustrate important
features of the framework: a tool for generating statistical
overviews of the data, a data printer for debugging, and an XML
formatter.

A common desire of a data analyst upon receiving a new data source is
to get a sense of the quality of the data. In particular, they might
be interested in knowing what percentage of the source has errors, or
which fields are the most problematic. For this purpose, Fisher and
Gruber\padsc{}~\cite{fisher+:pads} developed an \emph{accumulator}
tool for \padsc{} that statistically summarizes data sources. The
accumulator is designed for data sources whose basic structure is
series of records of the same type. \emph{another sentence or two
  here. explain notion of one acccumulator,  many records}

We have implemented a generic tool that provides some of the basic
features of \padsc{} accumulators. Our accummulator counts the number
of errors and the total number of values for every element of a
description. In \figref{fig:gentool-acc-output}, we show a sample
portion of accumulator output for the \dibbler{} data
from~\figref{figure:dibbler-records}.

The accumulator data shows that 1 out of the 2 \cd{Order}s has an
error. Investigating further, we notice that the problem lies in the
\cd{Order_header}, in particular within the \cd{att_order_num} field.
This field has a constraint on it, and one of the values violates the
constraint. A quick glance at the data fragment reveals that the
second order is contains the offending field. In general, specific
information like this could be found in the parse descriptor.

\emph{Discuss implementation of accum briefly here.}

In addition to the accumulator, we have implemented two different
kinds of pretty printers for parsed data.  One formats the data in
XML. The other prints the data in a simple text format that is helpful
for debugging descriptions. Importantly, both tool's output corresponds to the in-memory
representation of the data rather than its original format (which may,
for example, have delimiters that are not present in the
representation).

\begin{figure}
\begin{code}\scriptsize
module Record = struct
  type partial_state = baseAccErrs * acc G.StringMap.t
	
  let init accs = G.RecordData (initBaseAccErrs, G.buildStringMap accs)
      
  let start state header =
    match state with
      G.RecordData (((errs, total), headers), accs) ->
	(let (newerrs, newheaders) =
	  match header.Pads.error_code with
	    Pads.Good -> (errs, headers)
	  | Pads.Maybe -> (errs, headers)
	  | _ -> (errs + 1, header::headers)
	in (((newerrs, total + 1), newheaders), accs))
    | _ -> raise (Tool_error (state, "Acctool.Record.start: Expected state RecordData _"))
	  
  let project state label =
    match state with
      G.RecordData (_, accs) ->
	(try G.findStringMap label accs
	with _ -> raise (Tool_error (state, "Acctool.Record.project: Component " 
				     ^ label ^ " not found in record")))
    | _ -> raise (Tool_error (state, "Acctool.Record.project: Expected state RecordData _"))

  let process_field (baccErrs, accs) (label : string) acc =
    (baccErrs, G.addStringMap label acc accs)
      
  let finish (baccErrs, accs) =
    G.RecordData (baccErrs, accs)
end
    
module Datatype = struct
  type partial_state = Pads.pd_header * baseAccErrs * (acc G.StringMap.t)
	
  let init () = 
    G.DatatypeData (initBaseAccErrs, G.StringMap.empty)

  let start state header =
    match state with
      G.DatatypeData (baccErrs, accs) -> (header, baccErrs, accs)
    | _ -> raise (Tool_error (state, "Acctool.Datatype.start: Expected state DatatypeData _"))
	  
  let project state label =
    match state with
      G.DatatypeData (_, accs) ->
	(try Some (G.findStringMap label accs)
	with _ -> None)
    | _ -> raise (Tool_error (state, "Acctool.Datatype.project: Expected state DatatypeData_"))
	  
  let process_variant (header, ((errs, total), headers), accs) label acc =
    let newbaccErrs =
      match header.Pads.error_code with
	Pads.Good -> ((errs, total + 1), headers)
      | Pads.Maybe -> ((errs, total + 1), headers)
      | _ -> ((errs + 1, total + 1), header::headers)
    in
    G.DatatypeData (newbaccErrs, G.addStringMap label acc accs)
      
  module Empty = ...
end
...
\end{code}
\caption{Excerpts from the implementation of the accumulator.}
\label{fig:gentool-accum-code}
\end{figure}

% \begin{figure}
% \begin{code}\scriptsize
%   \kw{type} state = Xml.xml \kw{exception} Tool_error \kw{of} state
%   * string \kw{let} init () = () ...  \kw{module} Record =
%   \kw{struct} (* Partial state is a list of XML objects *
%   representing the fields processed so far * tagged with the
%   record's PD header *) \kw{type} partial_state = Pads.pd_header *
%   (Xml.xml list)

%   \kw{let} init named_states =
%     ... (* Create initial "blank" state with no data *)

%   \kw{let} start state header =
%     ... (* Initialize processing of a new record *)

%   \kw{let} project state field_name =
%     ... (* Extract named field's state *)

%   \kw{let} process_field (header, fields) field_name state =
%     (header, fields@[Xml.Element 
%     	(field_name, [], [state])])

%   \kw{let} finish pstate =
%     ... (* Convert a partial state into a final state *)
% \kw{end}
% ...
% \end{code}
% \caption{Excerpts from the implementation of the generic XML formatter
%   tool in {\tt xml\_formatter.ml}.}
% \label{fig:gentool-xmlf-code}
% \end{figure}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
