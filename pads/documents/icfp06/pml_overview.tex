\newcommand{\pvalue}{???}
\section{Describing Data in \padsmlbig{}}
\label{sec:padsml-overview}

{\em
To do:
\begin{itemize}
\item compare w/ pads/c: key thing is to find compelling
  comparisons. I think Newick is one (short and sweet). I suspect that
  Darkstar/Regulus, which uses polymorphism heavily, should be the other.
\end{itemize}
}

A \padsml{} description specifies the physical layout and semantic
properties of an ad hoc data source.  These descriptions are composed
of types: base types describe atomic data, while structured types
describe compound data built from simpler pieces.  Examples of base
types include ASCII-encoded, 8-bit unsigned integers (\cd{Puint8}) and
32-bit signed integers (\cd{Pint32}), binary 32-bit integers (\cd{Pbint32}),
dates (\cd{Pdate}), strings (\cd{Pstring}), zip codes (\cd{Pzip}),
phone numbers (\cd{Pphone}), and IP addresses (\cd{Pip}).  Semantic
conditions for such base types include checking 
that the resulting number fits in the indicated space, \ie, 16-bits
for \cd{Pint16}.

Base types (and other types) may be parameterized by \ml{} values. 
This mechanism serves both to reduce the number of base types
and to permit the format and properties of later portions of the data
to depend upon earlier portions.  For example, the base type
\cd{Puint16_FW(3)} specifies an unsigned two byte integer physically
represented by exactly three characters. The base type \cd{Pstring}
takes an argument indicating the \textit{terminator character}, \ie{},
the character in the source that immediately follows the string.

To describe more complex data, \padsml{} provides a collection of
type constructors derived from the type structure of functional
programming languages such as Haskell and ML.  We explain these
structured types in the following subsections using examples drawn
from data sources we have encountered in practice. 

% Readers eager to see the complete syntax
% of types should flip forward to Appendix~\ref{app:syntax-dd}.

\subsection{Simple Structured Descriptions}


\begin{figure*}
{\scriptsize
\begin{verbatim}
0|1005022800
9152|9152|1|9735551212|0||9085551212|07988|no_ii152272|EDTF_6|0|APRL1|DUO|
9153|9153|1|0|0|0|0||152268|LOC_6|0|FRDW1|DUO|
\end{verbatim}
}
  \caption{Miniscule example of \dibbler{} data.}
  \label{figure:dibbler-records}
\end{figure*}

The bread and butter of any \padsml{} description are the simple
structured types: tuples and records for expressing sequences of data;
sum types, realized here as datatypes, for expressing alternatives;
and singletons for expressing the placement of particular
characters in the data.  In this section, we explain each of these
items by building a description of the \dibbler{} data presented in
\figref{figure:dibbler-records}.

\dibbler{} data summarizes orders for phone service placed with AT\&T.
Each \dibbler{} data file starts with a timestamp and then contains one
record per phone service order.
Each such record consists of a header and a sequence of
events.  The header has 13 pipe separated fields: the order number,
AT\&T's internal order number, the order version, four different
telephone numbers associated with the order, the zip code of the
order, a billing identifier, the order type, a measure of the
complexity of the order, an unused field, and the source of the order
data.  Many of these fields are optional, in which case nothing
appears between the pipe characters.  The billing identifier may not
be available at the time of processing, in which case the system
generates a unique identifier, and prefixes this value with the string
``no\_ii'' to indicate that the number was generated. The event sequence
represents the various states a service order goes through; it is
represented as a new-line terminated, pipe separated list of state,
timestamp pairs.  There are over 400 distinct states that an order may
go through during provisioning.  The sequence is sorted in order of
increasing timestamps.

\begin{figure}
  \input{sirius_pml}
  \caption{\padsml{} description for \dibbler{} provisioning data.}
  \label{figure:sirius_pml}
\end{figure}

\figref{figure:sirius_pml} gives a \padsml{} description for the
\dibbler{} phone order summaries. The description is a
sequence of type definitions. Because each type must be declared
before it is used, it is probably easiest to read the definitions
bottom up. 

The last type definition, \cd{Source}, describes the entirety
of a \dibbler{} data file.  It uses the tuple type
constructor \cd{*} to define \cd{Source} as a a \cd{Summary\_header}
followed by \cd{Orders}. 
The definition of \cd{Orders} uses the list type
constructor, \cd{Plist}, which specifies a homogenous sequence of
objects in a data source.  \cd{Plist}, which we can define in \padsml{} itself,
depends upon three parameters.  The first (\cd{Order}) specifies the
type of the elements in the list.  The second (\cd{Peor}) describes
the syntactic separators that may be found between list elements.
In the example, the type \cd{Peor} indicates that an end-of-record marker
may be found between each element of the list~\footnote{%
  In our example, the end-of-record marker is a newline 
  character as there is one record per line in the file.  However,
  this marker is not set in the description itself.  Rather, the
  end-of-record is left abstract, and set later by the client program
  that uses the generated libraries}. 
The third parameter indicates the terminator for the list.  In this
case, the terminator is \cd{Peof}, a 
type that describes the special \emph{end-of-file marker}.  
We can also express more complex termination
conditions for sequences in \padsml{}, such as conditions involving
the number of characteristics of elements read so far.

An \cd{Order} is a sequence of objects made up of an
\cd{Order\_header} followed by \cd{Events}.  The definition of
\cd{Events} indicates that this part of the \dibbler{} data will
contain a sequence of \cd{Event}s separated by vertical bars and
terminated by an end-of-record marker.  Each \cd{Event} is a string
terminated by a vertical bar, followed by a vertical bar, and ending
with a timestamp.  The interesting part of this
sequence is the presence of the literal character \cd{'|'}.  In
type-theoretic terms, this literal represents a {\em singleton type},
meaning that the data source should contain exactly the character
\cd{'|'} in the input stream at this point.  In general, string,
character, and 
integer literals can be embedded in a description to be interpreted as
a singleton-type. For example, the string literal \cd{"0|"} appears in
the summary header type.

The type \cd{Order\_header} is a record type, which indicates the data
format involves the sequence of items described by the fields of the
record.  Notice that there are two different sorts of fields:
anonymous fields (a second form of singleton type) containing
directives to parse a particular literal, and fields with names.

The second named field, \cd{att\_order\_num}, reveals two other
features of \padsml: dependency and constraints.  Here,
\cd{att\_or}-\cd{der\_num} is constrained to be less than \cd{order\_num},
the value parsed in the previous field.  This is a relatively simple
constraint on the correctness of the ad hoc data format.  In practice,
constraints can become very rich, involving properties like
sortedness of records in an array, definitions of expected characters,
restrictions on date and time ranges, constraints on IP address
domains, restrictions on phone number area codes and virtually
infinite variety of other possibilities. In general, constrained
types have the form \cd{[x:T | e]} where \cd{e} is an arbitrary pure
boolean expression.  Data satisfies this description if it
satisfies \cd{T} and boolean \cd{e} evaluates to true when the parsed
representation of the data is substituted for \cd{x}.  If the boolean
evaluates to false, the data contains a semantic error.

The last interesting feature in the \dibbler{} example is the datatype
definition of \cd{Dib\_ramp}.  It describes two alternatives for a
portion of data, either an integer alone or the fixed string
\cd{"no\_ii"} followed by an integer.  To parse data in this format,
the parser will attempt to parse the first branch and only if it fails
will it attempt to parse the second branch.  Notice how this semantics
differs from similar constructs in regular expressions and
context-free grammars, which non-deterministically choose between
alternatives.  Fortunately, we have yet to come across an ad hoc data
source where we wish we had nondeterministic choice.\footnote{\padsml{}
  can recognize string data based on regular expressions.
  Non-determinism here has been useful, but as it has been confined to
  parsing elements of the \cd{Pstring} base type, it has had no impact
  on the overall parsing algorithm.}

\begin{figure}
\input{newick_pml}
Tiny fragment of Newick data:

{\scriptsize
\begin{verbatim}
(((erHomoC:0.28006,erCaelC:0.22089):0.40998,(erHomoA:0.32304,
(erpCaelC:0.58815,((erHomoB:0.5807,erCaelB:0.23569):0.03586,
erCaelA:0.38272):0.06516):0.03492):0.14265):0.63594,
(TRXHomo:0.65866,TRXSacch:0.38791):0.32147,TRXEcoli:0.57336)
\end{verbatim}
}
  \caption{Simplified tree-shaped Newick data}
  \label{fig:newick}
\end{figure}

\subsection{Recursive Descriptions}

Another powerful feature of \padsml{} is the ability to describe data
sources with recursive structure.  A representative example of
recursive, biological data comes courtesy of Steven Kleinstein,
program coordinator of Princeton's Picasso project for
interdisciplinary research in computational sciences.  
\emph{We need to check that the following is still true.} Kleinstein is
in the process of building a simulator to study the proliferation of B
lymphocytes during an immune response.  Data needed for his
simulations is represented in a variant of the Newick format, which is
a flat representation of trees used by many biologists~\cite{newick}.
In Newick, leaves of the tree are string labels followed by a colon
and a number.  A parent node in the tree introduces a collection of
children by placing a sequence of trees within parens.  Following the
parens is a colon and a number, as is the case for the leaf node.  The
numbers represent the ``distance'' that separates the child from the
parent.  In Kleinstein's case, the distance is the number of mutations
that occur in the antibody receptor genes of B lymphocytes.

\figref{fig:newick} gives a description of Newick and a short fragment 
of example data.  Despite the relative complexity of the structure of the data,
the description is remarkably concise and elegant.  Notice that the data type
definition of \cd{tree} is recursive --- we have not been able to find any
effective description of this data source without it.

\begin{figure*}
  \centering
\begin{code}\scriptsize
 2:3004092508||5001|dns1=abc.com;dns2=xyz.com|c=slow link;w=lost packets|INTERNATIONAL
 3:|3004097201|5074|dns1=bob.com;dns2=alice.com|src_addr=192.168.0.10;
 dst_addr=192.168.23.10;start_time=1234567890;end_time=1234568000;cycle_time=17412|SPECIAL
\end{code}  
  \caption{Simplified network monitoring data.  This 
data containts two alarm records.  Extra newlines 
were inserted mid-record so the data would fit on a page.}
  \label{fig:darkstar-records}
\end{figure*}
  
\subsection{Polymorphic Descriptions}

The last key feature of \padsml{} is the ability to define
parameterized descriptions.  In \padsc, description parameters were
limited to values.  In \padsml, descriptions maybe parameterized by
both values and types.  Type parameterization allows descriptions to
be reused with a variety of different types.  This feature helps make
data descriptions more concise and allows programmers to define
convenient libraries of reusable description components. For example,
the \cd{Plist} type that appears in both the \dibbler{} and Newick
formats is such a reuseable component.

Our final example, shown in Figure~\ref{fig:darkstar-records}, will
illustrate the usefulness of descriptions parameterized by both types
and values and introduce a couple of other useful features as well.
This example displays alarm data recorded by a network link monitor
used by the \darkstar{} project at AT\&T.  Each alarm signals some
problem with a network link.

Now, at this point, we could write an English description
of the \darkstar{} data, and indeed, in an earlier version of this paper
we did so.  However, English is a terrible specification language
for ad hoc data, and every description we have attempted to give has not 
only been imprecise, it has also made for some very 
boring reading.  Hence, we dispense with the informal
English and head straight for the \padsml{} description,
which is shown in \figref{fig:darkstar-ml}.

\begin{figure}
  \centering
  \input{darkstar_pml}
  \caption{Description of \darkstar{} data.}
  \label{fig:darkstar-ml}
\end{figure}

One of the interesting facets of this data source is the fact that it
contains multiple different kinds of name-value pairs.  In the fifth
definition from the top, \cd{Pnvp}, we take advantage of both the type
and value parameterization of types to encode all the different
variations. The type parameters are specified to the left of the type
name, as is customary in \ml{}.  To the right of the type name, in
parentheses, we give the value parameter and its (\ml{}) type.  In
the case of \cd{Pnvp}, there is a type parameter named \cd{Alpha} and
a value parameter named \cd{p}.  Informally, \cd{Alpha Pnvp(p)} is a
name-value pair where the value is described by \cd{Alpha} and the
name must satisfy the predicate \cd{p}.

The \cd{Pnvp} type is used in both of the following type definitions.
In the case of the \cd{Nvp} definition, the predicate is instantiated
with a test for a specific string but the type parameter remains
abstract.  In the \cd{Nvp\_a} definition, the name can be arbitrary,
but the value must be a string terminated by a semicolon or vertical
bar. Later in the description, \cd{Nvp}'s are used with ip addresses,
timestamps and integers.

% The source type is an array of \cd{alarm}s, where each alarm is a
% \cd{raw\_alarm}, constrained to ensure that the alarm number is
% properly correlated with the timestamps.  We check this correlation
% with the function \cd{checkCorr}.  The type \cd{raw\_alarm} closely
% follows the description above. We highlight a few important features.
% First, we note that the type of the field \cd{info} depends on the
% alarm code, reflecting the text above. More interestingly, the type
% \cd{info} is implemented with a switched datatype, deciding how to
% parse based on the parameter \cd{alarm\_code}.  Next, we note that the
% description includes five different types of name-value pairs. We take
% advantage of both the type and value parameterization of types to
% encode all of these pair types based on one common description,
% \cd{pnvp}. This type is polymorphic in the type of the value and takes
% an arbitrary constraint \cd{c} as an argument. The type \cd{nvp} is
% polymorphic in the type of the value, but takes the expected name of
% the string as an argument. 

The \darkstar{} description also introduces a new form of datatypes,
called \textit{switched} datatypes. Rather than determine which branch
of the datatype to choose based on the data about to be parsed, a
switched datatype makes the decision based on the value of a
user-specified \ocaml{} expression, which likely references parsed
data from earlier in the data source. The \cd{Info} type is a switched
datatype, choosing the appropriate variant based on its
\cd{alarm\_code} parameter.  More specifically, if the alarm code is
\cd{5074}, the format specification given by the \cd{Details}
constructor will be used to parse the current data.  Otherwise, the
format given by the \cd{Generic} constructor will be used to parse the
current data.

Another construct new to the \darkstar{} description is the type qualifier
\cd{omit}. We use \cd{omit} in the \cd{Service} datatype to specify
that the parsed string literal should be omitted from the parsed
data. We can do this because we can discern from the datatype constructor
which string was found in the data source.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
