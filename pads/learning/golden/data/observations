1. Floating point numbers are not detected (1967Transactions)

2. Special characters are treated as newlines (boot.txt)
** this is due to the file being binary. We treat this as a special case and don't consider it for now

3. Dates are not detected (boot.txt, ai.3000, yum.txt) 
** this is fixed by adding tokenization for Pdate 

4. If array body is too complicated, chances are it's not an array; also if an array has too few elements,
it may not be an array especially when it doesn't have a separator (boot.txt, rpmpkgs.txt)

5. If a Ty has too complex structure and low coverage, can consider downgrading it to a simple string because
it could be just comments, human language, rather than a fixed format (boot.txt)

6. File paths and URLs are not detected (boot.txt)
** this is fixed by adding tokenization for Ppath and Purl

7. The current system was unable to correctly identify rc.sysinit and fsck as having the same semantics (a daemon name) by putting them into a union (boot.txt)
** this requires semantics analysis which is hard

8. Failed to recognize multi-line records and file that contains different types of records (convert.log)
** this is a remification of the current system having various assumption of a single line record

9. Hostname was not identified (ai.3000)

10. Timezone -0700 taken as integer (ai.3000)
** this fixed by modifying the tokenization for Ptime

11. Terminator appears in the body of the array itself (dibbler.1000)
** this fixed by using revised refine_array rewriting rule

12. Failed to detect the file permission format as a whole string (ls-l.txt)

13. Array not detected when the separator is also used uniformly as a separator for structs (quarterlypersonalincome)

14. Unable to distinguish table headers from the table body (quarterlypersonalincome) -> 
consider doing the following rewriting:
(a1 + b1), (a2 + b2), (a3 + b3) = (a1, a2, a3) + (b1, b2, b3) 
where a and b are header and body rows of a table
** Implemented a new rewriting rule for separating the header from the body of a table. 
It turns out there are two problems with this: first just by looking at the coverage of the header
(presumably 1) and the body (n-1) is not enough; some tables may not exhibit that property. Second,
the rewrite of the above kind often causes the cost of the Ty to be higher due to the fact that there
are often common elements in both the header and body (such as spaces) and 
these get duplicated in the above, e.g. if we have
x, (a1 + b1), y, z, (a2 + b2), (a3 + b3) ==> (x, a1, y, z, a2, a3) + (x, b1, y, z, b2, b3)
the resulting structure is longer and more complicated cos of the duplicate of x, y and z.

15. Cannot handle Parray with a non-struct body, e.g. base or refinedbase, however these arrays with a base Ty as body are normally not really arrays (ai.3000, rpmpkgs.txt). 
** fixed by the new refine_array rewriting rule, however such Parrays are not really arrays, the initial
format construction need to be modified to take care of this case

16. The current RArray construction compares the first with the body and the last with the body but the comparison is not completely correct. It is missing the case of the first is "part" of the body in the sense that it can be "merged" into the body; similar goes for the last. Another problem is since the first, body and last may contain RefinedBase types may included Enums, StringME's which are difficult to compare and the fix this an order of reduction needs to be enforced which is discussed below. 
** fixed by the new refine_array rewriting rule

17. The current algorithm generates a table from the original Ty and run functional analysis on it to obtain
constraints on either single column or multiple columns (switch and equation). And then all the rewriting rules are attempted to each node in the Ty tree in a depth-first manner. The problem is some rewriting rules change
the structure of the tree which causes the initial computed constraints not to hold any more. E.g. unnest the Punions will cause the switch constraints to be wrong. Almost all other rules that change the structure of the Ty involve some change or removal of some constraint. Since most of these rules do not need the constraints at all, I am experimenting with a two-phase reduction. In the first face, we use the non-constraint-requiring rules to do one round of bottom-up reduction on the original Ty to make a Ty'. These rules are called pre_constraint_rules, and they include remove_degenerate_list, unnest_tuples, unnest_sums, prefix_postfix_sums, remove_nils, remove unused union branches, refine array. After this reduction step, the structure of the tree is stable, then we build the table and generate constraints based on Ty'. We then do one more round of reduction using the remaining rules: unqueness_to_constant, merge adjacent constants, covert enum or range constraint to refined base and converting Punions to Switch. 
** fixed by implementing a two-phase reduction scheme
