Insights:

1. Should we output begining and end locations in the pds when there
   is no error?

yes.  We omit the ending location in the pd in the implementation only
for performance reasons, and I think this is a mistake.  In the
implementation, I think we should record the info unless the user has
somehow asked not to, which gets to optimization questions that we
haven't even started to address.

3. What are the semantics of Pomit with regard to field scope?

Currently, we allow omitted fields to be accessed just as other fields
during parsing.  they are not available otherwise, however, so not in
unparse functions or in the in-memory validation functions.  In some
sense, literals are just anonymous omitted fields that can't be
accessed later.  We may want to revisit this design decision.  If we
had good support for transformations, then the need for omitted fields
would decrease, because the user could eliminate unwanted fields using
a transform.  It is not uncommon for omitted fields to be computed.

5. Should absorb and compute types be stand-alone, or do they belong
   only in structs?

Compute should definitely also be in unions because it allows default
values.  Literals, which we are representing as absorbs in structs,
are also very useful in unions, although they have a very different
semantics.  In unions, they play the role of data constants, with only
the tag being recorded in the in-memory representation.  So I think
absorbs are also important in unions.

Absorbs are essentially also being used in array separators.

So, I think it is useful to have them as stand alone constructs.  Like
None, though, they'll be most useful in certain contexts, however.

6. If a field's constraint is violated, is its rep still valid?

I think I already addressed this question (see note "Wrapping values
in errors").  In this case, the pd should indicate a constraint error,
but the user should be able to get at the erroneous value somehow, if
only for debugging purposes.  The rep itself could be invalid if the
buggy value were carried in the pd or elsewhere.

10. Unions are brittle wrt errors. Lets examine min-error model as
    opposed to no-error model.(also array termination and
    separator). Also, consider how this clarifies need for distinction
    b/w panic and err.

Bugs:

8. We can prove that the parsers generated by the compiler always
   terminate. This was a problem in the original implementation of
   PADS for arrays, which would have been caught with a formal
   semantics.

9. I don't quite understand the semantics of array errors with regard
   to element errors. It seems like we only count an element error if
   it is the first error to occur. I understand why we would only
   count it once (i.e. exactly once), but why only count if its first
   (i.e. at most once)?  It seems a little arbitrary. Counting it
   exactly once would parallel the other types, if we consider the
   array data-structure (in the array rep) as one subelement of the
   rep. Then, if there are any element errors it counts as one error
   in the array pd.
 
