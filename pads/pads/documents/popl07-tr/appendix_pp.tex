%\newpage
\appendix
\section{Complete Syntax and Semantics of \ddc{}}
\label{app:ddc-semantics}
We first define the syntax of \ddc{} terms:

\begin{figure}
{\small
\begin{bnf}
  \name{Kinds} \meta{\gk} \::= \kty \| \ity \-> \gk 
                               \| \kty \-> \gk \\
  \name{Types} \meta{\ty} \::= 
           \pbase{e} \| \plam{\var}{\ity}{\ty} \| \papp{\ty}{e} 
    \nlalt \psig x \ty \ty \| \psum \ty e \ty \| \pset x \ty e  
    \nlalt \ptyvar       \| \pmu{\ptyvar}{\gk}{\ty} \| \ptylam{\ptyvar}{\kty}{\ty} \| \ptyapp{\ty}{\ty}
    \nlalt \pcompute e \ity \| \pabsorb \ty
    \nlalt \ptry{\tau} \| \ptransform{e}{\ty}{\ty}{e} \| \pkleene{\ty}{e}
\end{bnf}
}
\caption{\ddc{} Syntax}
\label{fig:complete-ddc-syntax}
\end{figure}

\noindent
\figref{fig:ddc-kinding} gives the complete kinding rules for the
system.

\begin{figure*}[t]
\small
\fbox{$\ddck[\ty,\pctxt;\ctxt,\kind,\mcon]$}\\[-2ex]
\[
\infer[\text{Const}]{
    \ddck[\pbase{e},\pctxt;\ctxt,\kty,\con]
  }{
    \begin{semcond}
      \wfd {} {\fotyc \pctxt,\ctxt} &
      \stsem[e,{\fotyc \pctxt,\ctxt},\ity] \\
      \vlet {\ity \iarrowi \kty} {\Ikind(C)}
    \end{semcond}
  }
\]

\[
\infer[\text{Abs}]{
    \ddck[\plam{\var}{\ity}{\ty},
         \pctxt;\ctxt,\ity \iarrowi \kind,\mcon]
  }{
    \ddck[\ty,\pctxt;\ectxt{\var{:}\ity},\kind,\mcon]
  }
\quad
\infer[\text{App}]{
  \ddck[\papp{\ty}{e},\pctxt;\ctxt,\gk,\mcon]
}{
  \ddck[\ty,\pctxt;\ctxt,\ity \iarrowi \gk,\mcon] &
  \stsem[e,{\fotyc \pctxt,\ctxt},\ity]
}
\]

\[
\infer[\text{Prod}]{
    \ddck[\psig{x}{\ty}{\ty'},\pctxt;\ctxt,\kty,\con]
  }{       
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] &
    \ddck[\ty',\pctxt;
          \ectxt {x{:}\iprod {\itsem[\ty]} 
              {\itpdsem[\ty]}},
          \kty,\mcon']
  }
\]

\[
\infer[\text{Sum}]{
    \ddck[\psum{\ty}{e}{\ty'},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] & \ddck[\ty',\pctxt;\ctxt,\kty,\mcon'] 
  }
\]

\[
  \infer[\text{Con}]{
    \ddck[\pset x \ty e,\pctxt;\ctxt,\kty,\con]
  }{ 
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] & 
    \stsem[e,
     {\fotyc \pctxt,
    \ectxt{x{:}\iprod{\itsem[\ty]} 
      {\itpdsem[\ty]}}},\iboolty]
  }
\]

\[
  \infer[\text{TyVar}]{
    \ddck[\ptyvar,{\pctxt;\ctxt},\kty,\ncon]
  }{\wfd {}{\fotyc \pctxt, \ctxt} \quad \tyvar{:}\kty \in \pctxt}
\quad
  \infer[\text{Rec}]{
    \ddck[\pmu \ptyvar \kty \ty,\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,{\pctxt,\ptyvar{:}\kty;\ctxt},\kty,\con]
  }
\quad
\infer[\text{TyAbs}]{
    \ddck[\ptylam{\tyvar}{\kty}{\ty},
         \pctxt;\ctxt,\kty \iarrowi \kind,\mcon]
  }{
    \ddck[\ty,{\pctxt,\tyvar{:}\kty;\ctxt},\kind,\mcon]
  }
\quad
\infer[\text{TyApp}]{
  \ddck[\ptyapp{\ty_1}{\ty_2},\pctxt;\ctxt,\gk,\mcon]
}{
  \ddck[\ty_1,\pctxt;\ctxt,\kty \iarrowi \gk,\mcon] &
  \ddck[\ty_2,\pctxt;\ctxt,\kty,\mcon]
}
\]



\[
  \infer[\text{Compute}]{       
    \ddck[\pcompute{e}{\ity},\pctxt;\ctxt,\kty,\con]
  }{
    \wfd {}{\fotyc \pctxt, \ctxt} &
    \stsem[e,{\fotyc \pctxt,\ctxt},\ity] & 
    \fomegak{\fortyc \pctxt}{\ity}{\kty}
  }      
\quad
\infer[\text{Absorb}]{
    \ddck[\pabsorb{\ty},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon]
  }
\]

\[
  \infer[\text{Try}]{       
    \ddck[\ptry{\ty},\pctxt; \ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon]
  }      
\quad
\infer[\text{Transform}]{
    \ddck[\ptransform{e_1}{\ty_1}{\ty_2}{e_2},\pctxt;\ctxt,\kty,\con]
  }{
    \begin{array}{c}
    \ddck[\ty_1,\pctxt;\ctxt,\kty,\mcon]\\
    \ddck[\ty_2,\pctxt;\ctxt,\kty,\mcon]\\
    \stsem[e_1,\ctxt,
    \iprod {\itsem[\ty_1]}      
           {\itpdsem[\ty_1]}
    \iarrowi \iprod {\itsem[\ty_2]}      
           {\itpdsem[\ty_2]}]\\
    \stsem[e_2,\ctxt,
    \iprod {\itsem[\ty_2]}      
           {\itpdsem[\ty_2]}
    \iarrowi \iprod {\itsem[\ty_1]}      
           {\itpdsem[\ty_1]}]
    \end{array}
  }
\]

\[
  \infer[\text{Kleene}]{
    \ddck[\pkleene{\ty}{e},\pctxt;\ctxt,\kty,\con]
  }{
    \begin{array}{c}
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon]\\
    \stsem[e,\ctxt,
    \iprod {\iseq{\itsem[\ty]}}
    {\iseq{\itpdsem[\ty]}}
    \iarrowi \iboolty]
    \end{array}
  }
\]


\caption{\ddc{} Kinding Rules}
\label{fig:ddc-kinding}
\end{figure*}

\noindent
The representation for each \ddc{} type $\tau$ are defined as follows:
\vskip 1ex

%\begin{figure}
\fbox{$\itsem[\ty] = \ity$}
\[
\begin{array}{lcl} 
\itsem[\pbase{e}] & = & \Irty(C) \\
\itsem[\plam{\var}{\ity}{\ty}] & = & \itsem[\ty] \\
\itsem[\papp \ty e] & = & \itsem[\ty] \\
\itsem[\psig \var {\ty_1} {\ty_2}]  & = & \iprod {\itsem[\ty_1]} {\itsem[\ty_2]}    \\
\itsem[\psum {\ty_1} e {\ty_2}]     & = & \isum {\itsem[\ty_1]} {\itsem[\ty_2]} \\
\itsem[\pset x \ty e] & = & \itsem[\ty]\\
\itsem[\ptyvar] & = & \ptyvar_\repname \\
\itsem[\pmu{\ptyvar}{\gk}{\ty}] & = & \imu{\ptyvar_\repname}{\itsem[\ty]} \\
\itsem[\lambda \ptyvar.\ty]     & = & \lambda \ptyvar_\repname.\itsem[\ty] \\
\itsem[\ty_1 \ty_2]             & = & \itsem[\ty_1] \itsem[\ty_2] \\
\itsem[\pcompute e \ity]                 & = & \ity \\
\itsem[\pabsorb \ty]                     & = & \iunitty \\
\itsem[\ptry{\ty}]    & = & \itsem[\ty] \\
\itsem[\ptransform{e_1}{\ty_1}{\ty_2}{e_2}] & = & \itsem[\ty_2]\\
\itsem[\pkleene{\ty}{e}] & = & \iseq{\itsem[\ty]}

%% \pext{
%% \itsem[\ptransform e e \ty]              & = & \itsem[\ty]\\
%% }
\end{array}
\]
%\caption{Representation Types}
%\label{fig:complete-rep-tys}
%\end{figure}

\noindent
The parse descriptor for each \ddc{} type $\tau$ are defined as follows:
\vskip 1ex

%\begin{figure}
\fbox{$\itpdsem[\ty] = \ity$}
\[ 
\begin{array}{lcl} 
%% %% example: \ua.(int * a) + None
%% %%          pd = \ua.pd_hdr  * ((pd_hdr * ([int]_pd * [a]_pd)) + [None]_pd)
%% %%             = \ua.pd_hdr  * ((pd_hdr * ([int]_pd * a)) + [None]_pd)
\itpdsem[\pbase{e}] & = & \ipty \iunitty\\
\itpdsem[\plam \var \ity \ty] & = & \itpdsem[\ty] \\
\itpdsem[\papp \ty e] & = & \itpdsem[\ty] \\
\itpdsem[\psig \var {\ty_1} {\ty_2}] & = & 
               \ipty {\iprod {\itpdsem[\ty_1]} {\itpdsem[\ty_2]}} \\
\itpdsem[\psum {\ty_1} e {\ty_2}] & = & 
               \ipty {(\isum {\itpdsem[\ty_1]} {\itpdsem[\ty_2]})} \\
\itpdsem[\pset x \ty e] & = & \ipty {\itpdsem[\ty]} \\
\itpdsem[\ptyvar] & = & \ipty{\ptyvar_\pdbname} \\
\itpdsem[\pmu \ptyvar \kty \ty] & = & 
  \ipty{\imu{\ptyvar_\pdbname}{\itpdsem[\ty]}} \\
\itpdsem[\lambda \ptyvar.\ty]      
     & = & \lambda \ptyvar_\pdbname.\itpdsem[\ty] \\
\itpdsem[\ty_1 \ty_2]            & = & \itpdsem[\ty_1] \itpdsemstrip[\ty_2] \\
\itpdsem[\pcompute e \ity]            & = & \ipty \iunitty \\
\itpdsem[\pabsorb \ty]                & = & \ipty \iunitty \\
\itpdsem[\ptry{\ty}]    & = & \itpdsem[\ty] \\
\itpdsem[\ptransform{e_1}{\ty_1}{\ty_2}{e_2}] & = & \itpdsem[\ty_2]\\
\itpdsem[\pkleene{\ty}{e}] & = & \iapty {\itpdsem[\ty]}
\end{array}
\]

\fbox{$\itpdsemstrip[\ty] = \ity$}

\[
\begin{array}{lcl} 
\itpdsemstrip[\ty] & = & \ity \ \ \mbox{where}\ \itpdsem[\ty] \equiv \ipty{\ity}
\end{array}
\]
%\caption{Parse-Descriptor Types}
%\label{fig:complete-pd-tys}
%\end{figure}

\vskip 1ex
\noindent
\figref{fig:ddc-parsing-sem} gives the parsing semantics for \ddc{} type $\tau$.
\vskip 1ex
\begin{figure*}
\small
\fbox{$\trans[\ty,\ctxt,\gk] = e$} 

\[
\begin{array}{l}
%% Const 
\trans[\pbase{e},\ctxt,\kty] =
  \lampair{\iapp {\iapp {\Iimp(C)} (e)} {\itup {\idata,\off}}}
\\[3pt] %\\
%% Abs 
\trans[\plam{\var}{\ity}{\ty},,] =
   \sfn{\nrm\var}{\ity}{\trans[\ty,\ectxt{\var{:}\ity},\kind]}
\\[3pt] %\\
%% App 
\trans[\papp{\ty}{e},\ctxt,\gk] =
  \trans[\ty,,] \sapp e  
\\[3pt]
%% Prod 
%\begin{array}{l}
\trans[\psig{x}{\ty}{\ty'},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampair{} \\
    \quad  \ilet {\spair<\off',r,p>} 
    {{\trans[\ty,,]} \sapp \spair<\idata,\off>} \\
    \quad  \ilet x {\ictup{r,p}}\\
    \quad  \ilet {\spair<\off'',r',p'>} 
    {{\trans[\ty',,]} \sapp \spair<\idata,\off'>} \\
    \quad \spair<\off'',\newrep {\gS}{r,r'},\newpd {\gS}{p,p'}>
  \end{array}  
%\end{array}
\\
%% Sum 
%\begin{array}{l}
  \trans[\psum{\ty}{e}{\ty'},,] = \\
  \begin{array}{l}  
  \lampair{} \\
  \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
  \quad \iif {\pdok p} \; \ithen {
    \def \r {\newrep {+left}{r}}
    \def \p {\newpd {+left}{p}}
    \ictup{\off',r,\p}} \\
  \quad \ielse {\ilet {\itup{\off',r,p}}{\trans[\ty',,] \sapp \spair<\idata,\off>}} \\
  \quad 
  {  % begin scope
    \def \r {\newrep {+right}{r}}
    \def \p {\newpd {+right}{p}}
    %% 
    \ictup{\off',r,\p}
  }\\ % end scope
  \end{array}
\\
%\quad
%% Set 
  \trans[\pset{x}{\ty}{e},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampair{} \\
    \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
    \quad \ilet x {\ictup{r,p}}\\
    \quad \ictup{\off',r,\newpd {con} {x,p}}
%%    \quad \spair<\off',r,\newpd {con} {x,p}>
  \end{array}
\\
%\end{array}
%\quad
%\begin{array}{l}
%% Var
\trans[\ptyvar,,] = \codefont{f_\ptyvar}
\\[3pt]
%% Mu
\trans[\pmu \ptyvar \gk \ty,,] = \\
  \begin{array}{l}
  \ifun {f_\ptyvar} {\itup{\data{:}\ibitsty,\off{:}\ioffty}  
           : \ioffty * \pmu \ptyvar \gk \itsem[\ty] 
                    * (\ipty{\pmu \ptyvar \kty \itpdsem[\ty]}) } {}\\
  \quad \ilet {\itup{\off',r,p}} 
   {\trans[\ty,,] \iappi \ictup{\data,\off}} \\ 
  \qquad \ictup{\off',\iroll{r}{\pmu \ptyvar \gk \itsem[\ty]},
     (p.h,\iroll{p}{\pmu \ptyvar \kty \itpdsem[\ty]})}
%}}
  \end{array}  
\\[3pt]
%% lambda \alpha
\trans[\lambda\tyvar . \ty,,] = %\\
%  \begin{array}{l}
    \Lambda \tyvar_\repname. 
    \Lambda \tyvar_\pdbname. \lambda \codefont{f_\ptyvar}. \trans[\ty,,]
%  \end{array}  
\\
%% t1 t2
\trans[\ty_1 \ty_2,,] = 
    \trans[\ty_1,,]\; [\itsem[\ty_2]]\; [\itpdsemstrip[\ty_2]]\; \trans[\ty_2,,]
\\
\end{array}
\begin{array}{l}
%% Compute
\trans[\pcompute e \ity,,] = \\
  \quad \lampair{\itup{\off,{\nrm e},\newpd {compute} \off}}
\\[3pt]
%% Absorb
\trans[\pabsorb \ty,,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \ilet {\itup {\off',r,p}} {\trans[\ty,,] \sapp \spair<\idata,\off>}\\
    \quad \itup{\off', \iuval,\newpd {absorb} p}   
  \end{array}  
\\
%% Try ty
\trans[\ptry \ty,,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \ilet {\itup {\off',r,p}} {\trans[\ty,,] \sapp \spair<\idata,\off>}\\
    \quad \ictup{\off,r,p}   
  \end{array}  
\\
%% Transform e1 ty1 ty2 e2
\trans[\ptransform{e_1}{\ty_1}{\ty_2}{e_2},,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \ilet {\itup {\off',r,p}} {\trans[{\ty_1},,] \sapp \spair<\idata,\off>}\\
    \quad \ilet {\itup {r',p'}}{\codefont{ e_1\, r\, p}}\\
    \quad \ictup{\off',r', p'}   
  \end{array}  
\\
%% Kleene 
\trans[\pkleene{\ty}{e},,] = \\
  \begin{array}{l}  
    \lampair{}\\
      \quad \iletfun {isDone}{\itup{\off',r,p}}{\\
        \qquad \ior {\eofpred {\idata,\off'}} {e\codefont {\sapp
          \spair<r,p>}} 
      }\\
      \quad \iin \\
      \quad \iletfun {continue} {\itup{\off,\off',r,p}} {\\
        \qquad \iif  {\off = \off' \iori \isdone {\off',r,p}} \; \ithen {\itup{\off',\codefont{r,p}}} \\
        \qquad \ielse {
               \ilet {\itup{\off_e,r_e,p_e}}{\trans[\ty,,] \sapp \ictup{\idata,\off'}}}\\
        \qquad \mathtt{continue} \sapp \ictup{
            \off,\off_e,\newrep {kleene} {r,r_e}, \newpd {kleene} {p, p_e}
        }}\\
      \quad \iin
   \end{array}\\
  \begin{array}{l}  
      \quad \ilet {\mathtt{r}} {\newrep {kleene\_init}{}}\\
      \quad \ilet {\mathtt{p}} {\newpd {kleene\_init}{\off}}\\
      \quad \iif {\isdone{\off,r,p}} \; \ithen {\itup{\off,\codefont{r,p}}}\\
      \quad \ielse {\ilet {\itup{\off_e,r_e,p_e}}{\trans[\ty,,] \sapp
          \spair<\idata,\off>}} \\
      \quad \mathtt{continue} \sapp \ictup{\off,\off_e,
        \newrep {kleene} {r,r_e}, \newpd {kleene} {p, p_e}}      
  \end{array}  
\\
\end{array}
\]
%\caption{\ddc{} Semantics (cont.)}
\caption{\ddc{} Parsing Semantics}
\label{fig:ddc-parsing-sem}
\end{figure*}

The type correctness theorem relies on base type parsers behaving
properly.  The following conditions make explicit the properties that
base type semantic functions must satisfy.
\begin{condition}[Conditions on Base-type Interfaces]
  \begin{enumerate}
  \item $\dom {\Ikind} = \dom {\Iimp}$.
  \item If $\Ikind(C) = {\ity \iarrowi \kty}$ then $\Iopty(C) =
    \ioparrow \ity {\kTrans[\kty,\pbase e]}$ (for any $e$).
  \item $\fomegak{}{\Irty(C)}{\kty}$.
    \label{cond:closed-op}
  \end{enumerate}
\end{condition}

\vskip 1ex
\noindent
\figref{fig:ddc-parsing-sem} gives the parsing semantics for \ddc{} type $\tau$.
\vskip 1ex
\begin{figure*}
\small
\fbox{$\trans[\ty,\ctxt,\gk] = e$} 

\[
\begin{array}{l}
%% Const 
\transpp[\pbase{e},\ctxt,\kty] =
  \lampppair{\iapp {\iapp {\Igen{pp}(C)} (e)} {\ictup {r,pd}}}
\\[3pt] %\\
%% Abs 
\transpp[\plam{\var}{\ity}{\ty},,] =
   \sfn{\nrm\var}{\ity}{\transpp[\ty,\ectxt{\var{:}\ity},\kind]}
\\[3pt] %\\
%% App 
\transpp[\papp{\ty}{e},\ctxt,\gk] =
  \transpp[\ty,,] \sapp e  
\\[3pt]
%% Prod 
%\begin{array}{l}
\transpp[\psig{x}{\ty}{\ty'},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampppair{} \\
      \quad  \ilet x {\ictup{\ipid{1}{r},\ipid{1}{\ipid{2}{pd}}}}\\
      \quad  \ilet {bs_1} 
%%    \def \rf {foo} %% {\ipid{1}{r}}
%%   \def \pf {bar} %% {\ipid{1}{\ipid{2}{pd}}}
%%  \def \rs {baz} %% {\ipid{2}{r}}
%% \def \ps {foo} %% {\ipid{2}{\ipid{2}{pd}}}
      {{\transpp[\ty,,]} \sapp \codefont{x}} \\
      \quad  \ilet {bs_2} 
      {{\transpp[\ty',,]} \sapp \spair<\ipid{2}{r},\ipid{2}{\ipid{2}{pd}}>} \\
      \quad \iappend{bs_1}{bs_2}
  \end{array}  
%\end{array}
\\
%% Sum 
%\begin{array}{l}
  \trans[\psum{\ty}{e}{\ty'},,] = \\
  \begin{array}{l}  
  \lampair{} \\
  \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
  \quad \iif {\pdok p} \; \ithen {
    \def \r {\newrep {+left}{r}}
    \def \p {\newpd {+left}{p}}
    \ictup{\off',r,\p}} \\
  \quad \ielse {\ilet {\itup{\off',r,p}}{\trans[\ty',,] \sapp \spair<\idata,\off>}} \\
  \quad 
  {  % begin scope
    \def \r {\newrep {+right}{r}}
    \def \p {\newpd {+right}{p}}
    %% 
    \ictup{\off',r,\p}
  }\\ % end scope
  \end{array}
\\
%\quad
%% Set 
  \trans[\pset{x}{\ty}{e},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampair{} \\
    \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
    \quad \ilet x {\ictup{r,p}}\\
    \quad \ictup{\off',r,\newpd {con} {x,p}}
%%    \quad \spair<\off',r,\newpd {con} {x,p}>
  \end{array}
\\
%\end{array}
%\quad
%\begin{array}{l}
%% Var
\trans[\ptyvar,,] = \codefont{f_\ptyvar}
\\[3pt]
%% Mu
\trans[\pmu \ptyvar \gk \ty,,] = \\
  \begin{array}{l}
  \ifun {f_\ptyvar} {\itup{\data{:}\ibitsty,\off{:}\ioffty}  
           : \ioffty * \pmu \ptyvar \gk \itsem[\ty] 
                    * (\ipty{\pmu \ptyvar \kty \itpdsem[\ty]}) } {}\\
  \quad \ilet {\itup{\off',r,p}} 
   {\trans[\ty,,] \iappi \ictup{\data,\off}} \\ 
  \qquad \ictup{\off',\iroll{r}{\pmu \ptyvar \gk \itsem[\ty]},
     (p.h,\iroll{p}{\pmu \ptyvar \kty \itpdsem[\ty]})}
%}}
  \end{array}  
\\[3pt]
%% lambda \alpha
\trans[\lambda\tyvar . \ty,,] = %\\
%  \begin{array}{l}
    \Lambda \tyvar_\repname. 
    \Lambda \tyvar_\pdbname. \lambda \codefont{f_\ptyvar}. \trans[\ty,,]
%  \end{array}  
\\
%% t1 t2
\trans[\ty_1 \ty_2,,] = 
    \trans[\ty_1,,]\; [\itsem[\ty_2]]\; [\itpdsemstrip[\ty_2]]\; \trans[\ty_2,,]
\\
\end{array}
\begin{array}{l}
%% Compute
\trans[\pcompute e \ity,,] = \\
  \quad \lampair{\itup{\off,{\nrm e},\newpd {compute} \off}}
\\[3pt]
%% Absorb
\trans[\pabsorb \ty,,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \ilet {\itup {\off',r,p}} {\trans[\ty,,] \sapp \spair<\idata,\off>}\\
    \quad \itup{\off', \iuval,\newpd {absorb} p}   
  \end{array}  
\\
%% Try ty
\trans[\ptry \ty,,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \ilet {\itup {\off',r,p}} {\trans[\ty,,] \sapp \spair<\idata,\off>}\\
    \quad \ictup{\off,r,p}   
  \end{array}  
\\
%% Transform e1 ty1 ty2 e2
\trans[\ptransform{e_1}{\ty_1}{\ty_2}{e_2},,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \ilet {\itup {\off',r,p}} {\trans[{\ty_1},,] \sapp \spair<\idata,\off>}\\
    \quad \ilet {\itup {r',p'}}{\codefont{ e_1\, r\, p}}\\
    \quad \ictup{\off',r', p'}   
  \end{array}  
\\
%% Kleene 
\trans[\pkleene{\ty}{e},,] = \\
  \begin{array}{l}  
    \lampair{}\\
      \quad \iletfun {isDone}{\itup{\off',r,p}}{\\
        \qquad \ior {\eofpred {\idata,\off'}} {e\codefont {\sapp
          \spair<r,p>}} 
      }\\
      \quad \iin \\
      \quad \iletfun {continue} {\itup{\off,\off',r,p}} {\\
        \qquad \iif  {\off = \off' \iori \isdone {\off',r,p}} \; \ithen {\itup{\off',\codefont{r,p}}} \\
        \qquad \ielse {
               \ilet {\itup{\off_e,r_e,p_e}}{\trans[\ty,,] \sapp \ictup{\idata,\off'}}}\\
        \qquad \mathtt{continue} \sapp \ictup{
            \off,\off_e,\newrep {kleene} {r,r_e}, \newpd {kleene} {p, p_e}
        }}\\
      \quad \iin
   \end{array}\\
  \begin{array}{l}  
      \quad \ilet {\mathtt{r}} {\newrep {kleene\_init}{}}\\
      \quad \ilet {\mathtt{p}} {\newpd {kleene\_init}{\off}}\\
      \quad \iif {\isdone{\off,r,p}} \; \ithen {\itup{\off,\codefont{r,p}}}\\
      \quad \ielse {\ilet {\itup{\off_e,r_e,p_e}}{\trans[\ty,,] \sapp
          \spair<\idata,\off>}} \\
      \quad \mathtt{continue} \sapp \ictup{\off,\off_e,
        \newrep {kleene} {r,r_e}, \newpd {kleene} {p, p_e}}      
  \end{array}  
\\
\end{array}
\]
%\caption{\ddc{} Semantics (cont.)}
\caption{\ddc{} Printing Semantics}
\label{fig:ddc-printing-sem}
\end{figure*}


\section{Host Language}
\label{app:host-lang}

%\begin{figure}[tp]
\small
\begin{bnf}
%   \name{Variables} \meta{f,x,y} \\
%   \name{Bit}   \meta{b}   \::= 0 \| 1 \\ 
  \name{Bits}  \meta{B}   \::= \cdot \| 0\,B \| 1\,B \\ 
  \name{Constants} \meta{c} \::=
      () \| \itrue \| \ifalse \| 0 \| 1 \| -1 \| \dots \nlalt
      \ierr \| \data \| \off \| \iok \| \iecerr \| \iecpc \| \ldots \\

  \name{Values} \meta{v} \::= 
      \const \| % \ilam{\nrm \var}{\ity}{e} \| 
      \ifun {\nrm f} {\nrm x} e \| \ipair v v \nlalt
      \iinld{\ity}{v} \| \iinrd{\ity}{v} \|
      \iarr{\vec{v}} \\

  \name{Operators} \meta{op} \::= 
      = \; \| \; < \; \| \inotop % \| \isizeofop
      \| \ldots \\

  \name{Expressions} \meta{e} \::= 
      \const \| \var \| \iop{e} \|
%      \ilam {\nrm \var} \ity e \| 
      \ifun {\nrm f} {\nrm x} e \| 
      \iapp e e \nlalt
    \Lambda \alpha.e \| e \; [\ty] \nlalt
%      \iletfun {\nrm f} {\nrm x} e \; \iin \; e' \| 
      \ilet {\nrm x} e \; e \|
      \iif e \; \ithen e \; \ielse e \nlalt
      \ipair{e}{e} \| \ipi {\nrm i}{e} \|
      \iinld{\ity}{e} \| \iinrd{\ity}{e} \nlalt
      \icaseg{e}{\nrm x}{e}{\nrm x}{e} \nlalt
      \iarr{\vec e} \| \iappend e e \| \isub e {\nrm e} \nlalt
      \iroll{e}{\mu\alpha.\tau} \| \iunroll{e}{\mu\alpha.\tau}
      \\
      
  \name{Base Types} \meta{a} \::= 
      \iunitty \| \iboolty \| \iintty  \| 
      \invty \nlalt  \ibitsty \| \ioffty \| \iecty
  \\
  \name{Types} \meta{\ity} \::= 
      \ibasety \| \ityvar \| \iarrow \ity \ity \| \iprod \ity \ity \|
      \isum \ity \ity \nlalt
      \iseq \ity \| \forall \ityvar.\ity  \|
      \imu \ityvar \ity   
      \| \lambda \alpha.\ity 
      \| \ity \; \ity
  \\
  \name{Kinds} \meta{\kappa} \::= \kty \| \kappa \rightarrow \kappa
  
\end{bnf}
%\caption{\Implang{} Language: F$^\omega$}
%\label{fig:implang-syntax}
%\end{figure}

\section{Helper Functions}
\label{app:asst-functions}

\trversion{
%% Maps pads base types to implementation language base types
\begin{description}
\item $\Ikind : {Const} \rightarrow {Kind}$.
\item $\Irty : {Const} \rightarrow {Type}$.
% \item $\Ipdty : {Const} \rightarrow {Type}$.
\item $\Iimp : {Const} \rightarrow {Expression}$.
\end{description}
}

% In defining the parsing functions, we use the following helper functions:

Generic Helpers:

{\small
\begin{itemize}
\renewcommand{\labelitemi}{}
%\begin{description}
\item $\codefont {Eof} : \ibitsty \iprodi \ioffty \iarrowi \iboolty$

\item $\codefont{scanMax} : \iintty$

\item $\ifun {max} {\ictup{m,n}} {\codefont{\iif {m>n}\; \ithen m\; \ielse n}}$
\item $\ifun {pos} n {\codefont{\iif {n=0}\; \ithen 0\; \ielse 1}}$
\item $\ifun {isOk} p {\codefont{pos(p.h.nerr) = 0}}$
\item $\ifun {isErr} p {\codefont{pos(p.h.nerr) = 1}}$

\item $\ifun {max\_ec} {\ictup{ec_1, ec_2}} {}$ \\
  $\begin{array}{l}
    \iif {\codefont{ec_1} = \iecpc \iori \codefont{ec_2} = \iecpc}\; \ithen \iecpc \\
    \ielse{} \iif {\codefont{ec_1} = \iecerr \iori \codefont{ec_2} = \iecerr}\; \ithen \iecerr \\
    \ielse \iok
   \end{array}$
\end{itemize}
%\end{description}
}

% We define for each \ddc{} type a pair of constructor functions, one to build a representation and another to build a parse descriptor.
% The type of PD headers is $\iintty
%   \iprodi \iecty \iprodi \ispty$. We refer to the projections using
%   dot notation as $\codefont{nerr}$, $\codefont{ec}$ and
%   $\codefont{sp}$, respectively. A span is a pair of offsets, referred
%   to as $\codefont{begin}$ and $\codefont{end}$, respectively. Array
%   bodies have type $\iintty \iprodi \iintty \iprodi (\iseq \ity)$ (for
%   element type $\ity$). We refer to the projections as
%   $\codefont{neerr}$, $\codefont{length}$ and $\codefont{elts}$,
%   respectively.  

\noindent
Type-Specific Helpers:

{\small
\begin{itemize}
\renewcommand{\labelitemi}{}

\item %[Pair:]
\item $\ifun {R_{\gS}} {\ipair {r_1} {r_2}} {\itup {\codefont{r_1,r_2}}}$
\item $\ifun{H_{\gS}} {\ictup{h_1,h_2}}{}$ \\
  $\begin{array}{l}
    \ilet {nerr} {\codefont{pos \itup{{h_1}.{nerr}} + pos \itup{{h_2}.{nerr}}}}\\
    \ilet {ec} {\iif {\codefont{h_2.ec} = \iecpc}\; \ithen {\iecpc}\\
    \quad \ielse {\codefont{max\_ec} \iappi \codefont{h_1.ec} \iappi \codefont{h_2.ec}}} \\
    \ilet {sp} {\ictup{h_1.sp.begin, h_2.sp.end}} \\
    \quad \ictup {nerr,ec,sp}
  \end{array}$

\item $\ifun {P_{\gS}} {\ictup{p_1, p_2}} {\ictup {H_{\gS} \itup{p_1.h,p_2.h},\itup{p_1,p_2}}}$

\item %[Sum:]
\item $\ifun {H_+} h {\ictup{pos(h.nerr),h.ec,h.sp}}$
\item $\ifun {P_{+left}} p {\ictup{\codefont{H_+} \iappi p.h, \iinl p}}$
\item $\ifun {P_{+right}} p {\ictup{\codefont{H_+} \iappi p.h, 
      \iinr  p}}$

\item %[Set:]
\item $\ifun {P_{con}} {\ictup {c, p}} {}$ \\
    $\begin{array}{l}
      \iif {\codefont c} \; \ithen {\ictup{(pos(p.h.nerr),p.h.ec,p.h.sp),p}} \\
      \ielse {\ictup {(1 + pos(p.h.nerr),\maxec \iecerr {p.h.ec},p.h.sp),p}}
    \end{array}$
%% \end{itemize}

%% \begin{itemize}
%% \renewcommand{\labelitemi}{}
\item %[Compute:]
\item $\ifun{P_{compute}} \off {\ictup{\itup{0,\iok,\ipair \off \off},\iuval}}$

\item %[Absorb:]
\item $\ifun {P_{absorb}} p {\ictup{p.h,\iuval}}$

\item %[Kleene:] 
\item $\ifun {R_{kleene\_init}} {\iuval} {\ieseq}$   
\item $\ifun {P_{kleene\_init}} \off {\ictup{(0,\iok,\ipair \off
      \off),(0,0,\ieseq)}}$

\item $\ifun {R_{kleene}} {\ictup{r, r_e}} 
  {\iappend{r.elts} {\iarr{r_e}}}$
\item $\ifun {H_{kleene}} {\ictup{h, h_s, h_e}} {}$ \\
  $\begin{array}{l}
      \ilet {eerr} {
        \codefont{\iif {h.neerr = 0 \mathrel{and} h_e.nerr > 0}}\\
        \codefont{\quad \ithen 1 \;  \ielse 0}
      }\\
      \ilet {nerr} {\codefont{h.nerr + pos(h_s.nerr) + eerr}}\\
      \ilet {ec} {\iif{\codefont{h_e.ec} = \iecpc}\; \ithen {\iecpc}\\
      \quad \ielse{\maxec {\codefont{h.ec}} {\codefont{h_e.ec}}
          }} \\
      \ilet {sp} {\ictup{h.sp.begin,h_e.sp.end}} \\
      \quad \ictup {nerr,ec,sp}
    \end{array}$

\item $\ifun{P_{kleene}} {\ictup{p, p_s, p_e}}{}$ \\ 
  $\begin{array}{l}
    \codefont{(H_{kleene} \iappi \itup{p.h,p_s.h,p_e.h},}\\ 
    \codefont{\itup{p.neerr + pos(p_e.h.nerr), p.len + 1,\iappend {p.elts}
        {\iarr{p_e}}})}
  \end{array}$

\end{itemize}
}
\trversion{
\begin{lemma}[Function Types]
  $\stsem[\codefont{isOk},
  \codefont{pos}{:}\iintty \iarrowi \iintty,
  \forall \ga.\ipty \ga \iarrowi \iboolty]$.
\end{lemma}
}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "semantics"
%%% End: 
