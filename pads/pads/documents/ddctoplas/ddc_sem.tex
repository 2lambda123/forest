\section{\ddc{} Semantics}
\label{sec:ddc-sem}


At first glance, the primitives of \ddc{} are deceptively simple.  
However, deeper thought reveals
that their semantics is multifaceted. For example, each basic type
simultaneously describes a
collection of valid bit strings, two datatypes in the host language --
one for the data representation itself and one for its parse
descriptor -- and a transformation from bit strings, including
invalid ones, into data and corresponding metadata. 

% There are multiple facets to the semantics of every description in the \ddc{}.
% For example, every basic description
% simultaneously describes (1) a collection of valid bit strings, (2) two
% datatypes in the host language -- one for the data representation
% itself and one for its parse descriptor -- and (3) a transformation from
% bit strings, including invalid ones, into data and corresponding
% metadata.  Type and value abstractions also have multiple different
% semantic interpretations:  (1) functions that generate sets of bit strings,
% (2) representation and parse descriptor types in the host language, and
% (3) functions of the generate parsers.

We give semantics to \ddc{} types using three primary
semantic functions, each
of which precisely conveys a particular facet of a type's meaning.
The functions $\itsem[\cdot]$ and $\itpdsem[\cdot]$ describe the {\it
  representation semantics} of \ddc{}, detailing the types of the
data's in-memory representation and parse descriptor. The function
$\trans[\cdot,,]$ describes the {\it parsing semantics} of \ddc{},
defining a \implang{} language function for each type that parses bit
strings to produce a representation and parse descriptor. We define
the set of valid bit strings for each type to be those strings for
which the PD indicates no errors when parsed.  In addition to these
three semantic functions, we define a normalization relation,
which facilitates reasoning about parameterized descriptions.

We begin the technical discussion by describing
a kinding judgment that checks if a type is well formed
--- the other semantic functions
should only be applied to well-formed \ddc{} types.
We then specify the normalization relation after which we formalize
the three-fold semantics of \ddc{} types.  For reference,
\tblref{tab:judg-list} lists all the functions and judgments defined
in this section and a brief description of each. Additionally,
\tblref{tab:fomega-judg-list} lists all of the \fomega{} judgments
that we reference.



% % \ddc{} abstractions are a special case of \ddc{} types in that they do
% % not directly describe data, but rather are conventional functions that
% % operate over descriptions.
% % Therefore, the meaning \ddc{} abstractions (and applications) can be expressed
% % independently of any particular semantic interpretation of \ddc{}. We
% % do so with a small-step \textit{normalization} judgment $\ty \stepsto
% % \ty'$.  
% % %\edcom{M: Explain that also interpet them in other judgments, and
% % %  explain why.}
% % However, despite our assigning them a semantics with the normalization
% % judgment, we still interpret them in the other semantic
% % interpretations of \ddc.  We do so because the implementations of
% % \padsc\ and \padsml\ do not normalize types before translating them,
% % but, rather, translate abstraction and application directly into the
% % host language. The role of normalization, then, is only to provide
% % users with a simple and direct explanation of the meaning of
% % abstraction and application.

\edcom{TP: Put two tables side by side.}
\begin{table}
  \begin{center}
    \renewcommand{\arraystretch}{1.35}
    \begin{tabular}{l l}
      $\ddck[\ty,{\pctxt;\ctxt},\kind,\mcon]$ & {\it type
        kinding}\\
      $\ty \stepsto \ty'$ & {\it type normalization}\\
      $\itsem[\ty] = \ity$ & {\it representation-type interpretation of \ddca{}}\\
      $\itpdsem[\ty] = \ity$ & {\it parse-descriptor type  interpretation of \ddca{}}\\
      $\itpdsemstrip[\ty] = \ity$ & {\it pd-body type interpretation of \ddca{}}\\
      $\trans[\ty,\ctxt,\gk] = e$   & {\it parsing semantics of
        \ddca{}} \\
      $\kTrans[\gk,\ty] = \ity$     & {\it \fomega\ type of specified
        type's parsing function (parser-type)} \\
      $\ptyc \pctxt = \ctxt$     & {\it parser-type interpretation lifted to
        entire context }\\
      $\fotyc \pctxt = \ctxt$     & {\it \fomega{} image of \ddc{} type context }\\
      $\fortyc \pctxt = \ctxt$     & {\it representation-type variables in $\fotyc \pctxt$ }\\
      $\fopdtyc \pctxt = \ctxt$     & {\it parse-descriptor type variables in $\fotyc \pctxt$ }\\
      %$\stsem[e,\pctxt;\ctxt,\ity]$ & {\it \fomega expression typing} \\
    \end{tabular}
    \caption{\ddc{} functions and judgments defined in this section.}
    \label{tab:judg-list}
  \end{center}
\end{table}
\begin{table}
  \begin{center}
    \renewcommand{\arraystretch}{1.35}
    \begin{tabular}{l l}
      $\wfd {}{\ctxt}$ & {\it well-formed contexts}\\
      $\wfty \ctxt \ity \kind$ & {\it well-formed types}\\
      $\ity \equiv \ity'$ & {\it type equivalence}\\
      $\stsem[e,\ctxt,\ity]$ & {\it expression typing}\\
      $e \stepsto e'$ & {\it expression evaluation}
    \end{tabular}
    \caption{\fomega{} judgments referenced in this section.}
    \label{tab:fomega-judg-list}
  \end{center}
\end{table}

\subsection{\ddc{} Kinding}
\label{sec:ddc-kinding}

\begin{figure*}[t]
\small
\fbox{$\ddck[\ty,\pctxt;\ctxt,\kind,\mcon]$}\\[-2ex]
\[
\infer[\textsc{Unit}]{
    \ddck[\ptrue,\pctxt;\ctxt,\kty,\con]
  }{\wfd {} {\fotyc \pctxt,\ctxt}}
\quad 
\infer[\textsc{Bottom}]{
    \ddck[\pfalse,\pctxt;\ctxt,\kty,\con]
  }{\wfd {} {\fotyc \pctxt, \ctxt}}
\quad 
\infer[\textsc{Const}]{
    \ddck[\pbase{e},\pctxt;\ctxt,\kty,\con]
  }{
    \begin{semcond}
      \wfd {} {\fotyc \pctxt,\ctxt} &
      \stsem[e,{\fotyc \pctxt,\ctxt},\ity] \\
      \vlet {\ity \iarrowi \kty} {\Ikind(C)}
    \end{semcond}
  }
\]

\[
\infer[\textsc{Abs}]{
    \ddck[\plam{\var}{\ity}{\ty},
         \pctxt;\ctxt,\ity \iarrowi \kind,\mcon]
  }{
    \ddck[\ty,\pctxt;\ectxt{\var{:}\ity},\kind,\mcon]
  }
\quad
\infer[\textsc{App}]{
  \ddck[\papp{\ty}{e},\pctxt;\ctxt,\gk,\mcon]
}{
  \ddck[\ty,\pctxt;\ctxt,\ity \iarrowi \gk,\mcon] &
  \stsem[e,{\fotyc \pctxt,\ctxt},\ity]
}
\]

\[
\infer[\textsc{DepSum}]{
    \ddck[\psig{x}{\ty}{\ty'},\pctxt;\ctxt,\kty,\con]
  }{       
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] &
    \ddck[\ty',\pctxt;
          \ectxt {x{:}\iprod {\itsem[\ty]} 
              {\itpdsem[\ty]}},
          \kty,\mcon']
  }
\]

\[
\infer[\textsc{Sum}]{
    \ddck[\psum{\ty}{e}{\ty'},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] & \ddck[\ty',\pctxt;\ctxt,\kty,\mcon'] 
  }
\quad
  \infer[\textsc{Intersection}]{
    \ddck[\pand \ty {\ty'},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] & \ddck[\ty',\pctxt;\ctxt,\kty,\mcon'] 
  }
\]

\[
  \infer[\textsc{Con}]{
    \ddck[\pset x \ty e,\pctxt;\ctxt,\kty,\con]
  }{ 
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] & 
    \stsem[e,
     {\fotyc \pctxt,
    \ectxt{x{:}\iprod{\itsem[\ty]} 
      {\itpdsem[\ty]}}},\iboolty]
  }
\]

\[\infer[\textsc{Seq}]{
    \ddck[\pseq \ty {\ty_s} {\pterm e {\ty_t}},\pctxt;\ctxt,\kty,\con]
  }{
    \begin{array}{c}
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon] \qquad
    \ddck[{\ty_s},\pctxt;\ctxt,\kty,\mcon_s] \qquad
    \ddck[{\ty_t},\pctxt;\ctxt,\kty,\mcon_t] \\
    \stsem[e,{\fotyc \pctxt,\ctxt},
    \iprod {\itsem[{\ty_m}]}      
    {\itpdsem[{\ty_m}]}
    \iarrowi \iboolty]
    \quad (\ty_m = \pseq \ty {\ty_s} {\pterm e {\ty_t}})
    \end{array}
  }
\]

\[
  \infer[\textsc{TyVar}]{
    \ddck[\ptyvar,{\pctxt;\ctxt},\kty,\ncon]
  }{\wfd {}{\fotyc \pctxt, \ctxt} \quad \tyvar{:}\kty \in \pctxt}
\quad
  \infer[\textsc{Rec}]{
    \ddck[\pmu \ptyvar \kty \ty,\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,{\pctxt,\ptyvar{:}\kty;\ctxt},\kty,\con]
  }
\quad
\infer[\textsc{TyAbs}]{
    \ddck[\ptylam{\tyvar}{\kty}{\ty},
         \pctxt;\ctxt,\kty \iarrowi \kind,\mcon]
  }{
    \ddck[\ty,{\pctxt,\tyvar{:}\kty;\ctxt},\kind,\mcon]
  }
\]

\[
\infer[\textsc{TyApp}]{
  \ddck[\ptyapp{\ty_1}{\ty_2},\pctxt;\ctxt,\gk,\mcon]
}{
  \ddck[\ty_1,\pctxt;\ctxt,\kty \iarrowi \gk,\mcon] &
  \ddck[\ty_2,\pctxt;\ctxt,\kty,\mcon]
}
\quad
  \infer[\textsc{Compute}]{       
    \ddck[\pcompute{e}{\ity},\pctxt;\ctxt,\kty,\con]
  }{
    \wfd {}{\fotyc \pctxt, \ctxt} &
    \stsem[e,{\fotyc \pctxt,\ctxt},\ity] & 
    \fomegak{\fortyc \pctxt}{\ity}{\kty}
  }      
\]

\[
\infer[\textsc{Absorb}]{
    \ddck[\pabsorb{\ty},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon]
  }
\quad
  \infer[\textsc{Scan}]{
    \ddck[\pscan{\ty},\pctxt;\ctxt,\kty,\con]
  }{
    \ddck[\ty,\pctxt;\ctxt,\kty,\mcon]
  }
\]
\caption{\ddca{} kinding rules}
\label{fig:ddca-kinding}
\end{figure*}

The kinding judgment defined in \figref{fig:ddca-kinding} determines
well-formed \ddc{} types. We use two contexts to express our kinding
judgment:
\[
\begin{array}{ll}
\ctxt  & \mathrel{::=} \cdot \bnfalt \ctxt,{\var{:}\ity}\\
\pctxt  & \mathrel{::=} \cdot \bnfalt \pctxt,\tyvar{:}\kty
\end{array}
\]

Context $\Gamma$ is a finite partial map that binds expression
variables to their types. When appearing in \fomega{} judgments, such
contexts may also contain type-variable bindings of the form $\ityvar{::}\kind$.
Context $\pctxt$ is a finite partial map that binds type
variables to their kinds. We provide the following mappings from
\ddc{} contexts $\pctxt$ to \fomega{} contexts $\ctxt$.
\begin{align*}
&\fortyc {\cdot} = \cdot & &\fopdtyc {\cdot} = \cdot \\
&\fortyc {\pctxt,\ptyvar{:}\kty} = \fortyc \pctxt, \ptyvar_\repname
{\mathrel{::}} \kty 
&
&\fopdtyc {\pctxt,\ptyvar{:}\kty} = \fopdtyc \pctxt, \ptyvar_\pdbname
{\mathrel{::}} \kty
\end{align*}
Translation $\fotyc
\pctxt$ simply combines the two ($\fotyc \pctxt = \fortyc \pctxt,
\fopdtyc \pctxt$). These translations are used when checking the
well-formedness of contexts $\ctxt$ and types $\ity$ with open type
variables.

As the rules are mostly straightforward, we highlight just a few of
them. In rule \textsc{Base}, we use the function $\Ikind$ to assign
kinds to base types.  Base types must be fully applied to arguments of
the right type.  Once fully applied, all base types have kind $\kty$.
Rule \textsc{DepSum}, for dependent sums, shows that the name of the first component is
bound to a pair of a representation and corresponding PD.  The
semantic functions defined in the next section determine the type of
this pair. Type abstractions and recursive types (rules \textsc{TyAbs}
and \textsc{Rec}) restrict their type
variable to kind $\kty$. This restriction simplifies the metatheory
of \ddc{} with little practical impact.
%In future work, we intend to explore the ramifications of lifting this restriction.  
Finally, with the introduction of potentially open \implang types, we
must now check in rule \textsc{Compute} that the only (potentially)
open type variables in $\ity$ are the representation-type variables
bound (implicitly) in $\pctxt$.

%\edcom{M: Transition: In earlier work~\cite{popl}, we defined a
%  preliminary data description calculus \ddcold. ...}
At the beginning of this chapter, we mentioned that \ddc\ is an
extension and improvement of our prior work on \ddcold. The
improvements relate to changes in the kinding rules. In particular, we
have replaced the context $M$ of \ddcold{}, which mapped
recursive-type variables to their definitions, with a simpler context
$\pctxt$ which merely assigns a kind (always $\kty$) to open type
variables.  The type variables bound by recursive types are now
treated as abstract, just like the type variables bound by type
abstractions.  Correspondingly, the rule for type variables
(\textsc{TyVar}) now has a standard form, and the premise of the rule
for recursive types (\textsc{Rec}) is now nearly identical to the
premise of the rule for type abstractions (\textsc{TyAbs}).

\subsection{\ddc{} Normalization}
\label{sec:ddc-norm}

\begin{figure}
\begin{bnf}
  \mname{Normal\\ Types}{2} \meta{\tyval} \::= 
    \ptrue\| \pfalse \| \pbase{e} \| \plam{\var}{\ity}{\ty} \|
    \psig x \ty \ty  \nlalt
    \psum \ty e \ty  \| \pand \ty \ty \|
    \pset x \ty e \|
    \pseq \ty \ty {\pterm e \ty} \nlalt
    \pmu{\ptyvar}{}{\ty}  \| \plam{\ptyvar}{}{\ty} \nlalt
    \pcompute e \ity \| \pabsorb \ty \| \pscan{\ty} 
    \\
  \name{Types} \meta{\ty} \::= \tyval \| \papp{\ty}{e} \|
                               \papp{\ty}{\ty} \| \ptyvar
\end{bnf}
  \caption{Revised \ddc{} Syntax}
  \label{fig:revised-ddc-syntax}
\end{figure}

\begin{figure}
\[
  \infer{
    \papp {\ty} {e} \stepsto \papp {\ty'} {e}
  }{
    \ty \stepsto \ty'
  }
\quad
  \infer{
    \papp {\tyval} {e} \stepsto \papp {\tyval} {e'}
  }{
    e \stepsto e'
  }
\quad
  \infer{
    \papp {(\plam x {} \ty)} {v} \stepsto \ty[v/x]
  }{}
\]
\[
  \infer{
    \papp {\ty_1} {\ty_2} \stepsto \papp {\ty_1'} {\ty_2}
  }{
    \ty_1 \stepsto \ty_1'
  }
\quad
  \infer{
    \papp {\tyval} {\ty} \stepsto \papp {\tyval} {\ty'}
  }{
    \ty \stepsto \ty'
  }
\quad
  \infer{
    \papp {(\plam \ptyvar {} \ty)} {\tyval} \stepsto \ty[\tyval/\ptyvar]
  }{}
\]
  \caption{\ddc{} weak-head normalization}
  \label{fig:ddc-reduction-rules}
\end{figure}

To specify the rules of normalization, we must first refactor
the syntax of \ddc{} by distinguishing the subset of weak-head normal
types ($\tyval$) from all types $\ty$, as shown
in \figref{fig:revised-ddc-syntax}.
%\edcom{M: Define latter three together as abbreviation, and use special
%  symbols, like <t/x>}
In addition, we must define type and value substitution for \ddc{}.
The notation $\ty'[\ty/\ptyvar]$ denotes standard capture-avoiding
substitution of types into types,
except for constructs that contain an \fomega\ expression $e$ or type
$\ity$. For those constructs, the alternative substitution $\xsub \ty
\ptyvar$ is applied to the subcomponent expression or type. For
example, 
\[
\pcompute e \ity \subst \ty \ptyvar = \pcompute {e\xsub \ty \ptyvar\;}
{\;\ity \xsub \ty \ptyvar}.
\] 
This definition of substitution derives from the kinding rules of
\ddc{}. In a judgment
$\ddck[\ty,{\pctxt,\ptyvar{:}\kty;\ctxt},\kind,]$, the \ddc{} type
variable $\ptyvar$ implicitly binds the \fomega{} type variables
$\tyvar_\repname$ and $\tyvar_\pdbname$ for any types in $\ctxt$.
Therefore, when replacing $\ptyvar$ in a \ddc\ type, we must also make
sure to replace all type variables $\tyvar_\repname$ and
$\tyvar_\pdbname$ in constituent \fomega\ expressions and types in a
consistent manner. We denote standard capture-avoiding substitution of terms in \ddc\
types with $\ty[\ivaln/\ivarn]$. Similarly, $\kind\subst \ity \ityvar$
denotes standard capture-avoiding substitution of \fomega\ types into
\ddc\ kinds.

Normalization of \ddc{} is based on a standard call-by-value
small-step semantics of the lambda calculus. We present the rules of
the normalization judgment in \figref{fig:ddc-reduction-rules}.

\subsection{Representation Semantics}
\label{sec:intty-sem}

\begin{figure}
\fbox{$\itsem[\ty] = \ity$}
\[
\begin{array}{lcl} 
\itsem[\ptrue] & = & \iunitty \\
\itsem[\pfalse] & = & \invty \\
\itsem[\pbase{e}] & = & \isum {\Irty(C)} \invty   \\
\itsem[\plam{\var}{\ity}{\ty}] & = & \itsem[\ty] \\
\itsem[\papp \ty e] & = & \itsem[\ty] \\
\itsem[\psig \var {\ty_1} {\ty_2}]  & = & \iprod {\itsem[\ty_1]} {\itsem[\ty_2]}    \\
\itsem[\psum {\ty_1} e {\ty_2}]     & = & \isum {\itsem[\ty_1]} {\itsem[\ty_2]} \\
\itsem[\pand {\ty_1} {\ty_2}]  & = & \iprod {\itsem[\ty_1]}{\itsem[\ty_2]}\\
\itsem[\pset x \ty e] & = & \isum {\itsem[\ty]}{\itsem[\ty]}\\
% field names: length, elts
\itsem[\pseq \ty {\ty_{\text{sep}}} {\pterm e {\ty_{\text{term}}}}] & = & 
    \iprod \iintty {(\iseq{\itsem[\ty]})}             \\
\itsem[\ptyvar] & = & \ptyvar_\repname \\
\itsem[\pmu{\ptyvar}{\gk}{\ty}] & = & \imu{\ptyvar_\repname}{\itsem[\ty]} \\
\itsem[\lambda \ptyvar.\ty]       & = & \lambda \ptyvar_\repname.\itsem[\ty] \\
\itsem[\ty_1 \ty_2]              & = & \itsem[\ty_1] \itsem[\ty_2] \\
\itsem[\pcompute e \ity]                 & = & \ity \\
\itsem[\pabsorb \ty]                     & = & \isum \iunitty \invty \\
\itsem[\pscan \ty] & = & \isum {\itsem[\ty]} \invty
\end{array}
\]
\caption{Representation-type interpretation function.}
\label{fig:rep-tys}
\end{figure}

%\edcom{TP: This paragraph is verbose/redundant.  Revised.}
In Figure~\ref{fig:rep-tys}, we present the representation type of
each \ddc{} primitive. While the primitives are dependent types, the
\implang{} does not have such types, so the translation erases all
dependency. Removing expressions from the types renders variable
binding and application useless, so we drop those forms as well.
Consequently, we translate abstraction and application according to their
underlying types. 

In more detail, the \ddc{} type $\ptrue$ consumes no input and
produces only the $\iunitty$ value.  Correspondingly, $\pfalse$
consumes no input, but uniformly fails, producing the value $\invty$.
The function $\Irty$ maps each base type to a representation for
successfully parsed data. Note that this representation does not
depend on the argument expression. As base type parsers can fail, we
sum this type with $\invty$ to produce the actual representation type.
Intersection types produce a pair of values, one for each sub-type,
because the representations of the subtypes need not be identical nor
even compatible.  Constrained types produce sums, where a left branch
indicates the data satisfies the constraint and the right indicates it
does not. In the latter case, the parser returns the offending data
rather than $\ierr$ because the error is semantic rather than
syntactic.  Sequences produce a \implang{} language sequence paired
with its length.  

A type variable $\ptyvar$ in \ddca{} is mapped to a
corresponding type variable $\ptyvar_\repname$ in \fomega{}.
Recursive types generate recursive representation types with the type
variable named appropriately. Polymorphic types and their application
become \fomega{} type constructors and type application, respectively.
The output of a $\pcomputen$ is exactly the computed value, and
therefore shares its type.  The output of $\pabsorbn$ is a sum
indicating whether parsing the underlying type succeeded or failed.
The type of $\pscann$ is similar, but also returns an element of the
underlying type in case of success.

\begin{figure}
\fbox{$\itpdsem[\ty] = \ity$}
\[ 
\begin{array}{lcl} 
%% %% example: \ua.(int * a) + None
%% %%          pd = \ua.pd_hdr  * ((pd_hdr * ([int]_pd * [a]_pd)) + [None]_pd)
%% %%             = \ua.pd_hdr  * ((pd_hdr * ([int]_pd * a)) + [None]_pd)
\itpdsem[\ptrue] & = & \ipty \iunitty \\                                                  
\itpdsem[\pfalse] & = & \ipty \iunitty \\                                                  
\itpdsem[\pbase{e}] & = & \ipty \iunitty\\
\itpdsem[\plam \var \ity \ty] & = & \itpdsem[\ty] \\
\itpdsem[\papp \ty e] & = & \itpdsem[\ty] \\
\itpdsem[\psig \var {\ty_1} {\ty_2}] & = & 
               \ipty {\iprod {\itpdsem[\ty_1]} {\itpdsem[\ty_2]}} \\
\itpdsem[\psum {\ty_1} e {\ty_2}] & = & 
               \ipty {(\isum {\itpdsem[\ty_1]} {\itpdsem[\ty_2]})} \\
\itpdsem[\pand {\ty_1} {\ty_2}] & = & \ipty {\iprod {\itpdsem[\ty_1]} {\itpdsem[\ty_2]}}    \\
\itpdsem[\pset x \ty e] & = & \ipty {\itpdsem[\ty]} \\
\itpdsem[\pseq \ty {\ty_{\text{sep}}} {\pterm e {\ty_{\text{term}}}}] & = & 
  \iapty {\itpdsem[\ty]} \\
\itpdsem[\ptyvar] & = & \ipty{\ptyvar_\pdbname} \\
\itpdsem[\pmu \ptyvar \kty \ty] & = & 
  \ipty{\imu{\ptyvar_\pdbname}{\itpdsem[\ty]}} \\
\itpdsem[\lambda \ptyvar.\ty]      
     & = & \lambda \ptyvar_\pdbname.\itpdsem[\ty] \\
\itpdsem[\papp {\ty_1} {\ty_2}]            & = & \itpdsem[\ty_1] \; \itpdsemstrip[\ty_2] \\
\itpdsem[\pcompute e \ity]            & = & \ipty \iunitty \\
\itpdsem[\pabsorb \ty]                & = & \ipty \iunitty \\
\itpdsem[\pscan{\ty}] & = & \ipty {(\isum {(\iprod \iintty
    {\itpdsem[\ty]})} \iunitty)}
\end{array}
\]
\fbox{$\itpdsemstrip[\ty] = \ity$}

\[
\begin{array}{lcl} 
\itpdsemstrip[\ty] & = & \ity \ \ \mbox{where}\ \itpdsem[\ty] \equiv \ipty{\ity}
\end{array}
\]
\caption{Parse-descriptor type interpretation function}
\label{fig:pd-tys}
\end{figure}

In \figref{fig:pd-tys}, we give the parse descriptor type for each
\ddc{} type. Each PD type has a header and body.  This common shape
allows us to define functions that polymorphically process PDs based
on their headers. Each header stores the number of errors encountered
during parsing, an error code indicating the degree of success of the
parse -- success, success with errors, or failure -- and the span of
data described by the descriptor.  Formally, the type of the header
($\tyface{pd\_hdr}$) is $\iintty \iprodi \iecty \iprodi \ispty$.  Each
body consists of subdescriptors corresponding to the subcomponents of
the representation and any type-specific metadata. For types with
neither subcomponents nor special metadata, we use $\iunitty$ as the
body type.

We discuss a few of the more complicated parse descriptors in detail.
The parse descriptor body for sequences contains the parse descriptors
of its elements, the number of element errors, and the sequence
length. Note that the number of element errors is distinct from the
number of sequence errors, as sequences can have errors that are not
related to their elements (such as errors reading separators).  We
introduce an abbreviation for array PD body types, $\iaptyname \; \ity
= \iintty \iprodi \iintty \iprodi (\iseq \ity)$.  The $\pcomputen$
parse descriptors have no subelements because the data they describe
is not parsed from the data source.  The $\pabsorbn$ PD type is
$\iunitty$ as with its representation. We assume that just as the user
does not want the representation to be kept, so too the parse
descriptor.  The $\pscann{}$ parse descriptor is either $\iunitty$, in
case no match was found, or records the number of bits skipped before
the type was matched along with the type's corresponding parse
descriptor.

Like other types, \ddca{} type variables $\ptyvar$ are translated into
a pair of a header and a body.  The body has abstract type
$\ptyvar_\pdbname$.  This translation makes it possible for
polymorphic parsing code to examine the header of a PD, even though it
does not know the \ddca{} type it is parsing.  \ddca{} abstractions
are translated into \fomega\ type constructors that abstract the body
of the PD (as opposed to the entire PD) and \ddca{} applications are
translated into \fomega\ type applications where the argument type is
the PD-body type. 

It is important to note that the PD interpretation is not defined for
all types. The problem lies with the interpretation of type
application ($\itpdsem[\papp {\ty_1} {\ty_2}] = \itpdsem[\ty_1] \;
\itpdsemstrip[\ty_2]$).  The interpretation requires that $\itbdsem[\ty_2]$ be
defined, which, in turn, requires that $\itpdsem[\ty_2] \equiv
\ipty{\ity}$, for some $\ity$.  Yet, this requirement is not met by
all types; for example, $\lambda \ptyvar.\ty$.

\begin{figure}
\small
\fbox{$\kTrans[\gk,\ty] = \ity$} 
    
\begin{align*}
  &\kTrans[\kty,\ty] & = & \quad \extdom * \offdom \iarrowi \offdom * \itsem[\ty] * \itpdsem[\ty]
   \\
   &\kTrans[\ity \iarrowi \gk,\ty] & = & \quad \ity \iarrowi \kTrans[\gk,\ty e],
   \; \mbox{for any e}.
   \\
   &\kTrans[\kty \iarrowi \gk,\ty] & = & \quad 
      \forall\tyvar_\repname.\forall\tyvar_\pdbname.
         \kTrans[\kty,\tyvar] \iarrowi \kTrans[\gk,\ty \tyvar] \\
         & & & \quad (\ptyvar_\repname, \ptyvar_\pdbname \not \in \ftv \kind \cup
         \ftv \ty)
\end{align*}  
  \caption{\fomega types for parsing functions.}
  \label{fig:parser-types}
\end{figure}

\subsection{Parsing Semantics of the \ddc{}}
\label{sec:parse-sem}

\begin{figure}
\fbox{$\trans[\ty,\ctxt,\gk] = e$} 
\[
\begin{array}{l}
  %% None 
\trans[\ptrue,\ctxt,\kty] =
  \lampair{\spair<\off,\newrep{unit}{},\newpd{unit}{\off}>}
\\[3pt] %\\
%% False 
\trans[\pfalse,,] =
  \lampair{\spair<\off,\newrep {bot}{},\newpd {bot}{\off}>}
\\[3pt] %\\ 
%% Const 
\trans[\pbase{e},\ctxt,\kty] =
  \lampair{\iapp {\iapp {\Iimp(C)} (e)} {\itup {\idata,\off}}}
\\[3pt] %\\
%% Abs 
\trans[\plam{\var}{\ity}{\ty},,] =
   \sfn{\nrm\var}{\ity}{\trans[\ty,\ectxt{\var{:}\ity},\kind]}
\\[3pt] %\\
%% App 
\trans[\papp{\ty}{e},\ctxt,\gk] =
  \trans[\ty,,] \sapp e  
\\[3pt]
%% Prod 
%\begin{array}{l}
\trans[\psig{x}{\ty}{\ty'},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampair{} \\
    \quad  \ilet {\spair<\off',r,p>} 
    {{\trans[\ty,,]} \sapp \spair<\idata,\off>} \\
    \quad  \ilet x {\ictup{r,p}}\\
    \quad  \ilet {\spair<\off'',r',p'>} 
    {{\trans[\ty',,]} \sapp \spair<\idata,\off'>} \\
    \quad \spair<\off'',\newrep {\gS}{r,r'},\newpd {\gS}{p,p'}>
  \end{array}  
%\end{array}
\\
%% Sum 
%\begin{array}{l}
  \trans[\psum{\ty}{e}{\ty'},,] = \\
  \begin{array}{l}  
  \lampair{} \\
  \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
  \quad \iif {\pdok p} \; \ithen \\
  \qquad{
    \def \r {\newrep {+left}{r}}
    \def \p {\newpd {+left}{p}}
    \spair<\off',\r,\p>} \\
  \quad \ielse {\ilet {\itup{\off',r,p}}{\trans[\ty',,] \sapp \spair<\idata,\off>}} \\
  \quad 
  {  % begin scope
    \def \r {\newrep {+right}{r}}
    \def \p {\newpd {+right}{p}}
    %% 
    \spair<\off',\r,\p>
  }\\ % end scope
  \end{array}
\\
%% Intersection 
  \trans[\pand{\ty}{\ty'},,] = \\
  \begin{array}{l}  
     \lampair{} \\
     \quad \ilet {\itup{\off',r,p}} {\trans[\ty,,] \sapp \spair<\idata,\off>} \\
     \quad \ilet {\itup{\off'',r',p'}} {\trans[\ty',,] \sapp \spair<\idata,\off>} \\
     \quad {\spair<\codefont{max}(\off',\off''),\newrep {\&}{r,r'},\newpd {\&}{p,p'}>}
   \end{array}
\\
%\quad
%% Set 
  \trans[\pset{x}{\ty}{e},\ctxt,\kty] = \\
  \begin{array}{l}  
    \lampair{} \\
    \quad \ilet {\itup{\off',r,p}}{\trans[\ty,,] \sapp \spair<\idata,\off>} \\
    \quad \ilet x {\ictup{r,p}}\\
    \quad \ilet c e \\
    \quad \spair<\off',\newrep {con} {c,r},\newpd {con} {c,p}>
  \end{array}
\\
\end{array}
\begin{array}{l}
%% Array 
\trans[\pseq{\ty}{\ty_s}{\pterm e {\ty_t}},,] = \\
  \begin{array}{l}  
    \lampair{}\\
      \quad \iletfun {isDone}{\itup{\off,r,p}}{\\
        \qquad \ior {\eofpred {\idata,\off}} {e\codefont {\sapp
          \spair<r,p>}} \iori \\
        \qquad \ilet {\itup{\off',r',p'}}{\trans[\ty_t,,] \spair<\idata,\off>}\\
        \qquad \pdok{p'}
      }\\
      \quad \iin \\
      \quad \iletfun {continue} {\itup{\off,\off',r,p}} {\\
        \qquad \iif  {\off = \off' \iori \isdone {\off',r,p}} \; \ithen {\itup{\off',\codefont{r,p}}} \\
        \qquad \ielse {
          \ilet {\itup{\off_s,r_s,p_s}}{\trans[\ty_s,,] \sapp \spair<\idata,\off'>}}\\
        \qquad \ilet {\itup{\off_e,r_e,p_e}}{\trans[\ty,,] \sapp \ictup{\idata,\off_s}}\\
        \qquad \mathtt{continue} \sapp \ictup{
            \off,\off_e,\newrep {seq} {r,r_e}, \newpd {seq} {p, p_s, p_e}
        }}\\
      \quad \iin
   \end{array}\\
  \begin{array}{l}  
      \quad \ilet {\mathtt{r}} {\newrep {seq\_init}{}}\\
      \quad \ilet {\mathtt{p}} {\newpd {seq\_init}{\off}}\\
      \quad \iif {\isdone{\off,r,p}} \; \ithen {\itup{\off,\codefont{r,p}}}\\
      \quad \ielse {\ilet {\itup{\off_e,r_e,p_e}}{\trans[\ty,,] \sapp
          \spair<\idata,\off>}} \\
      \quad \mathtt{continue} \sapp \ictup{\off',\off_e,
        \newrep {seq} {r,r_e}, \newpd {seq} {p, \newpd {unit} \off, p_e}}      
  \end{array}  
\\
%\end{array}
%\quad
%\begin{array}{l}
%% Var
\trans[\ptyvar,,] = \codefont{\parsename_\ptyvar}
\\[3pt]
%% Mu
\trans[\pmu \ptyvar \gk \ty,,] = \\
  \begin{array}{l}
  \ifunan {\parsename_\ptyvar} {\itup{\data{:}\ibitsty,\off{:}\ioffty}}
  {\qquad \ioffty * \itsem[\pmu \ptyvar \gk \ty]
    * \itpdsem[\pmu \ptyvar \gk \ty]}{} \\
  \quad \ilets {\itup{\off',r,p}} \\
  \qquad {\trans[\ty,,][\itsem[\pmu \ptyvar \gk \ty]/\ptyvar_\repname]
          [\itpdsemstrip[\pmu \ptyvar \gk \ty]/\ptyvar_\pdbname] \iappi \ictup{\data,\off}} \\ 
        \quad \iin\\
  \qquad \ictup{\off',\iroll{r}{\itsem[\pmu \ptyvar \gk \ty]},
     (p.h,\iroll{p}{\itpdsemstrip[\pmu \ptyvar\gk \ty]})}
%}}
  \end{array}  
\\[3pt]
%% lambda \alpha
\trans[\lambda\tyvar . \ty,,] = %\\
%  \begin{array}{l}
    \Lambda \tyvar_\repname. 
    \Lambda \tyvar_\pdbname. \lambda \codefont{\parsename_\ptyvar}. \trans[\ty,,]
%  \end{array}  
\\
%% t1 t2
\trans[\ty_1 \ty_2,,] = 
    \trans[\ty_1,,]\; [\itsem[\ty_2]]\; [\itpdsemstrip[\ty_2]]\; \trans[\ty_2,,]
\\
%% Compute
\trans[\pcompute e \ity,,] = \\
  \quad \lampair{\itup{\off,\newrep {compute} {\nrm e},\newpd {compute} \off}}
\\[3pt]
%% Absorb
\trans[\pabsorb \ty,,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \ilet {\itup {\off',r,p}} {\trans[\ty,,] \sapp \spair<\idata,\off>}\\
    \quad \itup{\off',\newrep {absorb} p,\newpd {absorb} p}   
  \end{array}  
\\
%% Scan
\trans[\pscan \ty,,] = \\
  \begin{array}{l}  
    \lampair{}\\
    \quad \iletfun {try} {i} {\\
      \qquad \ilet {\itup{\off',r,p}} {\trans[\ty,,] \sapp
        \codefont{\spair<\data,\off + i>}} \\
      \qquad \iif {\pdok p}\; \ithen \\
      \quad \qquad {\ictup{\off',\newrep {scan} r,
        \newpd {scan} {i,\subbits \idata \off {i+1},p}}}\\
    \qquad \ielse {}\;
      \iif {\eofpred {\idata,\off + i}}\; \ithen \\
      \quad \qquad {\ictup{\off,\newrep {scan\_err} {},
        \newpd {scan\_err} {\off}}}\\
      \qquad \ielse {}\; \codefont {try \sapp (i+1)}
   }\\
   \quad \iin \sapp \codefont{try \sapp 0} \\
  \end{array}  
\\
\end{array}
\]
\caption{\ddca{} parsing semantics}
\label{fig:ddc-sem}
\end{figure}

The parsing semantics of a type $\tau$ with kind $\kty$ is a function
that transforms some amount of input into a pair of a representation
and a parse descriptor, the types of which are determined by $\tau$.
The parsing semantics for types with higher kind are functions that
construct parsers, or functions that construct functions that
construct parsers, and so forth. \figref{fig:parser-types} specifies the
host-language types of the functions generated from well-kinded
\ddca{} types. For each (unparameterized) type, the input to the
corresponding parser is a bit string to parse and an offset at which
to begin parsing.  The output is a new offset, a representation of the
parsed data, and a parse descriptor.

\figref{fig:ddc-sem} shows the parsing semantics function.  For each
type, the input to the corresponding parser is a bit string and an
offset which indicates the point in the bit string at which parsing
should commence.  The output is a new offset, a representation of the
parsed data, and a parse descriptor. As the bit string input is
never modified, it is not returned as an output.  In addition
to specifying how to handle correct data, each function describes how
to transform corrupted bit strings, marking detected errors in
a parse descriptor. The semantics function is partial, applying only
to well-formed \ddc{} types.

\begin{figure}
\begin{itemize}
%\newcommand{\labelitemi}{}
\item[] $\codefont {Eof} : \ibitsty \iprodi \ioffty \iarrowi \iboolty$

\item[] $\codefont{scanMax} : \iintty$

\item[] $\ifun {max} {\ictup{m,n}} {\codefont{\iif {m>n}\; \ithen m\; \ielse n}}$
\item[] $\ifun {pos} n {\codefont{\iif {n=0}\; \ithen 0\; \ielse 1}}$
\item[] $\ifun {isOk} p {\codefont{pos(p.h.nerr) = 0}}$
\item[] $\ifun {isErr} p {\codefont{pos(p.h.nerr) = 1}}$

\item[] $\ifun {max\_ec} {\ictup{ec_1, ec_2}} {}$ \\
  $\begin{array}{l}
    \iif {\codefont{ec_1} = \iecpc \iori \codefont{ec_2} = \iecpc}\; \ithen \iecpc \\
    \ielse{} \iif {\codefont{ec_1} = \iecerr \iori \codefont{ec_2} = \iecerr}\; \ithen \iecerr \\
    \ielse \iok
   \end{array}$
\end{itemize}
\caption{Auxiliary functions.  The type of PD headers is $\iintty
  \iprodi \iecty \iprodi \ispty$.  We refer to the projections using
  dot notation as $\codefont{nerr}$, $\codefont{ec}$ and
  $\codefont{sp}$, respectively. A span is a pair of offsets, referred
  to as $\codefont{begin}$ and $\codefont{end}$, respectively.}
\label{fig:aux-funs}
\end{figure}

\begin{figure}
\begin{itemize}


\item[] %[Unit:]
\item[] $\ifun {R_{unit}} \iuval \iuval$
\item[] $\ifun {P_{unit}} \off {\itup{\itup{0,\iok,\ipair \off \off},\iuval}}$

\item[] %[Bottom:]
\item[] $\ifun {R_{bot}} \iuval \ierr$
\item[] $\ifun {P_{bot}} \off ((1,\iecpc,\ipair \off \off),())$

\item[] %[Pair:]
\item[] $\ifun {R_{\gS}} {\ipair {r_1} {r_2}} {\itup {\codefont{r_1,r_2}}}$
\item[] $\ifun{H_{\gS}} {\ictup{h_1,h_2}}{}$ \\
  $\begin{array}{l}
    \ilet {nerr} {\codefont{pos \itup{{h_1}.{nerr}} + pos \itup{{h_2}.{nerr}}}}\\
    \ilet {ec} {\iif {\codefont{h_2.ec} = \iecpc}\; \ithen {\iecpc}\\
    \quad \ielse {\codefont{max\_ec} \iappi \codefont{h_1.ec} \iappi \codefont{h_2.ec}}} \\
    \ilet {sp} {\ictup{h_1.sp.begin, h_2.sp.end}} \\
    \quad \ictup {nerr,ec,sp}
  \end{array}$

\item[] $\ifun {P_{\gS}} {\ictup{p_1, p_2}} {\ictup {H_{\gS} \itup{p_1.h,p_2.h},\itup{p_1,p_2}}}$

\item[] %[Sum:]
\item[] $\ifun {R_{+left}} r {\iinl {\codefont r}}$
\item[] $\ifun {R_{+right}} r {\iinr {\codefont r}}$

\item[] $\ifun {H_+} h {\ictup{pos(h.nerr),h.ec,h.sp}}$
\item[] $\ifun {P_{+left}} p {\ictup{\codefont{H_+} \iappi p.h, \iinl p}}$
\item[] $\ifun {P_{+right}} p {\ictup{\codefont{H_+} \iappi p.h, 
      \iinr  p}}$

\item[] %[Intersection:]
\item[] $\ifun {R_{\&}} {\ictup {r,r'}} {\ictup {r,r'}}$
\item[] $\ifun {H_{\&}} {\ictup {h_1, h_2}} {}$ \\
    $\begin{array}{l}
      \ilet {nerr} {\codefont{pos \itup{{h_1}.{nerr}} + pos \itup{{h_2}.{nerr}}}}\\
      \ilet {ec} {\iif {\codefont{h_1.ec} = \iecpc \iandi \codefont{h_2.ec} = \iecpc}\; \ithen {\iecpc}\\
      \quad \ielse{\codefont{max\_ec} \iappi \codefont{h_1.ec} \iappi \codefont{h_2.ec}}} \\
      \ilet {sp} {\ictup{h_1.sp.begin, max \itup{h_1.sp.end, h_2.sp.end}}} \\
      \quad \ictup {nerr,ec,sp}
    \end{array}$

\item[] $\ifun {P_{\&}} {\ictup {p_1,p_2}} {\ictup{H_{\&} \iappi 
      \itup{p_1.h, p_2.h},\itup{p_1,p_2}}}$
 \end{itemize}

\caption{Constructor functions, part 1.  The type of parse descriptor headers is $\iintty
  \iprodi \iecty \iprodi \ispty$.  We refer to the projections using
  dot notation as $\codefont{nerr}$, $\codefont{ec}$ and
  $\codefont{sp}$, respectively. A span is a pair of offsets, referred
  to as $\codefont{begin}$ and $\codefont{end}$, respectively.}
\label{fig:cons-funs}
\end{figure}

\begin{figure}
\begin{itemize}
  \newcommand{\labelitemi}{}
\item[] %[Set:]
\item[] $\ifun {R_{con}} {\ictup{c,r}} {
    \iif {\codefont c} \; \ithen {\iinl {\codefont r}} \; \ielse {\iinr {\codefont r}}
  }$ 
\item[] $\ifun {P_{con}} {\ictup {c, p}} {}$ \\
    $\begin{array}{l}
      \iif {\codefont c} \; \ithen {\ictup{(pos(p.h.nerr),p.h.ec,p.h.sp),p}} \\
      \ielse {\ictup {(1 + pos(p.h.nerr),\maxec \iecerr {p.h.ec},p.h.sp),p}}
    \end{array}$
   
\item[] %[Array:] 
\item[] $\ifun {R_{seq\_init}} {\iuval} {\ictup{0,\ieseq}}$   
\item[] $\ifun {P_{seq\_init}} \off {\ictup{(0,\iok,\ipair \off
      \off),(0,0,\ieseq)}}$

\item[] $\ifun {R_{seq}} {\ictup{r, r_e}} 
  {\ictup{r.len+1,\iappend{r.elts} {\iarr{r_e}}}}$
\item[] $\ifun {H_{seq}} {\ictup{h, h_s, h_e}} {}$ \\
  $\begin{array}{l}
      \ilet {eerr} {
        \codefont{\iif {h.neerr = 0 \mathrel{and} h_e.nerr > 0}}\\
        \codefont{\quad \ithen 1 \;  \ielse 0}
      }\\
      \ilet {nerr} {\codefont{h.nerr + pos(h_s.nerr) + eerr}}\\
      \ilet {ec} {\iif{\codefont{h_e.ec} = \iecpc}\; \ithen {\iecpc}\\
      \quad \ielse{\maxec {\codefont{h.ec}} {\codefont{h_e.ec}}
          }} \\
      \ilet {sp} {\ictup{h.sp.begin,h_e.sp.end}} \\
      \quad \ictup {nerr,ec,sp}
    \end{array}$

\item[] $\ifun{P_{seq}} {\ictup{p, p_s, p_e}}{}$ \\ 
  $\begin{array}{l}
    \codefont{(H_{seq} \iappi \itup{p.h,p_s.h,p_e.h},}\\ 
    \codefont{\itup{p.neerr + pos(p_e.h.nerr), p.len + 1,\iappend {p.elts}
        {\iarr{p_e}}})}
  \end{array}$

\item[] %[Compute:]
\item[] $\ifun{R_{compute}} r {\codefont r}$
\item[] $\ifun{P_{compute}} \off {\ictup{\itup{0,\iok,\ipair \off \off},\iuval}}$

\item[] %[Absorb:]
\item[] $\ifun {R_{absorb}} p {\iif {\pdok p}\; 
    \ithen {\iinl \iuval}\; \ielse {\iinr \ierr}}$
\item[] $\ifun {P_{absorb}} p {\ictup{p.h,\iuval}}$

\item[] %[Scan:]
\item[] $\ifun{R_{scan}} r  {\codefont{\iinl r}}$
\item[] $\ifun{P_{scan}} {\itup{i,p}} {}$ \\
$\begin{array}{l}
\ilet {nerr} {\codefont{pos(i) + pos(p'.h.nerr)}}\\
\ilet {ec} {\iif {\codefont{nerr = 0}}\; \ithen \iok\; \ielse \iecerr} \\
\ilet {hdr} {\ictup{nerr,ec,(p.sp.begin - i,p.sp.end)}} \\
\quad \ictup{hdr,\iinl {\ictup{i,p}}}
\end{array}$

\item[] $\ifun {R_{scan\_err}} {()} {\iinr \ierr}$
\item[] $\ifun {P_{scan\_err}} \off {\ilet {hdr} {\ictup{1,\iecpc,(\off,\off)}}}$\\
  \verb+ +$\ictup{hdr,\iinr \iuval}$
\end{itemize}
\caption{Constructor functions, part 2.}
\label{fig:cons-funs-cont}
\end{figure}

For any type, there are three steps to parsing: parse the
subcomponents of the type (if any), assemble the resultant
representation, and tabulate metadata based on subcomponent metadata
(if any). For the sake of clarity, we have factored the latter two
steps into separate representation and PD constructor functions which
we define for many of the types. For some types, we additionally factor the PD
header construction into a separate function. For example, the
representation and PD constructors for $\ptrue$ are $\newrepf {unit}$
and $\newpdf {unit}$, respectively, and the header constructor for
dependent sums is ${\codefont{H_{\gS}}}$. The constructor functions are shown in
\figref{fig:cons-funs} and \figref{fig:cons-funs-cont}. We have also
factored out some commonly occuring code into auxiliary functions,
explained as needed and defined formally in~\figref{fig:aux-funs}.

The PD constructors determine the error code and calculate the error
count.  There are three possible error codes: $\iok$, $\iecerr$, and
$\iecpc$, corresponding to the three possible results of a parse: it
can succeed, parsing the data without errors; it can succeed, but
discover errors in the process; or, it can find an unrecoverable error
and fail.  Note that the purpose of the $\iecpc$ code is to
indicate to any higher level elements that some form of error recovery
is required.  Hence, the whole parse is marked as failed exactly when
the parse ends in failure.  The error count is determined by
subcomponent error counts and any errors associated directly with the
type itself.  If a subcomponent has errors then the error count is
increased by one; otherwise it is not increased at all. We use the
function $\codefont {pos}$, which maps all positive numbers to 1
(leaving zero as is), to assist in calculating the contribution of
subcomponents to the total error count.  Errors at the level of the
element itself - such as constraint violation in constrained types -
are generally counted individually.

With this background, we can now discuss the semantics.  The $\ptrue$ and
$\pfalse$ descriptions do not consume any input. Hence, the output offset is the
same as the input offset in the parsers for these constructs. A look
at their constructors shows that the parse descriptor for $\ptrue$
always indicates no errors and a corresponding $\iok$ code, while that
of $\pfalse$ always indicates failure with an error count of one and
the $\iecpc$ error code. The semantics of base types applies the
implementation of the base type's parser, provided by the function
$\Iimp$, to the appropriate arguments.  Abstraction and application
are defined directly in terms of \implang language abstraction and
application.  Dependent sums read the first element at $\off$ and then
the second at $\off'$, the offset returned from parsing the first
element.  Notice that we bind the pair of the returned representation
and parse descriptor to the variable $\codefont{x}$ before parsing the
second element, implicitly mapping the \ddc{} variable $x$ to the
\implang{} language variable $\codefont{x}$ in the process.  Finally,
we combine the results using the constructor functions, returning
$\off''$ as the final offset of the parse.

Sums first attempt to parse according to the left type, returning the resulting
value if it parses without errors. Otherwise, they parse according to
the right type. Intersections read both types starting at the same
offset. They advance the stream to the maximum of the two offsets
returned by the component parsers. The construction of the parse
descriptor is similar to that of products. For constrained types, we call the
parser for the underlying type $\ty$, bind $\ivar$ to the resulting rep
and PD, and check whether the constraint is satisfied. The result
indicates whether the data has a semantic error and is used in
constructing the representation and PD. For example, the PD constructor will add
one to the error count if the constraint is not satisfied. Notice that
we advance the stream independent of whether the constraint was
satisfied.

Sequences have the most complicated semantics because the number of
subcomponents depends upon a combination of the data, the termination
predicate, and the terminator type. Consequently, the sequence parser
uses the function $\codefont{isDone}$ and the recursive function
$\codefont{continue}$ to implement this open-ended semantics.
Function $\codefont{isDone}$ determines if the parser should terminate
by checking whether the end of the source has been reached, the
termination condition $e$ has been satisfied, or the terminator type
can be read from the stream without errors at $\off$.  Function
$\codefont{continue}$ takes four arguments: two offsets, a sequence
representation, and a sequence PD.  The two offsets are the starting
and ending offset of the previous round of parsing. They are compared
to determine whether the parser is progressing in the source, a check
that is critical to ensuring that the parser terminates. Next, the
parser checks whether the sequence is finished, and if so, terminates.
Otherwise, it attempts to read a separator followed by an element and
then continues parsing the sequence with a call to
$\codefont{continue}$.  Then, the body of the parser creates an
initial sequence representation and parse descriptor and then checks
whether the sequence described is empty. If not, it reads an element
and creates a new rep and PD for the sequence.  Note that it passes
the PD for $\ptrue$ in place of a separator PD, as no separator is
read before the first element.  Finally, it continues reading the
sequence with a call to $\codefont{continue}$.

Because of the iterative nature of sequence parsing, the
representation and PD are constructed incrementally. The parser first
creates an empty representation and PD and then adds elements to them
with each call to $\codefont{continue}$. The error count for an array
is the sum of the number of separators with errors plus one if there
were any element errors. Therefore, in function ${\codefont{H_{seq}}}$
we first check if the element is the first with an error, setting
$\codefont{eerr}$ to one if so. Then, the new error count is a sum of
the old, potentially one for a separator error, and $\codefont{eerr}$.
In $\newpdf{seq}$ we calculate the element error count by
unconditionally adding one if the element had an error.

A type variable translates to an expression variable whose name
corresponds directly to the name of the type variable. These
expression variables are bound in the interpretations of recursive
types and type abstractions. We interpret each recursive type as a
recursive function whose name corresponds to the name of the recursive
type variable. For clarity, we annotate the recursive function with its
type.

We interpret type abstraction as a function over other parsing
functions. Because those parsing functions can correspond to arbitrary
\ddca{} types (of kind $\kty$), and, therefore, can have different
\fomega{} types, the interpretation must be a polymorphic function,
parameterized by the representation and PD-body type of the \ddca{}
type parameter.  For clarity, we present this type parameterization
explicitly.  Type application $\papp {\ty_1}{\ty_2}$ becomes the
application of the interpretation of $\ty_1$ to the
representation-type, PD-body type, and parsing-function
interpretations of $\ty_2$.

The $\pscann$ type attempts to parse the underlying type from the
stream at an increasing offset $i$ from the original offset
$\off$, until success is achieved or the end of the file is reached.
In the semantics we give here, offsets are incremented one bit at a
time -- a practical implementation would choose some larger increment
(for example, 32 bits at a time).  Note that, upon success, $i$ is
passed to the PD constructor function, which both records it in the PD
and sets the error code based on it.  It is considered a semantic
error for the value to be found at a positive $i$, whereas it is a
syntactic error for it not to be found at all.

%\edcom{M: You describe a quadratic algorithm...}. 
Notice that the upper-bound on the running time of $\pscann$ is at
least linear in the size of the data, depending on the particular
argument type. More precisely, if the running time of a type $\ty$ is
$O(f(n))$, where $n$ is the size of the data, then the running time of
$\pscan \ty$ is $O(n f(n))$. While such a running time is potentially
high, it is reasonable if it is only incurred for erroneous data, in
which case the cost is not incurred on the ``fast path'' of processing
good data; or, if $f(n)$ is $1$ and $\pscann$ consumes all of the
scanned data, in which case the total running time of the parser is
linear in the amount of data consumed, which is the best running time
achievable without skipping data.  However, we cannot guarantee that
either of these conditions are met. The $\pscann$ type can legally
appear in branches of sums, in which case the cost could be incurred
for valid data (that matches a different branch) without consuming any
of the data scanned.

In \padsc{} and \padsml{}, we control the potentially high cost of
$\pscann$ in two ways. First, we only scan for literals, thereby
bounding the running time to linear in the size of the data source.
Second, we set a data-source independent maximum on the number of bits
scanned for any particular instance of $\pscann$, rather than
potentially scanning until end of the data source. Together, these
factors reduce the running time of scanning to $O(1)$. However, the
second factor implies that \padsc{} and \padsml{}, unlike \ddc{}, do
not guarantee to find the targets of scans, even if they are present
in the data source. This difference between \ddc{} and the \pads{}
languages could have a significant impact an any guarantees we might
make about error recovery based on \ddc{} alone. We leave for future
work the development of a more sophisticated semantics for $\pscann$
that accounts for the unreliable nature of scans in \padsc{} and
\padsml{}.

Returning to our discussion of the semantics of \ddc{}, we note that
$\pcomputen$ only calls the compute constructors without performing
any parsing.  The representation constructor returns the value
computed by $e$, while the PD records no errors and reports a span of
length 0, as no data is consumed by the computation. The $\pabsorbn$
parser first parses the underlying type and then calls the absorb
constructors, passing only the PD, which is needed by the rep
constructor to determine whether an error occured while parsing the
underlying type.  If so, the value returned is a $\ierr$. Otherwise,
it is $\iunitty$.  The absorb parse descriptor duplicates the error
information of its underlying type.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: 
