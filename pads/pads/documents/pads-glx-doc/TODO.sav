PGLX Library:
+ QUE for Mary: Do textnodes need their own ids? (I don't think so)

  Mary: yes, but given PADS current use of text nodes, we probably
  don't need them right now.

+ Fix: Is the PDCI_node_no_kthChild function correct? It doesn't
       seem to match it's comments.
  Yes. Fix the comments. Only text nodes will be using this function.

+ Fix: Enum vals print out correctly? You can correctly
  test their typed value, as in:
    ./elt[last()]/f4[val = "S_init"]
  But, when printing them, val shows up as:
    <val/>

  Mary: cstr nodes should behave like val nodes in that their "text
  node" representation (containing their string rep) should be
  returned when kth-child(0) is applied.

+ Test: Create snd (smart-node-descendant) versions of pd kthChildNamed
  functions. These functions touch the pd to decided whether to
  include the "loc" child. Hence, they need snd versions to bring
  validate the node first.

+ Test: In file pglx-codegen-macros.h, in macro SN_ELT_ALLOC, we now
  initialize reps and pd's after allocation. This new feature should
  be tested.

+ Test: Remove smarts from generic_get_id. Allow virtual function to do
  the work.

+ In pglx.c, Ppos_t kth_child doesn't return its 3rd child. Fix it
  and fix basic-PADS-XML-types.xsd.

+ If memory allocation fails for smart node, is this an error, or
  perfectly fine?

  ANS: Parameterize smart nodes by  min and desired/max number of
  elements. Allocation failure is Fatal if fail before min allocated,
  otherwise failure is silent.

+ Don't allow max_elts == 0 in smart array init. Array can't function
  with no memory.

+ QUE : Are the _id_'s of smart array pd's and length correct?
  They are unique, but they are not in order relative to the elements
  themselves.

  Leave open for now -- Mary needs to think about this one.
  Semantic constraint: 
    XML Schema: <array><pd/><item/>...<item/></array>
  then 
    children (<array>) should return <pd/><item/>...<item/></array>

  Probably should change arrays so that pd is last in XML Schema. 

+ QUE: Why isn't the nerr field of the Pbase_pd returned 
  as a child?

+ QUE: Why are there are vtables declared in pglx-internal.h that are
  not defined in pglx.c?

   PDCI_DECL_NEW_VT(Pa_char);
   PDCI_DECL_NEW_VT(Pe_char);

   PDCI_DECL_NEW_VT(Pstring_ME);
   PDCI_DECL_NEW_VT(Pstring_CME);
   PDCI_DECL_NEW_VT(Pstring_SE);
   PDCI_DECL_NEW_VT(Pstring_CSE);

   PDCI_DECL_NEW_VT(Pa_string);
   PDCI_DECL_NEW_VT(Pa_string_ME);
   PDCI_DECL_NEW_VT(Pa_string_CME);
   PDCI_DECL_NEW_VT(Pa_string_SE);
   PDCI_DECL_NEW_VT(Pa_string_CSE);

   PDCI_DECL_NEW_VT(Pe_string);
   PDCI_DECL_NEW_VT(Pe_string_ME);
   PDCI_DECL_NEW_VT(Pe_string_CME);
   PDCI_DECL_NEW_VT(Pe_string_SE);
   PDCI_DECL_NEW_VT(Pe_string_CSE);

+ Document: Why are the children of a base_pd returned as XXX_vals instead of as
  XXX itself?  Example: loc/b/offset. Because they don't have pds.

PADS Library:
+ QUE: Where does function P_io_seek belong?

+ Once P_io_seek and P_io_get are integrated into pads, remove them
  from pglx.c and include/templates/read_and_reread.h. Also remove
  headers from pglx-internal.h.

+ Make sure to increment the id_gen counter (in pads->disc) for computed
  fields. Currently, it is only incremented in read functions.Consider
  using PD_INIT, but be sure that PD_INIT is called in the correct order.

+ Update pads/padsc/include/templates/read_and_reread.h. It uses
  obsolete return codes of the type Pread_res_t.

PADSC:
+ QUE: Should the read_one function have null param checks? In other
  words, do we expect it to be used directly by the user? Currently
  used by the driver read function and by the smart array read element
  function.

+ Check for max == 0 in read_one_init. In read_one itself, we only compare
  rep->length to max_elts after one element has been read. 

+ Add a smartNode_cleanup function, which deallocates memory used by
  elements an does any other cleanup necessary. You will also need to
  change the elt free macro to actually do the freeing. Currently, it
  looks like this:
  #define SN_ELT_FREE_BODY(ty,padsIN,infoIN)  /* no-op */

+ Map pd->elts[current] and variable "element" (or whatever its
  called) to elt_pd. Same for rep.

+ Stop compiler from generating monolithic array read function.

+ Update basic-PADS-XML-types.xsd, as necessary. Add whatever new types
  need to be added. 

+ Bring xschema generation in alignment with current pd child
  scheme. The compiler currently generates a schema for the pds of each
  type. However, the kthChild code never returns the actual pds to
  galax. Instead, struct pds are returned as PDCI_structured_pd_t,
  array pds are PDCI_sequenced_pd_t, and base pds are
  Pbase_pd_t. Therefore, we don't need to generate schemas for pds on
  a per-type basis. Instead, we should add the aforementioned
  PDCI_XXX_pd types to the basic-PADS-XML-types.xsd file, and change
  the xchemas to mention these types where appropriate.

+ Consider: What should we do about "real" errors in reread? A reread
  can't fail on any error, because parse errors are fine. What we
  want is some way to flag errors that didn't happen the first time
  around, to avoid problems such as we encountered with unseekable
  streams (e.g. stdin). Is there a way to distinguish between
  errors that are due specifically to the reread, and errors that
  are due to the contents of the stream? For now, reread will
  ignore any errors and always pass back P_READ_OK_DATA.

  Bob and Yitzhak believe that any hard errors should call
  PDCI_report_err with P_LEVEL_FATAL, and any other errors should be
  recorded in the pd. So, we're probably OK with current
  scheme. However, this should probably get some more consideration.

Tests:

+ Add a joint galax/pads init function to handle all init
  issues. 

+ Update old tests to correctly initialize pads-glx, using
  aforementioned init function.


Pads_dm:
+ Document: Is it correct for  padsDocumentNode (in the children
  call) not to check the kind of its child?

  Mary: yes, that is correct b/c document nodes can only contain
  elements, PIs and comments.


Questions:
+ QUE for Mary: in xquery, is foo[0] equivalent to foo[1]?

  **** Mary: This is a bug! ****

+ Document: Why does Galax ever ask for the typed value of an
      element node?  (in pads_dm.ml).

  Mary: The export_dm.ml module takes a DM instance and yields a typed
  XML token stream, so it has to call typed_value() to determine if
  the node contains a typed atomic value.  If typed_value() raises an
  exception, then it does not contain a typed_value(), and export_dm
  returns [].

+ QUE: What happens if the user names a field of the struct "pd"?

To Document:

+ Document this compiler quirk: Done: Debug type ordering in generated header files.
  Explanation: Structs generated simply using cnvExternalDecl are spit
  out differently than those converted using cnvCTy. The latter
  function removes some amount of surrounding material which seems to
  change the way that it is treated.

+ Document: Use only virtual functions to ensure nodetype-specific behaviour. DON'T use 
  switching on a field.

+ Note: Failwith is important, as exceptions can be caught by Galax. We
  have to find out from Mary how Galax uses the exceptions - for
  example, in the call to typed value is the exception mechanism
  part of the semantics for using it?

  Mary: we answered this one because export_dm is catching the
  exception raised by Pads_typed_value().  Other exceptions should be
  passed thru to Galax, which may or may not catch them.

+ Document: description of control flow for query
  execution and testing methods, copy of what we worked out for array
  read_one, etc.

+ Document: How do cstr's work?  It seems that cstr come about from enum
  children calls. They are created as val nodes of enums. Instead of
  providing the enum value, enum nodes provide the string. The id for
  the cstr should be retrieved based on the id_offset, just like other
  nodes. We need to add a cstr_node_new function to set things up
  correctly.

+ Document: the smart array extensions will be structured as follows:
  typedef struct ty_ro_params_s ty_ro_params_t;
  struct ty_ro_params_s{
    ...
  }

  struct ty_array_info_s{
    PDCI_smart_array_info_t base;
    ty_ro_params_t params;
  }

  Therefore, all such extensions can be safely "upcast" to
  PDCI_smart_array_info_t *.
  QUE: Where does the storage for regexp params belong? Currently,
       the storage is located in the ro_params struct, together
       with pointers to the storage.

+ Document: Changes made to pads to support nodeids:
  pads.h:
    Added type PDCI_id_t;
    Added field _id_ to PD_COMMON_FIELDS (ifdef USE_GALAX)
    Added field id_gen to struct Pdisc_s (ifdef USE_GALAX)
  pads-impl.h
    Defined macro PDCI_ID_NEW(idOUT,padsIN) (ifdef USE_GALAX).
    Defined macro PDCI_ID_RESET(padsIN,gidIN) (ifdef USE_GALAX).
    Defined macro PD_PGLX_INIT (ifdef USE_GALAX).
    Added call to PD_PGLX_INIT to PD_COMMON_READ_INIT.
  pads.c
    Added call to PD_PGLX_INIT to PDCI_READFN_PD_INIT.
  pglx-codegen-macros.h
    Added call to PDCI_ID_RESET to SN_SEQ_ELT_READ macro.

  Number of nodes in error array pd:1(pd) + 5(pd fields) +
  7(loc,b,byte,num,e,byte,num) = 13 for pd
  # nodes in normal array: 6 for pd
  #nodes in error field: 11 for pd
  #nodes in other field: 4 for pd
  #nodes in base field: # for pd + 1 for val (which is still less
  than 13).
  Offsets:
   all:
      pd:	 1
      pstate: pd + 1
      nerr:	 pd + 2
      errCode:pd + 3
      loc:	 pd + 4
      b:	 loc + 1
      byte:	 b  + 1
      num:	 b  + 2
      e:	 loc + 4
      byte:	 e + 1
      num:	 e + 2

   in structs/enums:
      val:	 12

   in arrays:
      pd:	 1
      neerr:	 12
      firstError: 13      
      length: 14

+ Document: incompatibility of variadic arguments with non C99
  compliant compilers.

+ Document: experience with the burden of maintaining the macros
  seperately from the compiler.

+ Document: EOR is a valid termination condition. It is not an
  error to end on eor/eof.

+ Document: the read driver can be called multiple times for a given
  array, just as the old read function could be called multiple times.

+ Document: Do we need phantom decls? I just found this code:
		   (* convert readEDs now, with mapping of field name -> void* for each field in a temporary scope *)
		   val () = pushLocalEnv()
		   val () = ignore(List.map (fn(name) => insTempVar(name, P.voidPtr)) allVars)
		   val readDecls = (emitRead readEDs)
		   val () = popLocalEnv()
  Verify that the two ways of adding variables to the environment
  have the same effect. Still, they are both useful.

+ Document: When no progress is made in reading the array, it should be
  marked as an error. However, there does not seem to be any reason
  to put us in panic mode.

+ Document: There are 3 possibilities upon return from read_one:
  1. We are still in the loop, 
  2. We have left the loop, 
  3. We already finished before.  
  All other information should be conveyed by variables such as pd,
  foundTerm, etc.

+ Document: Why doesn't typedef have init functions? Is it ok, then, that we
  do not initialize pd->loc.b? Yes. no problem.

+ Document: In SEP/TERM code, why is PDCI_report_err only called if its
  the first array error? To avoid cascading errors.

+ Document: describe the way that a smart node uses the PDCI_node_t
  that points to it. Include its use of mask and pd. Lack of use of
  rep->elts. Use of rep->length.

+ Document: QUE: Should an error on reading an element in make_valid should be
  considered a failure? 

  ANS: Yes. It can't be due to an error in the data, rather than an
  error in the program, as such an error would still result in a
  return code of P_READ_OK_DATA.

+ Document: INV: 
  forall node : PDCI_node_t *,
	(node->ancestor_gen == node->ancestor->gen
	&& node->ancestor->rep == NULL)
	==> (node->rep == NULL)
