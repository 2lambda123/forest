Smart Nodes and NodeRep Caching
-------------------------------

A. PADS-Galax Background

The PADS-Galax library adds a wrapper layer between the pads-glx api
and the standard PADS infrastructure.  The standard infrastructure is
used to create in-memory representations of PADS data. However, PADS
data structures alone are not directly suitable for querying from the
Galax Data Model. Therefore, a wrapper layer is added that receives
DM-style function calls (defined in pads_c.idl) and responds based on
the underlying PADS data. 

This wrapper layer is implemented with PDCI_nodes (henceforth
"nodes"), which store the information needed to support DM queries. 
/* Expand Later */

The key point is that nodes do not contain any PADS data, they are
merely a layer of indirection above the PADS data.

B. Smart Nodes vs. Caching

The issues of smart nodes and caching are orthogonal. Smart nodes
relate to actual PADS data that is too large to fit entirely in memory
at once. In a standard PADS program, the programmer would manage the
memory issues manually. However, a PADS-Galax "program" is just an
XQuery which knows nothing of PADS, let alone memory
management. Therefore, the PG library must handle such MM issues
automatically.

In contrast, caching relates to the nodes that we create while
accessing PADS data through the DM. We might like to avoid creating
a node for a portion of a PADS data structure if such a node has
already been created (depending on the cost of such creation).

However, there is (at least) one potential points of interaction, as
follows.  Nodes point to PADS data. Therefore, if the data has been
evicted from memory it might help to free the node. This could make
sense if the node is store seperately from the long_form_id. As only
the long_form_id needs to stay around, the node could be freed.

C. Smart Nodes

We've broken the problem of smart nodes into a number of related
subproblems:
  - Choosing a granularity for eviction and reconsitution.
  - The T-map: Keeping Track of Array Elements
  - Eviction and Reconstitution
  - Identifying subnodes of elements in a smart array.


C.1 Choosing a granularity for eviction and reconsitution.

We choose to distinguish certain arrays as smart arrays. All smart
activity happens with respect to elements of smart arrays. In
particular, eviction and reconstitution occur at the level of array
elements.  Therefore, all nodes must know which smart node they belong
to (if any), so that they can be properly located in memory.

C.2 The T-map: Keeping Track of Array Elements

Each S has map from T's to {Sfio offset; pointer to PADS info (rep,
pd, etc.);}.

We can either remember the offset of every index ever read from the
input stream, using an array that we just keep growing as we read in
later elements, or we can remember, say, offset for idx 0, offset for
idx K, offset for idx 2*K, and so on, in which case we would need to
read more than one element to get to the right location for some
arbitrary index I.

Some arrays will have fixed-sized element types, in which case all we
need to know is the starting offset of element at idx 0 and the fixed
size to compute the offset at index J.

C.3 Eviction and Reconstitution

We will need to work out the details of our heuristic for choosing
eviction candidates.  We discussed various forms of reference counting
- both at the granularity of array elements and of nodes
themselves. We seem to prefer the former.  The reference counting need
not be exact as we will be using it as a hint for choosing evictees.
We have not worked out these details yet.  Furthermore, the details of
how to evict a node will evolve as we develop the system further.

Reconstitution will be done lazily, when a node from a missing element
is requested. We could consider prefetching techniques at some later
date.

E. Caching

For now, we've decided not to cache nodes. Given their small size,
initialization is cheap, and it therefore doesn't seem worth the
effort. Instead, we can recreate them on each request, but use a free
list to avoid frequent calls to malloc.

F. Node Structure and Use

We introduce a new structure, called the long_form_id, that is
essentially a weak pointer to the PADS representation of the data. We
describe this structure below:

  long_form_ID =
    ptr to smart array object S
    index of containing array element T
    Sfio offset for node N

(Each node contains a pointer to the smart array object S to which it
belongs, the index of the containing array element T under which it is
located and its Sfio offset in the stream (e.g. file)).

Next, we combine the long_form_ID. with the (existing) PDCI_node_t.
This combined structure is stored at the C level with ML recieving an
opaque pointer to it (as is done now).

We will use the Sfio offset to identify nodes, as it will be
consistent throughout program execution.

As nodes are weak pointers, we need a way to check them for
validity. Here are two possibilities: either store T's generation
number and look up T's current generation in the T-map to check
validity, or check whether the rep field is null or not. Then,
invalidate subnodes of T by either 1) incrementing T's generation in
T-map, or 2) setting to NULL the rep fields of all existing subnodes
of T. This scheme requires the T-map to store a list of all existing
subnodes of T.

Access algorithm for node n:
  if isValid n then
    call fun n
  else
    reconstitute T
    update n  // fix pointers.
      walk T n
      ...
    validate n // fix flags/generations/etc. if need be.

Walk: 'walk' from T to find n's offset; returns a new n or fixes a
given n. At any given node n, the children of n have increasing
offsets, and if the offset we are looking for is between the offset of
child k and the offset of child k+1, we walk down to child k and keep
going.
    
G. Optimizing the fast path

According to the scheme discussed above, access to a node from galax
will involve (at least) three layers of indirection. The first layer
(itself comprising multiple function layers) is the call from OCaml
into C. The second layer is the dereference of the node ptr. The final
layer is the step from the node to the data itself. Therefore, it is
desirable that we be able to compress this path in the case of live
nodes.



6/9/2004 - Bob

PDCI_node_t Notes
-----------------

For now we will just build dumb nodes that assume parsing of the
entire document has occurred.  Moving forwards, some smart nodes will
have internal state to manage on-demand parsing, other nodes will
remain dumb.

It is possible that more than one cursor at the OCAML level will
traverse a node, thus a node must be prepared for arbitrary k's in the
get-kth-child calls -- cannot assume k will be monotonically
increasing.  Both smart and dumb nodes can cache constructed child
nodes.  However, for very large data streams, smart nodes will not
want to keep in memory all previously-parsed children, so they will
need to support eviction of cached nodes, and they will need to
remember the IO offsets of evicted children, to support re-parsing at
a specific offset.  This will require a change to the PADS IO
discipline API, which does not currently support moving the IO cursor
to a specific Ppos_t position.

We will probably want to defer full parsing of a child until some part
of the child's state (other than its name, type, or its parent, which
are all predetermined when it is created) is requested.  I suspect the
best idea is to leave the smart parent node in charge of on-demand
parsing, so the dumb children will become just a little bit smart --
they will know whether a parse is required, and if necessary they will
ask their parent to carry out the parse: "I am child 17, please
(re)parse me".  Note that even if a child was generated as the 3rd
"foo" node, if it is child number 17 it should store that in its state
and use that index when asking its parent to do something.  

It is the child node that learns it can be GC'd, so a child will
tell its parent "I am child 17 and I am no longer referenced
by the Caml level."  The parent can decide whether to evict the
child from its cache.

Notes on identity, caching, and GC in Galax
-------------------------------------------

Galax currently caches all child nodes returned from a children
cursor, so it never asks the C level for the same node more than once.
This means that an identity test can be done using pointer comparison,
since you cannot have two different opaque references that refer to
the same entity.

Alas, we need to get rid of this caching.  We want to discard parsed
state during a query, which means we need Galax to GC references to
child nodes during query eval.  In fact we may need explicit freeing
of children during query eval, or explicit GC calls, to be folded into
low-level query plan generation.  Relying on a background OCAML
garbage collection process seems like the wrong thing. 

As an aside, once you add the children_named call and other data model
API calls, so that there is more than one way to obtain a reference to
a given entity, then memoizing the results of a given call is no
longer sufficient to prevent obtaining two different refs that refer
to the same entity.  E.g., a query plan could use two cursors, one for
all children of node N and one for all children of node N named "foo".

Therefore, Galax cannot assume that two different opaque refs always
refer to two different entities, and the trivial identity test needs
to be replaced with something else.  The obvious answer is that the
abstract data model needs to include an identity function that takes
two opaque refs and returns a boolean.

On the other hand, crossing the Galax-C boundary for every ref
comparison may be costly, so I can imagine turning opaque refs into
semi-opaque refs: a semi-opaque ref has an opaque part plus a 64 bit
entityID that can be used for identity testing.  It is up to the impl
of the data model to produce semi-opaque refs such that the entityID
of two refs is the same iff the refs refer to the same entity.  I
suppose there should also be a moduleID, to support querying over two
or more data sources that can be implemented by different modules.
Each impl of the data model (PADS, ...) would be assigned a moduleID.

Or maybe the Galax-C costs are not too bad.
Anyway, this is something the Galax implementors need to decide on.

For PADS, we can implement an identity test by storing a stream offset
in each node, or we can store the stream offset as the entityID in a
semi-opaque reference.

Finally, note that we don't need to turn off caching of children for
all nodes, just for the smart nodes.  This suggests there needs to be
a way for Galax to find out whether caching the results of a children
cursor is OK or not.  Again this could be done with a function call
such as child_caching_ok(ref) or it could be done by adding a
childCachingOK field to the semi-opaque reference type.
 
