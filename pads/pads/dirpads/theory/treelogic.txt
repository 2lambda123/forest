----------
Tree Logic
----------

(basic value: integer, string, character ...)
w ::= i | s | c | ...

e ::= w | x | \x.e | e1 e2         (expressions)

t ::= name forest | w              (abstract trees)

f ::= {t, ..., t}                  (a forest = set of trees)

v ::= w | t | f                    (general values)

Note: only some trees model real file systems, we won't worry about the trees that
don't.  example tree modelling a file system:

root {
  planetlab1 {
    tuesday {
      corald.log.head {contents{...}, owner{mfreed}, ac{r-xr-xr-x}, sort{file}},
      coraldnssrv.log.head {contents{...}, owner{mfreed}, ac{r-xr-xr-x}, sort{file}},
      coralwebsrv.log.head {contents{...}, owner{mfreed}, ac{r-xr-xr-x}, sort{file}},
      coraldprob.log.head {contents{...}, owner{mfreed}, ac{r-xr-xr-x}, sort{file}},
      ac{r-xr-xr-x}, 
      sort{dir}
    },
    wednesday {
      corald.log.head {contents{...}, owner{mfreed}, ac{r-xr-xr-x}, sort{file}},
      coraldnssrv.log.head {contents{...}, owner{mfreed}, ac{r-xr-xr-x}, sort{file}},
      coralwebsrv.log.head {contents{...}, owner{mfreed}, ac{r-xr-xr-x}, sort{file}},
      coraldprob.log.head {contents{...}, owner{mfreed}, ac{r-xr-xr-x}, sort{file}},
      ac{r-xr-xr-x}, 
      sort{dir}
    },
    ac{r-xr-xr-x}, 
    sort{dir}
  },
  planetlab2 { 
    ... 
  },
  ac{r-xr-xr-x}, 
  sort{dir} 
}

--------------------
Tree splitting:

Intuition:  A single tree is split apart into two trees.  The "union" of the two
results must be equal to the original tree.  ie: nothing is lost during the splitting,
and some elements of the original may appear in both derived trees.

judgement form:  t = f1 . f2      (t splits into f1 and f2)

------------
t = {} . {t}

------------
t = {t} . {}

-------------
t = {t} . {t}

f = f1 . f2
----------------------------------
name f = {name {f1}} . {name {f2}}


judgement form:  f = f1 . f2      (f splits into f1 and f2)

for i=1..k, ti = fia . fib
-------------------------------------------
{t1,...,tk} = U{i=1..k} fia . U{i=1..k} fib


NOTES: 
-- we write f = f1 . ... . fk for f = f1 . f2 and f2 = f3 . f4 and ... 
-- we write f1 . f2 in place of f when f = f1 . f2

--------------------

basety ::= Pint | Pre(re) | Const(e) 
         | Pdate(formatstring) | Pip | ...

nameProp q ::= basety
             | {x:q * y:q}
             | {x:q + y:q}
             | array q (sep)

(basic predicates)
prop P   ::= (e1 = e2)         (equality)
           | (e1 in q)         (string matching)
           | {label:e}         (always valid; adds meta data)
           | ... 

(tree logic formula)
A,B      ::= P                 (basic predicates)
           | set(e)            (matches any element of forest e)
           | q{A}              (describes tree with label matching q and subforest A)
           | T                 ("true" describes all forests)
           | emp               (describes empty forest)
           | A o B             (relevant conjunction, aka "fusion") 
           | x:A o B           (dependent relevant conjunction, aka Sigma x:A.B) 
           | A \/ B            (disjunction)
           | A*                (finitary conjunction/iteration)
           | not A             (negation)
           | A =o B            (implication/adjoint to A o B)
           | Pi x:A.B          (implication/dependent function space, 
                                dont know what kind -- unrestricted intuitionistic?)

derived form:

           | [A | x <- e]      (is the same as Pi x:Set(e).A ?)


(environments)
E ::= [x1 -> v1,...,xk -> vk]

Formula Semantics

(1) E, name |= q       (file name matches q in environment E)

(2) E |= P             (predicate P is valid in environment E)

(3) E, f |= A          (forest f satisfies A in environment E)

(4) [[e]]E = v         (e is v in environment E)

Definition of (3):

E, {} |= P          if E |= P

E, {t} |= Set(e)    if t in [[e]]E

E, {name f} |= q{A} if E, name |= q and E, f |= A

E, f |= T           (always)

E, {} |= emp        (always)

E, f |= A o B       if f = f1 . f2 and E, f1 |= A and E,f2 |= B

E, f |= x:A o B     if f = f1 . f2 and E, f1 |= A and E[x->f1], f2 |= B

E, f |= A \/ B      if E, f |= A or E, f |= B

E, f |= A*          if f = f1 . ... . fk and for all i=1..k, E, fi |= A
                    or f = {}

E, f |= not A       if E, f |= A is not valid   // do we need this?

E, f |= A =o B      if forall f1 such that E, f1 |= A 
                         it is the case that E, f1 . f |= B

E, f |= Pi x:A.B    if forall f1 such that E, f1 |= A 
                         it is the case that E[x->f1], f |= B

plus derived form:

E, f |= [A | x <- e]  if [[e]]E = {t1,...,tk} and
                      f = f1 . ... . fk and
                      for all i:1..k, E[x->ti], fi |= A

-------------------------------
Unix Commands/Tools

Z ::= A | complement A

ls Z         -- list forest matching Z
mv Z root    -- move forest matching Z to root
cp Z root    -- copy forest matching Z to root
rm Z         -- delete forest matching Z
diff Z B     -- print differences between forests matching Z vs. B
chmod Z perm -- change permissions of forest matching Z to perm
zip/gzip     -- compress forest matching Z
lpr          -- print forest matching Z
mkdir Z      -- generate directory structure matching Z?
find Z       -- find files from within forest matching Z  
grep Z       -- print matching lines from forest matching Z 
du Z         -- disk usage of forest matching Z
tar Z        -- wrap up forest matcing Z into file
more/less Z  -- browse forest matching Z
tail         -- ?

New Command:
 
check Z      -- report deviations in current file system from Z
                (check Z == ls (complement Z) ?)

Definition of matching (defined to be a *maximal* matching for A and
a minimal matching for complement A):

subforest f1 of f matches A (written  f > f1 |= A) if:
  1) f = f1.f2 and 
  2) [], f1 |= A and
  3) for all f1', f2' such that f = f1'.f2' and [],f1' |= A, 
       it is the case that f1 = f1'.f3

f > f2 |= complement A if:
  4) f > f1 |= A and 
  5) f2 does not overlap with f1 and 
  6) f = f1 . f2  

Note: Condition 3 means that f1 must be a maximal matching subforest and hence by
conditions 5 and 6, the complement is a minimal matching.  







-------------------------------