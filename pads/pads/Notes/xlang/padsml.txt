PADS/ML
-------

constants k ::= true | false | () |  ...


Parsing Types
======================

T ::=  \alpha(M)
     | Pbase                  // base type
     | d(M)		      // parameterized data type; e is perimeter
     | M		      // singleton type.  eg: " " for literal space
     | x:T1 ** T2	      // dependent pair
     | {fieldtys}	      // dep. record
     | PD		      // parser descriptor type
     | T Parray(Msep, Mterm)  // array types
     | T stream		      // stream type; underlying rep for arrays
     | {x:T | M}	      // constrained type; ie: Pwhere


D ::= datatype typarams d(x:F) = DTBody
   |  type typarams \alpha(x:F) = T

typarams ::= . | \alpha typarams

DTBody ::= DS | case M of TS

DS ::= c of T
     | (c of T | DS)

TS ::= pat => c of T
   |   (pat => c of T | TS)

fieldtys ::= fieldty | fieldty ; fieldtys

fieldty ::= T | x = T

Transform Types
========================

F ::= T          (type of parsed value)
   | base
   | F -> F      (transform types)
   | F * F	 (ordinary pair)


Terms
=====

M ::=  x                        // variable
     | k			// constants
     | let x = M in M		// computation in host language
     | Pbase[M1](M2)		// base type constructor; M1 is
                                   an argument to the type; M2 computes the rep)
     | <M>                      // unit value given singleton type M
     | c(M)			// data type constructor with parameter M
     | (x:M1 ** M2)		// pair
     | {fields}
     | (M1 * M2)		// ordinary pair
     | {x = M1 | M2}		// set-type; M2 is the predicate
     | nil                      // empty list
     | M1 :: M2                 // cons
     | Parray(M, Msep, Mterm)   // array; first element is stream
     | case M of MS             // deconstructors
     | Fun x1(x2:F1):F2 = M     // recursive function x1 with arg x2
     | M1 (M2)			// function application
     | cast (M : T)		// type annot/dependent cast?
     | op M			// additional uninteresting operations
     
fields ::= x = M | x = M; fields

Parse Descriptors Values
-----------------------
pd ::=   G    // good
     |   B    // bad
     |   N    // nested error
     |   S    // semantic error
     |   U    // unknown

Patterns
--------
MS ::= pat => M | (pat => M | MS)

pat ::= x | k | nil
       | <<pat, pdpat>>           // project pd
       | (pat * pat)		  // normal pair
       | (pat ** pat)		  // dep. pair
       | {fieldpats}		  // record
       | {pat | setpat}		  // set-type
       | c(pat)			  // constructor
       | pat1 :: pat2		  // stream
       | Parray(pat, xsep, xterm) // array with stream, sep and term.

fieldpats ::= x = pat | x = pat; fieldpats

setpat ::= x | true | false

pdpat ::= x | pd


Complete Programs
=================

prog ::= M              
       | D prog          // type declaration
       | val x = M prog  // value declaration


Addendum
--------------

values V ::= <<P,pd>> | k 
              | (V1 * V2) | Fun x1 (x2 : F1) : F2 = M

prevalues P ::= k | c[M](V2) | (V1 ** V2) 
                    |  nil | V1 :: V2 | Parray (V1,V2,V3)  | noval


Semantics
========
G ::= . | G,m:F | G,d:T -> Type
    | G,c:[T](T)-> d
    | G,\alpha

F_simp ::= \alpha
       |   Pbase
       |   d
       |   Punit
       |   F_simp1 ** F_simp2
       |   PD
       |   F_simp Parray
       |   F_simp list
       |   base
       |   F_simp1 -> F_simp2
       |   F_simp1 * F_simp2

Main judgments for typing
-------------
|F| = F_simp (erases dependency)
-------------
|\alpha|	      = \alpha
|Pbase|               = Pbase
|d(M)|		      = d
|M|		      = Punit
|x:T1**T2|	      = |T1| ** |T2|
|PD|		      = PD
|T Parray(Msep,Mterm) = |T| Parray
|T list|	      = |T| list
|{x:T | M}|	      = |T|
|base|		      = base
|F1 -> F2|	      = |F1| -> |F2|
|F1 * F2|	      = |F1| * |F2|

F1 ~ F2  iff |F1| =_\alpha |F2|


!!! REPLACE m WITH x !!!

---------
G |- M :F
----------
Here is the typing rule for functions.  Assume that G is the typing context
mapping variables m to their (dependent) PADS types:

G, m:T1 -> T2, m1:T1 |- M : T2'    T2' ~ T2
------------------------------------------- 
G |- fun m (m1:T1):T2 = M : T1 -> T2

Operationally, when we reach the end of the function, we dynamically check
the function result to make sure it satisfies T2.  If it doesn't, we use the
relation V |= T2 ==> V'

Function application is similar [I screwed up... everywhere I wrote T I did
not just mean a PADS types T,  I meant possibly a transform type F.  I
should have been writing F... I am switching now]:

G |- M1 : F1 -> F2    G |- M2 : F1'    F1' ~ F1
-----------------------------------------------
G |- M1 M2 : F2

At run time, we evaluate M2, obtaining a value V2 and we dynamically check
whether or not V2 |= F1

The variable typing rule:

--------------
G,m:F |- m : F    

G |- M : F'   F' ~ F
---------------------
G |- cast (M : F) : F


------------------
G |- pat : F => G'
------------------

-----------------
G |- x : F => x:F

G |- pat1:F1 => G1   G|- pat2 : F2 => G2
---------------------------------------- 
G |- pat1 ** pat2 : F1 ** F2 => G1,G2

... (fill in myself)

Now we can do the operational semantics.  The basic operational judgment is:

--------
M --> M'   (M executes in one step to M')
--------

Cast operation:

V |= F ==> V'
-------------------------------
cast (V : F)  -->  V'


M --> M'
-------------------------------
cast (M : F)  -->  cast (M' : F)


Function application:

-----------------------------------------------------------------------
(fun m (m1:F1):F2 = M) M1  --> 
  let m1 = cast (M1:F1) in (cast (M : F2))[(fun m (m1:F1):F2 = M)/m]

