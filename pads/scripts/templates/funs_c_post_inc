
#ifndef READ_MASK
#  define READ_MASK P_CheckAndSet
#endif

#ifndef EXTRA_READ_ARGS
#  define EXTRA_READ_ARGS
#endif

#ifndef EXTRA_HDR_READ_ARGS
#  define EXTRA_HDR_READ_ARGS
#endif

// PADS_INIT: initialize pads data structures.
// Returns PADS_RET_OK or PADS_RET_ERR.
int PADS_INIT() {

  global_num_recs         = 0;
  global_num_bytes_parsed = 0;
  global_disc             = Pdefault_disc;
#ifdef WSPACE_OK
  global_disc.flags |= (Pflags_t)P_WSPACE_OK;
#endif
#ifdef COPY_STRINGS
  global_disc.copy_strings = 1;
#endif
  // is this the default for network data?
  global_disc.d_endian = PbigEndian;

  if (!(global_io_disc = IO_DISC_MK)) {
    error(0, "IO discipline make call [ " PDCI_MacroArg2String(IO_DISC_MK) " ] failed");
    return PADS_RET_ERR;
  } else { 
    error(0, "Installed " PDCI_MacroArg2String(IO_DISC_MK) );
  }

  if (P_ERR == P_open(&global_pads, &global_disc, global_io_disc)) {
    error(0, "*** P_open failed ***");
    return PADS_RET_ERR;
  }
  if (P_ERR == PADS_TY(_init)(global_pads, &global_rec)) {
    error(0, "*** representation initialization failed ***");
    return PADS_RET_ERR;
  }
  if (P_ERR == PADS_TY(_pd_init)(global_pads, &global_rec_pd)) {
    error(0, "*** parse description initialization failed ***");
    return PADS_RET_ERR;
  }
  /* init mask -- must do this! */
  PADS_TY(_m_init)(global_pads, &global_rec_m, READ_MASK);
#ifdef PADS_HDR_TY
  if (P_ERR == PADS_HDR_TY(_init)(global_pads, &global_hdr)) {
    error(0, "*** header representation initialization failed ***");
    return PADS_RET_ERR;
  }
  if (P_ERR == PADS_HDR_TY(_pd_init)(global_pads, &global_hdr_pd)) {
    error(0, "*** header parse description initialization failed ***");
    return PADS_RET_ERR;
  }
  /* init mask -- must do this! */
  PADS_HDR_TY(_m_init)(global_pads, &global_hdr_m, P_CheckAndSet);
#endif /* PADS_HDR_TY */

  return PADS_RET_OK;
}

// PADS_INPUT_FILE: (re)initialize pads to read from file "inName",
// which can be "/dev/stdin" or a file path.  If "continuation" is
// non-zero then the new input is treated as a continuation of the
// bytes already *successfully* parsed by PADS_NEXT calls (i.e.,
// PADS_NEXT calls with a return value of PADS_RET_OK or
// PADS_RET_ERR).  If "continuation" is 0, the new bytes begin a fresh
// parse, which resets the pads state.
//  Returns PADS_RET_OK or PADS_RET_ERR.
int PADS_INPUT_FILE(const char *inName, int expect_new_header) {
  if (expect_new_header) {
    global_num_bytes_parsed = 0;
    PADS_RESET_HEADER();
  }
  if (P_ERR == P_io_fopen(global_pads, inName)) {
    error(0, "*** P_io_fopen failed ***");
    return PADS_RET_ERR;
  }
  return PADS_RET_OK;
}

// PADS_INPUT_BUF: (re)initialize pads to read from a buffer "buf" of
// length "buf_len".  If "continuation" is non-zero then the new input
// is treated as a continuation of the bytes already *successfully*
// parsed by PADS_NEXT calls (i.e., PADS_NEXT calls with a return
// value of PADS_RET_OK or PADS_RET_ERR).  If "continuation" is 0, the
// new bytes begin a fresh parse, which resets the pads state.
// Returns PADS_RET_OK or PADS_RET_ERR.
int PADS_INPUT_BUF(char *buf, size_t buf_len, int expect_new_header) {
  if (expect_new_header) {
    global_num_bytes_parsed = 0;
    PADS_RESET_HEADER();
  }
  if (!(global_io_in = sfnew(global_io_in, (Void_t*)buf, buf_len, -1, SF_STRING|SF_READ))) {
    error(0, "*** sfnew failed ***");
    return PADS_RET_ERR;
  }
  if (P_ERR == P_io_set(global_pads, global_io_in)) {
    error(0, "*** P_io_set failed ***");
    return PADS_RET_ERR;
  }
  if (P_io_at_eof(global_pads)) { /* XXX_REMOVE */
    error(0, "*** XXX_REMOVE P_io_set succeeded but P_io_at_eof !! ***");
    return PADS_RET_ERR;
  }
  return PADS_RET_OK;
}

int PADS_CLEANUP() {
  if (P_ERR == P_io_close(global_pads)) {
    error(0, "*** P_io_close failed ***");
    return PADS_RET_ERR;
  }
  if (P_ERR == PADS_TY(_cleanup)(global_pads, &global_rec)) {
    error(0, "** representation cleanup failed **");
    return PADS_RET_ERR;
  }
  if (P_ERR == PADS_TY(_pd_cleanup)(global_pads, &global_rec_pd)) {
    error(0, "** parse descriptor cleanup failed **");
    return PADS_RET_ERR;
  }
#ifdef PADS_HDR_TY
  if (P_ERR == PADS_HDR_TY(_cleanup)(global_pads, &global_hdr)) {
    error(0, "** representation cleanup failed **");
    return PADS_RET_ERR;
  }
  if (P_ERR == PADS_HDR_TY(_pd_cleanup)(global_pads, &global_hdr_pd)) {
    error(0, "** parse descriptor cleanup failed **");
    return PADS_RET_ERR;
  }
#endif
  if (P_ERR == P_close(global_pads)) {
    error(0, "*** P_close failed ***");
    return PADS_RET_ERR;
  }

  return PADS_RET_OK;
}

// PADS_NEXT: read the next record.
//
// Returns one of three result codes:
//   PADS_RET_OK             => successful parse, no errors
//   PADS_RET_ERR            => entire record was read,
//                              but there were some field-level errors
//   PADS_RET_TOO_FEW_BYTES  => not enough bytes available to read entire record
//
// In addition, sets *done to one of two values:
//    0  => there are more records to be read
//    1  => there are no more records to be read
//          (another PADS_INPUT_FILE or PADS_INPUT_BUF call
//           must be used before using PADS_NEXT again).
int PADS_NEXT(int *done) {
  Ppos_t            bpos, epos;
  int               res = 0;
  int               bytes_parsed;
  Perror_t          read_error;

  *done = 0;
  if (P_io_at_eof(global_pads)) {
    //error(2, "<note>PADS : stopping due to EOF, returning PADS_RET_TOO_FEW_BYTES, *done = 1</note>");
    *done = 1;
    return PADS_RET_TOO_FEW_BYTES;
  }
  if (MAX_RECS && ++global_num_recs > MAX_RECS) {
    //error(2, "<note>PADS : stopping due to MAX_RECS, returning PADS_RET_ERR, *done = 1</note>");
    *done = 1;
    return PADS_RET_ERR;
  }

#ifdef PADS_HDR_TY
  if (PADS_DO_READ_HEADER) {
    P_io_getPos(global_pads, &bpos, 0);
    read_error = PADS_HDR_TY(_read)(global_pads, &global_hdr_m, EXTRA_HDR_READ_ARGS &global_hdr_pd, &global_hdr);
    P_io_getPos(global_pads, &epos, 0);
    bytes_parsed = epos.offset - bpos.offset;
    if (hdr_too_few_bytes()) {
      //error(2, "<note>PADS header read: too few bytes, returning PADS_RET_TOO_FEW_BYTES, *done = 1</note>");
      *done = 1;
      return PADS_RET_TOO_FEW_BYTES;
    }
    if (read_error != P_OK) {
      //error(2, "<note>PADS header read: error, returning PADS_RET_ERR, *done = 1</note>");
      *done = 1;
      return PADS_RET_ERR;
    } else {
      //error(2, "<note>PADS header read: OK</note>");
    }
    global_num_bytes_parsed += bytes_parsed;
    PADS_HEADER_READ;
  }
#endif /* PADS_HDR_TY */

  P_io_getPos(global_pads, &bpos, 0);
  read_error = PADS_TY(_read)(global_pads, &global_rec_m, EXTRA_READ_ARGS &global_rec_pd, &global_rec);
  P_io_getPos(global_pads, &epos, 0);
  bytes_parsed = epos.offset - bpos.offset;
  if (rec_too_few_bytes()) {
    //error(2, "<note>PADS rec read: too few bytes, returning PADS_RET_TOO_FEW_BYTES, *done = 1</note>");
    *done = 1;
    return PADS_RET_TOO_FEW_BYTES;
  }
  if (read_error != P_OK) {
    //error(2, "<note>PADS rec read: error, returning PADS_RET_ERR, *done = 0</note>");
    res = PADS_RET_ERR;
  } else {
    //error(2, "<note>PADS rec read: OK</note>");
  }
  PADS_REC_READ;
  global_num_bytes_parsed += bytes_parsed;
  return res;
}

int PADS_NUM_BYTES_PARSED() {
  return global_num_bytes_parsed;
}
