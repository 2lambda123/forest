/* Less than ideal definition of size_t. 
   Need to find out what the correct definition of size_t is.
*/
typedef long size_t;

typedef enum Perror_t_e {
  P_OK                            =    0,
  P_ERR                           =   -1
} Perror_t;

typedef int PerrCode_t;

/* typedef enum PerrCode_t_e { */
/*   /\* First set of errors have no corresponding location  *\/ */
/*   P_NOT_PARSED                    =    0, */
/*   P_NO_ERR                        =    1, */
/*   P_SKIPPED                       =    2, */

/*   P_UNEXPECTED_ERR                =    3, */

/*   P_BAD_PARAM                     =    4, */
/*   P_SYS_ERR                       =    5, */
/*   P_IO_ERR                        =    6, */

/*   P_CHKPOINT_ERR                  =   11, */
/*   P_COMMIT_ERR                    =   12, */
/*   P_RESTORE_ERR                   =   13, */
/*   P_ALLOC_ERR                     =   14, */
/*   P_FORWARD_ERR                   =   15, */
/*   P_PANIC_SKIPPED                 =   20, */

/*   P_FMT_EMPTY_DELIM_ERR           =   30, */

/*   P_INVALID_FUNCTION_CALL         =   50, */

/*   /\* A general error relating to smart nodes*\/ */
/*   P_SMART_NODE_ERR                =   60, */

/*   /\* */
/*    * A general error that requires that an ocaml */
/*    * ocaml exception be thrown. */
/*    *\/ */
/*   P_FAILWITH_ERR                  =   61, */

/*   /\* The following errors (code >= 100) DO have a corresponding location  *\/ */
/*   P_USER_CONSTRAINT_VIOLATION     =  100, */
/*   P_MISSING_LITERAL               =  101, */
/*   P_ARRAY_ELEM_ERR                =  110, */
/*   P_ARRAY_SEP_ERR                 =  111, */
/*   P_ARRAY_TERM_ERR                =  112, */
/*   P_ARRAY_SIZE_ERR                =  113, */
/*   P_ARRAY_SEP_TERM_SAME_ERR       =  114, */
/*   P_ARRAY_USER_CONSTRAINT_ERR     =  115, */
/*   P_ARRAY_MIN_BIGGER_THAN_MAX_ERR =  116, */
/*   P_ARRAY_MIN_NEGATIVE            =  117, */
/*   P_ARRAY_MAX_NEGATIVE            =  118, */
/*   P_ARRAY_EXTRA_BEFORE_SEP        =  119, */
/*   P_ARRAY_EXTRA_BEFORE_TERM       =  120, */

/*   P_STRUCT_FIELD_ERR              =  125, */
/*   P_STRUCT_EXTRA_BEFORE_SEP       =  126, */
/*   P_UNION_MATCH_ERR               =  130, */
/*   P_OPTION_MATCH_ERR              =  130, */
/*   P_ENUM_MATCH_ERR                =  140, */
/*   P_TYPEDEF_CONSTRAINT_ERR        =  150, */
/*   P_RECUR_VAL_ERR                 =  155, */

/*   P_AT_EOF                        =  160, */
/*   P_AT_EOR                        =  161, */
/*   P_EXTRA_BEFORE_EOR              =  162, */
/*   P_EOF_BEFORE_EOR                =  163, */
/*   P_COUNT_MAX_LIMIT               =  164, */
/*   P_RANGE                         =  170, */

/*   P_INVALID_A_NUM                 =  180, */
/*   P_INVALID_E_NUM                 =  181, */
/*   P_INVALID_EBC_NUM               =  182, */
/*   P_INVALID_BCD_NUM               =  183, */

/*   P_INVALID_CHARSET               =  190, */
/*   P_INVALID_WIDTH                 =  191, */

/*   P_CHAR_LIT_NOT_FOUND            =  200, */
/*   P_STR_LIT_NOT_FOUND             =  210, */
/*   P_REGEXP_NOT_FOUND              =  220, */
/*   P_INVALID_REGEXP                =  230, */
/*   P_WIDTH_NOT_AVAILABLE           =  240, */
/*   P_INVALID_TIMESTAMP             =  250, */
/*   P_INVALID_DATE                  =  251, */
/*   P_INVALID_TIME                  =  252, */
/*   P_INVALID_IP                    =  260, */
/*   P_INVALID_IP_RANGE              =  261, */
/* } PerrCode_t; */

/* ================================================================================
 * BASIC LIBRARY TYPES
 */

typedef unsigned int   Pbyte;

typedef signed int     Pint8;
typedef signed int     Pint16;
typedef signed int     Pint32; 
typedef signed int     Pint64; 

typedef unsigned int   Puint8;
typedef unsigned int   Puint16;
typedef unsigned int   Puint32; 
typedef unsigned int   Puint64; 

typedef unsigned char Pchar;

/* Approximation of real Pstring from pads.h */
typedef struct Pstring_s Pstring;

struct Pstring_s{
  size_t         len;
  [string] char *str;
};

typedef struct Pbase_pd_s Pbase_pd;
typedef struct Ppos_s           Ppos_t;
typedef struct Ploc_s           Ploc_t;
typedef [int64] int Sfoff_t;
typedef Puint32 Pflags_t;

/* Abstract definition for P_t and other types. Ensures that the file typechecks. 
   We don't need to specify the actual P_t.
*/
typedef [abstract] struct P_s         P_t;
typedef [abstract] struct Pdisc_s     Pdisc_t;
typedef [abstract] struct Pio_disc_s  Pio_disc_t;
typedef [abstract] struct Tm_zone_s   Tm_zone_t;
typedef [abstract] struct Sfio_s      Sfio_t;

/* As we are not outputing a header file, need to add this 
   typedef by hand.
*/
quote(c,"typedef Sfio_t *SfioPtr;");
typedef [ptr] Sfio_t            *SfioPtr;

/* As we are not outputing a header file, need to add this 
   typedef by hand.
*/
quote(c,"typedef SfioPtr SfioPtrOpt;");
/* Declarations and Definitions for SfioPtrOpt conversion functions. */
quote(h,"cnv_opt_decl(padsc,SfioPtr)");
quote(c,"cnv_opt(padsc,SfioPtr)");

typedef [mltype("sfio_t Com.opaque option"), 
	 c2ml(c2ml_padsc_SfioPtrOpt), 
	 ml2c(ml2c_padsc_SfioPtrOpt)] 
        SfioPtr                     SfioPtrOpt;

/* Hack: IDL defines "byte" as a type, making it illegal as a field
   identifier.  Unfortunately, the first field of the Ppos_s structure
   is named byte.  So, we fake out the IDL compile with FIELD_BYTE and
   fix it in the generated C code with the #define.
*/
quote(c,"#define FIELD_BYTE byte");

struct Ppos_s {
  size_t       FIELD_BYTE;
  size_t       num;
  Sfoff_t      offset;
};

struct Ploc_s {
  Ppos_t b;
  Ppos_t e;
};

struct Pbase_pd_s {
  Pflags_t    pstate; /* parse state */
  Puint32     nerr;
  PerrCode_t  errCode;
  Ploc_t      loc;
};


/* ================================================================================
 * LIBRARY HANDLE OPEN/CLOSE FUNCTIONS
 *
 */

[pointer_default(unique)] 
interface LibraryHandle {
  Perror_t  P_open  ([out,*ptr] P_t **pads_out, [in] Pdisc_t *disc, [in,ptr] Pio_disc_t *io_disc);
  Perror_t  P_close ([in,ptr] P_t *pads); 
}


/* ================================================================================
 * MISCELLANY
 *
 */

interface Misc {
  Tm_zone_t *P_cstr2timezone([in,string] const char *tzone_str);
  SfioPtrOpt P_fopen([in,string] const char* source, [in,string] const char* mode);
}

/* ================================================================================
 * TOP-LEVEL IO FUNCTIONS
 */

/* Perror_t  P_io_set       (P_t *pads, Sfio_t *io); */
/* Perror_t  P_io_next_rec  (P_t *pads, size_t *skipped_bytes_out); */
/* Perror_t  P_io_skip_bytes(P_t *pads, size_t width, size_t *skipped_bytes_out); */


interface IO{
  Perror_t  P_io_fopen     ([in,ptr] P_t *pads, [string] const char *path);
  Perror_t  P_io_close     ([in,ptr] P_t *pads);

  Perror_t  P_io_getPos   ([in,ptr] P_t *pads, [out] Ppos_t *pos, [in] int offset);
  Perror_t  P_io_getLocB  ([in,ptr] P_t *pads, [out] Ploc_t *loc, [in] int offset);
  Perror_t  P_io_getLocE  ([in,ptr] P_t *pads, [out] Ploc_t *loc, [in] int offset);
  Perror_t  P_io_getLoc   ([in,ptr] P_t *pads, [out] Ploc_t *loc, [in] int offset);

  int       P_io_at_eor        ([in,ptr] P_t *pads);
  int       P_io_at_eof        ([in,ptr] P_t *pads);
  /* eor_or_eof causing linking problems. removed for now.*/
/*   int       P_io_at_eor_or_eof ([in,ptr] P_t *pads);  */
}

/* ================================================================================
 * SCAN FUNCTIONS
 *
 */

interface Scan{
  Perror_t Pchar_lit_scan1   ([in,ptr] P_t *pads, [in] Pchar f,
			      [in] int eat_f, [in] int panic, [out] size_t *offset_out);
/*   Perror_t Pstr_lit_scan1    ([in,ptr] P_t *pads, [in,ref] const Pstring *f,  */
/* 			      [in] int eat_f, [in] int panic, [out] size_t *offset_out); */
  Perror_t Pcstr_lit_scan1   ([in,ptr] P_t *pads, [in,string] const char *f,
			      [in] int eat_f, [in] int panic, [out] size_t *offset_out);
  /* Perror_t Pre_scan1         ([in,ptr] P_t *pads, Pregexp_t *f,     int eat_f, int panic, size_t *offset_out); */

  Perror_t Pchar_lit_scan2   ([in,ptr] P_t *pads, [in] Pchar f, [in] Pchar s,
			      [in] int eat_f, [in] int eat_s, [in] int panic,
			      [out] int *f_found_out, [out] size_t *offset_out);
/*   Perror_t Pstr_lit_scan2    ([in,ptr] P_t *pads, [in,ref] const Pstring *f, [in,ref] const Pstring *s, */
/* 			      [in] int eat_f, [in] int eat_s, [in] int panic, */
/* 			      [out] int *f_found_out, [out] size_t *offset_out); */
  Perror_t Pcstr_lit_scan2   ([in,ptr] P_t *pads, [in,string] const char *f, [in,string] const char *s,
			      [in] int eat_f, [in] int eat_s, [in] int panic,
			      [out] int *f_found_out, [out] size_t *offset_out);
/* Perror_t Pre_scan2         (P_t *pads, Pregexp_t *f, Pregexp_t *s, */
/* 			    int eat_f, int eat_s, int panic, */
/* 			    int *f_found_out, size_t *offset_out); */
}


/* ================================================================================
 * MATCH FUNCTIONS
 *
 */

interface Match{
  Perror_t Pchar_lit_match   ([in,ptr] P_t *pads, [in] Pchar f, [in] int eat_f);
  /* Perror_t Pstr_lit_match    (P_t *pads, const Pstring *f, int eat_f); */
  Perror_t Pcstr_lit_match   ([in,ptr] P_t *pads, [in,string] const char *f,    int eat_f);
  /* Perror_t Pre_match         (P_t *pads, Pregexp_t *f,     int eat_f); */
  /* Perror_t Pcstr_re_match    (P_t *pads, const char *f,    int eat_f); */
}

/* ================================================================================
 * IO CHECKPOINT API
 *
 */

interface Checkpoint{
  Perror_t  P_io_checkpoint  ([in,ptr] P_t *pads, int speculative);
  Perror_t  P_io_commit      ([in,ptr] P_t *pads);
  /* Perror_t  P_io_commit_pos  (P_t *pads, Ppos_t pos); */
  /*           /\* commit at pos rather than using the current IO cursor position *\/ */
  /*           /\* pos should be >= the checkpoint position and <= the current IO cursor position *\/ */
  Perror_t  P_io_restore     ([in,ptr] P_t *pads);
  unsigned int P_spec_level  ([in,ptr] P_t *pads);
}

/* ================================================================================
 * IO Descriptor API
 *
 */

interface IO_Disc{

  [ptr] Pio_disc_t * P_ctrec_make([in] Pbyte termChar, [in] size_t block_size_hint);
  /* Instantiates an instance of ctrec, a discipline for
   * character-terminated variable-width records. termChar is the
   * character that marks the end of a record. block_size_hint is a
   * hint as to what block size to use, if the discipline chooses to do
   * fixed block-sized reads 'under the covers'.  It may be ignored by
   * the discipline.
   * 
   * For ASCII newline-terminated records use, '\n' or P_ASCII_NEWLINE
   * as the term character.  For EBCDIC newline-terminated records, use
   * P_EBCDIC_NEWLINE as the term character.
   */

  [ptr] Pio_disc_t * P_norec_make([in] size_t block_size_hint);
  /* Instantiates an instance of norec, a raw bytes discipline that
   * does not use records.  block_size_hint is a hint as to what block size
   * to use, if the discipline chooses to do fixed block-sized reads
   * 'under the covers'.  It may be ignored by the discipline.
   */

}
